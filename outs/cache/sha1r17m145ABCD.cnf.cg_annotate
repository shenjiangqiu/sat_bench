--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/sha1r17m145ABCD.cnf
Data file:        sha1r17m145ABCD.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr      ILmr   Dr              D1mr           DLmr       Dw              D1mw          DLmw       
--------------------------------------------------------------------------------
2,191,507,177,722 4,120,700 24,299 712,348,585,489 40,770,394,202 10,641,663 260,534,145,183 8,837,540,115 17,331,245  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr              D1mr           DLmr      Dw              D1mw          DLmw       file:function
--------------------------------------------------------------------------------
984,715,508,787  17,252    95 366,346,988,107 21,390,128,382   466,590 119,103,434,609    26,240,906         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
390,968,832,609      12     4  73,280,337,268  3,487,648,675   141,511  52,665,266,532             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
225,764,486,912 156,950    43  54,729,868,412  3,662,789,284     3,111  32,997,494,226 5,011,145,427 1,862,340  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
102,175,116,446     399   250  26,636,968,662  3,988,551,670    21,418  10,460,342,096    77,891,014        42  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
 67,773,494,891      95    63  17,372,258,868    760,389,738     6,610               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
 48,182,749,906      55    32  11,930,691,496    978,201,729        79   8,891,928,971 1,378,247,508   302,919  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
 42,038,352,159       4     2  41,330,192,172    385,344,912         0     708,143,863             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
 27,937,616,069  40,087   379  10,174,106,334    589,666,790       384   1,841,936,773    15,671,663        50  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 27,845,210,026       0     0  13,922,605,013         82,680         0               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
 22,789,155,068  13,501   229   8,902,856,180  1,059,998,255       186   2,688,471,173   284,621,762        40  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
 21,995,193,726      12     4   9,388,750,490    437,561,224       653   6,691,204,398 1,418,088,433     6,719  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 20,471,333,692  43,332   197   6,576,117,493    110,374,109        68   2,295,477,848     1,986,629         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 20,268,856,136 783,878 1,072   4,355,435,476    100,319,710       531   1,950,983,638    14,817,615         0  ???:__ieee754_pow_fma
 16,357,431,244 689,666   106   4,617,613,354            219         0   2,935,723,331     9,341,852       708  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 15,889,960,451  21,261    48   6,211,095,117    709,062,775       763   4,046,105,450    55,413,204        61  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
 14,488,988,728   6,105   172   3,345,148,517      5,603,105         3   1,444,676,241    30,459,940    19,521  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 12,762,392,601     419    33   6,119,974,307    265,071,962       590     714,983,841    18,488,535         5  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
 10,859,843,270   2,064   135   2,901,005,480    291,974,841     8,578     108,571,849       795,189         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  9,260,728,804     146    84   1,801,970,073     98,008,626     3,495     938,871,344    70,197,517     2,132  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
  7,602,053,027     193    84   2,514,109,858    400,120,381       846               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  7,232,771,069     600   149   3,672,605,082    249,576,341    17,738     568,505,980            55         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  6,677,373,045      45    30   2,129,442,264    235,157,159       141   1,266,028,532    77,837,663        88  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
  6,351,558,505   5,347   412   1,524,268,906     81,842,818     3,761     169,398,838     7,614,524         1  ???:__exp1_fma
  6,296,598,780       0     0   3,148,299,390          4,630         0               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::simplePropagate()
  5,874,316,300   1,587    32   2,425,508,497     23,270,883       380               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  5,826,740,828   1,766    74   2,602,429,315    262,634,617     1,468     823,949,516    29,317,582       122  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  4,920,121,108       9     9   1,693,261,678      6,370,363         0   1,533,597,752    56,598,456     1,476  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  4,600,813,790       0     0   3,067,205,076     46,118,722       125     766,798,181   129,255,051        97  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  4,373,669,973       0     0   4,373,669,973            102         0               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::simplePropagate()
  4,132,389,572   1,758    32   1,266,301,210        646,778         0      92,118,449     3,783,228       118  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  3,067,195,504       0     0     766,798,876              0         0     766,798,876        54,276         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  3,058,686,677   8,306    96     849,442,738          4,274       109     509,634,621        26,568         0  ???:pow
  2,205,833,696   1,321   680     565,780,125     64,371,678 1,151,333     335,927,297    15,959,425 4,023,849  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr          DLmr    Dw             D1mw        DLmw      

-- line 54 ----------------------------------------
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  struct Lit {
              .     .    .              .             .       .              .           .         .      int     x;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // Use this as a constructor:
              .     .    .              .             .       .              .           .         .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      bool operator == (Lit p) const { return x == p.x; }
    878,305,821     0    0    446,975,007   235,598,937   2,257              0           0         0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .             .       .              .           .         .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
        215,194     0    0              0             0       0            677           0         0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 37,102,258,553    43   27 16,793,186,770       148,037     649  1,392,446,670     795,189         0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .             .       .              .           .         .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
132,802,310,387    25   15  3,074,019,680             0       0  1,540,423,318 129,309,327        97  inline  bool sign      (Lit p)              { return p.x & 1; }
214,470,208,212 7,590  214  4,323,113,792    86,263,210   3,512 39,913,897,351           0         0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .             .       .              .           .         .  inline  int  toInt     (Var v)              { return v; } 
          4,236     1    1            347             0       0            348           9         0  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .             .       .              .           .         .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .             .       .              .           .         .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .             .       .              .           .         .  const Lit lit_Error = { -1 };  // }
              .     .    .              .             .       .              .           .         .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .     .    .              .             .       .              .           .         .  #define l_Undef (lbool((uint8_t)2))
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  class lbool {
              .     .    .              .             .       .              .           .         .      uint8_t value;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  public:
              .     .    .              .             .       .              .           .         .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .             .       .              .           .         .  
            974     1    1              0             0       0            246          58        58      lbool()       : value(0) { }
              .     .    .              .             .       .              .           .         .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .             .       .              .           .         .  
  6,666,347,458     1    1              0             0       0              0           0         0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
         11,493     0    0          7,662            60       0              0           0         0      bool  operator != (lbool b) const { return !(*this == b); }
 33,660,353,376    49   31 30,566,177,190   313,638,228      75              0           0         0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      lbool operator && (lbool b) const {
              .     .    .              .             .       .              .           .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .             .       .              .           .         .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .             .       .              .           .         .          return lbool(v); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      lbool operator || (lbool b) const {
              .     .    .              .             .       .              .           .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .             .       .              .           .         .          unsigned simplified : 1;}                            header;
              .     .    .              .             .       .              .           .         .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      friend class ClauseAllocator;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .             .       .              .           .         .      template<class V>
              .     .    .              .             .       .              .           .         .      Clause(const V& ps, bool use_extra, bool learnt) {
     66,541,843     0    0     15,996,709             0       0     18,551,715     148,709         0          header.mark      = 0;
     47,939,295     1    1     15,979,765       999,469 271,510              0           0         0          header.learnt    = learnt;
     95,997,198     2    2     16,013,653             5       0     15,996,709           0         0          header.has_extra = learnt | use_extra;
              .     .    .              .             .       .              .           .         .          header.reloced   = 0;
     21,123,663     0    0      2,571,949           112       0     18,551,714   2,444,164   188,982          header.size      = ps.size();
              .     .    .              .             .       .              .           .         .          header.lbd       = 0;
              .     .    .              .             .       .              .           .         .          header.removable = 1;
              .     .    .              .             .       .              .           .         .          //simplify
              .     .    .              .             .       .              .           .         .          //
     18,551,715     8    5     18,551,715     2,159,582 636,189              0           0         0          header.simplified = 0;
              .     .    .              .             .       .              .           .         .  
    700,885,044   213  110      2,628,078             0       0              0           0         0          for (int i = 0; i < ps.size(); i++)
    439,345,873   280  109    153,020,623    19,097,247 303,166    182,556,363  20,643,791 7,338,386              data[i].lit = ps[i];
              .     .    .              .             .       .              .           .         .  
     55,655,144   109   75     18,551,714             0       0              0           0         0          if (header.has_extra){
     34,039,052     0    0              0             0       0              0           0         0              if (header.learnt){
     33,984,170     1    1     14,437,063             0       0     16,992,085   1,060,327   338,695                  data[header.size].act = 0;
     33,984,186     0    0              0             0       0     16,992,085   1,062,106   337,875                  data[header.size+1].touched = 0;
              .     .    .              .             .       .              .           .         .              }else
              .     .    .              .             .       .              .           .         .                  calcAbstraction(); }
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  public:
              .     .    .              .             .       .              .           .         .      void calcAbstraction() {
              .     .    .              .             .       .              .           .         .          assert(header.has_extra);
         30,227     0    0              0             0       0              0           0         0          uint32_t abstraction = 0;
        430,170     5    4         11,908             0       0              0           0         0          for (int i = 0; i < size(); i++)
        632,568     3    2              0             0       0              1           0         0              abstraction |= 1 << (var(data[i].lit) & 31);
         88,546     0    0         10,497             0       0         40,112       1,704     1,704          data[header.size].abs = abstraction;  }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
 29,163,101,148   213  133 15,246,014,704 2,048,235,218  26,884 11,377,629,622          48         0      int          size        ()      const   { return header.size; }
      4,047,454    38   24      1,012,178       257,439       0      1,012,178      64,390         0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .             .       .              .           .         .      void         pop         ()              { shrink(1); }
    226,480,804     4    4      2,421,141             0       0              0           0         0      bool         learnt      ()      const   { return header.learnt; }
         13,770     0    0              0             0       0              0           0         0      bool         has_extra   ()      const   { return header.has_extra; }
    327,775,175   211   82     42,543,998    40,372,784  91,435    105,327,100           0         0      uint32_t     mark        ()      const   { return header.mark; }
     77,100,606   252  111     19,978,967        67,460       0     18,986,513           0         0      void         mark        (uint32_t m)    { header.mark = m; }
        298,464     0    0              0             0       0        149,232           0         0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .             .       .              .           .         .  
     48,093,265     0    0     48,093,265    40,525,093   4,818              0           0         0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .             .       .              .           .         .      CRef         relocation  ()      const   { return data[0].rel; }
     63,919,060    50   35     15,979,765             0       0     31,959,530           0         0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .             .       .              .           .         .  
     22,787,990     0    0      7,570,687             0       0              0           0         0      int          lbd         ()      const   { return header.lbd; }
    112,219,467   191   98     32,088,554             0       0     17,653,614           0         0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .             .       .              .           .         .      bool         removable   ()      const   { return header.removable; }
     89,559,963     2    2     31,811,647             0       0     14,437,079           0         0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .             .       .              .           .         .      //       subsumption operations to behave correctly.
 29,889,986,290   156   84 28,694,167,477 2,318,123,184 129,930              0           0         0      Lit&         operator [] (int i)         { return data[i].lit; }
    305,485,525   459  145    275,524,981    10,288,499  14,617              0           0         0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .             .       .              .           .         .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .             .       .              .           .         .  
     14,899,573     0    0     14,899,573             7       0              0           0         0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     10,732,341     0    0      3,208,445       872,158   6,217              0           0         0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .             .       .              .           .         .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .             .       .              .           .         .      void         strengthen  (Lit p);
              .     .    .              .             .       .              .           .         .      // simplify
              .     .    .              .             .       .              .           .         .      //
    101,982,795     0    0     29,335,779             0       0     14,437,079           0         0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .             .       .              .           .         .      bool simplified() { return header.simplified; }
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  //=================================================================================================
              .     .    .              .             .       .              .           .         .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .             .       .              .           .         .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      static int clauseWord32Size(int size, int extras){
     36,942,143     4    3     18,390,413       915,619   6,713              0           0         0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .             .       .              .           .         .  public:
              .     .    .              .             .       .              .           .         .      bool extra_clause_field;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0             0       0              1           0         0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void moveTo(ClauseAllocator& to){
            306    64   29            153             1       0            153           0         0          to.extra_clause_field = extra_clause_field;
              .     .    .              .             .       .              .           .         .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      template<class Lits>
              .     .    .              .             .       .              .           .         .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .             .       .              .           .         .          assert(sizeof(float)    == sizeof(uint32_t));
     33,519,159   233  120      1,559,629           203       0              0           0         0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .             .       .              .           .         .  
      2,588,892     0    0              0             0       0         16,943           0         0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .             .       .              .           .         .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .          return cid;
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    119,110,844   170   68    109,869,731        48,747       0         25,164           0         0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
         13,144     2    2          6,572             0       0              0           0         0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     15,979,765     0    0     15,979,765             0       0              0           0         0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .           .         .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .           .         .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void free(CRef cid)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .          Clause& c = operator[](cid);
      7,245,702    19    2              0             0       0              0           0         0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .             .       .              .           .         .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
     26,105,023   152   65              0             0       0     22,375,734         301         0      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .          Clause& c = operator[](cr);
              .     .    .              .             .       .              .           .         .          
    172,783,862     0    0     32,113,500     5,543,829      12     32,113,500           0         0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .             .       .              .           .         .          
     15,979,766     0    0              1             0       0     15,979,765           0         0          cr = to.alloc(c, c.learnt());
              .     .    .              .             .       .              .           .         .          c.relocate(cr);
              .     .    .              .             .       .              .           .         .          
              .     .    .              .             .       .              .           .         .          // Copy extra data-fields:
              .     .    .              .             .       .              .           .         .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .             .       .              .           .         .          to[cr].mark(c.mark());
     31,959,530     1    1              0             0       0              0           0         0          if (to[cr].learnt()){
     57,748,316     0    0     14,437,079       798,277   4,810     14,437,079           0         0              to[cr].touched() = c.touched();
     57,748,300     0    0     28,874,158       800,562   4,759     14,437,079           0         0              to[cr].activity() = c.activity();
              .     .    .              .             .       .              .           .         .              to[cr].set_lbd(c.lbd());
              .     .    .              .             .       .              .           .         .              to[cr].removable(c.removable());
              .     .    .              .             .       .              .           .         .              // simplify
              .     .    .              .             .       .              .           .         .              //
              .     .    .              .             .       .              .           .         .              to[cr].setSimplified(c.simplified());
              .     .    .              .             .       .              .           .         .          }
      3,085,372   306  132              0             0       0              0           0         0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     29,834,312     0    0     26,105,023             0       0              0           0         0      }
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .             .       .              .           .         .  class OccLists
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      vec<Vec>  occs;
              .     .    .              .             .       .              .           .         .      vec<char> dirty;
              .     .    .              .             .       .              .           .         .      vec<Idx>  dirties;
              .     .    .              .             .       .              .           .         .      Deleted   deleted;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  public:
              3     0    0              0             0       0              3           0         0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .             .       .              .           .         .      unsigned int size(){
              .     .    .              .             .       .              .           .         .          auto m_size=0;
             40     2    2              4             3       0              0           0         0          for(int i=0;i<occs.size();i++){
         84,356    14   14         30,652         7,664     658              0           0         0              m_size+=occs[i].size();
              .     .    .              .             .       .              .           .         .          }
              .     .    .              .             .       .              .           .         .          
              .     .    .              .             .       .              .           .         .          return m_size;
              .     .    .              .             .       .              .           .         .      }
         42,141     1    1              0             0       0          7,662           0         0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .             .       .              .           .         .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
    798,952,323    35    5    798,952,323     2,005,247       0              0           0         0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
         72,337     1    1         36,880         3,339       0          3,522           1         0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void  cleanAll  ();
              .     .    .              .             .       .              .           .         .      void  clean     (const Idx& idx);
              .     .    .              .             .       .              .           .         .      void  smudge    (const Idx& idx){
     14,504,740     0    0      9,663,010       157,743   8,094              0           0         0          if (dirty[toInt(idx)] == 0){
        323,215   247   70              0             0       0        323,215           0         0              dirty[toInt(idx)] = 1;
             49     1    1              0             0       0              0           0         0              dirties.push(idx);
              .     .    .              .             .       .              .           .         .          }
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void  clear(bool free = true){
              .     .    .              .             .       .              .           .         .          occs   .clear(free);
              .     .    .              .             .       .              .           .         .          dirty  .clear(free);
              .     .    .              .             .       .              .           .         .          dirties.clear(free);
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  template<class Idx, class Vec, class Deleted>
          2,416     0    0              0             0       0          1,812           1         0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .             .       .              .           .         .  {
    103,061,645 1,607   14     51,205,442        18,758       4              0           0         0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .             .       .              .           .         .          // Dirties may contain duplicates so check here if a variable is already cleaned:
        969,645     0    0        646,430       266,939       0              0           0         0          if (dirty[toInt(dirties[i])])
              .     .    .              .             .       .              .           .         .              clean(dirties[i]);
              .     .    .              .             .       .              .           .         .      dirties.clear();
          2,416     0    0          2,416           499       0              0           0         0  }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  template<class Idx, class Vec, class Deleted>
              .     .    .              .             .       .              .           .         .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      Vec& vec = occs[toInt(idx)];
              .     .    .              .             .       .              .           .         .      int  i, j;
    113,622,007     2    2      1,273,183       329,695      85              0           0         0      for (i = j = 0; i < vec.size(); i++)
     70,528,778     0    0         64,134         4,218       0              0           0         0          if (!deleted(vec[i]))
    212,088,571     2    2     60,717,103            20       0     30,374,721      83,964         0              vec[j++] = vec[i];
        320,887   199   75              0             0       0              0           0         0      vec.shrink(i - j);
      1,296,584     1    1        646,430        30,334       0        324,104      15,025         0      dirty[toInt(idx)] = 0;
              .     .    .              .             .       .              .           .         .  }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  //=================================================================================================
              .     .    .              .             .       .              .           .         .  // CMap -- a class for mapping clauses to values:
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .             .       .              .           .         .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .             .       .              .           .         .  |________________________________________________________________________________________________@*/
              .     .    .              .             .       .              .           .         .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .             .       .              .           .         .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .             .       .              .           .         .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .             .       .              .           .         .      assert(header.has_extra); assert(other.header.has_extra);
      1,565,601     0    0        521,867         8,099       0              0           0         0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .             .       .              .           .         .          return lit_Error;
              .     .    .              .             .       .              .           .         .  
         58,416     0    0              0             0       0              0           0         0      Lit        ret = lit_Undef;
              .     .    .              .             .       .              .           .         .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .             .       .              .           .         .      const Lit* d   = (const Lit*)other;
              .     .    .              .             .       .              .           .         .  
        538,014     1    1        106,204             0       0              0           0         0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .             .       .              .           .         .          // search for c[i] or ~c[i]
      1,370,877     2    2         58,416             0       0         58,416           0         0          for (unsigned j = 0; j < other.header.size; j++)
      1,828,717     0    0        388,132             0       0              0           0         0              if (c[i] == d[j])
              .     .    .              .             .       .              .           .         .                  goto ok;
        248,908     0    0              0             0       0              0           0         0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .             .       .              .           .         .                  ret = c[i];
              .     .    .              .             .       .              .           .         .                  goto ok;
              .     .    .              .             .       .              .           .         .              }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .          // did not find it
              .     .    .              .             .       .              .           .         .          return lit_Error;
              .     .    .              .             .       .              .           .         .  ok:;
              .     .    .              .             .       .              .           .         .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr      DLmr    Dw         D1mw DLmw 

-- line 40 ----------------------------------------
             .     .    .              .         .       .          .    .    .      void capacity(uint32_t min_cap);
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .   public:
             .     .    .              .         .       .          .    .    .      // TODO: make this a class for better type-checking?
             .     .    .              .         .       .          .    .    .      typedef uint32_t Ref;
             .     .    .              .         .       .          .    .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .              .         .       .          .    .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .              .         .       .          .    .    .  
           771     1    1              0         0       0        616    0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .              .         .       .          .    .    .      ~RegionAllocator()
             .     .    .              .         .       .          .    .    .      {
             .     .    .              .         .       .          .    .    .          if (memory != NULL)
             .     .    .              .         .       .          .    .    .              ::free(memory);
             .     .    .              .         .       .          .    .    .      }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .      uint32_t size      () const      { return sz; }
             .     .    .              .         .       .          .    .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .      Ref      alloc     (int size); 
     7,231,936     0    0      2,410,644         0       0  2,410,644    0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
36,220,252,566   549  231 18,150,269,079 6,019,776 590,783    421,327    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    35,159,065     0    0     35,159,065 4,654,159  83,993          0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .              .         .       .          .    .    .  
    58,210,151 5,955   34      2,571,950         0       0          0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     4,346,171     0    0              0         0       0          0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .              .         .       .          .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .              .         .       .          .    .    .          return  (Ref)(t - &memory[0]); }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .      void     moveTo(RegionAllocator& to) {
           612     0    0            153         0       0        153    0    0          if (to.memory != NULL) ::free(to.memory);
           306     0    0            153         0       0        153    0    0          to.memory = memory;
           306     0    0            153         0       0        153    0    0          to.sz = sz;
             .     .    .              .         .       .          .    .    .          to.cap = cap;
           306     0    0            153         0       0        153    0    0          to.wasted_ = wasted_;
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .          memory = NULL;
             .     .    .              .         .       .          .    .    .          sz = cap = wasted_ = 0;
             .     .    .              .         .       .          .    .    .      }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  };
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  template<class T>
         1,602    81   48              0         0       0        534  152    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .              .         .       .          .    .    .  {
    55,655,607     1    0     18,551,869         0       0          0    0    0      if (cap >= min_cap) return;
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .      uint32_t prev_cap = cap;
         9,267     0    0              0         0       0        267    0    0      while (cap < min_cap){
             .     .    .              .         .       .          .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .              .         .       .          .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .              .         .       .          .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .              .         .       .          .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        27,000     0    0              0         0       0          0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         4,500     0    0              0         0       0          0    0    0          cap += delta;
             .     .    .              .         .       .          .    .    .  
         9,000     0    0              0         0       0          0    0    0          if (cap <= prev_cap)
             .     .    .              .         .       .          .    .    .              throw OutOfMemoryException();
             .     .    .              .         .       .          .    .    .      }
             .     .    .              .         .       .          .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .      assert(cap > 0);
           534     2    1              0         0       0        267  113    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
         1,068     0    0            801         0       0          0    0    0  }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  template<class T>
             .     .    .              .         .       .          .    .    .  typename RegionAllocator<T>::Ref
        67,772     2    1              0         0       0     50,829    0    0  RegionAllocator<T>::alloc(int size)
             .     .    .              .         .       .          .    .    .  { 
             .     .    .              .         .       .          .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .              .         .       .          .    .    .      assert(size > 0);
   103,577,497     0    0     18,551,715 1,904,544       0 50,494,285   41    0      capacity(sz + size);
             .     .    .              .         .       .          .    .    .  
    58,159,308     0    0     34,514,521         0       0          0    0    0      uint32_t prev_sz = sz;
    18,551,715     2    1              0         0       0 18,551,715    0    0      sz += size;
             .     .    .              .         .       .          .    .    .      
             .     .    .              .         .       .          .    .    .      // Handle overflow:
    85,042,721   156   96     15,979,764         0       0          0    0    0      if (sz < prev_sz)
             2     1    1              1         1       0          0    0    0          throw OutOfMemoryException();
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .      return prev_sz;
        67,772     0    0         67,772         0       0          0    0    0  }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  //=================================================================================================
             .     .    .              .         .       .          .    .    .  }
             .     .    .              .         .       .          .    .    .  
             .     .    .              .         .       .          .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr            D1mr        DLmr  Dw            D1mw        DLmw  

-- line 31 ----------------------------------------
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  template<class Comp>
             .      .    .             .           .     .             .           .     .  class Heap {
             .      .    .             .           .     .             .           .     .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
             .      .    .             .           .     .             .           .     .      vec<int> heap;     // Heap of integers
             .      .    .             .           .     .             .           .     .      vec<int> indices;  // Each integers position (index) in the Heap
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .      // Index "traversal" functions
   899,661,467     16   13             0           0     0             0           0     0      static inline int left  (int i) { return i*2+1; }
 3,415,927,070     37   13 1,366,233,061 513,937,666 4,556             0           0     0      static inline int right (int i) { return (i+1)*2; }
 1,759,452,440     13    6   217,473,872           0     0             0           0     0      static inline int parent(int i) { return (i-1) >> 1; }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
   434,947,744     30   24             0           0     0   434,947,744       6,601     0      void percolateUp(int i)
             .      .    .             .           .     .             .           .     .      {
 1,210,046,409      0    0   727,414,765  81,979,608   627   265,157,772           0     0          int x  = heap[i];
             .      .    .             .           .     .             .           .     .          int p  = parent(i);
             .      .    .             .           .     .             .           .     .          
 5,394,515,539     52   15 1,838,641,851 335,458,179   879    47,337,420           0     0          while (i != 0 && lt(x, heap[p])){
   393,629,501     53   28             0           0     0   393,629,501           0     0              heap[i]          = heap[p];
   393,629,501      0    0             0           0     0   393,629,501 125,649,443   215              indices[heap[p]] = i;
             .      .    .             .           .     .             .           .     .              i                = p;
   408,380,926      0    0             0           0     0             0           0     0              p                = parent(p);
             .      .    .             .           .     .             .           .     .          }
   509,940,893     12    5   132,587,749           0     0   377,353,144           0     0          heap   [i] = x;
   537,942,654      2    2   132,603,064           0     0   377,369,643           0     0          indices[x] = i;
   880,617,090      0    0   652,421,616           0     0             0           0     0      }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
 3,030,035,190      0    0   432,862,170           0     0 2,597,173,020      88,170     0      void percolateDown(int i)
             .      .    .             .           .     .             .           .     .      {
 1,383,858,305  5,161   39   903,273,062 255,998,901   106   480,494,295           0     0          int x = heap[i];
 3,623,147,519 16,230   28   880,679,413          31     0             0           0     0          while (left(i) < heap.size()){
 4,852,821,684     25    7   681,364,437  30,427,520   148             0           0     0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
 1,765,935,203     52    6             0           0     0             0           0     0              if (!lt(heap[child], x)) break;
   429,184,130      0    0             0           0     0   429,184,130           0     0              heap[i]          = heap[child];
   429,267,319      0    0        83,189           0     0   429,184,130 109,829,804 1,880              indices[heap[i]] = i;
   353,872,917      0    0             0           0     0             0           0     0              i                = child;
             .      .    .             .           .     .             .           .     .          }
   940,711,676     47   14   470,356,582           0     0   470,355,094           0     0          heap   [i] = x;
   545,207,491      3    2    37,506,219           0     0   470,355,094       6,050     0          indices[x] = i;
 3,059,546,294      1    0 3,030,035,190           0     0             0           0     0      }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .    public:
             .      .    .             .           .     .             .           .     .      Heap(const Comp& c) : lt(c) { }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .      int  size      ()          const { return heap.size(); }
    27,280,208      1    1    27,280,208   1,701,910     6             0           0     0      bool empty     ()          const { return heap.size() == 0; }
11,858,216,842  3,142   85 6,093,781,348 478,605,617   926             0           0     0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
    58,702,720     10    8    35,785,729   1,060,280     7             0           0     0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
 1,073,802,648      0    0   754,375,196         236     0   217,473,872          31     0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
 2,277,845,169      7    7 1,412,120,828           0     0   432,862,170           0     0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .      // Safe variant of insert/decrease/increase:
             .      .    .             .           .     .             .           .     .      void update(int n)
             .      .    .             .           .     .             .           .     .      {
             .      .    .             .           .     .             .           .     .          if (!inHeap(n))
             .      .    .             .           .     .             .           .     .              insert(n);
             .      .    .             .           .     .             .           .     .          else {
             .      .    .             .           .     .             .           .     .              percolateUp(indices[n]);
        35,452      0    0        17,726           0     0             0           0     0              percolateDown(indices[n]); }
             .      .    .             .           .     .             .           .     .      }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .      void insert(int n)
             .      .    .             .           .     .             .           .     .      {
    27,291,523      2    2             0           0     0             0           0     0          indices.growTo(n+1, -1);
             .      .    .             .           .     .             .           .     .          assert(!inHeap(n));
             .      .    .             .           .     .             .           .     .  
    54,583,046      1    1    27,291,523           0     0    27,291,523           0     0          indices[n] = heap.size();
        19,410      1    1             0           0     0        12,892           0     0          heap.push(n);
    54,583,046      0    0    27,291,523           0     0             0           0     0          percolateUp(indices[n]); 
             .      .    .             .           .     .             .           .     .      }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .      int  removeMin()
             .      .    .             .           .     .             .           .     .      {
    81,840,621      1    1    54,560,414   1,286,453     5    27,280,207         267     0          int x            = heap[0];
    54,560,414      0    0    27,280,207   2,636,517    33    27,280,207           0     0          heap[0]          = heap.last();
    54,560,414     27   22    27,280,207           0     0    27,280,207  13,564,447   304          indices[heap[0]] = 0;
    27,280,207      1    1             0           0     0    27,280,207   2,154,682     9          indices[x]       = -1;
             .      .    .             .           .     .             .           .     .          heap.pop();
    54,560,414      0    0             0           0     0             0           0     0          if (heap.size() > 1) percolateDown(0);
             .      .    .             .           .     .             .           .     .          return x; 
             .      .    .             .           .     .             .           .     .      }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .      // Rebuild the heap from scratch, using the elements in 'ns':
             .      .    .             .           .     .             .           .     .      void build(const vec<int>& ns) {
       372,024     33    6       186,012          48     0             0           0     0          for (int i = 0; i < heap.size(); i++)
       186,084     23    3            72           0     0       185,868      15,660   598              indices[heap[i]] = -1;
            72      0    0             0           0     0             0           0     0          heap.clear();
             .      .    .             .           .     .             .           .     .  
       364,218      8    3       182,001          47     0             0           0     0          for (int i = 0; i < ns.size(); i++){
       363,858      0    0       181,929           0     0       181,929       2,771     0              indices[ns[i]] = i;
             .      .    .             .           .     .             .           .     .              heap.push(ns[i]); }
             .      .    .             .           .     .             .           .     .  
       637,380     57    9        91,020           0     0            72           0     0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
             .      .    .             .           .     .             .           .     .              percolateDown(i);
             .      .    .             .           .     .             .           .     .      }
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .      void clear(bool dealloc = false) 
             .      .    .             .           .     .             .           .     .      { 
             4      0    0             2           1     0             0           0     0          for (int i = 0; i < heap.size(); i++)
             .      .    .             .           .     .             .           .     .              indices[heap[i]] = -1;
             .      .    .             .           .     .             .           .     .          heap.clear(dealloc); 
             .      .    .             .           .     .             .           .     .      }
             .      .    .             .           .     .             .           .     .  };
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  
             .      .    .             .           .     .             .           .     .  //=================================================================================================
             .      .    .             .           .     .             .           .     .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr             D1mr           DLmr    Dw             D1mw        DLmw  

-- line 51 ----------------------------------------
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  //=================================================================================================
              .       .    .              .              .       .              .           .     .  // Options:
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  static const char* _cat = "CORE";
              .       .    .              .              .       .              .           .     .  
              4       0    0              0              0       0              1           0     0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1           0     0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1           0     0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
              4       1    1              0              0       0              1           0     0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1           0     0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1           0     0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
              4       0    0              0              0       0              1           0     0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
              4       0    0              0              0       0              1           0     0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
              4       0    0              0              0       0              1           0     0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
              4       1    1              0              0       0              1           0     0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
              4       0    0              0              0       0              1           0     0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
              4       1    1              0              0       0              1           0     0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
              4       1    1              0              0       0              1           0     0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
              4       1    1              0              0       0              1           0     0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
              4       1    1              0              0       0              1           0     0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
              .       .    .              .              .       .              .           .     .  
              4       1    1              0              0       0              1           0     0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
              1       1    1              0              0       0              1           0     0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
              4       0    0              0              0       0              1           0     0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
              .       .    .              .              .       .              .           .     .  
              4       1    1              0              0       0              1           0     0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  //VSIDS_props_limit
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  //=================================================================================================
              .       .    .              .              .       .              .           .     .  // Constructor/Destructor:
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              4       1    1              0              0       0              2           0     0  Solver::Solver() :
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Parameters (user settable):
              .       .    .              .              .       .              .           .     .      //
              .       .    .              .              .       .              .           .     .      drup_file        (NULL)
              .       .    .              .              .       .              .           .     .    , verbosity        (0)
              .       .    .              .              .       .              .           .     .    , step_size        (opt_step_size)
              .       .    .              .              .       .              .           .     .    , step_size_dec    (opt_step_size_dec)
              .       .    .              .              .       .              .           .     .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
              .       .    .              .              .       .              .           .     .    , garbage_frac     (opt_garbage_frac)
              .       .    .              .              .       .              .           .     .    , restart_first    (opt_restart_first)
              .       .    .              .              .       .              .           .     .    , restart_inc      (opt_restart_inc)
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .    , min_number_of_learnts_copies(opt_min_dupl_app)  
              .       .    .              .              .       .              .           .     .    , max_lbd_dup(opt_max_lbd_dup)
              .       .    .              .              .       .              .           .     .    , dupl_db_init_size(opt_dupl_db_init_size)
              3       1    1              1              0       0              1           0     0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .    // Parameters (the rest):
              .       .    .              .              .       .              .           .     .    //
              .       .    .              .              .       .              .           .     .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .    // Parameters (experimental):
              .       .    .              .              .       .              .           .     .    //
              .       .    .              .              .       .              .           .     .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
              .       .    .              .              .       .              .           .     .    //
              .       .    .              .              .       .              .           .     .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
              .       .    .              .              .       .              .           .     .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
              .       .    .              .              .       .              .           .     .    , chrono_backtrack(0), non_chrono_backtrack(0)
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .    , ok                 (true)
              .       .    .              .              .       .              .           .     .    , cla_inc            (1)
              .       .    .              .              .       .              .           .     .    , var_inc            (1)
              1       0    0              0              0       0              0           0     0    , watches_bin        (WatcherDeleted(ca))
              .       .    .              .              .       .              .           .     .    , watches            (WatcherDeleted(ca))
              .       .    .              .              .       .              .           .     .    , qhead              (0)
              .       .    .              .              .       .              .           .     .    , simpDB_assigns     (-1)
              .       .    .              .              .       .              .           .     .    , simpDB_props       (0)
              .       .    .              .              .       .              .           .     .    , order_heap_CHB     (VarOrderLt(activity_CHB))
              .       .    .              .              .       .              .           .     .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
              .       .    .              .              .       .              .           .     .    , progress_estimate  (0)
              .       .    .              .              .       .              .           .     .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
              .       .    .              .              .       .              .           .     .    // simplifyAll adjust occasion
              .       .    .              .              .       .              .           .     .    , curSimplify(1)
              .       .    .              .              .       .              .           .     .    , nbconfbeforesimplify(1000)
              .       .    .              .              .       .              .           .     .    , incSimplify(1000)
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .    , my_var_decay       (0.6)
              .       .    .              .              .       .              .           .     .    , DISTANCE           (true)
              .       .    .              .              .       .              .           .     .    , var_iLevel_inc     (1)
             94       8    8             25              2       2             63           1     0    , order_heap_distance(VarOrderLt(activity_distance))
              .       .    .              .              .       .              .           .     .  
              4       0    0              3              0       0              0           0     0  {}
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  Solver::~Solver()
              .       .    .              .              .       .              .           .     .  {
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  // simplify All
              .       .    .              .              .       .              .           .     .  //
              .       .    .              .              .       .              .           .     .  CRef Solver::simplePropagate()
     54,610,088       7    7              0              0       0     40,957,566       6,840     0  {
      6,826,261       0    0              0              0       0      6,826,261           0     0      CRef    confl = CRef_Undef;
      6,826,261       0    0              0              0       0      6,826,261         166     0      int     num_props = 0;
     13,652,522       0    0              0              0       0      6,826,261       6,633     0      watches.cleanAll();
     20,478,783      49   31      6,826,261            169       0      6,826,261           0     0      watches_bin.cleanAll();
    188,530,724       0    0     94,265,362              0       0              0           0     0      while (qhead < trail.size())
              .       .    .              .              .       .              .           .     .      {
    437,269,425       4    4    174,907,770      3,596,793       0    174,907,770           0     0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .    .              .              .       .              .           .     .          vec<Watcher>&  ws = watches[p];
              .       .    .              .              .       .              .           .     .          Watcher        *i, *j, *end;
     87,439,101       0    0     87,439,101              2       0              0           0     0          num_props++;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          // First, Propagate binary clauses
              .       .    .              .              .       .              .           .     .          vec<Watcher>&  wbin = watches_bin[p];
              .       .    .              .              .       .              .           .     .  
    625,867,708       0    0     87,453,885     83,631,735     349              0           0     0          for (int k = 0; k<wbin.size(); k++)
              .       .    .              .              .       .              .           .     .          {
              .       .    .              .              .       .              .           .     .  
    180,192,414       0    0    136,735,395     50,332,139     941              0           0     0              Lit imp = wbin[k].blocker;
              .       .    .              .              .       .              .           .     .  
    180,192,414       0    0              0              0       0              0           0     0              if (value(imp) == l_False)
              .       .    .              .              .       .              .           .     .              {
         29,568       0    0         14,784              0       0         14,784           0     0                  return wbin[k].cref;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
    180,162,846       8    8              0              0       0              0           0     0              if (value(imp) == l_Undef)
              .       .    .              .              .       .              .           .     .              {
     34,795,842       0    0     34,795,842              0       0              0           0     0                  simpleUncheckEnqueue(imp, wbin[k].cref);
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
  9,525,213,254      39   25  4,501,908,987     68,437,246     167    170,350,014           0     0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
              .       .    .              .              .       .              .           .     .          {
              .       .    .              .              .       .              .           .     .              // Try to avoid inspecting the clause:
  4,327,030,785      35   17  4,327,030,785    594,739,629  16,033              0           0     0              Lit blocker = i->blocker;
  8,654,061,570       0    0  4,327,030,785     78,171,013       0              0           0     0              if (value(blocker) == l_True)
              .       .    .              .              .       .              .           .     .              {
              .       .    .              .              .       .              .           .     .                  *j++ = *i++; continue;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Make sure the false literal is data[1]:
  6,296,598,780       0    0  3,148,299,390              0       0              0           0     0              CRef     cr = i->cref;
              .       .    .              .              .       .              .           .     .              Clause&  c = ca[cr];
              .       .    .              .              .       .              .           .     .              Lit      false_lit = ~p;
  9,444,898,170       0    0  3,148,299,390  3,017,516,756   3,670              0           0     0              if (c[0] == false_lit)
  3,584,996,982       0    0  1,194,998,994     70,751,718     256  2,389,997,988           0     0                  c[0] = c[1], c[1] = false_lit;
              .       .    .              .              .       .              .           .     .              assert(c[1] == false_lit);
              .       .    .              .              .       .              .           .     .              //  i++;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // If 0th watch is true, then clause is already satisfied.
              .       .    .              .              .       .              .           .     .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
              .       .    .              .              .       .              .           .     .              // why not simply do i->blocker=first in this case?
              .       .    .              .              .       .              .           .     .              Lit     first = c[0];
              .       .    .              .              .       .              .           .     .              //  Watcher w     = Watcher(cr, first);
  7,946,246,090       0    0    824,823,655     13,242,432       0              0           0     0              if (first != blocker && value(first) == l_True)
              .       .    .              .              .       .              .           .     .              {
    219,960,204       0    0              0              0       0    219,960,204           0     0                  i->blocker = first;
  5,594,766,396       0    0  1,398,691,599              0       0  1,398,691,599  10,394,568     0                  *j++ = *i++; continue;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Look for new watch:
              .       .    .              .              .       .              .           .     .              //if (incremental)
              .       .    .              .              .       .              .           .     .              //{ // ----------------- INCREMENTAL MODE
              .       .    .              .              .       .              .           .     .              //	int choosenPos = -1;
              .       .    .              .              .       .              .           .     .              //	for (int k = 2; k < c.size(); k++)
              .       .    .              .              .       .              .           .     .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
              .       .    .              .              .       .              .           .     .              //		Watcher w = Watcher(cr, first); i++;
              .       .    .              .              .       .              .           .     .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
              .       .    .              .              .       .              .           .     .              //		watches[~c[1]].push(w);
              .       .    .              .              .       .              .           .     .              //		goto NextClause;
              .       .    .              .              .       .              .           .     .              //	}
              .       .    .              .              .       .              .           .     .              //}
              .       .    .              .              .       .              .           .     .              else
              .       .    .              .              .       .              .           .     .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
  9,505,267,728      49   35              0              0       0              0           0     0                  for (int k = 2; k < c.size(); k++)
              .       .    .              .              .       .              .           .     .                  {
              .       .    .              .              .       .              .           .     .  
 17,580,198,951       0    0              0              0       0              0           0     0                      if (value(c[k]) != l_False)
              .       .    .              .              .       .              .           .     .                      {
              .       .    .              .              .       .              .           .     .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
              .       .    .              .              .       .              .           .     .                          // the blocker is first in the watcher. However,
              .       .    .              .              .       .              .           .     .                          // the blocker in the corresponding watcher in ~first is not c[1]
              .       .    .              .              .       .              .           .     .                          Watcher w = Watcher(cr, first); i++;
 11,514,676,220       0    0  2,878,669,055              0       0  5,757,338,110           0     0                          c[1] = c[k]; c[k] = false_lit;
              .       .    .              .              .       .              .           .     .                          watches[~c[1]].push(w);
  2,878,669,055       0    0              0              0       0              0           0     0                          goto NextClause;
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Did not find watch -- clause is unit under assignment:
     49,670,131       0    0              0              0       0     49,670,131           0     0              i->blocker = first;
    198,680,524       3    0     49,670,131              0       0     49,670,131     165,431     0              *j++ = *i++;
     99,340,262      49   31              0              0       0              0           0     0              if (value(first) == l_False)
              .       .    .              .              .       .              .           .     .              {
      1,484,304       6    3              0              0       0        226,352           2     0                  confl = cr;
        452,704      44   26        226,352          4,761       0        226,352           0     0                  qhead = trail.size();
              .       .    .              .              .       .              .           .     .                  // Copy the remaining watches:
     26,411,666       4    1        432,672          1,805       0              0           0     0                  while (i < end)
     12,546,809       0    0     12,546,809      1,557,335       2     12,546,809      52,919     0                      *j++ = *i++;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              else
              .       .    .              .              .       .              .           .     .              {
              .       .    .              .              .       .              .           .     .                  simpleUncheckEnqueue(first, cr);
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  NextClause:;
              .       .    .              .              .       .              .           .     .          }
    165,821,826      49   30              0              0       0              0           0     0          ws.shrink(i - j);
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
     13,622,954       0    0     13,622,954      2,649,002       0              0           0     0      s_propagations += num_props;
              .       .    .              .              .       .              .           .     .  
      6,811,477       0    0      6,811,477              0       0              0           0     0      return confl;
  2,208,653,005      53   32     47,783,827      2,890,292       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
              .       .    .              .              .       .              .           .     .      assert(value(p) == l_Undef);
     84,239,621       0    0              0              0       0     84,239,621           0     0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
    182,131,764      49   30     91,065,882      1,028,844       0     91,065,882  73,525,549    42      vardata[var(p)].reason = from;
     56,270,040       0    0     56,270,040              0       0              0           0     0      trail.push_(p);
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::cancelUntilTrailRecord()
              .       .    .              .              .       .              .           .     .  {
    184,094,339       0    0        785,030              0       0              0           0     0      for (int c = trail.size() - 1; c >= trailRecord; c--)
              .       .    .              .              .       .              .           .     .      {
        392,515      49   29        392,515              0       0              0           0     0          Var x = var(trail[c]);
     92,243,427       0    0        392,515              0       0     91,065,882   2,432,065     0          assigns[x] = l_Undef;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      }
        392,515       0    0              0              0       0        392,515           0     0      qhead = trailRecord;
        785,030       0    0              0              0       0              0           0     0      trail.shrink(trail.size() - trailRecord);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::litsEnqueue(int cutP, Clause& c)
              .       .    .              .              .       .              .           .     .  {
              .       .    .              .              .       .              .           .     .      for (int i = cutP; i < c.size(); i++)
              .       .    .              .              .       .              .           .     .      {
              .       .    .              .              .       .              .           .     .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  bool Solver::removed(CRef cr) {
              .       .    .              .              .       .              .           .     .      return ca[cr].mark() == 1;
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
      4,294,048      45   28              0              0       0      2,342,208           0     0  {
        390,368       0    0              0              0       0              0           0     0      int pathC = 0;
        390,368       0    0              0              0       0              0           0     0      Lit p = lit_Undef;
      1,171,104       0    0        390,368              0       0              0           0     0      int index = trail.size() - 1;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      do{
     43,998,436      49   30              0              0       0              0           0     0          if (confl != CRef_Undef){
              .       .    .              .              .       .              .           .     .              reason_clause.push(confl);
              .       .    .              .              .       .              .           .     .              Clause& c = ca[confl];
              .       .    .              .              .       .              .           .     .              // Special case for binary clauses
              .       .    .              .              .       .              .           .     .              // The first one has to be SAT
     70,057,834      66   29              0              0       0              0           0     0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                  assert(value(c[1]) == l_True);
              .       .    .              .              .       .              .           .     .                  Lit tmp = c[0];
      2,283,312       0    0        761,104         44,376       0      1,522,208           0     0                  c[0] = c[1], c[1] = tmp;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              // if True_confl==true, then choose p begin with the 1th index of c;
    138,455,916       0    0     29,492,622        382,724       0              0           0     0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
              .       .    .              .              .       .              .           .     .                  Lit q = c[j];
     77,674,908       0    0     38,837,454      3,590,747       0              0           0     0                  if (!seen[var(q)]){
     21,608,906       0    0              0              0       0     21,608,906           0     0                      seen[var(q)] = 1;
     64,826,718       0    0     21,608,906              0       0              0           0     0                      pathC++;
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          else if (confl == CRef_Undef){
              .       .    .              .              .       .              .           .     .              out_learnt.push(~p);
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
     71,695,292      49   29     21,608,905              0       0              0           0     0          if (pathC == 0) break;
              .       .    .              .              .       .              .           .     .          // Select next clause to look at:
    606,982,970       0    0    202,327,675     12,307,270       0              0           0     0          while (!seen[var(trail[index--])]);
              .       .    .              .              .       .              .           .     .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
              .       .    .              .              .       .              .           .     .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
     43,217,810       0    0     21,608,905              0       0              0           0     0          if (trailRecord > index + 1) break;
              .       .    .              .              .       .              .           .     .          p = trail[index + 1];
              .       .    .              .              .       .              .           .     .          confl = reason(var(p));
     21,608,850       0    0              0              0       0     21,608,850           0     0          seen[var(p)] = 0;
     21,608,850       0    0              0              0       0              0           0     0          pathC--;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      } while (pathC >= 0);
      3,903,680      55   30      2,732,576         32,822       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::simplifyLearnt(Clause& c)
      3,532,635      98   63              0              0       0      2,355,090         432     0  {
              .       .    .              .              .       .              .           .     .      ////
        392,515       0    0        392,515          8,802       0              0           0     0      original_length_record += c.size();
              .       .    .              .              .       .              .           .     .  
        785,030       0    0        392,515          5,838       0        392,515           0     0      trailRecord = trail.size();// record the start pointer
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      vec<Lit> falseLit;
              .       .    .              .              .       .              .           .     .      falseLit.clear();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
              .       .    .              .              .       .              .           .     .  
        482,272      43   25              0              0       0              0           0     0      bool True_confl = false;
              .       .    .              .              .       .              .           .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .           .     .      beforeSize = c.size();
              .       .    .              .              .       .              .           .     .      int i, j;
              .       .    .              .              .       .              .           .     .      CRef confl;
              .       .    .              .              .       .              .           .     .  
     24,695,205      49   29              0              0       0              0           0     0      for (i = 0, j = 0; i < c.size(); i++){
     15,674,146       0    0              0              0       0              0           0     0          if (value(c[i]) == l_Undef){
              .       .    .              .              .       .              .           .     .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
              .       .    .              .              .       .              .           .     .              simpleUncheckEnqueue(~c[i]);
     27,063,908       0    0      6,826,261              0       0      6,826,261     126,356     0              c[j++] = c[i];
     20,478,783       0    0              0              0       0      6,826,261           0     0              confl = simplePropagate();
     20,478,783      49   29      6,826,261      2,790,720       0              0           0     0              if (confl != CRef_Undef){
              .       .    .              .              .       .              .           .     .                  break;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          else{
      2,021,624       0    0              0              0       0              0           0     0              if (value(c[i]) == l_True){
              .       .    .              .              .       .              .           .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
        596,928      30   15        149,232              0       0        149,232       5,031     0                  c[j++] = c[i];
        149,232      25   16              0              0       0              0           0     0                  True_confl = true;
              .       .    .              .              .       .              .           .     .                  confl = reason(var(c[i]));
              .       .    .              .              .       .              .           .     .                  break;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              else{
              .       .    .              .              .       .              .           .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
              .       .    .              .              .       .              .           .     .                  falseLit.push(c[i]);
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .      c.shrink(c.size() - j);
              .       .    .              .              .       .              .           .     .      afterSize = c.size();
              .       .    .              .              .       .              .           .     .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      if (confl != CRef_Undef || True_confl == true){
        390,368       0    0              0              0       0              0           0     0          simp_learnt_clause.clear();
        390,368       0    0              0              0       0              0           0     0          simp_reason_clause.clear();
        780,736       0    0              0              0       0              0           0     0          if (True_confl == true){
              .       .    .              .              .       .              .           .     .              simp_learnt_clause.push(c.last());
              .       .    .              .              .       .              .           .     .          }
      2,732,576      24   14              0              0       0        390,368           0     0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
              .       .    .              .              .       .              .           .     .  
      1,171,104       0    0        390,368              0       0              0           0     0          if (simp_learnt_clause.size() < c.size()){
      5,130,782      49   29      2,344,125              0       0              0           0     0              for (i = 0; i < simp_learnt_clause.size(); i++){
      8,933,968       0    0      2,233,492            210       0      2,233,492      76,473     0                  c[i] = simp_learnt_clause[i];
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              c.shrink(c.size() - i);
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      cancelUntilTrailRecord();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      ////
        392,515       0    0        392,515              0       0              0           0     0      simplified_length_record += c.size();
              .       .    .              .              .       .              .           .     .  
      3,140,120       0    0      2,747,605        385,089       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
              .       .    .              .              .       .              .           .     .  {
              .       .    .              .              .       .              .           .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .           .     .      int learnts_x_size_before = learnts_x.size();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      int ci, cj, li, lj;
              .       .    .              .              .       .              .           .     .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .              .              .       .              .           .     .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      return true;
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  bool Solver::simplifyLearnt_core()
            539       0    0              0              0       0            294           0     0  {
              .       .    .              .              .       .              .           .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .           .     .      int learnts_core_size_before = learnts_core.size();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      int ci, cj, li, lj;
              .       .    .              .              .       .              .           .     .      bool sat, false_lit;
              .       .    .              .              .       .              .           .     .      unsigned int nblevels;
              .       .    .              .              .       .              .           .     .      ////
              .       .    .              .              .       .              .           .     .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      ////
              .       .    .              .              .       .              .           .     .      int nbSimplified = 0;
              .       .    .              .              .       .              .           .     .      int nbSimplifing = 0;
              .       .    .              .              .       .              .           .     .  
      5,489,405      49   31             49              0       0              0           0     0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
      8,233,821      49   32      5,489,214        171,583  32,590              0           0     0          CRef cr = learnts_core[ci];
              .       .    .              .              .       .              .           .     .          Clause& c = ca[cr];
              .       .    .              .              .       .              .           .     .  
      5,489,214       0    0              0              0       0              0           0     0          if (removed(cr)) continue;
      5,489,214       0    0      2,744,607        338,377   1,000              0           0     0          else if (c.simplified()){
      5,337,318       0    0              0              0       0      2,668,659           0     0              learnts_core[cj++] = learnts_core[ci];
              .       .    .              .              .       .              .           .     .              ////
      8,006,015       0    0      2,668,659              0       0              0           0     0              nbSimplified++;
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          else{
              .       .    .              .              .       .              .           .     .              int saved_size=c.size();
              .       .    .              .              .       .              .           .     .              //         if (drup_file){
              .       .    .              .              .       .              .           .     .              //                 add_oc.clear();
              .       .    .              .              .       .              .           .     .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .    .              .              .       .              .           .     .              ////
              .       .    .              .              .       .              .           .     .              nbSimplifing++;
         75,944       0    0              0              0       0              0           0     0              sat = false_lit = false;
      2,178,092       0    0              0              0       0              0           0     0              for (int i = 0; i < c.size(); i++){
      2,178,114       0    0              0              0       0              0           0     0                  if (value(c[i]) == l_True){
              .       .    .              .              .       .              .           .     .                      sat = true;
              .       .    .              .              .       .              .           .     .                      break;
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .                  else if (value(c[i]) == l_False){
      2,329,972      49   33              0              0       0         75,944          47     0                      false_lit = true;
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              if (sat){
            105       3    3             30              0       0             30           0     0                  removeClause(cr);
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              else{
        455,598       0    0              0              0       0        227,799           0     0                  detachClause(cr, true);
              .       .    .              .              .       .              .           .     .  
        303,732      49   30        151,866            150       0              0           0     0                  if (false_lit){
          1,523       0    0            122              0       0              0           0     0                      for (li = lj = 0; li < c.size(); li++){
            974       0    0              0              0       0              0           0     0                          if (value(c[li]) != l_False){
          1,254       0    0              0              0       0            418           0     0                              c[lj++] = c[li];
              .       .    .              .              .       .              .           .     .                          }
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                      c.shrink(li - lj);
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                  beforeSize = c.size();
              .       .    .              .              .       .              .           .     .                  assert(c.size() > 1);
              .       .    .              .              .       .              .           .     .                  // simplify a learnt clause c
        303,732       0    0              0              0       0        151,866           0     0                  simplifyLearnt(c);
              .       .    .              .              .       .              .           .     .                  assert(c.size() > 0);
              .       .    .              .              .       .              .           .     .                  afterSize = c.size();
              .       .    .              .              .       .              .           .     .                  
        386,224       0    0        227,799        141,381       0              0           0     0                  if(drup_file && saved_size !=c.size()){
              .       .    .              .              .       .              .           .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .           .     .                      binDRUP('a', c , drup_file);
              .       .    .              .              .       .              .           .     .                      //                    binDRUP('d', add_oc, drup_file);
              .       .    .              .              .       .              .           .     .  #else
              .       .    .              .              .       .              .           .     .                      for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .           .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .           .     .                      fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
              .       .    .              .              .       .              .           .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .    .              .              .       .              .           .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .              .              .       .              .           .     .                      //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .    .              .              .       .              .           .     .  
        151,866       0    0              0              0       0              0           0     0                  if (c.size() == 1){
              .       .    .              .              .       .              .           .     .                      // when unit clause occur, enqueue and propagate
             20       3    1              4              0       0              4           0     0                      uncheckedEnqueue(c[0]);
             12       0    0              4              0       0              0           0     0                      if (propagate() != CRef_Undef){
              .       .    .              .              .       .              .           .     .                          ok = false;
              .       .    .              .              .       .              .           .     .                          return false;
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                      // delete the clause memory in logic
              .       .    .              .              .       .              .           .     .                      c.mark(1);
              .       .    .              .              .       .              .           .     .                      ca.free(cr);
              .       .    .              .              .       .              .           .     .  //#ifdef BIN_DRUP
              .       .    .              .              .       .              .           .     .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
              .       .    .              .              .       .              .           .     .  //#else
              .       .    .              .              .       .              .           .     .  //                    fprintf(drup_file, "d ");
              .       .    .              .              .       .              .           .     .  //                    for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .           .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .           .     .  //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  //#endif
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .                  else{
        227,787       0    0              0              0       0         75,929           0     0                      attachClause(cr);
        455,574      49   35        227,787        141,749       0         75,929         339     0                      learnts_core[cj++] = learnts_core[ci];
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                      nblevels = computeLBD(c);
        151,858      46   33              0              0       0              0           0     0                      if (nblevels < c.lbd()){
              .       .    .              .              .       .              .           .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .    .              .              .       .              .           .     .                          c.set_lbd(nblevels);
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                      c.setSimplified(true);
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
             49       0    0              0              0       0              0           0     0      learnts_core.shrink(ci - cj);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .              .              .       .              .           .     .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
              .       .    .              .              .       .              .           .     .  
             49      32   20              0              0       0              0           0     0      return true;
              .       .    .              .              .       .              .           .     .  
            392       0    0            343             49       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
     18,514,620       2    2              0              0       0     12,343,080           0     0  int Solver::is_duplicate(std::vector<uint32_t>&c){
      4,114,360       0    0              0              0       0      4,114,360      47,209     0     auto time_point_0 = std::chrono::high_resolution_clock::now();
      2,057,180       0    0      2,057,180      1,224,896       1              0           0     0      dupl_db_size++;
      4,659,956     980   13        683,846              0       0              0           0     0      int res = 0;    
              .       .    .              .              .       .              .           .     .      
      4,114,360       0    0      4,114,360              0       0              0           0     0      int sz = c.size();
              .       .    .              .              .       .              .           .     .      std::vector<uint32_t> tmp(c);    
              .       .    .              .              .       .              .           .     .      sort(tmp.begin(),tmp.end());
              .       .    .              .              .       .              .           .     .      
      2,057,180 199,582    8              0              0       0      2,057,180           0     0      uint64_t hash = 0;    
              .       .    .              .              .       .              .           .     .      
    153,639,132   5,139   55              0              0       0      2,057,180           0     0      for (int i =0; i<sz; i++) {
    685,908,460       0    0     68,590,846              0       0              0           0     0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
              .       .    .              .              .       .              .           .     .      }    
              .       .    .              .              .       .              .           .     .      
      2,057,180       0    0              0              0       0      2,057,180           0     0      int32_t head = tmp[0];
              .       .    .              .              .       .              .           .     .      auto it0 = ht.find(head);
     10,275,569       0    0      2,057,176              0       0              0           0     0      if (it0 != ht.end()){
              .       .    .              .              .       .              .           .     .          auto it1=ht[head].find(sz);
      4,107,478       0    0              0              0       0              0           0     0          if (it1 != ht[head].end()){
      1,960,963       0    0              0              0       0      1,960,963           0     0              auto it2 = ht[head][sz].find(hash);
      5,882,889       0    0              0              0       0      1,960,963           0     0              if (it2 != ht[head][sz].end()){
        207,375       0    0         69,125         15,618   4,085         69,125           0     0                  it2->second++;
         69,125       0    0              0              0       0              0           0     0                  res = it2->second;            
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              else{
      1,891,838       0    0              0              0       0      1,891,838           0     0                  ht[head][sz][hash]=1;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          else{            
        185,552       9    0              0              0       0         92,776           0     0              ht[head][sz][hash]=1;
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }else{        
      1,991,496   2,151   62              0              0       0      1,991,496          92     0          ht[head][sz][hash]=1;
              .       .    .              .              .       .              .           .     .      } 
      2,057,180     101    3              0              0       0      2,057,180           0     0      auto time_point_1 = std::chrono::high_resolution_clock::now();
              .       .    .              .              .       .              .           .     .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
              .       .    .              .              .       .              .           .     .      return res;
     18,514,620       0    0     14,400,260            481       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  bool Solver::simplifyLearnt_tier2()
            539      49   31              0              0       0            294           0     0  {
              .       .    .              .              .       .              .           .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .           .     .      int learnts_tier2_size_before = learnts_tier2.size();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      int ci, cj, li, lj;
              .       .    .              .              .       .              .           .     .      bool sat, false_lit;
              .       .    .              .              .       .              .           .     .      unsigned int nblevels;
              .       .    .              .              .       .              .           .     .      ////
              .       .    .              .              .       .              .           .     .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      ////
              .       .    .              .              .       .              .           .     .      int nbSimplified = 0;
              .       .    .              .              .       .              .           .     .      int nbSimplifing = 0;
              .       .    .              .              .       .              .           .     .  
        842,799      41    7             49             49       0              0           0     0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
      1,263,978       0    0        842,652         32,633   1,869              0           0     0          CRef cr = learnts_tier2[ci];
              .       .    .              .              .       .              .           .     .          Clause& c = ca[cr];
              .       .    .              .              .       .              .           .     .  
        842,652       0    0              0              0       0              0           0     0          if (removed(cr)) continue;
        842,636       0    0        421,318         51,757       0              0           0     0          else if (c.simplified()){
        208,694       0    0              0              0       0        104,347         676     0              learnts_tier2[cj++] = learnts_tier2[ci];
              .       .    .              .              .       .              .           .     .              ////
        946,999       0    0        104,347              0       0              0           0     0              nbSimplified++;
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          else{
              .       .    .              .              .       .              .           .     .              int saved_size=c.size();
              .       .    .              .              .       .              .           .     .              //            if (drup_file){
              .       .    .              .              .       .              .           .     .              //                    add_oc.clear();
              .       .    .              .              .       .              .           .     .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .    .              .              .       .              .           .     .              ////
              .       .    .              .              .       .              .           .     .              nbSimplifing++;
        316,891       0    0              0              0       0              0           0     0              sat = false_lit = false;
     16,172,212       0    0              0              0       0              0           0     0              for (int i = 0; i < c.size(); i++){
     16,172,830       0    0              0              0       0              0           0     0                  if (value(c[i]) == l_True){
              .       .    .              .              .       .              .           .     .                      sat = true;
              .       .    .              .              .       .              .           .     .                      break;
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .                  else if (value(c[i]) == l_False){
     16,805,834      12    7              0              0       0        316,891           0     0                      false_lit = true;
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              if (sat){
          1,945       0    0            389              0       0            389           0     0                  removeClause(cr);
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              else{
      1,899,492      35   23              0              0       0        949,746          47     0                  detachClause(cr, true);
              .       .    .              .              .       .              .           .     .  
      1,266,328       0    0        633,164          3,943       0              0           0     0                  if (false_lit){
         82,550       4    3          2,640             64       0              0           0     0                      for (li = lj = 0; li < c.size(); li++){
         70,670       0    0              0              0       0              0           0     0                          if (value(c[li]) != l_False){
        101,535       0    0              0              0       0         33,845           0     0                              c[lj++] = c[li];
              .       .    .              .              .       .              .           .     .                          }
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                      c.shrink(li - lj);
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                  beforeSize = c.size();
              .       .    .              .              .       .              .           .     .                  assert(c.size() > 1);
              .       .    .              .              .       .              .           .     .                  // simplify a learnt clause c
      1,582,910       0    0              0              0       0        949,746           0     0                  simplifyLearnt(c);
              .       .    .              .              .       .              .           .     .                  assert(c.size() > 0);
              .       .    .              .              .       .              .           .     .                  afterSize = c.size();
              .       .    .              .              .       .              .           .     .                  
      1,266,328      49   28        633,164        628,565       0              0           0     0                  if(drup_file && saved_size!=c.size()){
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .           .     .                      binDRUP('a', c , drup_file);
              .       .    .              .              .       .              .           .     .                      //                    binDRUP('d', add_oc, drup_file);
              .       .    .              .              .       .              .           .     .  #else
              .       .    .              .              .       .              .           .     .                      for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .           .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .           .     .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
              .       .    .              .              .       .              .           .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .    .              .              .       .              .           .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .              .              .       .              .           .     .                      //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .    .              .              .       .              .           .     .  
        633,164       0    0              0              0       0              0           0     0                  if (c.size() == 1){
              .       .    .              .              .       .              .           .     .                      // when unit clause occur, enqueue and propagate
              .       .    .              .              .       .              .           .     .                      uncheckedEnqueue(c[0]);
              .       .    .              .              .       .              .           .     .                      if (propagate() != CRef_Undef){
              .       .    .              .              .       .              .           .     .                          ok = false;
              .       .    .              .              .       .              .           .     .                          return false;
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                      // delete the clause memory in logic
              .       .    .              .              .       .              .           .     .                      c.mark(1);
-- line 838 ----------------------------------------
-- line 845 ----------------------------------------
              .       .    .              .              .       .              .           .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .           .     .  //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  //#endif
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .                  else{
              .       .    .              .              .       .              .           .     .                      
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                      nblevels = computeLBD(c);
        633,164       0    0              0              0       0              0           0     0                      if (nblevels < c.lbd()){
              .       .    .              .              .       .              .           .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .    .              .              .       .              .           .     .                          c.set_lbd(nblevels);
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                       //duplicate learnts 
              .       .    .              .              .       .              .           .     .                      int id = 0;                    
              .       .    .              .              .       .              .           .     .                      
              .       .    .              .              .       .              .           .     .                      std::vector<uint32_t> tmp;
     22,118,369       0    0     16,400,485              0       0              0           0     0                      for (int i = 0; i < c.size(); i++)                           
     11,355,766       0    0      5,677,883              0       0      5,677,883           0     0                          tmp.push_back(c[i].x);
      1,266,328       0    0              0              0       0        316,582           0     0                      id = is_duplicate(tmp);
              .       .    .              .              .       .              .           .     .                       
              .       .    .              .              .       .              .           .     .                                          
              .       .    .              .              .       .              .           .     .                      //duplicate learnts 
              .       .    .              .              .       .              .           .     .  
      1,266,328       6    6        316,582        314,367       0              0           0     0                      if (id < min_number_of_learnts_copies+2){
        929,289      15   13              0              0       0        309,763           0     0                          attachClause(cr);
      1,539,546       0    0        929,289        615,850       0        309,763     288,817     0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
      1,239,052      49   32        309,763              0       0              0           0     0                          if (id == min_number_of_learnts_copies+1){                            
            742       3    3            742              0       0              0           0     0                              duplicates_added_minimization++;                                  
              .       .    .              .              .       .              .           .     .                          }
        618,042       0    0        309,021        307,258       0              0           0     0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
              .       .    .              .              .       .              .           .     .                          //if (id == min_number_of_learnts_copies+1){
              .       .    .              .              .       .              .           .     .                              cj--;
              2       2    1              0              0       0              0           0     0                              learnts_core.push(cr);
              .       .    .              .              .       .              .           .     .                              c.mark(CORE);
              .       .    .              .              .       .              .           .     .                          }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                          c.setSimplified(true);
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
             49      44   32              0              0       0              0           0     0      learnts_tier2.shrink(ci - cj);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .              .              .       .              .           .     .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
              .       .    .              .              .       .              .           .     .  
             49       0    0              0              0       0              0           0     0      return true;
              .       .    .              .              .       .              .           .     .  
            392       0    0            343             49       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  bool Solver::simplifyAll()
            245      12    8              0              0       0            147           0     0  {
              .       .    .              .              .       .              .           .     .      ////
             98       0    0              0              0       0             49           0     0      simplified_length_record = original_length_record = 0;
              .       .    .              .              .       .              .           .     .  
            196       0    0             49             24       0              0           0     0      if (!ok || propagate() != CRef_Undef)
              .       .    .              .              .       .              .           .     .          return ok = false;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      //// cleanLearnts(also can delete these code), here just for analyzing
              .       .    .              .              .       .              .           .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .    .              .              .       .              .           .     .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
              .       .    .              .              .       .              .           .     .      //local_learnts_dirty = tier2_learnts_dirty = false;
              .       .    .              .              .       .              .           .     .  
            196       0    0              0              0       0             49           0     0      if (!simplifyLearnt_core()) return ok = false;
            196      49   31              0              0       0             49           0     0      if (!simplifyLearnt_tier2()) return ok = false;
              .       .    .              .              .       .              .           .     .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      checkGarbage();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      ////
              .       .    .              .              .       .              .           .     .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
              .       .    .              .              .       .              .           .     .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      return true;
            245       0    0            196              0       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  //=================================================================================================
              .       .    .              .              .       .              .           .     .  // Minor methods:
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
              .       .    .              .              .       .              .           .     .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
              .       .    .              .              .       .              .           .     .  //
              .       .    .              .              .       .              .           .     .  Var Solver::newVar(bool sign, bool dvar)
         38,310       1    1              0              0       0         30,648           0     0  {
              .       .    .              .              .       .              .           .     .      int v = nVars();
              .       .    .              .              .       .              .           .     .      watches_bin.init(mkLit(v, false));
              .       .    .              .              .       .              .           .     .      watches_bin.init(mkLit(v, true ));
              .       .    .              .              .       .              .           .     .      watches  .init(mkLit(v, false));
              .       .    .              .              .       .              .           .     .      watches  .init(mkLit(v, true ));
             18       1    1              0              0       0              0           0     0      assigns  .push(l_Undef);
             18       1    1              0              0       0              0           0     0      vardata  .push(mkVarData(CRef_Undef, 0));
             18       0    0              0              0       0              0           0     0      activity_CHB  .push(0);
         11,529       0    0          3,831            161       0             18           0     0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
              .       .    .              .              .       .              .           .     .  
             18       1    1              0              0       0              0           0     0      picked.push(0);
             18       0    0              0              0       0              0           0     0      conflicted.push(0);
             18       0    0              0              0       0              0           0     0      almost_conflicted.push(0);
              .       .    .              .              .       .              .           .     .  #ifdef ANTI_EXPLORATION
             18       0    0              0              0       0              0           0     0      canceled.push(0);
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .  
             18       0    0              0              0       0              0           0     0      seen     .push(0);
             18       0    0              0              0       0              0           0     0      seen2    .push(0);
             18       0    0              0              0       0              0           0     0      polarity .push(sign);
             18       0    0              0              0       0              0           0     0      decision .push();
         19,155       1    1              0              0       0          7,662         276     0      trail    .capacity(v+1);
              .       .    .              .              .       .              .           .     .      setDecisionVar(v, dvar);
              .       .    .              .              .       .              .           .     .  
             18       0    0              0              0       0              0           0     0      activity_distance.push(0);
             18       1    1              0              0       0              0           0     0      var_iLevel.push(0);
             18       0    0              0              0       0              0           0     0      var_iLevel_tmp.push(0);
             18       0    0              0              0       0              0           0     0      pathCs.push(0);
              .       .    .              .              .       .              .           .     .      return v;
         34,479       0    0         26,817             17       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  bool Solver::addClause_(vec<Lit>& ps)
        122,801       2    1              0              0       0        105,258          13     0  {
              .       .    .              .              .       .              .           .     .      assert(decisionLevel() == 0);
         52,629       2    1         17,543              0       0              0           0     0      if (!ok) return false;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Check if clause is satisfied and remove false/duplicate literals:
              .       .    .              .              .       .              .           .     .      sort(ps);
              .       .    .              .              .       .              .           .     .      Lit p; int i, j;
              .       .    .              .              .       .              .           .     .  
         35,086       0    0         17,543             30       0              0           0     0      if (drup_file){
              .       .    .              .              .       .              .           .     .          add_oc.clear();
         17,543       2    1         17,543              0       0              0           0     0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
              .       .    .              .              .       .              .           .     .  
        206,266       0    0              0              0       0              0           0     0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
        356,145       0    0         57,407              0       0              0           0     0          if (value(ps[i]) == l_True || ps[i] == ~p)
              .       .    .              .              .       .              .           .     .              return true;
        227,386       4    2              0              0       0              0           0     0          else if (value(ps[i]) != l_False && ps[i] != p)
        169,899       0    0         56,633              0       0         56,633           0     0              ps[j++] = p = ps[i];
        137,568       0    0         17,196              0       0              0           0     0      ps.shrink(i - j);
              .       .    .              .              .       .              .           .     .  
         34,392       2    1              0              0       0              0           0     0      if (drup_file && i != j){
              .       .    .              .              .       .              .           .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .           .     .          binDRUP('a', ps, drup_file);
         17,196       0    0         17,196              0       0              0           0     0          binDRUP('d', add_oc, drup_file);
              .       .    .              .              .       .              .           .     .  #else
              .       .    .              .              .       .              .           .     .          for (int i = 0; i < ps.size(); i++)
              .       .    .              .              .       .              .           .     .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
              .       .    .              .              .       .              .           .     .          fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          fprintf(drup_file, "d ");
              .       .    .              .              .       .              .           .     .          for (int i = 0; i < add_oc.size(); i++)
              .       .    .              .              .       .              .           .     .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .              .              .       .              .           .     .          fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .      
         34,392       0    0              0              0       0              0           0     0      if (ps.size() == 0)
              .       .    .              .              .       .              .           .     .          return ok = false;
         34,392       2    1              0              0       0              0           0     0      else if (ps.size() == 1){
          1,518       0    0            506              0       0            253           0     0          uncheckedEnqueue(ps[0]);
          1,012       0    0              0              0       0            253           0     0          return ok = (propagate() == CRef_Undef);
              .       .    .              .              .       .              .           .     .      }else{
         16,943       0    0              0              0       0         16,943           0     0          CRef cr = ca.alloc(ps, false);
              .       .    .              .              .       .              .           .     .          //auto ca_size=ca.size();
              .       .    .              .              .       .              .           .     .          //printf("ca size:%d\n",ca_size);
         50,829       0    0              0              0       0         16,943           0     0          clauses.push(cr);
         50,829       2    1         16,943              0       0         16,943           0     0          attachClause(cr);
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
         16,943       0    0              0              0       0              0           0     0      return true;
        192,973       0    0        122,801              3       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
     29,591,720       7    4              0              0       0     17,755,032           0     0  void Solver::attachClause(CRef cr) {
              .       .    .              .              .       .              .           .     .      const Clause& c = ca[cr];
              .       .    .              .              .       .              .           .     .      assert(c.size() > 1);
     11,832,490       0    0      2,959,172            231       0              0           0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .    .              .              .       .              .           .     .      ws[~c[0]].push(Watcher(cr, c[1]));
              .       .    .              .              .       .              .           .     .      ws[~c[1]].push(Watcher(cr, c[0]));
      8,859,042       0    0      5,899,870      2,074,092       0              0           0     0      if (c.learnt()) learnts_literals += c.size();
     23,691,850       0    0     20,732,678             13       0              0           0     0      else            clauses_literals += c.size(); }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
     16,828,116     241   72              0              0       0     11,218,744           7     0  void Solver::detachClause(CRef cr, bool strict) {
              .       .    .              .              .       .              .           .     .      const Clause& c = ca[cr];
              .       .    .              .              .       .              .           .     .      assert(c.size() > 1);
     11,218,744       0    0              0              0       0              0           0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .    .              .              .       .              .           .     .      
     11,218,744       0    0              0              0       0              0           0     0      if (strict){
              .       .    .              .              .       .              .           .     .          remove(ws[~c[0]], Watcher(cr, c[1]));
              .       .    .              .              .       .              .           .     .          remove(ws[~c[1]], Watcher(cr, c[0]));
              .       .    .              .              .       .              .           .     .      }else{
              .       .    .              .              .       .              .           .     .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
              .       .    .              .              .       .              .           .     .          ws.smudge(~c[0]);
              .       .    .              .              .       .              .           .     .          ws.smudge(~c[1]);
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
      8,405,642      10    0      5,600,956         12,130       0              0           0     0      if (c.learnt()) learnts_literals -= c.size();
     16,836,532       0    0     14,031,846          4,182       0              0           0     0      else            clauses_literals -= c.size(); }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
     19,285,120     403  146              0              0       0      9,642,560         126     0  void Solver::removeClause(CRef cr) {
              .       .    .              .              .       .              .           .     .      Clause& c = ca[cr];
              .       .    .              .              .       .              .           .     .  
      7,231,920       0    0      2,410,640            305       0              0           0     0      if (drup_file){
              .       .    .              .              .       .              .           .     .          if (c.mark() != 1){
              .       .    .              .              .       .              .           .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .           .     .              binDRUP('d', c, drup_file);
              .       .    .              .              .       .              .           .     .  #else
              .       .    .              .              .       .              .           .     .              fprintf(drup_file, "d ");
              .       .    .              .              .       .              .           .     .              for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .           .     .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .           .     .              fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .          }else
              .       .    .              .              .       .              .           .     .              printf("c Bug. I don't expect this to happen.\n");
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
      9,642,560     195   81              0              0       0      2,410,640           0     0      detachClause(cr);
              .       .    .              .              .       .              .           .     .      // Don't leave pointers to free'd memory!
              .       .    .              .              .       .              .           .     .      if (locked(c)){
          1,310       0    0            258              0       0              0           0     0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
            794       0    0              0              0       0            397           0     0          vardata[var(implied)].reason = CRef_Undef; }
              .       .    .              .              .       .              .           .     .      c.mark(1);
              .       .    .              .              .       .              .           .     .      ca.free(cr);
     14,463,840       0    0     12,053,200              0       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  bool Solver::satisfied(const Clause& c) const {
     14,827,546      53    8              0              0       0              0           0     0      for (int i = 0; i < c.size(); i++)
     15,983,470       0    0      6,840,803          8,476       0              0           0     0          if (value(c[i]) == l_True)
          2,209       1    1              0              0       0              0           0     0              return true;
         48,727       0    0         25,468              0       0              0           0     0      return false; }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
              .       .    .              .              .       .              .           .     .  //
     23,043,051   5,585   70              0              0       0     15,362,034           0     0  void Solver::cancelUntil(int bLevel) {
              .       .    .              .              .       .              .           .     .  	
     10,251,946      15    2          5,307              0       0      2,560,339           0     0      if (decisionLevel() > bLevel){
              .       .    .              .              .       .              .           .     .  #ifdef PRINT_OUT
              .       .    .              .              .       .              .           .     .  		std::cout << "bt " << bLevel << "\n";
              .       .    .              .              .       .              .           .     .  #endif				
      5,120,678       0    0              0              0       0      2,560,339     415,041     0  		add_tmp.clear();
  3,869,897,411   6,447   52    779,612,228      3,862,713       2              0           0     0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
              .       .    .              .              .       .              .           .     .          {
              .       .    .              .              .       .              .           .     .              Var      x  = var(trail[c]);
              .       .    .              .              .       .              .           .     .  
  1,533,621,066       0    0    766,810,533    353,346,307       4              0           0     0  			if (level(x) <= bLevel)
              .       .    .              .              .       .              .           .     .  			{
              .       .    .              .              .       .              .           .     .  				add_tmp.push(trail[c]);
              .       .    .              .              .       .              .           .     .  			}
              .       .    .              .              .       .              .           .     .  			else
              .       .    .              .              .       .              .           .     .  			{
  1,533,596,362       0    0    766,798,181        562,200       0              0           0     0  				 if (!VSIDS){
  1,163,946,486       0    0    775,964,324         75,799       0              0           0     0  					uint32_t age = conflicts - picked[x];
    775,964,324       0    0    387,982,162    172,193,409      45              0           0     0  					if (age > 0){
  3,877,526,460   1,060   27  1,551,010,584    345,809,940       7              0           0     0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
    387,752,646       0    0    387,752,646    180,168,907     128              0           0     0  						double old_activity = activity_CHB[x];
  2,714,268,522      35   20    775,505,292      1,789,908       0    387,752,646           0     0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
              .       .    .              .              .       .              .           .     .  						if (order_heap_CHB.inHeap(x)){
  2,250,910,944     127   14              0              0       0  1,125,455,472         422     0  							if (activity_CHB[x] > old_activity)
              .       .    .              .              .       .              .           .     .  								order_heap_CHB.decrease(x);
              .       .    .              .              .       .              .           .     .  							else
              .       .    .              .              .       .              .           .     .  								order_heap_CHB.increase(x);
              .       .    .              .              .       .              .           .     .  						}
              .       .    .              .              .       .              .           .     .  					}
              .       .    .              .              .       .              .           .     .  #ifdef ANTI_EXPLORATION
    775,964,324       0    0    387,982,162        651,271       0    387,982,162 170,764,450    34  					canceled[x] = conflicts;
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .  				}
              .       .    .              .              .       .              .           .     .  				
  1,533,596,362     246   45    766,798,181         48,144       0    766,798,181 113,441,849     6  				assigns [x] = l_Undef;
              .       .    .              .              .       .              .           .     .  #ifdef PRINT_OUT
              .       .    .              .              .       .              .           .     .  				std::cout << "undo " << x << "\n";
              .       .    .              .              .       .              .           .     .  #endif				
  1,533,596,362       0    0    766,798,181              0       0              0           0     0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
    766,798,181       0    0    766,798,181              0       0              0           0     0  					polarity[x] = sign(trail[c]);
              .       .    .              .              .       .              .           .     .  				insertVarOrder(x);
              .       .    .              .              .       .              .           .     .  			}
              .       .    .              .              .       .              .           .     .          }
      2,560,339       0    0              0              0       0      2,560,339           0     0          qhead = trail_lim[bLevel];
      5,120,678       0    0              0              0       0              0           0     0          trail.shrink(trail.size() - trail_lim[bLevel]);
      7,681,017       0    0      2,560,339              0       0              0           0     0          trail_lim.shrink(trail_lim.size() - bLevel);
      7,705,721       1    1      2,560,339              0       0              0           0     0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
              .       .    .              .              .       .              .           .     .  		{
          1,422       0    0            474              0       0              0           0     0  			trail.push_(add_tmp[nLitId]);
              .       .    .              .              .       .              .           .     .  		}
              .       .    .              .              .       .              .           .     .  		
              .       .    .              .              .       .              .           .     .  		add_tmp.clear();
     20,482,712       0    0     17,922,373      1,489,657       0              0           0     0      } }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  //=================================================================================================
              .       .    .              .              .       .              .           .     .  // Major methods:
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  Lit Solver::pickBranchLit()
     27,271,752     361    7              0              0       0     20,453,814           0     0  {
              .       .    .              .              .       .              .           .     .      Var next = var_Undef;
              .       .    .              .              .       .              .           .     .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
     22,371,445   2,247   75      6,376,563      2,290,714       1              0           0     0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Random decision:
              .       .    .              .              .       .              .           .     .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
              .       .    .              .              .       .              .           .     .          next = order_heap[irand(random_seed,order_heap.size())];
              .       .    .              .              .       .              .           .     .          if (value(next) == l_Undef && decision[next])
              .       .    .              .              .       .              .           .     .              rnd_decisions++; }*/
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Activity based decision:
    136,376,035     466    1     64,779,048      6,893,774      67              0           0     0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
     54,552,146       0    0              0              0       0              0           0     0          if (order_heap.empty())
              1       0    0              0              0       0              0           0     0              return lit_Undef;
              .       .    .              .              .       .              .           .     .          else{
              .       .    .              .              .       .              .           .     .  #ifdef ANTI_EXPLORATION
     54,552,144       0    0     27,276,072            522       0              0           0     0              if (!VSIDS){
              .       .    .              .              .       .              .           .     .                  Var v = order_heap_CHB[0];
     25,737,476       0    0     25,737,476         73,703       0              0           0     0                  uint32_t age = conflicts - canceled[v];
     54,345,318       0    0     22,916,991     12,455,693   1,281      4,255,668           3     0                  while (age > 0){
              .       .    .              .              .       .              .           .     .                      double decay = pow(0.95, age);
     20,096,506       0    0     10,048,253        100,243       6     10,048,253           0     0                      activity_CHB[v] *= decay;
              .       .    .              .              .       .              .           .     .                      if (order_heap_CHB.inHeap(v))
              .       .    .              .              .       .              .           .     .                          order_heap_CHB.increase(v);
     30,144,759       0    0     20,096,506              4       0     10,048,253           1     0                      canceled[v] = conflicts;
              .       .    .              .              .       .              .           .     .                      v = order_heap_CHB[0];
              .       .    .              .              .       .              .           .     .                      age = conflicts - canceled[v];
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .              next = order_heap.removeMin();
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .  
     13,635,872       0    0      6,817,936      3,082,369      10              0           0     0      return mkLit(next, polarity[next]);
     30,680,720       0    0     23,862,783        135,691       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
              .       .    .              .              .       .              .           .     .  {
              .       .    .              .              .       .              .           .     .  	ConflictData data;
              .       .    .              .              .       .              .           .     .  	Clause& conflCls = ca[cind];
              .       .    .              .              .       .              .           .     .  	data.nHighestLevel = level(var(conflCls[0]));
     10,220,070       0    0      5,110,035         45,408       0              0           0     0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
              .       .    .              .              .       .              .           .     .  	{
              .       .    .              .              .       .              .           .     .  		return data;
              .       .    .              .              .       .              .           .     .  	}
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  	int highestId = 0;
              .       .    .              .              .       .              .           .     .      data.bOnlyOneLitFromHighest = true;
              .       .    .              .              .       .              .           .     .  	// find the largest decision level in the clause
          1,042       3    1              0              0       0              0           0     0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
              .       .    .              .              .       .              .           .     .  	{
              .       .    .              .              .       .              .           .     .  		int nLevel = level(var(conflCls[nLitId]));
            425       0    0              0              0       0              0           0     0  		if (nLevel > data.nHighestLevel)
              .       .    .              .              .       .              .           .     .  		{
              .       .    .              .              .       .              .           .     .  			highestId = nLitId;
              .       .    .              .              .       .              .           .     .  			data.nHighestLevel = nLevel;
             13       0    0              0              0       0              0           0     0  			data.bOnlyOneLitFromHighest = true;
              .       .    .              .              .       .              .           .     .  		}
              .       .    .              .              .       .              .           .     .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
              .       .    .              .              .       .              .           .     .  		{
            360       0    0              0              0       0              0           0     0  			data.bOnlyOneLitFromHighest = false;
              .       .    .              .              .       .              .           .     .  		}
              .       .    .              .              .       .              .           .     .  	}
              .       .    .              .              .       .              .           .     .  
            164      31    1              0              0       0              0           0     0  	if (highestId != 0)
              .       .    .              .              .       .              .           .     .  	{
              .       .    .              .              .       .              .           .     .  		std::swap(conflCls[0], conflCls[highestId]);
             24       0    0              0              0       0              0           0     0  		if (highestId > 1)
              .       .    .              .              .       .              .           .     .  		{
             12       0    0              0              0       0              0           0     0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
              .       .    .              .              .       .              .           .     .  			//ws.smudge(~conflCls[highestId]);
              .       .    .              .              .       .              .           .     .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
              .       .    .              .              .       .              .           .     .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
              .       .    .              .              .       .              .           .     .  		}
              .       .    .              .              .       .              .           .     .  	}
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  	return data;
              .       .    .              .              .       .              .           .     .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
              .       .    .              .              .       .              .           .     .  |  
              .       .    .              .              .       .              .           .     .  |    Post-conditions:
              .       .    .              .              .       .              .           .     .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
              .       .    .              .              .       .              .           .     .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
              .       .    .              .              .       .              .           .     .  |        rest of literals. There may be others from the same level though.
              .       .    .              .              .       .              .           .     .  |  
              .       .    .              .              .       .              .           .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .           .     .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
     33,215,416     101   33              0              0       0     22,995,288           0     0  {
      2,555,032       0    0              0              0       0      2,555,032      39,398     0      int pathC = 0;
      2,555,032       0    0              0              0       0              0           0     0      Lit p     = lit_Undef;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Generate conflict clause:
              .       .    .              .              .       .              .           .     .      //
              .       .    .              .              .       .              .           .     .      out_learnt.push();      // (leave room for the asserting literal)
      5,110,064       0    0      2,555,032              0       0              0           0     0      int index   = trail.size() - 1;
      2,555,032       0    0      2,555,032              2       0              0           0     0      int nDecisionLevel = level(var(ca[confl][0]));
              .       .    .              .              .       .              .           .     .      assert(nDecisionLevel == level(var(ca[confl][0])));
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      do{
              .       .    .              .              .       .              .           .     .          assert(confl != CRef_Undef); // (otherwise should be UIP)
              .       .    .              .              .       .              .           .     .          Clause& c = ca[confl];
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
    904,682,112       0    0              0              0       0              0           0     0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
              .       .    .              .              .       .              .           .     .              assert(value(c[1]) == l_True);
              .       .    .              .              .       .              .           .     .              Lit tmp = c[0];
      5,757,897       0    0      1,919,299        116,414       4      3,838,598           0     0              c[0] = c[1], c[1] = tmp; }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          // Update LBD if improved.
    679,092,780       1    1     27,084,984              0       0              0           0     0          if (c.learnt() && c.mark() != CORE){
              .       .    .              .              .       .              .           .     .              int lbd = computeLBD(c);
     14,371,474       0    0              0              0       0              0           0     0              if (lbd < c.lbd()){
      1,189,910       0    0              0              0       0              0           0     0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
              .       .    .              .              .       .              .           .     .                  c.set_lbd(lbd);
      1,189,910       0    0        594,955        428,172       0              0           0     0                  if (lbd <= core_lbd_cut){
             12       2    0              0              0       0              6           0     0                      learnts_core.push(confl);
              .       .    .              .              .       .              .           .     .                      c.mark(CORE);
      1,725,299       0    0        254,575              0       0              0           0     0                  }else if (lbd <= 6 && c.mark() == LOCAL){
              .       .    .              .              .       .              .           .     .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
              .       .    .              .              .       .              .           .     .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     18,264,272       6    5              0              0       0      5,299,588   2,508,889     3                      learnts_tier2.push(confl);
              .       .    .              .              .       .              .           .     .                      c.mark(TIER2); }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
     14,048,376       0    0      7,024,188              0       0              0           0     0              if (c.mark() == TIER2)
     13,756,336      49   29      3,439,084        486,516       0      3,439,084     407,201    47                  c.touched() = conflicts;
      7,359,732       0    0      3,679,866              0       0              0           0     0              else if (c.mark() == LOCAL)
              .       .    .              .              .       .              .           .     .                  claBumpActivity(c);
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .  
  3,857,465,106      14    5  1,022,065,666            100       0    215,665,407          55     0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
    806,400,259       0    0    806,400,259     60,213,743      29              0           0     0              Lit q = c[j];
              .       .    .              .              .       .              .           .     .  
  2,858,685,926       1    1  1,221,695,395    218,920,828      34              0           0     0              if (!seen[var(q)] && level(var(q)) > 0){
    830,585,752       0    0    415,292,876          3,627       0              0           0     0                  if (VSIDS){
              .       .    .              .              .       .              .           .     .                      varBumpActivity(var(q), .5);
             24       0    0              0              0       0             12           0     0                      add_tmp.push(q);
              .       .    .              .              .       .              .           .     .                  }else
    215,021,770       0    0    215,021,770     80,073,414       9              0           0     0                      conflicted[var(q)]++;
    415,292,876       0    0              0              0       0    415,292,876          40     0                  seen[var(q)] = 1;
    830,585,752       0    0    415,292,876             67       0              0           0     0                  if (level(var(q)) >= nDecisionLevel){
    431,330,814       0    0    431,330,814             69       0              0           0     0                      pathC++;
              .       .    .              .              .       .              .           .     .                  }else
              .       .    .              .              .       .              .           .     .                      out_learnt.push(q);
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          
              .       .    .              .              .       .              .           .     .          // Select next clause to look at:
              .       .    .              .              .       .              .           .     .  		do {
  4,117,623,719       0    0  1,690,182,569    102,454,648     269              0           0     0  			while (!seen[var(trail[index--])]);
              .       .    .              .              .       .              .           .     .  			p  = trail[index+1];
    431,331,450       0    0    215,665,725     10,351,777       0              0           0     0  		} while (level(var(p)) < nDecisionLevel);
              .       .    .              .              .       .              .           .     .  		
    431,330,814       0    0    215,665,407              0       0    215,665,407           0     0          confl = reason(var(p));
    215,665,407       0    0              0              0       0    215,665,407           0     0          seen[var(p)] = 0;
    431,330,814       0    0    431,330,814             12       0              0           0     0          pathC--;
              .       .    .              .              .       .              .           .     .  
  1,283,772,314       0    0    426,220,750          3,190       0              0           0     0      }while (pathC > 0);
      2,555,032       0    0      2,555,032            100       0              0           0     0      out_learnt[0] = ~p;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Simplify conflict clause:
              .       .    .              .              .       .              .           .     .      //
              .       .    .              .              .       .              .           .     .      int i, j;
      5,110,064       0    0              0              0       0      2,555,032           0     0      out_learnt.copyTo(analyze_toclear);
      7,665,096       0    0      2,555,032              4       0              0           0     0      if (ccmin_mode == 2){
      2,555,006     629   34              0              0       0              0           0     0          uint32_t abstract_level = 0;
    404,365,002     661   18              0              0       0              0           0     0          for (i = 1; i < out_learnt.size(); i++)
    204,737,481       0    0      2,555,006              0       0              0           0     0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
              .       .    .              .              .       .              .           .     .  
  1,422,942,343      34   11    596,327,401          1,300       0      2,555,006           0     0          for (i = j = 1; i < out_learnt.size(); i++)
  1,467,698,450      62   26    281,928,400     13,634,411       0    180,768,330           0     0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
    303,480,210       6    0    101,160,070            249       0    101,160,070      67,328     0                  out_learnt[j++] = out_learnt[i];
              .       .    .              .              .       .              .           .     .          
              .       .    .              .              .       .              .           .     .      }else if (ccmin_mode == 1){
              .       .    .              .              .       .              .           .     .          for (i = j = 1; i < out_learnt.size(); i++){
              .       .    .              .              .       .              .           .     .              Var x = var(out_learnt[i]);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              if (reason(x) == CRef_Undef)
              .       .    .              .              .       .              .           .     .                  out_learnt[j++] = out_learnt[i];
              .       .    .              .              .       .              .           .     .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
              .       .    .              .              .       .              .           .     .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
              .       .    .              .              .       .              .           .     .                          out_learnt[j++] = out_learnt[i];
              .       .    .              .              .       .              .           .     .                          break; }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }else
              .       .    .              .              .       .              .           .     .          i = j = out_learnt.size();
              .       .    .              .              .       .              .           .     .  
      5,110,064       0    0      2,555,032      2,541,619       2              0           0     0      max_literals += out_learnt.size();
    188,533,468       1    1     46,494,609              0       0              0           0     0      out_learnt.shrink(i - j);
      2,555,032     264    1      2,555,032              0       0              0           0     0      tot_literals += out_learnt.size();
              .       .    .              .              .       .              .           .     .  
      5,110,064       0    0      2,555,032        925,265       0      2,555,032           0     0      out_lbd = computeLBD(out_learnt);
     29,068,004   7,018  119     13,044,626              0       0              0           0     0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
      1,886,990  17,754   10        269,570              0       0        539,140           0     0          if (binResMinimize(out_learnt))
          6,798       0    0          2,266              0       0          2,266           0     0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Find correct backtrack level:
              .       .    .              .              .       .              .           .     .      //
      4,955,914       0    0              0              0       0              0           0     0      if (out_learnt.size() == 1)
             78       0    0             26              0       0             26           0     0          out_btlevel = 0;
              .       .    .              .              .       .              .           .     .      else{
      5,108,720       0    0              0              0       0              0           0     0          int max_i = 1;
              .       .    .              .              .       .              .           .     .          // Find the first literal assigned at the next-highest level:
    400,760,839       0    0              0              0       0              0           0     0          for (int i = 2; i < out_learnt.size(); i++)
    311,283,765       0    0     98,602,747              0       0              0           0     0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
              .       .    .              .              .       .              .           .     .                  max_i = i;
              .       .    .              .              .       .              .           .     .          // Swap-in this literal at index 1:
              .       .    .              .              .       .              .           .     .          Lit p             = out_learnt[max_i];
      5,110,012       9    0      2,555,006              0       0      2,555,006           0     0          out_learnt[max_i] = out_learnt[1];
      2,555,006       0    0              0              0       0      2,555,006           0     0          out_learnt[1]     = p;
      5,110,012       0    0      2,555,006              0       0      2,555,006           0     0          out_btlevel       = level(var(p));
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
      5,110,064   2,206   32      2,555,032        842,487       0              0           0     0      if (VSIDS){
    695,002,785   7,507   49    204,316,243        793,243       0              0           0     0          for (int i = 0; i < add_tmp.size(); i++){
              .       .    .              .              .       .              .           .     .              Var v = var(add_tmp[i]);
    600,813,318       0    0    200,271,106     48,781,021       0              0           0     0              if (level(v) >= out_btlevel - 1)
              .       .    .              .              .       .              .           .     .                  varBumpActivity(v, 1);
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          add_tmp.clear();
              .       .    .              .              .       .              .           .     .      }else{
      2,413,306       0    0      1,206,653              0       0      1,206,653      48,806     0          seen[var(p)] = true;
    168,534,259       0    0      1,206,653              0       0              0           0     0          for(int i = out_learnt.size() - 1; i >= 0; i--){
              .       .    .              .              .       .              .           .     .              Var v = var(out_learnt[i]);
              .       .    .              .              .       .              .           .     .              CRef rea = reason(v);
    103,507,384       0    0              0              0       0              0           0     0              if (rea != CRef_Undef){
              .       .    .              .              .       .              .           .     .                  const Clause& reaC = ca[rea];
    615,767,480       0    0              0              0       0              0           0     0                  for (int i = 0; i < reaC.size(); i++){
              .       .    .              .              .       .              .           .     .                      Lit l = reaC[i];
    447,959,100       0    0    223,979,550      2,134,373       4              0           0     0                      if (!seen[var(l)]){
     78,437,978       0    0              0              0       0     78,437,978           0     0                          seen[var(l)] = true;
     78,437,978       0    0     78,437,978     45,084,274      33              0           0     0                          almost_conflicted[var(l)]++;
              .       .    .              .              .       .              .           .     .                          analyze_toclear.push(l); } } } } }
              .       .    .              .              .       .              .           .     .  
  1,469,077,228   3,762    4    730,706,066        306,308       0    364,075,517  12,599,946     0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
     20,440,256       0    0     17,885,224      1,569,557       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  // Try further learnt clause minimization by means of binary clause resolution.
              .       .    .              .              .       .              .           .     .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
        669,545       0    0              0              0       0        535,636           0     0  {
              .       .    .              .              .       .              .           .     .      // Preparation: remember which false variables we have in 'out_learnt'.
        808,710      25   21        269,570              0       0        269,570           0     0      counter++;
     10,086,620       0    0        539,140              0       0              0           0     0      for (int i = 1; i < out_learnt.size(); i++)
      4,235,894       0    0        269,544              0       0      3,966,350   3,470,495 7,906          seen2[var(out_learnt[i])] = counter;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Get the list of binary clauses containing 'out_learnt[0]'.
              .       .    .              .              .       .              .           .     .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
              .       .    .              .              .       .              .           .     .  
        133,909       0    0              0              0       0              0           0     0      int to_remove = 0;
      1,534,286       1    0        269,570        239,063       3          2,266           0     0      for (int i = 0; i < ws.size(); i++){
        426,170       0    0        426,170        134,895      14              0           0     0          Lit the_other = ws[i].blocker;
              .       .    .              .              .       .              .           .     .          // Does 'the_other' appear negatively in 'out_learnt'?
      1,709,314      10    5        723,065        219,103   1,614              0           0     0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
          2,317       0    0              0              0       0              0           0     0              to_remove++;
          6,951       0    0              0              0       0          2,317           0     0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Shrink.
        401,727      15    4              0              0       0              0           0     0      if (to_remove > 0){
          2,266       0    0              0              0       0              0           0     0          int last = out_learnt.size() - 1;
        272,260     168   68          2,266              0       0              0           0     0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
         75,728       0    0         37,864              0       0              0           0     0              if (seen2[var(out_learnt[i])] != counter)
         10,640       0    0          4,256              0       0          2,128           0     0                  out_learnt[i--] = out_learnt[last--];
              .       .    .              .              .       .              .           .     .          out_learnt.shrink(to_remove);
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .      return to_remove != 0;
        805,206       4    4        805,206              0       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
              .       .    .              .              .       .              .           .     .  // visiting literals at levels that cannot be removed later.
              .       .    .              .              .       .              .           .     .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
  1,807,683,300  41,716    5              0              0       0  1,084,609,980   1,986,422     0  {
    361,536,660       0    0              0              0       0    180,768,330           0     0      analyze_stack.clear(); analyze_stack.push(p);
    542,304,990       0    0    361,536,660              0       0    180,768,330           0     0      int top = analyze_toclear.size();
  1,120,827,560       0    0              0              0       0              0           0     0      while (analyze_stack.size() > 0){
              .       .    .              .              .       .              .           .     .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
              .       .    .              .              .       .              .           .     .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          // Special handling for binary clauses like in 'analyze()'.
  1,166,463,014      67   38              0              0       0              0           0     0          if (c.size() == 2 && value(c[0]) == l_False){
              .       .    .              .              .       .              .           .     .              assert(value(c[1]) == l_True);
              .       .    .              .              .       .              .           .     .              Lit tmp = c[0];
      2,191,251       0    0        730,417         44,119       3      1,460,834           0     0              c[0] = c[1], c[1] = tmp; }
              .       .    .              .              .       .              .           .     .  
  2,822,061,622       0    0              0              0       0              0           0     0          for (int i = 1; i < c.size(); i++){
  1,152,670,487     133   38  1,152,670,487     91,344,380      42              0           0     0              Lit p  = c[i];
  4,553,953,773       0    0  2,305,340,974     18,982,944      23              0           0     0              if (!seen[var(p)] && level(var(p)) > 0){
  2,058,831,050       0    0    547,963,637              0       0              0           0     0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
    465,662,706       0    0              0              0       0    465,662,706           0     0                      seen[var(p)] = 1;
              .       .    .              .              .       .              .           .     .                      analyze_stack.push(p);
              7       0    0              0              0       0              0           0     0                      analyze_toclear.push(p);
              .       .    .              .              .       .              .           .     .                  }else{
  1,831,568,826   1,374   99    546,809,530            152       0              0           0     0                      for (int j = top; j < analyze_toclear.size(); j++)
    695,594,215       0    0    313,386,547              0       0    382,207,668         207     0                          seen[var(analyze_toclear[j])] = 0;
    164,601,862      33   15     82,300,931              0       0              0           0     0                      analyze_toclear.shrink(analyze_toclear.size() - top);
     82,300,931       0    0              0              0       0              0           0     0                      return false;
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
    196,934,798       0    0              0              0       0              0           0     0      return true;
  1,446,146,640       9    2  1,265,378,310          2,514       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .           .     .  |
              .       .    .              .              .       .              .           .     .  |  analyzeFinal : (p : Lit)  ->  [void]
              .       .    .              .              .       .              .           .     .  |  
              .       .    .              .              .       .              .           .     .  |  Description:
              .       .    .              .              .       .              .           .     .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      seen[var(p)] = 0;
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
  7,667,988,760       6    2              0              0       0  3,833,994,380           2     0  {
              .       .    .              .              .       .              .           .     .      assert(value(p) == l_Undef);
              .       .    .              .              .       .              .           .     .      Var x = var(p);
  1,533,597,752       0    0    766,798,876     10,118,999       0              0           0     0      if (!VSIDS){
  1,163,948,340       0    0    775,965,560     10,169,479       0    387,982,780 282,556,579 1,707          picked[x] = conflicts;
    775,965,560       0    0    387,982,780              0       0    387,982,780 282,824,034 1,772          conflicted[x] = 0;
    775,965,560       2    1    387,982,780              0       0    387,982,780 284,604,371 1,760          almost_conflicted[x] = 0;
              .       .    .              .              .       .              .           .     .  #ifdef ANTI_EXPLORATION
    387,982,780       0    0    387,982,780      4,693,861       0              0           0     0          uint32_t age = conflicts - canceled[var(p)];
    775,965,560       0    0    387,982,780    279,613,634     334              0           0     0          if (age > 0){
              .       .    .              .              .       .              .           .     .              double decay = pow(0.95, age);
    319,327,852       0    0    159,663,926    132,964,655     319    159,663,926           0     0              activity_CHB[var(p)] *= decay;
              .       .    .              .              .       .              .           .     .              if (order_heap_CHB.inHeap(var(p)))
    159,663,926       0    0              0              0       0              0           0     0                  order_heap_CHB.increase(var(p));
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
    766,798,876       1    0    766,798,876            596       0              0           0     0      assigns[x] = lbool(!sign(p));
  1,533,597,752       0    0              0              0       0  1,533,597,752 568,103,447 1,480      vardata[x] = mkVarData(from, level);
    766,798,876       3    1    766,798,876              0       0              0           0     0      trail.push_(p);
  5,367,592,132       0    0  4,600,793,256              0       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  unsigned number_watch_changed_total=0;
              .       .    .              .              .       .              .           .     .  unsigned number_clause_read_total=0;
              .       .    .              .              .       .              .           .     .  unsigned times_only_access_watch=0;
              .       .    .              .              .       .              .           .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .           .     .  |
              .       .    .              .              .       .              .           .     .  |  propagate : [void]  ->  [Clause*]
              .       .    .              .              .       .              .           .     .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
              .       .    .              .              .       .              .           .     .  |  Description:
              .       .    .              .              .       .              .           .     .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
              .       .    .              .              .       .              .           .     .  |    otherwise CRef_Undef.
              .       .    .              .              .       .              .           .     .  |  
              .       .    .              .              .       .              .           .     .  |    Post-conditions:
              .       .    .              .              .       .              .           .     .  |      * the propagation queue is empty, even if there was a conflict.
              .       .    .              .              .       .              .           .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .           .     .  CRef Solver::propagate_()
     47,799,568       6    4              0              0       0     35,849,676           0     0  {
              .       .    .              .              .       .              .           .     .      //auto start_time=std::chrono::steady_clock::now();
      5,974,946       0    0              0              0       0      5,974,946           0     0      CRef    confl     = CRef_Undef;
      5,974,946       0    0              0              0       0      5,974,946          25     0      int     num_props = 0;
     11,949,892       0    0              0              0       0      5,974,946     654,282     0      watches.cleanAll();
     11,949,892       4    2              0              0       0      5,974,946           0     0      watches_bin.cleanAll();
              .       .    .              .              .       .              .           .     .      
  2,626,043,240       0    0  1,909,591,833      8,462,615       1              0           0     0      while (qhead < trail.size()){
  3,540,719,315       0    0  1,416,287,726     23,282,359       0    708,143,863           0     0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .    .              .              .       .              .           .     .          int currLevel = level(var(p));
              .       .    .              .              .       .              .           .     .          vec<Watcher>&  ws  = watches[p];
              .       .    .              .              .       .              .           .     .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          Watcher        *i, *j, *end;
  1,189,603,375       1    1  1,189,603,375     10,171,321       0              0           0     0          num_props++;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
              .       .    .              .              .       .              .           .     .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
  3,892,539,632       3    1    708,143,863    685,792,298   7,409              0           0     0          for (int k = 0; k < ws_bin.size(); k++){
    781,273,093       0    0    781,273,093    304,827,484   7,546              0           0     0              Lit the_other = ws_bin[k].blocker;
 30,977,561,226       0    0 28,552,378,908              0       0              0           0     0              if (value(the_other) == l_False){
        210,594       2    0        105,297              0       0        105,297           0     0                  confl = ws_bin[k].cref;
              .       .    .              .              .       .              .           .     .                  //auto end_time=std::chrono::steady_clock::now();
              .       .    .              .              .       .              .           .     .                  //auto duration=end_time-start_time;
              .       .    .              .              .       .              .           .     .  #ifdef LOOSE_PROP_STAT
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                  return confl;
              .       .    .              .              .       .              .           .     .  #else
              .       .    .              .              .       .              .           .     .                  goto ExitProp;
              .       .    .              .              .       .              .           .     .  #endif
    987,045,544       5    1              0              0       0              0           0     0              }else if(value(the_other) == l_Undef)
              .       .    .              .              .       .              .           .     .              {
    824,644,140       1    0    494,786,484              0       0    164,928,828   3,366,819     0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
              .       .    .              .              .       .              .           .     .  #ifdef  PRINT_OUT                
              .       .    .              .              .       .              .           .     .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
              .       .    .              .              .       .              .           .     .  #endif                
              .       .    .              .              .       .              .           .     .  			}
              .       .    .              .              .       .              .           .     .          }
  1,416,077,132       0    0  1,416,077,132    623,607,456   2,725              0           0     0          total_Watchers+=ws.size();
    708,038,566       0    0    708,038,566              0       0              0           0     0          total_indexs++;//number of rounds
              .       .    .              .              .       .              .           .     .          //int count=0;
    694,945,819       0    0              0              0       0              0           0     0          bool no_clause_access=true;
    694,945,819       0    0              0              0       0    694,945,819           0     0          bool no_implication_added=true;
    694,945,819       0    0              0              0       0    694,945,819           0     0          bool no_change_other_watch=true;
 84,062,892,451      11    4 40,621,915,467              0       0    708,038,566           0     0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
              .       .    .              .              .       .              .           .     .              // Try to avoid inspecting the clause:
              .       .    .              .              .       .              .           .     .              //count++;
 39,913,876,901       3    1 39,913,876,901  5,545,651,362 182,550              0           0     0              Lit blocker = i->blocker;
 79,827,753,802       0    0 39,913,876,901      2,128,800       3              0           0     0              total_access_watches++;
 79,827,753,802       0    0 39,913,876,901    532,552,748     172              0           0     0              if (value(blocker) == l_True){
              .       .    .              .              .       .              .           .     .                  
103,965,087,552       0    0 25,991,271,888              0       0 25,991,271,888   8,760,511     0                  *j++ = *i++; continue; }//no clause accessed
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Make sure the false literal is data[1]:
 13,936,367,627       0    0      2,262,571              0       0              0           0     0              no_clause_access=false;
 41,767,815,039       4    2 27,845,210,026      4,450,988       2 13,922,605,013           0     0              total_clause_access_times++;
 27,845,210,026       0    0 13,922,605,013              0       0              0           0     0              CRef     cr        = i->cref;
              .       .    .              .              .       .              .           .     .              //std::cout<<"cr: "<<cr<<"\n";
              .       .    .              .              .       .              .           .     .              Clause&  c         = ca[cr];
              .       .    .              .              .       .              .           .     .              Lit      false_lit = ~p;
 13,922,605,013       0    0 13,922,605,013              0       0              0           0     0              total_clause_access_size+=2;
 41,767,815,039       0    0 27,845,210,026 13,242,179,087 257,330              0           0     0              if (c[0] == false_lit)
 23,624,999,696       0    0 11,812,499,848    344,475,460   8,116 11,812,499,848           0     0                  c[0] = c[1], c[1] = false_lit;
              .       .    .              .              .       .              .           .     .              assert(c[1] == false_lit);
              .       .    .              .              .       .              .           .     .              i++;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // If 0th watch is true, then clause is already satisfied.
              .       .    .              .              .       .              .           .     .              Lit     first = c[0];
              .       .    .              .              .       .              .           .     .              Watcher w     = Watcher(cr, first);
 34,566,511,016       0    0  3,360,650,495     39,478,458       3              0           0     0              if (first != blocker && value(first) == l_True){
  7,683,321,060       0    0              0              0       0  5,122,214,040   3,246,894     0                  *j++ = w; continue; }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Look for new watch:
 63,726,462,010       2    1              0              0       0              0           0     0              for (int k = 2; k < c.size(); k++)
              .       .    .              .              .       .              .           .     .              {
113,846,177,375       0    0              0              0       0 24,430,964,466           0     0                  total_clause_access_size++;
 78,028,887,174       0    0  6,443,962,256              0       0              0           0     0                  if (value(c[k]) != l_False){
 43,052,569,832  11,135    1 21,526,284,916              0       0 21,526,284,916           0     0                      c[1] = c[k]; c[k] = false_lit;
 10,763,142,458       0    0 10,763,142,458              0       0              0           0     0                      total_change_other_watch++;
 10,763,142,458       0    0              0              0       0 10,763,142,458           0     0                      no_change_other_watch=false;
              .       .    .              .              .       .              .           .     .                      watches[~c[1]].push(w);
              .       .    .              .              .       .              .           .     .                      goto NextClause; }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Did not find watch -- clause is unit under assignment:
  1,797,516,364       0    0              0              0       0  1,196,711,070     436,930     0              *j++ = w;
  1,196,711,070       0    0              0              0       0              0           0     0              if (value(first) == l_False){
      2,449,759       0    0      2,449,759              0       0              0           0     0                  time_find_conflict++;
     14,698,554       1    0      9,799,036         23,132       0              0           0     0                  total_find_conflict_length+=i-(Watcher*)ws;
      4,899,518       0    0      4,899,518              0       0              0           0     0                  total_find_conflict_allsize+=ws.size();
              .       .    .              .              .       .              .           .     .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
      2,449,759       0    0              0              0       0      2,449,759           0     0                  confl = cr;
      4,899,518       0    0      2,449,759          9,699       0      2,449,759           0     0                  qhead = trail.size();
              .       .    .              .              .       .              .           .     .                  // Copy the remaining watches:
              .       .    .              .              .       .              .           .     .  
    232,216,939       4    3      4,712,330             36       0              0           0     0                  while (i < end)
    110,171,260       0    0    110,171,260     13,714,136     732    110,171,260     129,775     0                      *j++ = *i++;
              .       .    .              .              .       .              .           .     .              }else
              .       .    .              .              .       .              .           .     .              {//new implecate
    595,905,776       0    0              0              0       0    595,905,776           0     0                  no_implication_added=false;
    595,905,776       0    0    595,905,776              0       0              0           0     0                  total_push_new_implication++;
  1,787,717,328       0    0  1,191,811,552      2,163,699       0              0           0     0  				if (currLevel == decisionLevel())
              .       .    .              .              .       .              .           .     .  				{
  1,191,811,552       0    0              0              0       0              0           0     0  					uncheckedEnqueue(first, currLevel, cr);
              .       .    .              .              .       .              .           .     .  #ifdef PRINT_OUT					
              .       .    .              .              .       .              .           .     .  					std::cout << "i " << first << " l " << currLevel << "\n";
              .       .    .              .              .       .              .           .     .  #endif					
              .       .    .              .              .       .              .           .     .  				}
              .       .    .              .              .       .              .           .     .  				else
              .       .    .              .              .       .              .           .     .  				{
              .       .    .              .              .       .              .           .     .  					int nMaxLevel = currLevel;
         16,124       0    0              0              0       0              0           0     0  					int nMaxInd = 1;
              .       .    .              .              .       .              .           .     .  					// pass over all the literals in the clause and find the one with the biggest level
         55,090       0    0          8,062              0       0              0           0     0  					for (int nInd = 2; nInd < c.size(); ++nInd)
              .       .    .              .              .       .              .           .     .  					{
              .       .    .              .              .       .              .           .     .  						int nLevel = level(var(c[nInd]));
         24,812       0    0              0              0       0              0           0     0  						if (nLevel > nMaxLevel)
              .       .    .              .              .       .              .           .     .  						{
              .       .    .              .              .       .              .           .     .  							nMaxLevel = nLevel;
              .       .    .              .              .       .              .           .     .  							nMaxInd = nInd;
              .       .    .              .              .       .              .           .     .  						}
              .       .    .              .              .       .              .           .     .  					}
              .       .    .              .              .       .              .           .     .  
         16,124       2    1              0              0       0              0           0     0  					if (nMaxInd != 1)
              .       .    .              .              .       .              .           .     .  					{
              .       .    .              .              .       .              .           .     .  						std::swap(c[1], c[nMaxInd]);
              .       .    .              .              .       .              .           .     .  						*j--; // undo last watch
            928       0    0            928              0       0              0           0     0                          total_change_other_watch++;
            928       0    0              0              0       0            928           0     0                          no_change_other_watch=false;
              .       .    .              .              .       .              .           .     .  						watches[~c[1]].push(w);
              .       .    .              .              .       .              .           .     .  					}
              .       .    .              .              .       .              .           .     .  					
  2,979,536,942       0    0    595,905,776              0       0    595,905,776   9,645,670     0  					uncheckedEnqueue(first, nMaxLevel, cr);
              .       .    .              .              .       .              .           .     .  #ifdef PRINT_OUT					
              .       .    .              .              .       .              .           .     .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
              .       .    .              .              .       .              .           .     .  #endif	
              .       .    .              .              .       .              .           .     .  				}
              .       .    .              .              .       .              .           .     .  			}
              .       .    .              .              .       .              .           .     .  
      2,262,571     120   29              0              0       0              0           0     0  NextClause:;
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
  3,474,729,095       0    0    694,945,819              0       0              0           0     0          if(no_clause_access==true){
    120,061,931     149   10    120,061,931          2,367       1              0           0     0              total_no_clause_access++;
              .       .    .              .              .       .              .           .     .          }
  1,496,860,822      26   11    694,945,819              0       0              0           0     0          if(no_implication_added==true){
    369,753,778       3    1    356,661,031             13       0              0           0     0              total_no_implication_added++;
              .       .    .              .              .       .              .           .     .          }
  1,514,915,922       0    0    694,945,819              0       0              0           0     0          if(no_change_other_watch==true){
    226,473,757     207   13    226,473,757              3       0              0           0     0              total_no_change_other_watch++;
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          ws.shrink(i - j);
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  ExitProp:;
     11,739,298       3    1     11,739,298      2,500,836       0              0           0     0      propagations += num_props;
      5,869,649       0    0      5,869,649              0       0              0           0     0      simpDB_props -= num_props;
              .       .    .              .              .       .              .           .     .  
      5,869,649       0    0      5,869,649              0       0              0           0     0      return confl;
  4,965,335,305   5,560    8     41,824,622      4,654,025       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .           .     .  |
              .       .    .              .              .       .              .           .     .  |  reduceDB : ()  ->  [void]
              .       .    .              .              .       .              .           .     .  |  
              .       .    .              .              .       .              .           .     .  |  Description:
              .       .    .              .              .       .              .           .     .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
              .       .    .              .              .       .              .           .     .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
              .       .    .              .              .       .              .           .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .           .     .  struct reduceDB_lt { 
              .       .    .              .              .       .              .           .     .      ClauseAllocator& ca;
              .       .    .              .              .       .              .           .     .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    121,159,050     340  148    118,804,591     39,746,952   8,177              0           0     0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
              .       .    .              .              .       .              .           .     .  };
              .       .    .              .              .       .              .           .     .  void Solver::reduceDB()
          1,020     158   63              0              0       0            680           0     0  {
              .       .    .              .              .       .              .           .     .      int     i, j;
              .       .    .              .              .       .              .           .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .    .              .              .       .              .           .     .      //local_learnts_dirty = false;
              .       .    .              .              .       .              .           .     .  
            170       0    0              0              0       0              0           0     0      sort(learnts_local, reduceDB_lt(ca));
              .       .    .              .              .       .              .           .     .  
            850       0    0            170            170       0              0           0     0      int limit = learnts_local.size() / 2;
      9,726,686     170   65              0              0       0              0           0     0      for (i = j = 0; i < learnts_local.size(); i++){
     14,588,754     170   98      9,725,836        304,144       0              0           0     0          Clause& c = ca[learnts_local[i]];
      9,725,836       0    0      4,862,918      4,833,182     979              0           0     0          if (c.mark() == LOCAL)
     18,317,978       0    0      4,757,426              0       0              0           0     0              if (c.removable() && !locked(c) && i < limit)
     12,010,975       0    0      2,402,195              0       0      2,402,195           0     0                  removeClause(learnts_local[i]);
              .       .    .              .              .       .              .           .     .              else{
        354,744       0    0              0              0       0              0           0     0                  if (!c.removable()) limit++;
              .       .    .              .              .       .              .           .     .                  c.removable(true);
     11,987,139       0    0      2,355,231              0       0      2,355,231     147,485     0                  learnts_local[j++] = learnts_local[i]; }
              .       .    .              .              .       .              .           .     .      }
            170       0    0              0              0       0              0           0     0      learnts_local.shrink(i - j);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      checkGarbage();
            869       0    0            699            170       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  void Solver::reduceDB_Tier2()
          1,530     218   62              0              0       0          1,275           0     0  {
              .       .    .              .              .       .              .           .     .      int i, j;
      5,954,068     141   26            255            172       0              0           0     0      for (i = j = 0; i < learnts_tier2.size(); i++){
      7,337,103     214   74      4,891,402        153,039  10,477              0           0     0          Clause& c = ca[learnts_tier2[i]];
      4,891,402       0    0              0              0       0              0           0     0          if (c.mark() == TIER2)
     11,955,165     206   43      4,782,066      2,156,614   5,623              0           0     0              if (!locked(c) && c.touched() + 30000 < conflicts){
              .       .    .              .              .       .              .           .     .                  learnts_local.push(learnts_tier2[i]);
              .       .    .              .              .       .              .           .     .                  c.mark(LOCAL);
              .       .    .              .              .       .              .           .     .                  //c.removable(true);
              .       .    .              .              .       .              .           .     .                  c.activity() = 0;
              .       .    .              .              .       .              .           .     .                  claBumpActivity(c);
              .       .    .              .              .       .              .           .     .              }else
      9,575,665       0    0      1,915,133              0       0      1,915,133      85,334     0                  learnts_tier2[j++] = learnts_tier2[i];
              .       .    .              .              .       .              .           .     .      }
            255       0    0              0              0       0              0           0     0      learnts_tier2.shrink(i - j);
          1,530       0    0          1,530            255       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::removeSatisfied(vec<CRef>& cs)
            396       0    0              0              0       0            176           0     0  {
              .       .    .              .              .       .              .           .     .      int i, j;
      2,043,520      21    3        408,722             21       0              0           0     0      for (i = j = 0; i < cs.size(); i++){
      1,226,031       0    0        817,354         25,583       0              0           0     0          Clause& c = ca[cs[i]];
              .       .    .              .              .       .              .           .     .          if (satisfied(c))
          2,110      19    2              1              0       0            703         104     0              removeClause(cs[i]);
              .       .    .              .              .       .              .           .     .          else
        815,948       0    0              0              0       0        407,974         404     0              cs[j++] = cs[i];
              .       .    .              .              .       .              .           .     .      }
             44       0    0              0              0       0              0           0     0      cs.shrink(i - j);
            264       4    1            220             60       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
            276       0    0              0              0       0            230           0     0  {
              .       .    .              .              .       .              .           .     .      int i, j;
        297,616      22    3             46             22       0              0           0     0      for (i = j = 0; i < cs.size(); i++){
        435,516       0    0        290,344          9,110       0              0           0     0          Clause& c = ca[cs[i]];
        290,344       0    0              0              0       0              0           0     0          if (c.mark() == valid_mark)
              .       .    .              .              .       .              .           .     .              if (satisfied(c))
          3,568       1    1            892              0       0            892          21     0                  removeClause(cs[i]);
              .       .    .              .              .       .              .           .     .              else
        708,685       0    0        141,737              0       0        141,737       1,785     0                  cs[j++] = cs[i];
              .       .    .              .              .       .              .           .     .      }
             44       0    0              0              0       0              0           0     0      cs.shrink(i - j);
            276      10    2            276             73       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::rebuildOrderHeap()
            216       5    3              0              0       0            144           0     0  {
              .       .    .              .              .       .              .           .     .      vec<Var> vs;
        183,984       0    0             24              0       0             24           0     0      for (Var v = 0; v < nVars(); v++)
        520,522       0    0        260,261          2,399      20              0           0     0          if (decision[v] && value(v) == l_Undef)
              .       .    .              .              .       .              .           .     .              vs.push(v);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      order_heap_CHB  .build(vs);
              .       .    .              .              .       .              .           .     .      order_heap_VSIDS.build(vs);
              .       .    .              .              .       .              .           .     .      order_heap_distance.build(vs);
            192      24    3            168             47       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .           .     .  |
              .       .    .              .              .       .              .           .     .  |  simplify : [void]  ->  [bool]
              .       .    .              .              .       .              .           .     .  |  
              .       .    .              .              .       .              .           .     .  |  Description:
              .       .    .              .              .       .              .           .     .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
              .       .    .              .              .       .              .           .     .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
              .       .    .              .              .       .              .           .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .           .     .  bool Solver::simplify()
         31,824   1,028    8              0              0       0         21,216           0     0  {
              .       .    .              .              .       .              .           .     .      assert(decisionLevel() == 0);
              .       .    .              .              .       .              .           .     .  
         26,520       0    0          5,304          3,021       1              0           0     0      if (!ok || propagate() != CRef_Undef)
              .       .    .              .              .       .              .           .     .          return ok = false;
              .       .    .              .              .       .              .           .     .  
         16,120     229   45         10,712              0       0              0           0     0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
              .       .    .              .              .       .              .           .     .          return true;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Remove satisfied clauses:
             69       0    0              0              0       0             23           0     0      removeSatisfied(learnts_core); // Should clean core first.
             92       0    0              0              0       0             23           0     0      safeRemoveSatisfied(learnts_tier2, TIER2);
             92      23    3              0              0       0             23           0     0      safeRemoveSatisfied(learnts_local, LOCAL);
             46       0    0             23             22       0              0           0     0      if (remove_satisfied)        // Can be turned off.
             88      44    5              0              0       0             22           0     0          removeSatisfied(clauses);
              .       .    .              .              .       .              .           .     .      checkGarbage();
             46       1    1              0              0       0             23           0     0      rebuildOrderHeap();
              .       .    .              .              .       .              .           .     .  
             46       0    0             23             23       0             23           0     0      simpDB_assigns = nAssigns();
             69       0    0             46             23       0             23           0     0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
              .       .    .              .              .       .              .           .     .  
             23       0    0              0              0       0              0           0     0      return true;
         37,128       0    0         26,520              0       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  // pathCs[k] is the number of variables assigned at level k,
              .       .    .              .              .       .              .           .     .  // it is initialized to 0 at the begining and reset to 0 after the function execution
         80,120       9    1              0              0       0         60,090           0     0  bool Solver::collectFirstUIP(CRef confl){
         20,030       0    0              0              0       0         10,015           0     0      involved_lits.clear();
        994,938      13    1              0              0       0              0           0     0      int max_level=1;
              .       .    .              .              .       .              .           .     .      Clause& c=ca[confl]; int minLevel=decisionLevel();
        121,314       0    0         10,015              0       0              0           0     0      for(int i=0; i<c.size(); i++) {
              .       .    .              .              .       .              .           .     .          Var v=var(c[i]);
              .       .    .              .              .       .              .           .     .          //        assert(!seen[v]);
        106,653      63    1         35,551          7,384       0              0           0     0          if (level(v)>0) {
         70,756       0    0         35,378          8,259       0         35,378      22,237     0              seen[v]=1;
         80,771       0    0         45,393         17,648       0         35,378      31,815     0              var_iLevel_tmp[v]=1;
         35,378       0    0         35,378         17,396       0              0           0     0              pathCs[level(v)]++;
              .       .    .              .              .       .              .           .     .              if (minLevel>level(v)) {
              .       .    .              .              .       .              .           .     .                  minLevel=level(v);
              .       .    .              .              .       .              .           .     .                  assert(minLevel>0);
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              //    varBumpActivity(v);
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
         30,045       0    0         20,030          8,508       0              0           0     0      int limit=trail_lim[minLevel-1];
     30,371,292       0    0         10,015              0       0              0           0     0      for(int i=trail.size()-1; i>=limit; i--) {
     15,165,616     305    1     15,165,616        439,291       0              0           0     0          Lit p=trail[i]; Var v=var(p);
     15,165,616       0    0      7,582,808        445,376       0              0           0     0          if (seen[v]) {
              .       .    .              .              .       .              .           .     .              int currentDecLevel=level(v);
              .       .    .              .              .       .              .           .     .              //      if (currentDecLevel==decisionLevel())
              .       .    .              .              .       .              .           .     .              //      	varBumpActivity(v);
        640,724       0    0              0              0       0        640,724           0     0              seen[v]=0;
      1,281,448       0    0        640,724          1,625       0              0           0     0              if (--pathCs[currentDecLevel]!=0) {
              .       .    .              .              .       .              .           .     .                  Clause& rc=ca[reason(v)];
      1,919,771       7    1      1,402,272          2,361       0              0           0     0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
        934,848       0    0              0              0       0              0           0     0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
      1,225,808       0    0              0              0       0              0           0     0                  if (rc.size()==2 && value(rc[0])==l_False) {
              .       .    .              .              .       .              .           .     .                      // Special case for binary clauses
              .       .    .              .              .       .              .           .     .                      // The first one has to be SAT
              .       .    .              .              .       .              .           .     .                      assert(value(rc[1]) != l_False);
              .       .    .              .              .       .              .           .     .                      Lit tmp = rc[0];
         33,990       0    0         11,330            510       0         22,660           0     0                      rc[0] =  rc[1], rc[1] = tmp;
              .       .    .              .              .       .              .           .     .                  }
      2,679,152       0    0              0              0       0              0           0     0                  for (int j = 1; j < rc.size(); j++){
              .       .    .              .              .       .              .           .     .                      Lit q = rc[j]; Var v1=var(q);
      2,035,264       0    0              0              0       0              0           0     0                      if (level(v1) > 0) {
      1,985,844       0    0              0              0       0              0           0     0                          if (minLevel>level(v1)) {
        101,960       0    0         50,980         21,374       0              0           0     0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
              .       .    .              .              .       .              .           .     .                          }
      2,978,766       0    0      1,985,844         43,834       0              0           0     0                          if (seen[v1]) {
        775,152       0    0        387,576          3,345       0              0           0     0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
        497,034       0    0              0              0       0        248,517           0     0                                  var_iLevel_tmp[v1]=reasonVarLevel;
              .       .    .              .              .       .              .           .     .                          }
              .       .    .              .              .       .              .           .     .                          else {
        605,346       0    0              0              0       0        605,346     356,138     0                              var_iLevel_tmp[v1]=reasonVarLevel;
              .       .    .              .              .       .              .           .     .                              //   varBumpActivity(v1);
        605,346       0    0              0              0       0        605,346           0     0                              seen[v1] = 1;
      1,816,038       6    1      1,210,692         68,888       0              0           0     0                              pathCs[level(v1)]++;
              .       .    .              .              .       .              .           .     .                          }
              .       .    .              .              .       .              .           .     .                      }
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              involved_lits.push(p);
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
         30,045     996    1         10,015              0       0         10,015           0     0      double inc=var_iLevel_inc;
              .       .    .              .              .       .              .           .     .      vec<int> level_incs; level_incs.clear();
        804,215       0    0        309,668              0       0              0           0     0      for(int i=0;i<max_level;i++){
        329,698       5    1        164,849              0       0              0           0     0          level_incs.push(inc);
        494,547       0    0        329,698              0       0        164,849           0     0          inc = inc/my_var_decay;
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
      1,321,508       0    0        650,739              0       0              0           0     0      for(int i=0;i<involved_lits.size();i++){
         10,015       0    0         10,015              0       0              0           0     0          Var v =var(involved_lits[i]);
              .       .    .              .              .       .              .           .     .          //        double old_act=activity_distance[v];
              .       .    .              .              .       .              .           .     .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
      5,926,756   5,656    2      1,962,232        524,082       0        650,739           0     0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
              .       .    .              .              .       .              .           .     .  
      1,281,448       0    0              0              0       0              0           0     0          if(activity_distance[v]>1e100){
              .       .    .              .              .       .              .           .     .              for(int vv=0;vv<nVars();vv++)
         50,075   1,195    1         20,030         18,826       0         20,030           0     0                  activity_distance[vv] *= 1e-100;
              .       .    .              .              .       .              .           .     .              var_iLevel_inc*=1e-100;
         21,519      39    1              0              0       0              0           0     0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .          if (order_heap_distance.inHeap(v))
              .       .    .              .              .       .              .           .     .              order_heap_distance.decrease(v);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          //        var_iLevel_inc *= (1 / my_var_decay);
              .       .    .              .              .       .              .           .     .      }
         50,075     137    1         20,030              5       0         10,015           0     0      var_iLevel_inc=level_incs[level_incs.size()-1];
              .       .    .              .              .       .              .           .     .      return true;
         90,135       0    0         70,105          4,193       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  struct UIPOrderByILevel_Lt {
              .       .    .              .              .       .              .           .     .      Solver& solver;
              .       .    .              .              .       .              .           .     .      const vec<double>&  var_iLevel;
              .       .    .              .              .       .              .           .     .      bool operator () (Lit x, Lit y) const
              .       .    .              .              .       .              .           .     .      {
              .       .    .              .              .       .              .           .     .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
              .       .    .              .              .       .              .           .     .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
              .       .    .              .              .       .              .           .     .  |    Search for a model the specified number of conflicts. 
              .       .    .              .              .       .              .           .     .  |  
              .       .    .              .              .       .              .           .     .  |  Output:
              .       .    .              .              .       .              .           .     .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
              .       .    .              .              .       .              .           .     .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
              .       .    .              .              .       .              .           .     .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
              .       .    .              .              .       .              .           .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .           .     .  lbool Solver::search(int& nof_conflicts)
         58,113   4,317   25              0              0       0         36,981          49     0  {
              .       .    .              .              .       .              .           .     .      assert(ok);
              .       .    .              .              .       .              .           .     .      int         backtrack_level;
              .       .    .              .              .       .              .           .     .      int         lbd;
              .       .    .              .              .       .              .           .     .      vec<Lit>    learnt_clause;
              .       .    .              .              .       .              .           .     .      bool        cached = false;
          5,283       0    0          5,283            138       0              0           0     0      starts++;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // simplify
              .       .    .              .              .       .              .           .     .      //
         21,132       4    4         15,849          5,283      30              0           0     0      if (conflicts >= curSimplify * nbconfbeforesimplify){
              .       .    .              .              .       .              .           .     .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
              .       .    .              .              .       .              .           .     .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
              .       .    .              .              .       .              .           .     .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
              .       .    .              .              .       .              .           .     .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
             49      32   23             49             45       0              0           0     0          nbSimplifyAll++;
            147      49   32              0              0       0             49           0     0          if (!simplifyAll()){
              .       .    .              .              .       .              .           .     .              return l_False;
              .       .    .              .              .       .              .           .     .          }
            343       0    0             98              0       0             49           0     0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
            147       0    0             49              0       0             49           0     0          nbconfbeforesimplify += incSimplify;
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      for (;;){
              .       .    .              .              .       .              .           .     .          CRef confl = propagate();
              .       .    .              .              .       .              .           .     .  
     11,938,614       0    0              0              0       0              0           0     0          if (confl != CRef_Undef){
              .       .    .              .              .       .              .           .     .              // CONFLICT
      7,665,168       0    0      2,555,056         30,309       0              0           0     0              if (VSIDS){
      2,696,930       0    0      1,348,450      1,321,897       1             30           0     0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
              .       .    .              .              .       .              .           .     .              }else
      4,639,962      25    1      2,753,307      1,186,052       1        340,001           0     0                  if (step_size > min_step_size) step_size -= step_size_dec;
              .       .    .              .              .       .              .           .     .  
     10,220,224     140   68      5,110,112      2,572,792       0      2,555,056           0     0              conflicts++; nof_conflicts--;
              .       .    .              .              .       .              .           .     .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
              .       .    .              .              .       .              .           .     .              ConflictData data = FindConflictLevel(confl);
      5,110,112      31    1              0              0       0              0           0     0              if (data.nHighestLevel == 0) return l_False;
            280       0    0            116              0       0              0           0     0              if (data.bOnlyOneLitFromHighest)
              .       .    .              .              .       .              .           .     .              {
             24       3    0              0              0       0              0           0     0  				cancelUntil(data.nHighestLevel - 1);
              .       .    .              .              .       .              .           .     .  				continue;
              .       .    .              .              .       .              .           .     .  			}
              .       .    .              .              .       .              .           .     .  			
              .       .    .              .              .       .              .           .     .              learnt_clause.clear();
      5,110,064       0    0              0              0       0      2,555,032   2,462,489     0              if(conflicts>50000) DISTANCE=0;
              .       .    .              .              .       .              .           .     .              else DISTANCE=1;
      7,806,822       0    0              0              0       0              0           0     0              if(VSIDS && DISTANCE)
         40,060       8    1              0              0       0         10,015           0     0                  collectFirstUIP(confl);
              .       .    .              .              .       .              .           .     .  
     15,330,192     146   67              0              0       0      2,555,032           0     0              analyze(confl, learnt_clause, backtrack_level, lbd);
              .       .    .              .              .       .              .           .     .              // check chrono backtrack condition
     35,742,455      61   30     12,771,161      1,349,230       0              0           0     0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
              .       .    .              .              .       .              .           .     .              {
            129       0    0            129              0       0              0           0     0  				++chrono_backtrack;
            129       0    0              0              0       0              0           0     0  				cancelUntil(data.nHighestLevel -1);
              .       .    .              .              .       .              .           .     .  			}
              .       .    .              .              .       .              .           .     .  			else // default behavior
              .       .    .              .              .       .              .           .     .  			{
      2,554,903   1,059   44      2,554,903        483,233       0              0           0     0  				++non_chrono_backtrack;
              .       .    .              .              .       .              .           .     .  				cancelUntil(backtrack_level);
              .       .    .              .              .       .              .           .     .  			}
              .       .    .              .              .       .              .           .     .  
      7,665,096       0    0      2,555,032      1,421,128       0      2,555,032           0     0              lbd--;
      5,110,064       0    0      2,555,032              0       0              0           0     0              if (VSIDS){
      1,348,379      28   20              0              0       0      1,348,379           0     0                  cached = false;
      4,045,137     284   28      4,045,137      1,562,989       1              0           0     0                  conflicts_VSIDS++;
              .       .    .              .              .       .              .           .     .                  lbd_queue.push(lbd);
     10,787,032       0    0      4,045,137              0       0      1,348,379           0     0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
              .       .    .              .              .       .              .           .     .  
      7,665,096      54   29      2,555,032              0       0              0           0     0              if (learnt_clause.size() == 1){
            182       1    0             52             17       0             26           0     0                  uncheckedEnqueue(learnt_clause[0]);
              .       .    .              .              .       .              .           .     .              }else{
              .       .    .              .              .       .              .           .     .                  CRef cr = ca.alloc(learnt_clause, true);
      2,555,006       0    0      2,555,006              0       0              0           0     0                  ca[cr].set_lbd(lbd);
              .       .    .              .              .       .              .           .     .                  //duplicate learnts 
              .       .    .              .              .       .              .           .     .                  int  id = 0;
      5,110,012       0    0      2,555,006      2,549,064       0              0           0     0                  if (lbd <= max_lbd_dup){                        
              .       .    .              .              .       .              .           .     .                      std::vector<uint32_t> tmp;
    262,210,051       0    0    185,257,693              0       0      1,740,598           0     0                      for (int i = 0; i < learnt_clause.size(); i++)
    188,738,889       8    2    125,825,926              0       0     62,912,963           0     0                          tmp.push_back(learnt_clause[i].x);
      5,221,794       5    2      1,740,598              0       0      1,740,598           0     0                      id = is_duplicate(tmp);             
      8,702,990       0    0      1,740,598            597       0              0           0     0                      if (id == min_number_of_learnts_copies +1){
             73       0    0             73             25       0              0           0     0                          duplicates_added_conflicts++;                        
              .       .    .              .              .       .              .           .     .                      }                    
      3,481,196       0    0              0              0       0              0           0     0                      if (id == min_number_of_learnts_copies){
          1,103       0    0          1,103              0       0              0           0     0                          duplicates_added_tier2++;
              .       .    .              .              .       .              .           .     .                      }                                        
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .                  //duplicate learnts
              .       .    .              .              .       .              .           .     .  
     15,166,752       0    0      5,069,191      1,165,586       1              0           0     0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
             18       3    1              0              0       0              0           0     0                      learnts_core.push(cr);
              .       .    .              .              .       .              .           .     .                      ca[cr].mark(CORE);
      9,131,826   1,903   32              0              0       0              0           0     0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
             20       1    1              0              0       0              0           0     0                      learnts_tier2.push(cr);
              .       .    .              .              .       .              .           .     .                      ca[cr].mark(TIER2);
      1,849,976       0    0        462,494              3       0        462,494          88     0                      ca[cr].touched() = conflicts;
              .       .    .              .              .       .              .           .     .                  }else{
             23      21    1              0              0       0              0           0     0                      learnts_local.push(cr);
              .       .    .              .              .       .              .           .     .                      claBumpActivity(ca[cr]); }
      7,665,018   3,817   34              0              0       0      2,555,006           0     0                  attachClause(cr);
              .       .    .              .              .       .              .           .     .  
     15,330,036       0    0      7,665,018            620       0      2,555,006           0     0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
              .       .    .              .              .       .              .           .     .  #ifdef PRINT_OUT
              .       .    .              .              .       .              .           .     .                  std::cout << "new " << ca[cr] << "\n";
              .       .    .              .              .       .              .           .     .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
              .       .    .              .              .       .              .           .     .  #endif                
              .       .    .              .              .       .              .           .     .              }
      7,665,096       0    0      2,555,032      1,073,259       0              0           0     0              if (drup_file){
              .       .    .              .              .       .              .           .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .           .     .                  binDRUP('a', learnt_clause, drup_file);
              .       .    .              .              .       .              .           .     .  #else
              .       .    .              .              .       .              .           .     .                  for (int i = 0; i < learnt_clause.size(); i++)
              .       .    .              .              .       .              .           .     .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
              .       .    .              .              .       .              .           .     .                  fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
      7,665,096   1,256   39      5,110,064      1,346,986       0              0           0     0              if (VSIDS) varDecayActivity();
              .       .    .              .              .       .              .           .     .              claDecayActivity();
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              /*if (--learntsize_adjust_cnt == 0){
              .       .    .              .              .       .              .           .     .                  learntsize_adjust_confl *= learntsize_adjust_inc;
              .       .    .              .              .       .              .           .     .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
              .       .    .              .              .       .              .           .     .                  max_learnts             *= learntsize_inc;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
              .       .    .              .              .       .              .           .     .                             (int)conflicts,
              .       .    .              .              .       .              .           .     .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
              .       .    .              .              .       .              .           .     .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
              .       .    .              .              .       .              .           .     .              }*/
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .          }else{
              .       .    .              .              .       .              .           .     .              // NO CONFLICT
              .       .    .              .              .       .              .           .     .              bool restart = false;
     10,242,753      51   15      3,414,251        199,277       0              0           0     0              if (!VSIDS)
              .       .    .              .              .       .              .           .     .                  restart = nof_conflicts <= 0;
      3,682,394       1    1      1,841,197      1,211,613       0              0           0     0              else if (!cached){
     11,234,960       0    0      3,189,888      1,202,337       0        684,597           0     0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
              .       .    .              .              .       .              .           .     .                  cached = true;
              .       .    .              .              .       .              .           .     .              }
      4,719,162       0    0      1,573,054      1,134,855       0              0           0     0              if (restart /*|| !withinBudget()*/){
              .       .    .              .              .       .              .           .     .                  lbd_queue.clear();
              .       .    .              .              .       .              .           .     .                  cached = false;
              .       .    .              .              .       .              .           .     .                  // Reached bound on number of conflicts:
         15,846       0    0              0              0       0         10,564           0     0                  progress_estimate = progressEstimate();
              .       .    .              .              .       .              .           .     .                  cancelUntil(0);
         10,564       0    0              0              0       0              0           0     0                  return l_Undef; }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Simplify the set of problem clauses:
     10,852,041     142   31      3,408,969              0       0        609,217           0     0              if (decisionLevel() == 0 && !simplify())
              .       .    .              .              .       .              .           .     .                  return l_False;
              .       .    .              .              .       .              .           .     .  
     10,226,907      58    9      6,817,938          4,873       1              0           0     0              if (conflicts >= next_T2_reduce){
            510       0    0              0              0       0            255           0     0                  next_T2_reduce = conflicts + 10000;
          1,020       0    0            255              0       0            255           0     0                  reduceDB_Tier2(); }
      6,817,938      55   17      3,408,969              0       0              0           0     0              if (conflicts >= next_L_reduce){
            340       0    0              0              0       0            170           0     0                  next_L_reduce = conflicts + 15000;
            340       0    0              0              0       0            170           0     0                  reduceDB(); }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              Lit next = lit_Undef;
              .       .    .              .              .       .              .           .     .              /*while (decisionLevel() < assumptions.size()){
              .       .    .              .              .       .              .           .     .                  // Perform user provided assumption:
              .       .    .              .              .       .              .           .     .                  Lit p = assumptions[decisionLevel()];
              .       .    .              .              .       .              .           .     .                  if (value(p) == l_True){
              .       .    .              .              .       .              .           .     .                      // Dummy decision level:
              .       .    .              .              .       .              .           .     .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
              .       .    .              .              .       .              .           .     .                  }else{
              .       .    .              .              .       .              .           .     .                      next = p;
              .       .    .              .              .       .              .           .     .                      break;
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              if (next == lit_Undef)*/{
              .       .    .              .              .       .              .           .     .                  // New variable decision:
      3,408,969       0    0      3,408,969            170       0              0           0     0                  decisions++;
     10,226,907     872   43              0              0       0      3,408,969           0     0                  next = pickBranchLit();
              .       .    .              .              .       .              .           .     .  
      6,817,938       0    0              0              0       0              0           0     0                  if (next == lit_Undef)
              .       .    .              .              .       .              .           .     .                      // Model found:
              2       0    0              0              0       0              0           0     0                      return l_True;
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .              // Increase decision level and enqueue 'next'
              .       .    .              .              .       .              .           .     .              newDecisionLevel();
     20,453,808      57   28      3,408,968              0       0      3,408,968           0     0              uncheckedEnqueue(next, decisionLevel());
              .       .    .              .              .       .              .           .     .  #ifdef PRINT_OUT            
              .       .    .              .              .       .              .           .     .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
              .       .    .              .              .       .              .           .     .  #endif            
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
         47,547     114   27         36,981         10,563       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  double Solver::progressEstimate() const
         31,692       5    4              0              0       0         26,410           0     0  {
         10,564       0    0              0              0       0              0           0     0      double  progress = 0;
         26,410       0    0         10,564          3,667       0          5,282           0     0      double  F = 1.0 / nVars();
              .       .    .              .              .       .              .           .     .  
        517,597       5    4              0              0       0              0           0     0      for (int i = 0; i <= decisionLevel(); i++){
        485,905       0    0        316,894              0       0              0           0     0          int beg = i == 0 ? 0 : trail_lim[i - 1];
        649,634       0    0        322,176         11,901       1              0           0     0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
        998,220      30   15        169,011              0       0              0           0     0          progress += pow(F, i) * (end - beg);
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
         10,564       0    0              0              0       0              0           0     0      return progress / nVars();
         36,974       0    0         31,692              0       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  /*
              .       .    .              .              .       .              .           .     .    Finite subsequences of the Luby-sequence:
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .    0: 1
              .       .    .              .              .       .              .           .     .    1: 1 1 2
              .       .    .              .              .       .              .           .     .    2: 1 1 2 1 1 2 4
              .       .    .              .              .       .              .           .     .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .   */
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  static double luby(double y, int x){
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Find the finite subsequence that contains index 'x', and the
              .       .    .              .              .       .              .           .     .      // size of that subsequence:
              .       .    .              .              .       .              .           .     .      int size, seq;
        117,523       0    0              0              0       0              0           0     0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
              .       .    .              .              .       .              .           .     .  
         65,995       5    5              0              0       0              0           0     0      while (size-1 != x){
         37,882       0    0              0              0       0              0           0     0          size = (size-1)>>1;
         18,941       0    0              0              0       0              0           0     0          seq--;
         56,823       0    0              0              0       0              0           0     0          x = x % size;
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      return pow(y, seq);
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  static bool switch_mode = false;
              .       .    .              .              .       .              .           .     .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
              .       .    .              .              .       .              .           .     .  
             24       3    3              0              0       0             18           0     0  uint32_t Solver::reduceduplicates(){
              .       .    .              .              .       .              .           .     .      uint32_t removed_duplicates = 0;
              .       .    .              .              .       .              .           .     .      std::vector<std::vector<uint64_t>> tmp;
              .       .    .              .              .       .              .           .     .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
         12,915       0    0              6              0       0              0           0     0      for (auto & outer_mp: ht){//variables
        213,527       0    0              0              0       0              0           0     0          for (auto &inner_mp:outer_mp.second){//sizes
      3,415,678       0    0              0              0       0              0           0     0              for (auto &in_in_mp: inner_mp.second){
      4,832,238       3    3      1,610,746      1,549,978 661,267              0           0     0                  if (in_in_mp.second >= 2){
              .       .    .              .              .       .              .           .     .                  //min_number_of_learnts_copies
      1,203,450       3    3        481,380            964     519        481,380         593     0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
              .       .    .              .              .       .              .           .     .                  }
              .       .    .              .              .       .              .           .     .              }                    
              .       .    .              .              .       .              .           .     .           }
              .       .    .              .              .       .              .           .     .      }          
              9       0    0              3              3       0              3           0     0      removed_duplicates = dupl_db_size-tmp.size();  
              .       .    .              .              .       .              .           .     .      ht.clear();
        842,430       3    3        361,038             99       1              0           0     0      for (auto i=0;i<tmp.size();i++){
      1,203,450       0    0        601,725        135,500  73,722        361,035          38     1          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .      return removed_duplicates;
             27       0    0             24              9       2              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  // NOTE: assumptions passed in member-variable 'assumptions'.
              .       .    .              .              .       .              .           .     .  lbool Solver::solve_()
              8       0    0              0              0       0              6           0     0  {
              .       .    .              .              .       .              .           .     .      //signal(SIGALRM, SIGALRM_switch);
              .       .    .              .              .       .              .           .     .      //alarm(2500);
              .       .    .              .              .       .              .           .     .  
              1       1    1              0              0       0              0           0     0      model.clear();
              .       .    .              .              .       .              .           .     .      conflict.clear();
              2       1    1              1              0       0              0           0     0      if (!ok) return l_False;
              .       .    .              .              .       .              .           .     .  
              1       1    1              1              1       0              0           0     0      solves++;
              .       .    .              .              .       .              .           .     .  
              5       0    0              2              0       0              1           0     0      max_learnts               = nClauses() * learntsize_factor;
              3       0    0              1              1       0              0           0     0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
              1       0    0              0              0       0              1           1     0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
              .       .    .              .              .       .              .           .     .      lbool   status            = l_Undef;
              .       .    .              .              .       .              .           .     .  
              3       0    0              1              0       0              0           0     0      if (verbosity >= 1){
              2       0    0              0              0       0              1           0     0          printf("c ============================[ Search Statistics ]==============================\n");
              2       1    1              0              0       0              1           0     0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
              2       0    0              0              0       0              1           0     0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
              2       0    0              0              0       0              1           0     0          printf("c ===============================================================================\n");
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      add_tmp.clear();
              .       .    .              .              .       .              .           .     .  
              1       0    0              0              0       0              1           1     0      VSIDS = true;
              1       1    1              0              0       0              1           0     0      int init = 10000;
            695       0    0            139              0       0              0           0     0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
            556       3    0              0              0       0            139           0     0          status = search(init);
              1       0    0              0              0       0              1           0     0      VSIDS = false;
              .       .    .              .              .       .              .           .     .  
              3       1    1              0              0       0              2           1     0      duplicates_added_conflicts = 0;
              .       .    .              .              .       .              .           .     .      duplicates_added_minimization=0;
              .       .    .              .              .       .              .           .     .      duplicates_added_tier2 =0;    
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      dupl_db_size=0;
              1       0    0              1              1       0              0           0     0      size_t dupl_db_size_limit = dupl_db_init_size;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // Search:
              1       0    0              0              0       0              0           0     0      int curr_restarts = 0;
              1       0    0              0              0       0              0           0     0      uint64_t curr_props = 0;
              .       .    .              .              .       .              .           .     .      uint32_t removed_duplicates =0;
         10,288   1,763   30              0              0       0              0           0     0      while (status == l_Undef /*&& withinBudget()*/){
         10,288       1    1          5,144          2,838       0              0           0     0          if (dupl_db_size >= dupl_db_size_limit){    
             12       3    3              3              0       0              3           0     0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             12       0    0              3              3       0              3           0     0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             12       0    0              3              0       0              3           0     0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             12       3    3              3              1       0              3           0     0              printf("c Duptime: %i\n",duptime.count());
             12       0    0              3              0       0              3           0     0              printf("c Number of conflicts: %i\n",conflicts);
             12       0    0              3              1       0              3           0     0              printf("c Core size: %i\n",learnts_core.size());
              .       .    .              .              .       .              .           .     .              
              6       0    0              0              0       0              3           0     0              removed_duplicates = reduceduplicates();
             24       3    3              6              6       4              0           0     0              dupl_db_size_limit*=1.1;
              6       0    0              3              3       2              0           0     0              dupl_db_size -= removed_duplicates;
             15       0    0              0              0       0              3           0     0              printf("c removed duplicates %i\n",removed_duplicates);
              .       .    .              .              .       .              .           .     .          }   
         30,864     160   50         10,288          7,583       2              0           0     0          if (propagations - curr_props >  VSIDS_props_limit){
             12       0    0              0              0       0              0           0     0              curr_props = propagations;
             12       0    0              0              0       0             12           0     0              switch_mode = true;
             61       0    0              0              0       0             12           0     0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
              .       .    .              .              .       .              .           .     .          }     
         10,288       0    0          5,144              3       1              0           0     0          if (VSIDS){
          2,845       0    0              0              0       0          2,845           0     0              int weighted = INT32_MAX;
         11,380   2,845   14              0              0       0          2,845           0     0              status = search(weighted);
              .       .    .              .              .       .              .           .     .          }else{
         13,794   1,894   16          4,598              0       0          2,299           0     0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          2,299       0    0              0              0       0              0           0     0              curr_restarts++;
         11,495   2,294   10              0              0       0          2,299           0     0              status = search(nof_conflicts);
              .       .    .              .              .       .              .           .     .          }
         10,288   2,295    7          5,144          5,144      43              0           0     0          if (switch_mode){ 
             12       0    0              0              0       0             12           0     0              switch_mode = false;
              .       .    .              .              .       .              .           .     .              VSIDS = !VSIDS;
             24       0    0             12              0       0              0           0     0              if (VSIDS){
             12       6    6              0              0       0              6           0     0                  printf("c Switched to VSIDS.\n");
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              else{
             18       6    6              0              0       0              6           0     0                 printf("c Switched to LRB.\n");
              .       .    .              .              .       .              .           .     .              }
              .       .    .              .              .       .              .           .     .              //            reduceduplicates();            
             24       6    6             12             12      11             12           0     0              fflush(stdout);
              .       .    .              .              .       .              .           .     .              picked.clear();
              .       .    .              .              .       .              .           .     .              conflicted.clear();
              .       .    .              .              .       .              .           .     .              almost_conflicted.clear();
              .       .    .              .              .       .              .           .     .  #ifdef ANTI_EXPLORATION
              .       .    .              .              .       .              .           .     .              canceled.clear();
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              3       1    1              1              1       0              0           0     0      if (verbosity >= 1)
              2       0    0              0              0       0              1           0     0          printf("c ===============================================================================\n");
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  #ifdef BIN_DRUP
              3       0    0              1              0       0              0           0     0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
              .       .    .              .              .       .              .           .     .  #endif
              .       .    .              .              .       .              .           .     .  
              2       1    1              0              0       0              0           0     0      if (status == l_True){
              .       .    .              .              .       .              .           .     .          // Extend & copy model:
              .       .    .              .              .       .              .           .     .          model.growTo(nVars());
            509       1    1            240             26       4            246           0     0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
              .       .    .              .              .       .              .           .     .      }else if (status == l_False && conflict.size() == 0)
              .       .    .              .              .       .              .           .     .          ok = false;
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      cancelUntil(0);
              1       0    0              0              0       0              0           0     0      return status;
              8       1    1              7              1       1              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  //=================================================================================================
              .       .    .              .              .       .              .           .     .  // Writing CNF to DIMACS:
              .       .    .              .              .       .              .           .     .  // 
              .       .    .              .              .       .              .           .     .  // FIXME: this needs to be rewritten completely.
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  static Var mapVar(Var x, vec<Var>& map, Var& max)
              .       .    .              .              .       .              .           .     .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
              .       .    .              .              .       .              .           .     .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
              .       .    .              .              .       .              .           .     .  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  //=================================================================================================
              .       .    .              .              .       .              .           .     .  // Garbage Collection methods:
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::relocAll(ClauseAllocator& to)
          1,530     106   61              0              0       0          1,224           0     0  {
              .       .    .              .              .       .              .           .     .      // All watchers:
              .       .    .              .              .       .              .           .     .      //
              .       .    .              .              .       .              .           .     .      // for (int i = 0; i < watches.size(); i++)
            306       0    0              0              0       0            153           0     0      watches.cleanAll();
            306       0    0              0              0       0            153           0     0      watches_bin.cleanAll();
      5,862,348      12    6      4,103,154         34,747       0        586,449         152     0      for (int v = 0; v < nVars(); v++)
      2,344,572       0    0      1,172,286              0       0              0           0     0          for (int s = 0; s < 2; s++){
              .       .    .              .              .       .              .           .     .              Lit p = mkLit(v, s);
              .       .    .              .              .       .              .           .     .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
              .       .    .              .              .       .              .           .     .              vec<Watcher>& ws = watches[p];
    118,258,379      52   33     63,933,490        293,146  40,687              0           0     0              for (int j = 0; j < ws.size(); j++)
              .       .    .              .              .       .              .           .     .                  ca.reloc(ws[j].cref, to);
              .       .    .              .              .       .              .           .     .              vec<Watcher>& ws_bin = watches_bin[p];
     11,554,546       6    4      4,674,646        320,867  38,279              0           0     0              for (int j = 0; j < ws_bin.size(); j++)
              .       .    .              .              .       .              .           .     .                  ca.reloc(ws_bin[j].cref, to);
              .       .    .              .              .       .              .           .     .          }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // All reasons:
              .       .    .              .              .       .              .           .     .      //
        408,370       0    0            459              0       0              0           0     0      for (int i = 0; i < trail.size(); i++){
              .       .    .              .              .       .              .           .     .          Var v = var(trail[i]);
              .       .    .              .              .       .              .           .     .  
        598,144       0    0         95,346         88,253       0              0           0     0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
        477,036       0    0         95,346              0       0         95,346           0     0              ca.reloc(vardata[v].reason, to);
              .       .    .              .              .       .              .           .     .      }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // All learnt:
              .       .    .              .              .       .              .           .     .      //
     22,051,437     150   76     11,025,641            301       1              0           0     0      for (int i = 0; i < learnts_core.size(); i++)
              .       .    .              .              .       .              .           .     .          ca.reloc(learnts_core[i], to);
      2,691,526     457  240      1,345,762            606       0              0           0     0      for (int i = 0; i < learnts_tier2.size(); i++)
              .       .    .              .              .       .              .           .     .          ca.reloc(learnts_tier2[i], to);
      4,183,738     153   78      2,091,564            151       0              0           0     0      for (int i = 0; i < learnts_local.size(); i++)
      6,273,774       0    0              0              0       0      2,091,258           0     0          ca.reloc(learnts_local[i], to);
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      // All original:
              .       .    .              .              .       .              .           .     .      //
              .       .    .              .              .       .              .           .     .      int i, j;
      3,086,747     153   71            612            151       0              0           0     0      for (i = j = 0; i < clauses.size(); i++)
      3,085,370       0    0              0              0       0              0           0     0          if (ca[clauses[i]].mark() != 1){
      4,628,361     153   64      1,542,685            151       0      1,542,685           1     0              ca.reloc(clauses[i], to);
     15,426,697     150   63      6,170,587              0       0      1,542,685           0     0              clauses[j++] = clauses[i]; }
            153     152   69              0              0       0              0           0     0      clauses.shrink(i - j);
          1,224     152   75          1,071            153       0              0           0     0  }
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .  void Solver::garbageCollect()
              .       .    .              .              .       .              .           .     .  {
              .       .    .              .              .       .              .           .     .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
              .       .    .              .              .       .              .           .     .      // is not precise but should avoid some unnecessary reallocations for the new region:
              .       .    .              .              .       .              .           .     .      ClauseAllocator to(ca.size() - ca.wasted());
              .       .    .              .              .       .              .           .     .  
              .       .    .              .              .       .              .           .     .      relocAll(to);
              .       .    .              .              .       .              .           .     .      if (verbosity >= 2)
              .       .    .              .              .       .              .           .     .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
              .       .    .              .              .       .              .           .     .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
              .       .    .              .              .       .              .           .     .      to.moveTo(ca);
            155      18   18             47              4       4             61           0     0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr             D1mr          DLmr  Dw             D1mw          DLmw      

-- line 40 ----------------------------------------
              .       .    .              .             .     .              .             .         .      int sz;
              .       .    .              .             .     .              .             .         .      int cap;
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .      // Don't allow copying (error prone):
              .       .    .              .             .     .              .             .         .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              .       .    .              .             .     .              .             .         .               vec        (vec<T>& other) { assert(0); }
              .       .    .              .             .     .              .             .         .               
              .       .    .              .             .     .              .             .         .      // Helpers for calculating next capacity:
      4,663,523      12    9              0             0     0              0             0         0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
              .       .    .              .             .     .              .             .         .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .    .              .             .     .              .             .         .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  public:
              .       .    .              .             .     .              .             .         .      // Constructors:
        906,502      28   25              2             0     0        887,343        10,980     4,733      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
             48       0    0              0             0     0             48             0         0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
              .       .    .              .             .     .              .             .         .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
              .       .    .              .             .     .              .             .         .     ~vec()                                                          { clear(true); }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .      // Pointer to first element:
              .       .    .              .             .     .              .             .         .      operator T*       (void)           { return data; }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .      // Size operations:
              .       .    .              .             .     .              .             .         .      int      size     (void) const     { return sz; }
  2,129,774,840   1,836   23    209,840,959     6,417,158     0     76,985,805             0         0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
              .       .    .              .             .     .              .             .         .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
              .       .    .              .             .     .              .             .         .      int      capacity (void) const     { return cap; }
              .       .    .              .             .     .              .             .         .      void     capacity (int min_cap);
              .       .    .              .             .     .              .             .         .      void     growTo   (int size);
              .       .    .              .             .     .              .             .         .      void     growTo   (int size, const T& pad);
              .       .    .              .             .     .              .             .         .      void     clear    (bool dealloc = false);
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .      // Stack interface:
     10,272,505     524    5      5,132,141         4,275     0      2,565,616           214         0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
160,240,286,420 166,628  462 57,820,467,109 4,623,564,775 3,191 44,242,026,089 6,438,604,160 2,255,480      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
  3,515,772,765       0    0    892,685,304            71     0  1,715,754,220    64,651,543     1,476      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
  1,006,917,055      14    3     27,280,207             0     0    490,016,214             0         0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
              .       .    .              .             .     .              .             .         .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
              .       .    .              .             .     .              .             .         .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
              .       .    .              .             .     .              .             .         .      // happen given the way capacities are calculated (below). Essentially, all capacities are
              .       .    .              .             .     .              .             .         .      // even, but INT_MAX is odd.
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .      const T& last  (void) const        { return data[sz-1]; }
    461,963,324       0    0              0             0     0              0             0         0      T&       last  (void)              { return data[sz-1]; }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .      // Vector interface:
 84,644,778,367   1,773  113    548,238,409             3     0     27,455,551             5         0      const T& operator [] (int index) const { return data[index]; }
 62,991,322,143     886  421 17,706,123,748    26,842,029   446  1,089,681,351       326,158         0      T&       operator [] (int index)       { return data[index]; }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .      // Duplicatation (preferred instead):
  1,230,980,230      25    7    412,030,098     2,695,908     0    202,182,501             0         0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
         64,107       1    0         64,038             4     0             46             0         0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
              .       .    .              .             .     .              .             .         .  };
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  template<class T>
      1,165,764       0    0              0             0     0        582,882             0         0  void vec<T>::capacity(int min_cap) {
      9,585,633      59   15      3,195,211             6     0              0             0         0      if (cap >= min_cap) return;
      4,080,641      12    8              0             0     0             16             0         0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
      7,581,773     102   26        582,984            22     0      1,748,830         2,492         0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
              .       .    .              .             .     .              .             .         .          throw OutOfMemoryException();
      3,762,769       3    3      3,762,769             1     0              0             0         0   }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  template<class T>
              .       .    .              .             .     .              .             .         .  void vec<T>::growTo(int size, const T& pad) {
     81,909,048       9    7     27,299,185           378     0              0             0         0      if (sz >= size) return;
         76,620       4    4          7,662             0     0         34,479             0         0      capacity(size);
        432,905       7    7         68,959             0     0         34,480           922         0      for (int i = sz; i < size; i++) data[i] = pad;
     44,576,744       6    5          8,606             0     0         34,479             0         0      sz = size; }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  template<class T>
         76,620       1    1              0             0     0         30,648             0         0  void vec<T>::growTo(int size) {
      5,202,061       1    1         26,820            71     0         15,324             0         0      if (sz >= size) return;
     10,227,867   1,381   31              0             0     0      5,113,922             0         0      capacity(size);
     36,077,253      59   26     10,258,492             0     0      5,110,090             0         0      for (int i = sz; i < size; i++) new (&data[i]) T();
      7,745,646       0    0      2,601,074            14     0      2,574,214             3         0      sz = size; }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  template<class T>
              .       .    .              .             .     .              .             .         .  void vec<T>::clear(bool dealloc) {
    622,506,392 691,352  220    189,662,481     3,205,428     2          3,522             0         0      if (data != NULL){
          7,667       0    0              1             0     0              0             0         0          for (int i = 0; i < sz; i++) data[i].~T();
  1,532,361,700      11    5     25,602,117             1     0    218,759,562            41         0          sz = 0;
        261,282       5    5         17,726             0     0        240,411             6         0          if (dealloc) free(data), data = NULL, cap = 0; } }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  //=================================================================================================
              .       .    .              .             .     .              .             .         .  }
              .       .    .              .             .     .              .             .         .  
              .       .    .              .             .     .              .             .         .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr        DLmr   Dw          D1mw    DLmw 

-- line 77 ----------------------------------------
             .     .    .              .           .      .           .       .    .  private:
             .     .    .              .           .      .           .       .    .      template<typename T>
             .     .    .              .           .      .           .       .    .      class MyQueue {
             .     .    .              .           .      .           .       .    .          int max_sz, q_sz;
             .     .    .              .           .      .           .       .    .          int ptr;
             .     .    .              .           .      .           .       .    .          int64_t sum;
             .     .    .              .           .      .           .       .    .          vec<T> q;
             .     .    .              .           .      .           .       .    .      public:
             4     1    1              0           0      0           3       0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .     .    .              .           .      .           .       .    .          inline bool   full () const { return q_sz == max_sz; }
             .     .    .              .           .      .           .       .    .  #ifdef INT_QUEUE_AVG
     2,427,592   141    6        606,898           0      0           0       0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .     .    .              .           .      .           .       .    .  #else
             .     .    .              .           .      .           .       .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .     .    .              .           .      .           .       .    .  #endif
        10,564    33   20              0           0      0      10,564   1,962    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .     .    .              .           .      .           .       .    .          void push(T e) {
     8,388,674     0    0      4,045,137           0      0     149,200       0    0              if (q_sz < max_sz) q_sz++;
     3,597,537     8    7      1,199,179   1,197,915     10           0       0    0              else sum -= q[ptr];
     4,045,137    31   22              0           0      0   1,348,379       0    0              sum += e;
     4,045,137     0    0              0           0      0   2,696,758 148,865   25              q[ptr++] = e;
     4,071,201     0    0      2,696,758           0      0      26,064       0    0              if (ptr == max_sz) ptr = 0;
             .     .    .              .           .      .           .       .    .          }
             .     .    .              .           .      .           .       .    .      };
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  public:
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      // Constructor/Destructor:
             .     .    .              .           .      .           .       .    .      //
             .     .    .              .           .      .           .       .    .      Solver();
             .     .    .              .           .      .           .       .    .      virtual ~Solver();
            10     2    2              0           0      0           4       0    0      void print_size(std::ostream &os)
             .     .    .              .           .      .           .       .    .      {
             4     2    2              0           0      0           4       1    0          program_end_time=std::chrono::steady_clock::now();
             2     0    0              0           0      0           2       0    0          total_work_time=program_end_time-program_start_time;
             4     0    0              2           1      0           0       0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2     0    0              2           1      0           0       0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4     0    0              2           1      0           0       0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4     0    0              2           1      0           0       0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4     0    0              2           2      0           0       0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .     .    .              .           .      .           .       .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .     .    .              .           .      .           .       .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2     0    0              2           2      0           0       0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2     0    0              2           0      0           0       0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2     0    0              2           0      0           0       0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4     0    0              2           2      0           0       0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4     0    0              2           2      0           0       0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_Watchers: " << total_Watchers << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_indexs: " << total_indexs << "\n";
             .     .    .              .           .      .           .       .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .     .    .              .           .      .           .       .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6     0    0              4           0      0           0       0    0      }
             .     .    .              .           .      .           .       .    .      using ull=unsigned long long;
             .     .    .              .           .      .           .       .    .      ull total_Watchers = 0;
             .     .    .              .           .      .           .       .    .      ull total_act_watchers = 0;
             .     .    .              .           .      .           .       .    .      ull total_indexs = 0;
             .     .    .              .           .      .           .       .    .      ull time_find_conflict = 0;
             .     .    .              .           .      .           .       .    .      ull total_find_conflict_length = 0;
             .     .    .              .           .      .           .       .    .      ull total_find_conflict_allsize = 0;
             .     .    .              .           .      .           .       .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .              .           .      .           .       .    .      {
             .     .    .              .           .      .           .       .    .          const ClauseAllocator& ca;
             .     .    .              .           .      .           .       .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .     .    .              .           .      .           .       .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .     .    .              .           .      .           .       .    .      };
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      struct VarOrderLt {
             .     .    .              .           .      .           .       .    .          const vec<double>&  activity;
 3,888,520,539 1,091   50  2,681,802,460 317,395,130  3,935 131,406,230       0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .     .    .              .           .      .           .       .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .     .    .              .           .      .           .       .    .      };
             .     .    .              .           .      .           .       .    .      
             .     .    .              .           .      .           .       .    .      struct ConflictData
             .     .    .              .           .      .           .       .    .  	{
             .     .    .              .           .      .           .       .    .  		ConflictData() :
             .     .    .              .           .      .           .       .    .  			nHighestLevel(-1),
             .     .    .              .           .      .           .       .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .     .    .              .           .      .           .       .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .     .    .              .           .      .           .       .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .     .    .              .           .      .           .       .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .     .    .              .           .      .           .       .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .     .    .              .           .      .           .       .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .     .    .              .           .      .           .       .    .      std::chrono::nanoseconds total_duration;
             .     .    .              .           .      .           .       .    .      CRef     propagate(){
             .     .    .              .           .      .           .       .    .  
    11,949,892 6,156   49              0           0      0   5,974,946       1    0          auto start_time=std::chrono::steady_clock::now();
    17,924,838     0    0              0           0      0   5,974,946       0    0          auto ref= propagate_();
     5,974,946     1    1              0           0      0   5,974,946       0    0          auto end_time=std::chrono::steady_clock::now();
             .     .    .              .           .      .           .       .    .          auto duration=end_time-start_time;
             .     .    .              .           .      .           .       .    .          total_duration+=duration;
             .     .    .              .           .      .           .       .    .          return ref;
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .     .    .              .           .      .           .       .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .     .    .              .           .      .           .       .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .     .    .              .           .      .           .       .    .      
             .     .    .              .           .      .           .       .    .  public:
             .     .    .              .           .      .           .       .    .      int      level            (Var x) const;
             .     .    .              .           .      .           .       .    .  protected:
             .     .    .              .           .      .           .       .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .     .    .              .           .      .           .       .    .      bool     withinBudget     ()      const;
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      template<class V> int computeLBD(const V& c) {
   135,421,538    49   29              0           0      0           0       0    0          int lbd = 0;
             .     .    .              .           .      .           .       .    .  
    15,245,610    51   35     12,690,578   4,104,093      2           0       0    0          counter++;
   611,035,417     0    0      2,559,564           0      0           0       0    0          for (int i = 0; i < c.size(); i++){
             .     .    .              .           .      .           .       .    .              int l = level(var(c[i]));
 1,444,980,986     0    0    577,991,800  13,522,643     74           0       0    0              if (l != 0 && seen2[l] != counter){
    92,935,585     0    0              0           0      0  92,935,585       0    0                  seen2[l] = counter;
   196,688,689     0    0              0           0      0           0       0    0                  lbd++; } }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .          return lbd;
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  #ifdef BIN_DRUP
             .     .    .              .           .      .           .       .    .      static int buf_len;
             .     .    .              .           .      .           .       .    .      static unsigned char drup_buf[];
             .     .    .              .           .      .           .       .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      template<class V>
             .     .    .              .           .      .           .       .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .     .    .              .           .      .           .       .    .          assert(op == 'a' || op == 'd');
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = op; buf_len++;
             .     .    .              .           .      .           .       .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = 0; buf_len++;
       316,582    43   30              0           0      0     316,582       0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = 'a'; buf_len++;
             .     .    .              .           .      .           .       .    .          for (int i = 0; i < c.size(); i++)
             .     .    .              .           .      .           .       .    .              if (c[i] != l) byteDRUP(c[i]);
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = 0; buf_len++;
             .     .    .              .           .      .           .       .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .     .    .              .           .      .           .       .    .      double    my_var_decay;
             .     .    .              .           .      .           .       .    .      bool   DISTANCE;
             .     .    .              .           .      .           .       .    .  };
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  //=================================================================================================
             .     .    .              .           .      .           .       .    .  // Implementation of inline methods:
             .     .    .              .           .      .           .       .    .  
   621,767,921     0    0    621,767,921  15,062,384  3,100           0       0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
 4,478,550,368    54   34  3,762,736,845 574,733,906      5 708,143,863       0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::insertVarOrder(Var x) {
             .     .    .              .           .      .           .       .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
 4,943,850,400 1,586   31  1,522,318,492   1,519,003      0           0       0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    81,827,685     1    1     54,551,790  13,579,402    368           0       0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::varDecayActivity() {
     5,393,516     0    0      2,696,758     221,576      0   1,348,379       0    0      var_inc *= (1 / var_decay); }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::varBumpActivity(Var v, double mult) {
 2,248,140,350    10    9  1,366,097,840 145,412,039    672 340,885,702       0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .     .    .              .           .      .           .       .    .          // Rescale:
         3,292   116   55              1           0      0           0       0    0          for (int i = 0; i < nVars(); i++)
     2,521,456     0    0        630,693     138,873  2,300     630,364       0    0              activity_VSIDS[i] *= 1e-100;
           658     0    0            329         329      0         329       0    0          var_inc *= 1e-100; }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      // Update order_heap with respect to new activity:
   231,040,584     0    0              0           0      0           0       0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .     .    .              .           .      .           .       .    .  
    10,220,128 1,605   13      5,110,064         838      0   2,555,032       0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .     .    .              .           .      .           .       .    .  inline void Solver::claBumpActivity (Clause& c) {
    61,132,978   655   68     18,148,989   2,906,415      7   6,208,750  17,834  304      if ( (c.activity() += cla_inc) > 1e20 ) {
             .     .    .              .           .      .           .       .    .          // Rescale:
     3,470,906    55   47            165           0      0           0       0    0          for (int i = 0; i < learnts_local.size(); i++)
     8,097,754     2    0      1,156,822   1,083,755 14,679   1,156,822       0    0              ca[learnts_local[i]].activity() *= 1e-20;
       954,687   236   46        477,261           0      0          55      55    0          cla_inc *= 1e-20; } }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .     .    .              .           .      .           .       .    .  inline void Solver::checkGarbage(double gf){
        33,885   104    0         11,295         243      0           0       0    0      if (ca.wasted() > ca.size() * gf)
           607     1    1            304         304     65           1       0    0          garbageCollect(); }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
           103     0    0              0           0      0          15       0    0  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::locked          (const Clause& c) const {
    34,437,062   170   73     11,216,004     271,449      0           0       0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    40,275,715   212   83      9,205,716     273,532      0           0       0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .     .    .              .           .      .           .       .    .  }
     6,817,948     1    1      3,408,968           0      0           0       0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .     .    .              .           .      .           .       .    .  
       342,770     3    3        179,041           1      0     163,729       0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
 1,750,219,531 1,390   46    199,627,469  19,412,613      0           0       0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
    27,360,430     1    1     27,360,414         679      0           0       0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
44,296,390,374    55   34 44,296,390,374       4,954      0           0       0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .     .    .              .           .      .           .       .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .     .    .              .           .      .           .       .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .     .    .              .           .      .           .       .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3     0    0              2           0      0           1       1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .     .    .              .           .      .           .       .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
     1,305,588     2    1         12,179          17      0           1       0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6     1    1              3           2      0           0       0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .     .    .              .           .      .           .       .    .  { 
        22,986     0    0         11,493          27      0           0       0    0      if      ( b && !decision[v]) dec_vars++;
         2,031     0    0          1,354         267      0           0       0    0      else if (!b &&  decision[v]) dec_vars--;
             .     .    .              .           .      .           .       .    .  
         4,508     0    0              0           0      0       4,508       0    0      decision[v] = b;
             .     .    .              .           .      .           .       .    .      if (b && !order_heap_CHB.inHeap(v)){
             .     .    .              .           .      .           .       .    .          order_heap_CHB.insert(v);
             .     .    .              .           .      .           .       .    .          order_heap_VSIDS.insert(v);
             .     .    .              .           .      .           .       .    .          order_heap_distance.insert(v);}
             .     .    .              .           .      .           .       .    .  }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .     .    .              .           .      .           .       .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
Ir                I1mr      ILmr   Dr              D1mr           DLmr      Dw              D1mw          DLmw       
--------------------------------------------------------------------------------
2,147,293,330,905 1,290,800 10,020 701,961,725,160 40,315,576,484 3,599,024 255,737,736,376 8,751,031,332 10,485,579  events annotated

