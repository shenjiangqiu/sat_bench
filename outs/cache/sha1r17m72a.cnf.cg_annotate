--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/sha1r17m72a.cnf
Data file:        sha1r17m72a.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr      ILmr  Dr              D1mr           DLmr      Dw              D1mw          DLmw      
--------------------------------------------------------------------------------
1,230,498,697,907 3,902,560 9,181 401,017,939,718 21,908,168,784 3,118,509 142,476,101,437 4,678,734,958 4,569,320  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr              D1mr           DLmr    Dw             D1mw          DLmw       file:function
--------------------------------------------------------------------------------
531,857,751,191  11,392   55 204,078,697,183 10,703,919,952  98,952 61,233,265,251     9,797,504         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
211,699,898,205       9    3  34,337,942,484  1,572,304,251  25,594 29,902,818,639             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
106,185,999,717 161,005    8  23,466,171,640  1,559,191,724     451 14,185,637,257 2,167,953,899   333,058  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
 70,532,699,152     335  130  18,489,824,054  2,722,073,459     604  7,211,317,002    46,915,123        28  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
 46,870,810,117      74   36  11,944,113,874    517,172,094      52              0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
 33,270,092,837      47   17   8,233,751,366    563,682,593       5  6,142,026,534   850,851,228    94,266  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
 25,432,707,603       4    2  24,974,714,002    223,998,345       0    457,980,483             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
 17,089,928,495  30,069  122   6,254,047,262    349,900,522      35  1,135,139,776     6,816,412        11  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 16,822,739,783  13,268   74   6,494,674,367    787,502,767      16  2,075,911,088   215,541,494         1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
 15,038,276,679      12    4   6,520,476,221    328,259,492     126  4,573,382,281 1,020,582,984     3,168  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 13,634,804,783 782,560  260   2,938,724,493     69,986,898      66  1,322,737,705     9,101,717         0  ???:__ieee754_pow_fma
 12,790,409,921  14,129   26   5,056,183,209    555,185,502      98  3,275,127,061    30,875,472        15  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
 12,400,598,818       0    0   6,200,299,409          3,939       0              0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
 11,587,545,244  24,692   38   3,755,210,291     64,238,999      15  1,317,222,598     1,185,450         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  8,997,303,558 725,989   17   2,448,390,673              0       0  1,602,213,895     7,175,035        95  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  8,734,094,444   5,174   63   2,065,622,451      2,908,377       1    816,601,852    17,063,731     8,548  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  8,600,624,315     458   22   4,341,439,665    182,669,165     515    447,949,738     7,735,160         1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  6,830,285,394   1,977   64   1,815,055,977    165,799,668     557     63,204,102       431,599         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  4,344,888,018       0    0   2,172,444,009         19,448       0              0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::simplePropagate()
  4,293,921,875     170    9   1,398,754,635    247,276,478     252              0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  4,181,713,790   3,251  157   1,003,529,756     60,252,484   1,038    111,530,777     5,563,965         0  ???:__exp1_fma
  4,173,635,649     438   47   2,037,186,498    120,755,929     640    298,162,316            39         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  3,755,121,051      33   16   1,226,050,464    125,534,785      13    711,248,416    37,760,169        24  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
  3,709,666,979     695   17   1,534,778,800      9,344,315      90              0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  3,245,281,114       6    6   1,120,816,665      4,631,948       0  1,003,647,784    34,011,314       286  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  3,066,816,250       0    0   3,066,816,250             41       0              0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::simplePropagate()
  3,010,957,904       0    0   2,007,302,229     29,975,116       0    501,823,277    87,883,329         9  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  2,804,039,600   1,839   39   1,258,019,683    118,151,338     683    407,085,620    12,212,893        50  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  2,648,564,684     115   51     518,019,529     45,311,778   1,985    271,996,215    29,971,118     1,109  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
  2,562,568,670   1,726   22     851,996,458        611,636       0     32,835,374     1,733,608         1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  2,151,388,263   5,475   15     597,460,529          6,825       8    358,452,570         5,125         0  ???:pow
  2,007,295,568       0    0     501,823,892              0       0    501,823,892        20,026         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  1,752,385,590     495   53     406,959,155     34,312,045      43    136,905,034             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h:Minisat::Solver::detachClause(unsigned int, bool)
  1,406,026,572       0    0     820,182,167     95,130,559     163    117,168,881             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  1,380,280,823       0    0     907,417,485    188,100,794      81              0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  1,309,601,145   1,064  150     335,290,505     36,834,788 216,503    198,424,688     9,134,822 1,006,281  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr       DLmr Dw          D1mw DLmw 

-- line 30 ----------------------------------------
          .    .    .           .          .    .           .    .    .  
          .    .    .           .          .    .           .    .    .  //=================================================================================================
          .    .    .           .          .    .           .    .    .  // Removing and searching for elements:
          .    .    .           .          .    .           .    .    .  //
          .    .    .           .          .    .           .    .    .  
          .    .    .           .          .    .           .    .    .  template<class V, class T>
          .    .    .           .          .    .           .    .    .  static inline void remove(V& ts, const T& t)
          .    .    .           .          .    .           .    .    .  {
     27,021  304    1           0          0    0           0    0    0      int j = 0;
791,941,107   85   31 132,635,785 17,283,244   40           0    0    0      for (; j < ts.size() && ts[j] != t; j++);
          .    .    .           .          .    .           .    .    .      assert(j < ts.size());
960,519,765  113   27 274,343,952 17,029,023    3 136,909,397    0    0      for (; j < ts.size()-1; j++) ts[j] = ts[j+1];
          .    .    .           .          .    .           .    .    .      ts.pop();
          .    .    .           .          .    .           .    .    .  }
          .    .    .           .          .    .           .    .    .  
          .    .    .           .          .    .           .    .    .  
          .    .    .           .          .    .           .    .    .  template<class V, class T>
          .    .    .           .          .    .           .    .    .  static inline bool find(V& ts, const T& t)
          .    .    .           .          .    .           .    .    .  {
          .    .    .           .          .    .           .    .    .      int j = 0;
    653,172    1    1     116,786      7,979    0           0    0    0      for (; j < ts.size() && ts[j] != t; j++);
          .    .    .           .          .    .           .    .    .      return j < ts.size();
          .    .    .           .          .    .           .    .    .  }
          .    .    .           .          .    .           .    .    .  
          .    .    .           .          .    .           .    .    .  
          .    .    .           .          .    .           .    .    .  //=================================================================================================
          .    .    .           .          .    .           .    .    .  // Copying vectors with support for nested vector types:
          .    .    .           .          .    .           .    .    .  //
          .    .    .           .          .    .           .    .    .  
-- line 58 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr        DLmr  Dw          D1mw   DLmw 

-- line 77 ----------------------------------------
             .     .    .              .           .     .           .      .    .  private:
             .     .    .              .           .     .           .      .    .      template<typename T>
             .     .    .              .           .     .           .      .    .      class MyQueue {
             .     .    .              .           .     .           .      .    .          int max_sz, q_sz;
             .     .    .              .           .     .           .      .    .          int ptr;
             .     .    .              .           .     .           .      .    .          int64_t sum;
             .     .    .              .           .     .           .      .    .          vec<T> q;
             .     .    .              .           .     .           .      .    .      public:
             4     1    1              0           0     0           3      0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .     .    .              .           .     .           .      .    .          inline bool   full () const { return q_sz == max_sz; }
             .     .    .              .           .     .           .      .    .  #ifdef INT_QUEUE_AVG
     1,369,440   139    4        342,360           0     0           0      0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .     .    .              .           .     .           .      .    .  #else
             .     .    .              .           .     .           .      .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .     .    .              .           .     .           .      .    .  #endif
         7,516    20   10              0           0     0       7,516  1,736    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .     .    .              .           .     .           .      .    .          void push(T e) {
     4,765,784     0    0      2,297,292           0     0      85,600      0    0              if (q_sz < max_sz) q_sz++;
     2,040,492     5    5        680,164     679,361     0           0      0    0              else sum -= q[ptr];
     2,297,292    24   11              0           0     0     765,764      0    0              sum += e;
     2,297,292     0    0              0           0     0   1,531,528 85,298   12              q[ptr++] = e;
     2,312,084     0    0      1,531,528           0     0      14,792      0    0              if (ptr == max_sz) ptr = 0;
             .     .    .              .           .     .           .      .    .          }
             .     .    .              .           .     .           .      .    .      };
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  public:
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .      // Constructor/Destructor:
             .     .    .              .           .     .           .      .    .      //
             .     .    .              .           .     .           .      .    .      Solver();
             .     .    .              .           .     .           .      .    .      virtual ~Solver();
            10     2    2              0           0     0           4      0    0      void print_size(std::ostream &os)
             .     .    .              .           .     .           .      .    .      {
             4     2    2              0           0     0           4      1    0          program_end_time=std::chrono::steady_clock::now();
             2     0    0              0           0     0           2      0    0          total_work_time=program_end_time-program_start_time;
             4     0    0              2           1     0           0      0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2     0    0              2           0     0           0      0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4     0    0              2           1     0           0      0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4     0    0              2           1     0           0      0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4     0    0              2           0     0           0      0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4     0    0              2           2     0           0      0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .     .    .              .           .     .           .      .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .     .    .              .           .     .           .      .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2     0    0              2           2     0           0      0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2     0    0              2           0     0           0      0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2     0    0              2           0     0           0      0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4     0    0              2           2     0           0      0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4     0    0              2           0     0           0      0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4     0    0              2           0     0           0      0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4     0    0              2           2     0           0      0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .     .    .              .           .     .           .      .    .          os << "total_Watchers: " << total_Watchers << "\n";
             .     .    .              .           .     .           .      .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .     .    .              .           .     .           .      .    .          os << "total_indexs: " << total_indexs << "\n";
             .     .    .              .           .     .           .      .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .     .    .              .           .     .           .      .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .     .    .              .           .     .           .      .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .     .    .              .           .     .           .      .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .     .    .              .           .     .           .      .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .     .    .              .           .     .           .      .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .     .    .              .           .     .           .      .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .     .    .              .           .     .           .      .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .     .    .              .           .     .           .      .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .     .    .              .           .     .           .      .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .     .    .              .           .     .           .      .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .     .    .              .           .     .           .      .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .     .    .              .           .     .           .      .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6     0    0              4           0     0           0      0    0      }
             .     .    .              .           .     .           .      .    .      using ull=unsigned long long;
             .     .    .              .           .     .           .      .    .      ull total_Watchers = 0;
             .     .    .              .           .     .           .      .    .      ull total_act_watchers = 0;
             .     .    .              .           .     .           .      .    .      ull total_indexs = 0;
             .     .    .              .           .     .           .      .    .      ull time_find_conflict = 0;
             .     .    .              .           .     .           .      .    .      ull total_find_conflict_length = 0;
             .     .    .              .           .     .           .      .    .      ull total_find_conflict_allsize = 0;
             .     .    .              .           .     .           .      .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .              .           .     .           .      .    .      {
             .     .    .              .           .     .           .      .    .          const ClauseAllocator& ca;
             .     .    .              .           .     .           .      .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .     .    .              .           .     .           .      .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .     .    .              .           .     .           .      .    .      };
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .      struct VarOrderLt {
             .     .    .              .           .     .           .      .    .          const vec<double>&  activity;
 2,361,141,176 1,221   33  1,662,508,834 221,583,382 1,717  67,758,947      0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .     .    .              .           .     .           .      .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .     .    .              .           .     .           .      .    .      };
             .     .    .              .           .     .           .      .    .      
             .     .    .              .           .     .           .      .    .      struct ConflictData
             .     .    .              .           .     .           .      .    .  	{
             .     .    .              .           .     .           .      .    .  		ConflictData() :
             .     .    .              .           .     .           .      .    .  			nHighestLevel(-1),
             .     .    .              .           .     .           .      .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .     .    .              .           .     .           .      .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .     .    .              .           .     .           .      .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .     .    .              .           .     .           .      .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .     .    .              .           .     .           .      .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .     .    .              .           .     .           .      .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .     .    .              .           .     .           .      .    .      std::chrono::nanoseconds total_duration;
             .     .    .              .           .     .           .      .    .      CRef     propagate(){
             .     .    .              .           .     .           .      .    .  
     8,638,638 4,428   13              0           0     0   4,319,319      1    0          auto start_time=std::chrono::steady_clock::now();
    12,957,957     0    0              0           0     0   4,319,319      0    0          auto ref= propagate_();
     4,319,319     1    1              0           0     0   4,319,319      0    0          auto end_time=std::chrono::steady_clock::now();
             .     .    .              .           .     .           .      .    .          auto duration=end_time-start_time;
             .     .    .              .           .     .           .      .    .          total_duration+=duration;
             .     .    .              .           .     .           .      .    .          return ref;
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .      }
             .     .    .              .           .     .           .      .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .     .    .              .           .     .           .      .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .     .    .              .           .     .           .      .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .     .    .              .           .     .           .      .    .      
             .     .    .              .           .     .           .      .    .  public:
             .     .    .              .           .     .           .      .    .      int      level            (Var x) const;
             .     .    .              .           .     .           .      .    .  protected:
             .     .    .              .           .     .           .      .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .     .    .              .           .     .           .      .    .      bool     withinBudget     ()      const;
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .      template<class V> int computeLBD(const V& c) {
    86,842,039    41   18              0           0     0           0      0    0          int lbd = 0;
             .     .    .              .           .     .           .      .    .  
    11,714,462    42   18      9,887,594   2,580,932     0           0      0    0          counter++;
   412,876,436     0    0      1,829,408           0     0           0      0    0          for (int i = 0; i < c.size(); i++){
             .     .    .              .           .     .           .      .    .              int l = level(var(c[i]));
   967,061,347     0    0    386,824,346   8,148,659    10           0      0    0              if (l != 0 && seen2[l] != counter){
    71,835,033     0    0              0           0     0  71,835,033      0    0                  seen2[l] = counter;
   133,571,770     0    0              0           0     0           0      0    0                  lbd++; } }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .          return lbd;
             .     .    .              .           .     .           .      .    .      }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  #ifdef BIN_DRUP
             .     .    .              .           .     .           .      .    .      static int buf_len;
             .     .    .              .           .     .           .      .    .      static unsigned char drup_buf[];
             .     .    .              .           .     .           .      .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .     .    .              .           .     .           .      .    .      }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .      template<class V>
             .     .    .              .           .     .           .      .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .     .    .              .           .     .           .      .    .          assert(op == 'a' || op == 'd');
             .     .    .              .           .     .           .      .    .          *buf_ptr++ = op; buf_len++;
             .     .    .              .           .     .           .      .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .     .    .              .           .     .           .      .    .          *buf_ptr++ = 0; buf_len++;
       231,416    34   18              0           0     0     231,416      0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .     .    .              .           .     .           .      .    .      }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .     .    .              .           .     .           .      .    .          *buf_ptr++ = 'a'; buf_len++;
             .     .    .              .           .     .           .      .    .          for (int i = 0; i < c.size(); i++)
             .     .    .              .           .     .           .      .    .              if (c[i] != l) byteDRUP(c[i]);
             .     .    .              .           .     .           .      .    .          *buf_ptr++ = 0; buf_len++;
             .     .    .              .           .     .           .      .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .     .    .              .           .     .           .      .    .      double    my_var_decay;
             .     .    .              .           .     .           .      .    .      bool   DISTANCE;
             .     .    .              .           .     .           .      .    .  };
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  //=================================================================================================
             .     .    .              .           .     .           .      .    .  // Implementation of inline methods:
             .     .    .              .           .     .           .      .    .  
   377,243,215     0    0    377,243,215   8,379,218   431           0      0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
 2,786,022,041    46   17  2,321,722,910 333,657,977     1 457,980,483      0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  inline void Solver::insertVarOrder(Var x) {
             .     .    .              .           .     .           .      .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
 3,156,881,945   694   16    990,485,872   1,038,399     0           0      0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    25,476,318     1    1     16,984,212   5,648,042    90           0      0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  inline void Solver::varDecayActivity() {
     3,063,056     0    0      1,531,528     284,578     0     765,764      0    0      var_inc *= (1 / var_decay); }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  inline void Solver::varBumpActivity(Var v, double mult) {
 1,030,707,337     8    7    626,313,096  63,846,265   260 156,121,557      0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .     .    .              .           .     .           .      .    .          // Rescale:
         1,992    71   11              1           0     0           0      0    0          for (int i = 0; i < nVars(); i++)
     1,430,412     0    0        357,802      79,160   365     357,603      0    0              activity_VSIDS[i] *= 1e-100;
           398     0    0            199           0     0         199      0    0          var_inc *= 1e-100; }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .      // Update order_heap with respect to new activity:
   111,974,662     0    0              0           0     0           0      0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .     .    .              .           .     .           .      .    .  
     7,307,472 1,440    2      3,653,736       1,115     0   1,826,868      0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .     .    .              .           .     .           .      .    .  inline void Solver::claBumpActivity (Clause& c) {
    45,519,714   485   10     13,532,335   2,368,249     2   4,613,761 10,397    0      if ( (c.activity() += cla_inc) > 1e20 ) {
             .     .    .              .           .     .           .      .    .          // Rescale:
     2,422,641    39   15            117           0     0           0      0    0          for (int i = 0; i < learnts_local.size(); i++)
     5,652,101     5    0        807,443     736,345     2     807,443      0    0              ca[learnts_local[i]].activity() *= 1e-20;
       618,013   158    4        308,948           0     0          39     39    0          cla_inc *= 1e-20; } }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .     .    .              .           .     .           .      .    .  inline void Solver::checkGarbage(double gf){
        30,663    99    0         10,221         175     0           0      0    0      if (ca.wasted() > ca.size() * gf)
           483     1    1            242         242     5           1      0    0          garbageCollect(); }
             .     .    .              .           .     .           .      .    .  
             .     .    .              .           .     .           .      .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
            62     0    0              0           0     0           6      0    0  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .     .    .              .           .     .           .      .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .     .    .              .           .     .           .      .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .     .    .              .           .     .           .      .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .     .    .              .           .     .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .     .    .              .           .     .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .     .    .              .           .     .           .      .    .  inline bool     Solver::locked          (const Clause& c) const {
    24,069,745   121    6      7,973,820     188,964     0           0      0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    29,711,337   121    5      6,408,365     148,913     0           0      0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .     .    .              .           .     .           .      .    .  }
     4,969,198     1    1      2,484,593           0     0           0      0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .     .    .              .           .     .           .      .    .  
       234,070     2    2        123,926           0     0     110,144      0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
   989,735,098 1,518    5    126,393,433   7,075,764     0           0      0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
     8,545,115     1    1      8,545,099         450     0           0      0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
27,130,994,806    47   18 27,130,994,806      13,717     0           0      0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .     .    .              .           .     .           .      .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .     .    .              .           .     .           .      .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .     .    .              .           .     .           .      .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3     0    0              2           0     0           1      1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .     .    .              .           .     .           .      .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
       739,071     1    1         11,194          10     0           1      0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6     1    1              3           2     0           0      0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .     .    .              .           .     .           .      .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .     .    .              .           .     .           .      .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .     .    .              .           .     .           .      .    .  { 
        21,558     0    0         10,779          22     0           0      0    0      if      ( b && !decision[v]) dec_vars++;
           951     0    0            634         132     0           0      0    0      else if (!b &&  decision[v]) dec_vars--;
             .     .    .              .           .     .           .      .    .  
         3,910     0    0              0           0     0       3,910      0    0      decision[v] = b;
             .     .    .              .           .     .           .      .    .      if (b && !order_heap_CHB.inHeap(v)){
             .     .    .              .           .     .           .      .    .          order_heap_CHB.insert(v);
             .     .    .              .           .     .           .      .    .          order_heap_VSIDS.insert(v);
             .     .    .              .           .     .           .      .    .          order_heap_distance.insert(v);}
             .     .    .              .           .     .           .      .    .  }
             .     .    .              .           .     .           .      .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .     .    .              .           .     .           .      .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .     .    .              .           .     .           .      .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr          DLmr    Dw             D1mw       DLmw      

-- line 54 ----------------------------------------
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  struct Lit {
              .     .    .              .             .       .              .          .         .      int     x;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // Use this as a constructor:
              .     .    .              .             .       .              .          .         .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      bool operator == (Lit p) const { return x == p.x; }
    513,875,913     0    0    260,997,161   136,403,827     527              0          0         0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .             .       .              .          .         .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
        187,544     0    0              0             0       0            317          0         0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 19,761,661,570    31   17  8,750,541,124       115,728      14    895,077,252    431,599         0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .             .       .              .          .         .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 77,924,263,391    18   10  2,011,747,636             0       0  1,008,101,082 87,903,355         9  inline  bool sign      (Lit p)              { return p.x & 1; }
124,349,770,854 7,563   71  2,571,763,657    51,670,040     476 24,058,744,008          0         0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .             .       .              .          .         .  inline  int  toInt     (Var v)              { return v; } 
          3,890     1    1            243             0       0            244         11        11  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .             .       .              .          .         .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .             .       .              .          .         .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .             .       .              .          .         .  const Lit lit_Error = { -1 };  // }
              .     .    .              .             .       .              .          .         .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .     .    .              .             .       .              .          .         .  #define l_Undef (lbool((uint8_t)2))
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  class lbool {
              .     .    .              .             .       .              .          .         .      uint8_t value;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  public:
              .     .    .              .             .       .              .          .         .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .             .       .              .          .         .  
            916     1    1              0             0       0            233         55        55      lbool()       : value(0) { }
              .     .    .              .             .       .              .          .         .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .             .       .              .          .         .  
  4,611,436,830     1    1              0             0       0              0          0         0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
         10,779     0    0          7,186            57       0              0          0         0      bool  operator != (lbool b) const { return !(*this == b); }
 17,895,407,444    41   12 15,775,856,823   149,337,898      13              0          0         0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      lbool operator && (lbool b) const {
              .     .    .              .             .       .              .          .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .             .       .              .          .         .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .             .       .              .          .         .          return lbool(v); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      lbool operator || (lbool b) const {
              .     .    .              .             .       .              .          .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .             .       .              .          .         .          unsigned simplified : 1;}                            header;
              .     .    .              .             .       .              .          .         .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      friend class ClauseAllocator;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .             .       .              .          .         .      template<class V>
              .     .    .              .             .       .              .          .         .      Clause(const V& ps, bool use_extra, bool learnt) {
     40,628,267     0    0      9,700,353             0       0     11,527,207    105,126         1          header.mark      = 0;
     29,054,112     1    1      9,684,704       604,902  68,770              0          0         0          header.learnt    = learnt;
     58,217,767     3    3      9,716,002             2       0      9,700,353          0         0          header.has_extra = learnt | use_extra;
              .     .    .              .             .       .              .          .         .          header.reloced   = 0;
     13,369,708     0    0      1,842,502            96       0     11,527,206  1,734,705    43,023          header.size      = ps.size();
              .     .    .              .             .       .              .          .         .          header.lbd       = 0;
              .     .    .              .             .       .              .          .         .          header.removable = 1;
              .     .    .              .             .       .              .          .         .          //simplify
              .     .    .              .             .       .              .          .         .          //
     11,527,207     7    5     11,527,207     1,326,725 159,208              0          0         0          header.simplified = 0;
              .     .    .              .             .       .              .          .         .  
    424,445,163   168   33      1,894,101             0       0              0          0         0          for (int i = 0; i < ps.size(); i++)
    259,419,737   226   24     89,480,681    11,178,386   7,146    108,172,593 11,955,654 1,623,052              data[i].lit = ps[i];
              .     .    .              .             .       .              .          .         .  
     34,581,620    90   29     11,527,206             0       0              0          0         0          if (header.has_extra){
     20,358,674     0    0              0             0       0              0          0         0              if (header.learnt){
     20,304,794     2    2      8,325,519             0       0     10,152,397    635,185    79,693                  data[header.size].act = 0;
     20,304,818     0    0              0             0       0     10,152,397    634,857    79,632                  data[header.size+1].touched = 0;
              .     .    .              .             .       .              .          .         .              }else
              .     .    .              .             .       .              .          .         .                  calcAbstraction(); }
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  public:
              .     .    .              .             .       .              .          .         .      void calcAbstraction() {
              .     .    .              .             .       .              .          .         .          assert(header.has_extra);
         29,570     0    0              0             0       0              0          0         0          uint32_t abstraction = 0;
        431,728     5    4         12,604             0       0              0          0         0          for (int i = 0; i < size(); i++)
        633,659     3    2              0             0       0              1          0         0              abstraction |= 1 << (var(data[i].lit) & 31);
         89,796     0    0         11,291             0       0         40,275      1,720     1,720          data[header.size].abs = abstraction;  }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
 14,035,577,430   173   77  7,537,427,399 1,045,292,679   7,014  4,960,602,531         40         0      int          size        ()      const   { return header.size; }
      2,851,748    28   12        712,932       173,585       0        712,932     35,018         0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .             .       .              .          .         .      void         pop         ()              { shrink(1); }
    132,174,917     5    5      1,716,861             0       0              0          0         0      bool         learnt      ()      const   { return header.learnt; }
          9,022     0    0              0             0       0              0          0         0      bool         has_extra   ()      const   { return header.has_extra; }
    187,300,216   146   11     23,059,032    21,710,219   1,158     60,881,029          0         0      uint32_t     mark        ()      const   { return header.mark; }
     48,001,758   178   18     12,469,763        41,744       0     11,808,521          0         0      void         mark        (uint32_t m)    { header.mark = m; }
        222,768     0    0              0             0       0        111,384          0         0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .             .       .              .          .         .  
     29,172,595     0    0     29,172,595    23,138,819     729              0          0         0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .             .       .              .          .         .      CRef         relocation  ()      const   { return data[0].rel; }
     38,738,816    39   19      9,684,704             0       0     19,369,408          0         0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .             .       .              .          .         .  
     18,684,989     0    0      6,214,989             0       0              0          0         0      int          lbd         ()      const   { return header.lbd; }
     68,345,854   164   23     18,964,750             0       0     10,640,313          0         0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .             .       .              .          .         .      bool         removable   ()      const   { return header.removable; }
     52,022,115     3    3     18,719,943             0       0      8,325,543          0         0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .             .       .              .          .         .      //       subsumption operations to behave correctly.
 15,415,581,857   145   39 14,586,898,353 1,158,097,255  18,984              0          0         0      Lit&         operator [] (int i)         { return data[i].lit; }
    204,099,209   327   34    187,047,065     5,757,819   2,021              0          0         0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .             .       .              .          .         .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .             .       .              .          .         .  
      8,637,294     0    0      8,637,294            11       0              0          0         0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
      7,661,978     0    0      2,303,716       620,247       0              0          0         0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .             .       .              .          .         .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .             .       .              .          .         .      void         strengthen  (Lit p);
              .     .    .              .             .       .              .          .         .      // simplify
              .     .    .              .             .       .              .          .         .      //
     58,867,421     0    0     16,945,396             0       0      8,325,543          0         0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .             .       .              .          .         .      bool simplified() { return header.simplified; }
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  //=================================================================================================
              .     .    .              .             .       .              .          .         .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .             .       .              .          .         .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      static int clauseWord32Size(int size, int extras){
     22,917,506     3    2     11,390,276       562,233     943              0          0         0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .             .       .              .          .         .  public:
              .     .    .              .             .       .              .          .         .      bool extra_clause_field;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0             0       0              1          0         0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void moveTo(ClauseAllocator& to){
            244    34    8            122             1       0            122          0         0          to.extra_clause_field = extra_clause_field;
              .     .    .              .             .       .              .          .         .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      template<class Lits>
              .     .    .              .             .       .              .          .         .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .             .       .              .          .         .          assert(sizeof(float)    == sizeof(uint32_t));
     20,744,217   196   16      1,374,809           208       0              0          0         0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .             .       .              .          .         .  
      1,858,150     0    0              0             0       0         15,648          0         0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .             .       .              .          .         .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .          return cid;
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
     76,126,246   121    8     69,570,329        34,605       0         23,754          0         0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
         10,520     2    2          5,260             0       0              0          0         0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
      9,684,704     0    0      9,684,704             0       0              0          0         0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .          .         .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .          .         .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void free(CRef cid)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .          Clause& c = operator[](cid);
      5,125,732     8    1              0             0       0              0          0         0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .             .       .              .          .         .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
     21,511,273   121   19              0             0       0     18,438,234        241         0      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .          Clause& c = operator[](cr);
              .     .    .              .             .       .              .          .         .          
    104,014,561     0    0     19,487,891     3,245,849       0     19,487,891          0         0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .             .       .              .          .         .          
      9,684,705     0    0              1             0       0      9,684,704          0         0          cr = to.alloc(c, c.learnt());
              .     .    .              .             .       .              .          .         .          c.relocate(cr);
              .     .    .              .             .       .              .          .         .          
              .     .    .              .             .       .              .          .         .          // Copy extra data-fields:
              .     .    .              .             .       .              .          .         .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .             .       .              .          .         .          to[cr].mark(c.mark());
     19,369,408     2    2              0             0       0              0          0         0          if (to[cr].learnt()){
     33,302,172     0    0      8,325,543       470,697     447      8,325,543          0         0              to[cr].touched() = c.touched();
     33,302,148     0    0     16,651,086       472,695     459      8,325,543          0         0              to[cr].activity() = c.activity();
              .     .    .              .             .       .              .          .         .              to[cr].set_lbd(c.lbd());
              .     .    .              .             .       .              .          .         .              to[cr].removable(c.removable());
              .     .    .              .             .       .              .          .         .              // simplify
              .     .    .              .             .       .              .          .         .              //
              .     .    .              .             .       .              .          .         .              to[cr].setSimplified(c.simplified());
              .     .    .              .             .       .              .          .         .          }
      2,718,322   244   16              0             0       0              0          0         0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     24,584,312     0    0     21,511,273             0       0              0          0         0      }
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .             .       .              .          .         .  class OccLists
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      vec<Vec>  occs;
              .     .    .              .             .       .              .          .         .      vec<char> dirty;
              .     .    .              .             .       .              .          .         .      vec<Idx>  dirties;
              .     .    .              .             .       .              .          .         .      Deleted   deleted;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  public:
              3     0    0              0             0       0              3          0         0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .             .       .              .          .         .      unsigned int size(){
              .     .    .              .             .       .              .          .         .          auto m_size=0;
             40     2    2              4             3       0              0          0         0          for(int i=0;i<occs.size();i++){
         79,120    14   14         28,748         7,187       1              0          0         0              m_size+=occs[i].size();
              .     .    .              .             .       .              .          .         .          }
              .     .    .              .             .       .              .          .         .          
              .     .    .              .             .       .              .          .         .          return m_size;
              .     .    .              .             .       .              .          .         .      }
         39,523     1    1              0             0       0          7,186          0         0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .             .       .              .          .         .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
    508,931,140    31    3    508,931,140     1,674,813       0              0          0         0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
         65,442     1    1         33,257         3,045       0          3,232          1         0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void  cleanAll  ();
              .     .    .              .             .       .              .          .         .      void  clean     (const Idx& idx);
              .     .    .              .             .       .              .          .         .      void  smudge    (const Idx& idx){
     10,260,520     0    0      6,835,828        83,393     511              0          0         0          if (dirty[toInt(idx)] == 0){
        166,167   135    9              0             0       0        166,167          0         0              dirty[toInt(idx)] = 1;
             48     1    1              0             0       0              0          0         0              dirties.push(idx);
              .     .    .              .             .       .              .          .         .          }
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void  clear(bool free = true){
              .     .    .              .             .       .              .          .         .          occs   .clear(free);
              .     .    .              .             .       .              .          .         .          dirty  .clear(free);
              .     .    .              .             .       .              .          .         .          dirties.clear(free);
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  template<class Idx, class Vec, class Deleted>
            732     0    0              0             0       0            549          2         0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .             .       .              .          .         .  {
     70,522,115 1,445    5     35,093,418        36,908       3              0          0         0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .             .       .              .          .         .          // Dirties may contain duplicates so check here if a variable is already cleaned:
        498,501     0    0        332,334       129,390       0              0          0         0          if (dirty[toInt(dirties[i])])
              .     .    .              .             .       .              .          .         .              clean(dirties[i]);
              .     .    .              .             .       .              .          .         .      dirties.clear();
            732     0    0            732           253       0              0          0         0  }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  template<class Idx, class Vec, class Deleted>
              .     .    .              .             .       .              .          .         .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      Vec& vec = occs[toInt(idx)];
              .     .    .              .             .       .              .          .         .      int  i, j;
     59,808,146     2    2        650,987       167,874       0              0          0         0      for (i = j = 0; i < vec.size(); i++)
     36,607,894     0    0         50,086         3,445       0              0          0         0          if (!deleted(vec[i]))
    103,612,395     2    2     29,650,995            14       0     14,838,987     87,356         0              vec[j++] = vec[i];
        164,985   136    7              0             0       0              0          0         0      vec.shrink(i - j);
        667,427     1    1        332,334        16,299       0        166,681      8,195         0      dirty[toInt(idx)] = 0;
              .     .    .              .             .       .              .          .         .  }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  //=================================================================================================
              .     .    .              .             .       .              .          .         .  // CMap -- a class for mapping clauses to values:
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .             .       .              .          .         .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .             .       .              .          .         .  |________________________________________________________________________________________________@*/
              .     .    .              .             .       .              .          .         .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .             .       .              .          .         .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .             .       .              .          .         .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .             .       .              .          .         .      assert(header.has_extra); assert(other.header.has_extra);
      1,431,951     0    0        477,317         7,133       0              0          0         0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .             .       .              .          .         .          return lit_Error;
              .     .    .              .             .       .              .          .         .  
         51,554     0    0              0             0       0              0          0         0      Lit        ret = lit_Undef;
              .     .    .              .             .       .              .          .         .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .             .       .              .          .         .      const Lit* d   = (const Lit*)other;
              .     .    .              .             .       .              .          .         .  
        472,294     1    1         93,126             0       0              0          0         0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .             .       .              .          .         .          // search for c[i] or ~c[i]
      1,216,698     2    2         51,554             0       0         51,554          0         0          for (unsigned j = 0; j < other.header.size; j++)
      1,612,341     0    0        342,081             0       0              0          0         0              if (c[i] == d[j])
              .     .    .              .             .       .              .          .         .                  goto ok;
        220,478     0    0              0             0       0              0          0         0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .             .       .              .          .         .                  ret = c[i];
              .     .    .              .             .       .              .          .         .                  goto ok;
              .     .    .              .             .       .              .          .         .              }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .          // did not find it
              .     .    .              .             .       .              .          .         .          return lit_Error;
              .     .    .              .             .       .              .          .         .  ok:;
              .     .    .              .             .       .              .          .         .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr            D1mr      DLmr   Dw         D1mw DLmw 

-- line 40 ----------------------------------------
             .     .    .             .         .      .          .    .    .      void capacity(uint32_t min_cap);
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .   public:
             .     .    .             .         .      .          .    .    .      // TODO: make this a class for better type-checking?
             .     .    .             .         .      .          .    .    .      typedef uint32_t Ref;
             .     .    .             .         .      .          .    .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .             .         .      .          .    .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .             .         .      .          .    .    .  
           616     1    1             0         0      0        492    0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .             .         .      .          .    .    .      ~RegionAllocator()
             .     .    .             .         .      .          .    .    .      {
             .     .    .             .         .      .          .    .    .          if (memory != NULL)
             .     .    .             .         .      .          .    .    .              ::free(memory);
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      uint32_t size      () const      { return sz; }
             .     .    .             .         .      .          .    .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      Ref      alloc     (int size); 
     5,116,712     0    0     1,705,570         0      0  1,705,570    0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
17,985,395,067   426   49 9,008,548,223 3,849,413 59,516    314,458    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    18,221,142     0    0    18,221,142 2,408,609  3,563          0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .             .         .      .          .    .    .  
    36,408,475 5,951   14     1,842,503         0      0          0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     3,324,402     0    0             0         0      0          0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .             .         .      .          .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .             .         .      .          .    .    .          return  (Ref)(t - &memory[0]); }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      void     moveTo(RegionAllocator& to) {
           488     0    0           122         0      0        122    0    0          if (to.memory != NULL) ::free(to.memory);
           244     0    0           122         0      0        122    0    0          to.memory = memory;
           244     0    0           122         0      0        122    0    0          to.sz = sz;
             .     .    .             .         .      .          .    .    .          to.cap = cap;
           244     0    0           122         0      0        122    0    0          to.wasted_ = wasted_;
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .          memory = NULL;
             .     .    .             .         .      .          .    .    .          sz = cap = wasted_ = 0;
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  };
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  template<class T>
         1,326    67   12             0         0      0        442  121    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .             .         .      .          .    .    .  {
    34,581,990     1    0    11,527,330         0      0          0    0    0      if (cap >= min_cap) return;
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      uint32_t prev_cap = cap;
         7,273     0    0             0         0      0        221    0    0      while (cap < min_cap){
             .     .    .             .         .      .          .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .             .         .      .          .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .             .         .      .          .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .             .         .      .          .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        21,156     0    0             0         0      0          0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         3,526     0    0             0         0      0          0    0    0          cap += delta;
             .     .    .             .         .      .          .    .    .  
         7,052     0    0             0         0      0          0    0    0          if (cap <= prev_cap)
             .     .    .             .         .      .          .    .    .              throw OutOfMemoryException();
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      assert(cap > 0);
           442     2    1             0         0      0        221   98    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
           884     0    0           663         0      0          0    0    0  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  template<class T>
             .     .    .             .         .      .          .    .    .  typename RegionAllocator<T>::Ref
        62,592     2    1             0         0      0     46,944    0    0  RegionAllocator<T>::alloc(int size)
             .     .    .             .         .      .          .    .    .  { 
             .     .    .             .         .      .          .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .             .         .      .          .    .    .      assert(size > 0);
    63,620,085     0    0    11,527,207 1,115,222      0 30,880,942  161    0      capacity(sz + size);
             .     .    .             .         .      .          .    .    .  
    36,361,509     0    0    21,196,239         0      0          0    0    0      uint32_t prev_sz = sz;
    11,527,207     2    1             0         0      0 11,527,207    0    0      sz += size;
             .     .    .             .         .      .          .    .    .      
             .     .    .             .         .      .          .    .    .      // Handle overflow:
    52,108,522   133   24     9,684,703         0      0          0    0    0      if (sz < prev_sz)
             2     1    1             1         1      0          0    0    0          throw OutOfMemoryException();
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      return prev_sz;
        62,592     0    0        62,592         0      0          0    0    0  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  //=================================================================================================
             .     .    .             .         .      .          .    .    .  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr             D1mr          DLmr    Dw             D1mw        DLmw  

-- line 51 ----------------------------------------
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  //=================================================================================================
             .       .    .              .             .       .              .           .     .  // Options:
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  static const char* _cat = "CORE";
             .       .    .              .             .       .              .           .     .  
             4       0    0              0             0       0              1           0     0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0     0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0     0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
             4       1    1              0             0       0              1           0     0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0     0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0     0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
             4       0    0              0             0       0              1           0     0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
             4       0    0              0             0       0              1           0     0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
             4       0    0              0             0       0              1           0     0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
             4       1    1              0             0       0              1           0     0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
             4       0    0              0             0       0              1           0     0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
             4       1    1              0             0       0              1           0     0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
             4       1    1              0             0       0              1           0     0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
             4       1    1              0             0       0              1           0     0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
             4       1    1              0             0       0              1           0     0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
             .       .    .              .             .       .              .           .     .  
             4       1    1              0             0       0              1           0     0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
             1       1    1              0             0       0              1           0     0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
             4       0    0              0             0       0              1           0     0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
             .       .    .              .             .       .              .           .     .  
             4       1    1              0             0       0              1           0     0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  //VSIDS_props_limit
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  //=================================================================================================
             .       .    .              .             .       .              .           .     .  // Constructor/Destructor:
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             4       1    1              0             0       0              2           0     0  Solver::Solver() :
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Parameters (user settable):
             .       .    .              .             .       .              .           .     .      //
             .       .    .              .             .       .              .           .     .      drup_file        (NULL)
             .       .    .              .             .       .              .           .     .    , verbosity        (0)
             .       .    .              .             .       .              .           .     .    , step_size        (opt_step_size)
             .       .    .              .             .       .              .           .     .    , step_size_dec    (opt_step_size_dec)
             .       .    .              .             .       .              .           .     .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
             .       .    .              .             .       .              .           .     .    , garbage_frac     (opt_garbage_frac)
             .       .    .              .             .       .              .           .     .    , restart_first    (opt_restart_first)
             .       .    .              .             .       .              .           .     .    , restart_inc      (opt_restart_inc)
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .    , min_number_of_learnts_copies(opt_min_dupl_app)  
             .       .    .              .             .       .              .           .     .    , max_lbd_dup(opt_max_lbd_dup)
             .       .    .              .             .       .              .           .     .    , dupl_db_init_size(opt_dupl_db_init_size)
             3       1    1              1             0       0              1           0     0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .    // Parameters (the rest):
             .       .    .              .             .       .              .           .     .    //
             .       .    .              .             .       .              .           .     .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .    // Parameters (experimental):
             .       .    .              .             .       .              .           .     .    //
             .       .    .              .             .       .              .           .     .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
             .       .    .              .             .       .              .           .     .    //
             .       .    .              .             .       .              .           .     .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
             .       .    .              .             .       .              .           .     .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
             .       .    .              .             .       .              .           .     .    , chrono_backtrack(0), non_chrono_backtrack(0)
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .    , ok                 (true)
             .       .    .              .             .       .              .           .     .    , cla_inc            (1)
             .       .    .              .             .       .              .           .     .    , var_inc            (1)
             1       0    0              0             0       0              0           0     0    , watches_bin        (WatcherDeleted(ca))
             .       .    .              .             .       .              .           .     .    , watches            (WatcherDeleted(ca))
             .       .    .              .             .       .              .           .     .    , qhead              (0)
             .       .    .              .             .       .              .           .     .    , simpDB_assigns     (-1)
             .       .    .              .             .       .              .           .     .    , simpDB_props       (0)
             .       .    .              .             .       .              .           .     .    , order_heap_CHB     (VarOrderLt(activity_CHB))
             .       .    .              .             .       .              .           .     .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
             .       .    .              .             .       .              .           .     .    , progress_estimate  (0)
             .       .    .              .             .       .              .           .     .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
             .       .    .              .             .       .              .           .     .    // simplifyAll adjust occasion
             .       .    .              .             .       .              .           .     .    , curSimplify(1)
             .       .    .              .             .       .              .           .     .    , nbconfbeforesimplify(1000)
             .       .    .              .             .       .              .           .     .    , incSimplify(1000)
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .    , my_var_decay       (0.6)
             .       .    .              .             .       .              .           .     .    , DISTANCE           (true)
             .       .    .              .             .       .              .           .     .    , var_iLevel_inc     (1)
            94       8    8             25             2       2             63           1     0    , order_heap_distance(VarOrderLt(activity_distance))
             .       .    .              .             .       .              .           .     .  
             4       0    0              3             0       0              0           0     0  {}
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  Solver::~Solver()
             .       .    .              .             .       .              .           .     .  {
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  // simplify All
             .       .    .              .             .       .              .           .     .  //
             .       .    .              .             .       .              .           .     .  CRef Solver::simplePropagate()
    35,631,304       5    3              0             0       0     26,723,478      14,945     0  {
     4,453,913       0    0              0             0       0      4,453,913           0     0      CRef    confl = CRef_Undef;
     4,453,913       0    0              0             0       0      4,453,913           0     0      int     num_props = 0;
     8,907,826       0    0              0             0       0      4,453,913      13,996     0      watches.cleanAll();
    13,361,739      41   17      4,453,913             0       0      4,453,913           0     0      watches_bin.cleanAll();
   106,042,288       0    0     53,021,144             0       0              0           0     0      while (qhead < trail.size())
             .       .    .              .             .       .              .           .     .      {
   242,894,615       3    2     97,157,846     2,121,297       0     97,157,846           0     0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .       .    .              .             .       .              .           .     .          vec<Watcher>&  ws = watches[p];
             .       .    .              .             .       .              .           .     .          Watcher        *i, *j, *end;
    48,567,231       0    0     48,567,231           649       0              0           0     0          num_props++;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          // First, Propagate binary clauses
             .       .    .              .             .       .              .           .     .          vec<Watcher>&  wbin = watches_bin[p];
             .       .    .              .             .       .              .           .     .  
   349,486,477       0    0     48,578,923    46,737,754      16              0           0     0          for (int k = 0; k<wbin.size(); k++)
             .       .    .              .             .       .              .           .     .          {
             .       .    .              .             .       .              .           .     .  
   100,942,180       0    0     76,663,898    27,989,442      33              0           0     0              Lit imp = wbin[k].blocker;
             .       .    .              .             .       .              .           .     .  
   100,942,180       0    0              0             0       0              0           0     0              if (value(imp) == l_False)
             .       .    .              .             .       .              .           .     .              {
        23,384       0    0         11,692             0       0         11,692           0     0                  return wbin[k].cref;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
   100,918,796       7    6              0             0       0              0           0     0              if (value(imp) == l_Undef)
             .       .    .              .             .       .              .           .     .              {
    20,744,865       0    0     20,744,865             0       0              0           0     0                  simpleUncheckEnqueue(imp, wbin[k].cref);
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
 6,565,920,904      34   14  3,137,757,904    36,537,454       7     95,067,679           0     0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
             .       .    .              .             .       .              .           .     .          {
             .       .    .              .             .       .              .           .     .              // Try to avoid inspecting the clause:
 3,040,623,442      31   10  3,040,623,442   408,908,392     515              0           0     0              Lit blocker = i->blocker;
 6,081,246,884       0    0  3,040,623,442    41,776,823       0              0           0     0              if (value(blocker) == l_True)
             .       .    .              .             .       .              .           .     .              {
             .       .    .              .             .       .              .           .     .                  *j++ = *i++; continue;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Make sure the false literal is data[1]:
 4,344,888,018       0    0  2,172,444,009             0       0              0           0     0              CRef     cr = i->cref;
             .       .    .              .             .       .              .           .     .              Clause&  c = ca[cr];
             .       .    .              .             .       .              .           .     .              Lit      false_lit = ~p;
 6,517,332,027       0    0  2,172,444,009 2,095,894,323      32              0           0     0              if (c[0] == false_lit)
 2,484,309,942       0    0    828,103,314    49,277,208       1  1,656,206,628           0     0                  c[0] = c[1], c[1] = false_lit;
             .       .    .              .             .       .              .           .     .              assert(c[1] == false_lit);
             .       .    .              .             .       .              .           .     .              //  i++;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // If 0th watch is true, then clause is already satisfied.
             .       .    .              .             .       .              .           .     .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
             .       .    .              .             .       .              .           .     .              // why not simply do i->blocker=first in this case?
             .       .    .              .             .       .              .           .     .              Lit     first = c[0];
             .       .    .              .             .       .              .           .     .              //  Watcher w     = Watcher(cr, first);
 5,502,578,976       0    0    578,845,479     6,623,721       0              0           0     0              if (first != blocker && value(first) == l_True)
             .       .    .              .             .       .              .           .     .              {
   146,331,191       0    0              0             0       0    146,331,191           0     0                  i->blocker = first;
 4,058,042,496       0    0  1,014,510,624             0       0  1,014,510,624   9,333,062     0                  *j++ = *i++; continue;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Look for new watch:
             .       .    .              .             .       .              .           .     .              //if (incremental)
             .       .    .              .             .       .              .           .     .              //{ // ----------------- INCREMENTAL MODE
             .       .    .              .             .       .              .           .     .              //	int choosenPos = -1;
             .       .    .              .             .       .              .           .     .              //	for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .     .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
             .       .    .              .             .       .              .           .     .              //		Watcher w = Watcher(cr, first); i++;
             .       .    .              .             .       .              .           .     .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
             .       .    .              .             .       .              .           .     .              //		watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .     .              //		goto NextClause;
             .       .    .              .             .       .              .           .     .              //	}
             .       .    .              .             .       .              .           .     .              //}
             .       .    .              .             .       .              .           .     .              else
             .       .    .              .             .       .              .           .     .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
 6,482,710,109      41   17              0             0       0              0           0     0                  for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .     .                  {
             .       .    .              .             .       .              .           .     .  
12,144,425,601       0    0              0             0       0              0           0     0                      if (value(c[k]) != l_False)
             .       .    .              .             .       .              .           .     .                      {
             .       .    .              .             .       .              .           .     .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
             .       .    .              .             .       .              .           .     .                          // the blocker is first in the watcher. However,
             .       .    .              .             .       .              .           .     .                          // the blocker in the corresponding watcher in ~first is not c[1]
             .       .    .              .             .       .              .           .     .                          Watcher w = Watcher(cr, first); i++;
 8,000,142,468       0    0  2,000,035,617             0       0  4,000,071,234           0     0                          c[1] = c[k]; c[k] = false_lit;
             .       .    .              .             .       .              .           .     .                          watches[~c[1]].push(w);
 2,000,035,617       0    0              0             0       0              0           0     0                          goto NextClause;
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Did not find watch -- clause is unit under assignment:
    26,077,201       0    0              0             0       0     26,077,201           0     0              i->blocker = first;
   104,308,804       1    0     26,077,201             0       0     26,077,201     130,899     0              *j++ = *i++;
    52,154,402      41   18              0             0       0              0           0     0              if (value(first) == l_False)
             .       .    .              .             .       .              .           .     .              {
       962,892       5    2              0             0       0        147,106           3     0                  confl = cr;
       294,212      37   14        147,106         4,041       0        147,106           0     0                  qhead = trail.size();
             .       .    .              .             .       .              .           .     .                  // Copy the remaining watches:
    24,100,784       4    2        280,842         1,092       0              0           0     0                  while (i < end)
    11,622,444       0    0     11,622,444     1,445,075       0     11,622,444      74,580     0                      *j++ = *i++;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              else
             .       .    .              .             .       .              .           .     .              {
             .       .    .              .             .       .              .           .     .                  simpleUncheckEnqueue(first, cr);
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  NextClause:;
             .       .    .              .             .       .              .           .     .          }
    93,000,896      41   13              0             0       0              0           0     0          ws.shrink(i - j);
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
     8,884,442       0    0      8,884,442     2,004,326       0              0           0     0      s_propagations += num_props;
             .       .    .              .             .       .              .           .     .  
     4,442,221       0    0      4,442,221             0       0              0           0     0      return confl;
 1,534,937,493      44   12     31,177,391     1,991,828       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
             .       .    .              .             .       .              .           .     .      assert(value(p) == l_Undef);
    46,674,960       0    0              0             0       0     46,674,960           0     0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
   102,257,746      41   15     51,128,873       760,034       0     51,128,873  41,497,332    28      vardata[var(p)].reason = from;
    30,384,008       0    0     30,384,008             0       0              0           0     0      trail.push_(p);
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::cancelUntilTrailRecord()
             .       .    .              .             .       .              .           .     .  {
   103,614,946       0    0        542,880             0       0              0           0     0      for (int c = trail.size() - 1; c >= trailRecord; c--)
             .       .    .              .             .       .              .           .     .      {
       271,440      41   11        271,440             0       0              0           0     0          Var x = var(trail[c]);
    51,943,193       0    0        271,440             4       0     51,128,873   1,314,109     0          assigns[x] = l_Undef;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      }
       271,440       0    0              0             0       0        271,440           0     0      qhead = trailRecord;
       542,880       0    0              0             0       0              0           0     0      trail.shrink(trail.size() - trailRecord);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::litsEnqueue(int cutP, Clause& c)
             .       .    .              .             .       .              .           .     .  {
             .       .    .              .             .       .              .           .     .      for (int i = cutP; i < c.size(); i++)
             .       .    .              .             .       .              .           .     .      {
             .       .    .              .             .       .              .           .     .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  bool Solver::removed(CRef cr) {
             .       .    .              .             .       .              .           .     .      return ca[cr].mark() == 1;
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
     2,972,002      37   14              0             0       0      1,621,092           0     0  {
       270,182       0    0              0             0       0              0           0     0      int pathC = 0;
       270,182       0    0              0             0       0              0           0     0      Lit p = lit_Undef;
       810,546       0    0        270,182             0       0              0           0     0      int index = trail.size() - 1;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      do{
    24,110,080      41   17              0             0       0              0           0     0          if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .     .              reason_clause.push(confl);
             .       .    .              .             .       .              .           .     .              Clause& c = ca[confl];
             .       .    .              .             .       .              .           .     .              // Special case for binary clauses
             .       .    .              .             .       .              .           .     .              // The first one has to be SAT
    36,680,454      42    9              0             0       0              0           0     0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                  assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .     .                  Lit tmp = c[0];
     1,339,158       0    0        446,386        26,189       0        892,772           0     0                  c[0] = c[1], c[1] = tmp;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              // if True_confl==true, then choose p begin with the 1th index of c;
    71,789,685       0    0     15,511,015       263,679       0              0           0     0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
             .       .    .              .             .       .              .           .     .                  Lit q = c[j];
    40,041,852       0    0     20,020,926     2,157,412       0              0           0     0                  if (!seen[var(q)]){
    11,784,884       0    0              0             0       0     11,784,884           0     0                      seen[var(q)] = 1;
    35,354,652       0    0     11,784,884             0       0              0           0     0                      pathC++;
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          else if (confl == CRef_Undef){
             .       .    .              .             .       .              .           .     .              out_learnt.push(~p);
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
    38,895,290      41   16     11,784,883             0       0              0           0     0          if (pathC == 0) break;
             .       .    .              .             .       .              .           .     .          // Select next clause to look at:
   339,604,088       0    0    113,201,371     7,350,869       0              0           0     0          while (!seen[var(trail[index--])]);
             .       .    .              .             .       .              .           .     .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
             .       .    .              .             .       .              .           .     .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
    23,569,766       0    0     11,784,883             0       0              0           0     0          if (trailRecord > index + 1) break;
             .       .    .              .             .       .              .           .     .          p = trail[index + 1];
             .       .    .              .             .       .              .           .     .          confl = reason(var(p));
    11,784,858       0    0              0             0       0     11,784,858           0     0          seen[var(p)] = 0;
    11,784,858       0    0              0             0       0              0           0     0          pathC--;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      } while (pathC >= 0);
     2,701,820      41   12      1,891,274        10,536       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::simplifyLearnt(Clause& c)
     2,442,960      82   23              0             0       0      1,628,640         434     0  {
             .       .    .              .             .       .              .           .     .      ////
       271,440       0    0        271,440        21,936       0              0           0     0      original_length_record += c.size();
             .       .    .              .             .       .              .           .     .  
       542,880       0    0        271,440        16,431       0        271,440           0     0      trailRecord = trail.size();// record the start pointer
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      vec<Lit> falseLit;
             .       .    .              .             .       .              .           .     .      falseLit.clear();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
             .       .    .              .             .       .              .           .     .  
       317,596      38   13              0             0       0              0           0     0      bool True_confl = false;
             .       .    .              .             .       .              .           .     .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .     .      beforeSize = c.size();
             .       .    .              .             .       .              .           .     .      int i, j;
             .       .    .              .             .       .              .           .     .      CRef confl;
             .       .    .              .             .       .              .           .     .  
    15,549,738      41   14              0             0       0              0           0     0      for (i = 0, j = 0; i < c.size(); i++){
     9,821,096       0    0              0             0       0              0           0     0          if (value(c[i]) == l_Undef){
             .       .    .              .             .       .              .           .     .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
             .       .    .              .             .       .              .           .     .              simpleUncheckEnqueue(~c[i]);
    17,656,854       0    0      4,453,913             0       0      4,453,913      38,088     0              c[j++] = c[i];
    13,361,739       0    0              0             0       0      4,453,913           0     0              confl = simplePropagate();
    13,361,739      41   14      4,453,913     1,986,508       0              0           0     0              if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .     .                  break;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          else{
       913,270       0    0              0             0       0              0           0     0              if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
       445,536      31    9        111,384             0       0        111,384       2,176     0                  c[j++] = c[i];
       111,384      23    9              0             0       0              0           0     0                  True_confl = true;
             .       .    .              .             .       .              .           .     .                  confl = reason(var(c[i]));
             .       .    .              .             .       .              .           .     .                  break;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              else{
             .       .    .              .             .       .              .           .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
             .       .    .              .             .       .              .           .     .                  falseLit.push(c[i]);
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .      c.shrink(c.size() - j);
             .       .    .              .             .       .              .           .     .      afterSize = c.size();
             .       .    .              .             .       .              .           .     .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      if (confl != CRef_Undef || True_confl == true){
       270,182       0    0              0             0       0              0           0     0          simp_learnt_clause.clear();
       270,182       0    0              0             0       0              0           0     0          simp_reason_clause.clear();
       540,364       0    0              0             0       0              0           0     0          if (True_confl == true){
             .       .    .              .             .       .              .           .     .              simp_learnt_clause.push(c.last());
             .       .    .              .             .       .              .           .     .          }
     1,891,274      18    6              0             0       0        270,182           0     0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
             .       .    .              .             .       .              .           .     .  
       810,546       0    0        270,182             0       0              0           0     0          if (simp_learnt_clause.size() < c.size()){
     3,337,218      41   13      1,501,545             0       0              0           0     0              for (i = 0; i < simp_learnt_clause.size(); i++){
     5,672,052       0    0      1,418,013           206       0      1,418,013      47,426     0                  c[i] = simp_learnt_clause[i];
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              c.shrink(c.size() - i);
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      cancelUntilTrailRecord();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      ////
       271,440       0    0        271,440             0       0              0           0     0      simplified_length_record += c.size();
             .       .    .              .             .       .              .           .     .  
     2,171,520       0    0      1,900,080       264,619       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
             .       .    .              .             .       .              .           .     .  {
             .       .    .              .             .       .              .           .     .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .     .      int learnts_x_size_before = learnts_x.size();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .     .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .     .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      return true;
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  bool Solver::simplifyLearnt_core()
           451       0    0              0             0       0            246           0     0  {
             .       .    .              .             .       .              .           .     .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .     .      int learnts_core_size_before = learnts_core.size();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .     .      bool sat, false_lit;
             .       .    .              .             .       .              .           .     .      unsigned int nblevels;
             .       .    .              .             .       .              .           .     .      ////
             .       .    .              .             .       .              .           .     .      //printf("learnts_x size : %d\n", learnts_x.size());
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      ////
             .       .    .              .             .       .              .           .     .      int nbSimplified = 0;
             .       .    .              .             .       .              .           .     .      int nbSimplifing = 0;
             .       .    .              .             .       .              .           .     .  
     2,855,074      41   14             41             0       0              0           0     0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     4,282,377      41   16      2,854,918        89,252     112              0           0     0          CRef cr = learnts_core[ci];
             .       .    .              .             .       .              .           .     .          Clause& c = ca[cr];
             .       .    .              .             .       .              .           .     .  
     2,854,918       0    0              0             0       0              0           0     0          if (removed(cr)) continue;
     2,854,918       0    0      1,427,459       174,090       9              0           0     0          else if (c.simplified()){
     2,774,868       0    0              0             0       0      1,387,434           0     0              learnts_core[cj++] = learnts_core[ci];
             .       .    .              .             .       .              .           .     .              ////
     4,162,308       0    0      1,387,434             0       0              0           0     0              nbSimplified++;
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          else{
             .       .    .              .             .       .              .           .     .              int saved_size=c.size();
             .       .    .              .             .       .              .           .     .              //         if (drup_file){
             .       .    .              .             .       .              .           .     .              //                 add_oc.clear();
             .       .    .              .             .       .              .           .     .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .       .    .              .             .       .              .           .     .              ////
             .       .    .              .             .       .              .           .     .              nbSimplifing++;
        40,024       0    0              0             0       0              0           0     0              sat = false_lit = false;
       956,558       0    0              0             0       0              0           0     0              for (int i = 0; i < c.size(); i++){
       956,558       0    0              0             0       0              0           0     0                  if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .     .                      sat = true;
             .       .    .              .             .       .              .           .     .                      break;
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .                  else if (value(c[i]) == l_False){
     1,036,604      41   13              0             0       0         40,024          40     0                      false_lit = true;
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              if (sat){
             7       1    0              2             0       0              2           0     0                  removeClause(cr);
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              else{
       240,144       0    0              0             0       0        120,072           0     0                  detachClause(cr, true);
             .       .    .              .             .       .              .           .     .  
       160,096      41   11         80,048           346       0              0           0     0                  if (false_lit){
           145       0    0             18             0       0              0           0     0                      for (li = lj = 0; li < c.size(); li++){
            64       0    0              0             0       0              0           0     0                          if (value(c[li]) != l_False){
            69       0    0              0             0       0             23           0     0                              c[lj++] = c[li];
             .       .    .              .             .       .              .           .     .                          }
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                      c.shrink(li - lj);
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                  beforeSize = c.size();
             .       .    .              .             .       .              .           .     .                  assert(c.size() > 1);
             .       .    .              .             .       .              .           .     .                  // simplify a learnt clause c
       160,096       0    0              0             0       0         80,048           0     0                  simplifyLearnt(c);
             .       .    .              .             .       .              .           .     .                  assert(c.size() > 0);
             .       .    .              .             .       .              .           .     .                  afterSize = c.size();
             .       .    .              .             .       .              .           .     .                  
       197,948       0    0        120,072        70,470       0              0           0     0                  if(drup_file && saved_size !=c.size()){
             .       .    .              .             .       .              .           .     .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .     .                      binDRUP('a', c , drup_file);
             .       .    .              .             .       .              .           .     .                      //                    binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .     .  #else
             .       .    .              .             .       .              .           .     .                      for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .     .                      fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
             .       .    .              .             .       .              .           .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .     .                      //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .       .    .              .             .       .              .           .     .  
        80,048       0    0              0             0       0              0           0     0                  if (c.size() == 1){
             .       .    .              .             .       .              .           .     .                      // when unit clause occur, enqueue and propagate
            10       2    1              2             0       0              2           0     0                      uncheckedEnqueue(c[0]);
             6       0    0              2             0       0              0           0     0                      if (propagate() != CRef_Undef){
             .       .    .              .             .       .              .           .     .                          ok = false;
             .       .    .              .             .       .              .           .     .                          return false;
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                      // delete the clause memory in logic
             .       .    .              .             .       .              .           .     .                      c.mark(1);
             .       .    .              .             .       .              .           .     .                      ca.free(cr);
             .       .    .              .             .       .              .           .     .  //#ifdef BIN_DRUP
             .       .    .              .             .       .              .           .     .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
             .       .    .              .             .       .              .           .     .  //#else
             .       .    .              .             .       .              .           .     .  //                    fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .     .  //                    for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .     .  //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  //#endif
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .                  else{
       120,066       0    0              0             0       0         40,022           0     0                      attachClause(cr);
       240,132      41   16        120,066        70,738       0         40,022          82     0                      learnts_core[cj++] = learnts_core[ci];
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                      nblevels = computeLBD(c);
        80,044      36   15              0             0       0              0           0     0                      if (nblevels < c.lbd()){
             .       .    .              .             .       .              .           .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .       .    .              .             .       .              .           .     .                          c.set_lbd(nblevels);
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                      c.setSimplified(true);
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
            41       0    0              0             0       0              0           0     0      learnts_core.shrink(ci - cj);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .     .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .     .  
            41      27   11              0             0       0              0           0     0      return true;
             .       .    .              .             .       .              .           .     .  
           328       0    0            287            41       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
    14,609,430       2    2              0             0       0      9,739,620           0     0  int Solver::is_duplicate(std::vector<uint32_t>&c){
     3,246,540       0    0              0             0       0      3,246,540      20,564     0     auto time_point_0 = std::chrono::high_resolution_clock::now();
     1,623,270       0    0      1,623,270       784,591       0              0           0     0      dupl_db_size++;
     3,766,018     898    7        652,954             0       0              0           0     0      int res = 0;    
             .       .    .              .             .       .              .           .     .      
     3,246,540       0    0      3,246,540             0       0              0           0     0      int sz = c.size();
             .       .    .              .             .       .              .           .     .      std::vector<uint32_t> tmp(c);    
             .       .    .              .             .       .              .           .     .      sort(tmp.begin(),tmp.end());
             .       .    .              .             .       .              .           .     .      
     1,623,270 264,441    1              0             0       0      1,623,270           0     0      uint64_t hash = 0;    
             .       .    .              .             .       .              .           .     .      
   107,762,296   3,604    4              0             0       0      1,623,270           0     0      for (int i =0; i<sz; i++) {
   473,880,680       0    0     47,388,068             0       0              0           0     0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
             .       .    .              .             .       .              .           .     .      }    
             .       .    .              .             .       .              .           .     .      
     1,623,270       0    0              0             0       0      1,623,270           0     0      int32_t head = tmp[0];
             .       .    .              .             .       .              .           .     .      auto it0 = ht.find(head);
     8,106,571       0    0      1,623,269             0       0              0           0     0      if (it0 != ht.end()){
             .       .    .              .             .       .              .           .     .          auto it1=ht[head].find(sz);
     3,240,022       0    0              0             0       0              0           0     0          if (it1 != ht[head].end()){
     1,575,767       0    0              0             0       0      1,575,767           0     0              auto it2 = ht[head][sz].find(hash);
     4,727,301       0    0              0             0       0      1,575,767           0     0              if (it2 != ht[head][sz].end()){
       200,214       0    0         66,738        14,231     640         66,738           0     0                  it2->second++;
        66,738       0    0              0             0       0              0           0     0                  res = it2->second;            
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              else{
     1,509,029       0    0              0             0       0      1,509,029           0     0                  ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          else{            
        88,488      13    0              0             0       0         44,244           0     0              ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }else{        
     1,559,791   1,877    9              0             0       0      1,559,791         121     0          ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .     .      } 
     1,623,270     101    1              0             0       0      1,623,270           0     0      auto time_point_1 = std::chrono::high_resolution_clock::now();
             .       .    .              .             .       .              .           .     .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
             .       .    .              .             .       .              .           .     .      return res;
    14,609,430       0    0     11,362,890           626       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  bool Solver::simplifyLearnt_tier2()
           451      41   11              0             0       0            246           0     0  {
             .       .    .              .             .       .              .           .     .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .     .      int learnts_tier2_size_before = learnts_tier2.size();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .     .      bool sat, false_lit;
             .       .    .              .             .       .              .           .     .      unsigned int nblevels;
             .       .    .              .             .       .              .           .     .      ////
             .       .    .              .             .       .              .           .     .      //printf("learnts_x size : %d\n", learnts_x.size());
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      ////
             .       .    .              .             .       .              .           .     .      int nbSimplified = 0;
             .       .    .              .             .       .              .           .     .      int nbSimplifing = 0;
             .       .    .              .             .       .              .           .     .  
       629,037      38    2             41            41       0              0           0     0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
       943,371       0    0        628,914        35,726       0              0           0     0          CRef cr = learnts_tier2[ci];
             .       .    .              .             .       .              .           .     .          Clause& c = ca[cr];
             .       .    .              .             .       .              .           .     .  
       628,914       0    0              0             0       0              0           0     0          if (removed(cr)) continue;
       628,914       0    0        314,457        38,599       0              0           0     0          else if (c.simplified()){
       166,080       0    0              0             0       0         83,040         539     0              learnts_tier2[cj++] = learnts_tier2[ci];
             .       .    .              .             .       .              .           .     .              ////
       711,954       0    0         83,040             0       0              0           0     0              nbSimplified++;
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          else{
             .       .    .              .             .       .              .           .     .              int saved_size=c.size();
             .       .    .              .             .       .              .           .     .              //            if (drup_file){
             .       .    .              .             .       .              .           .     .              //                    add_oc.clear();
             .       .    .              .             .       .              .           .     .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .       .    .              .             .       .              .           .     .              ////
             .       .    .              .             .       .              .           .     .              nbSimplifing++;
       231,416       0    0              0             0       0              0           0     0              sat = false_lit = false;
    10,956,274       0    0              0             0       0              0           0     0              for (int i = 0; i < c.size(); i++){
    10,956,274       0    0              0             0       0              0           0     0                  if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .     .                      sat = true;
             .       .    .              .             .       .              .           .     .                      break;
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .                  else if (value(c[i]) == l_False){
    11,419,104      10    3              0             0       0        231,416           0     0                      false_lit = true;
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              if (sat){
             5       0    0              1             0       0              1           0     0                  removeClause(cr);
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              else{
     1,388,496      27   12              0             0       0        694,248          38     0                  detachClause(cr, true);
             .       .    .              .             .       .              .           .     .  
       925,664       0    0        462,832        11,822       0              0           0     0                  if (false_lit){
           735       1    1             58             0       0              0           0     0                      for (li = lj = 0; li < c.size(); li++){
           474       0    0              0             0       0              0           0     0                          if (value(c[li]) != l_False){
           621       0    0              0             0       0            207           0     0                              c[lj++] = c[li];
             .       .    .              .             .       .              .           .     .                          }
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                      c.shrink(li - lj);
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                  beforeSize = c.size();
             .       .    .              .             .       .              .           .     .                  assert(c.size() > 1);
             .       .    .              .             .       .              .           .     .                  // simplify a learnt clause c
     1,157,080       0    0              0             0       0        694,248           0     0                  simplifyLearnt(c);
             .       .    .              .             .       .              .           .     .                  assert(c.size() > 0);
             .       .    .              .             .       .              .           .     .                  afterSize = c.size();
             .       .    .              .             .       .              .           .     .                  
       925,664      41   17        462,832       459,279       0              0           0     0                  if(drup_file && saved_size!=c.size()){
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .     .                      binDRUP('a', c , drup_file);
             .       .    .              .             .       .              .           .     .                      //                    binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .     .  #else
             .       .    .              .             .       .              .           .     .                      for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .     .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
             .       .    .              .             .       .              .           .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .     .                      //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .       .    .              .             .       .              .           .     .  
       462,832       0    0              0             0       0              0           0     0                  if (c.size() == 1){
             .       .    .              .             .       .              .           .     .                      // when unit clause occur, enqueue and propagate
             .       .    .              .             .       .              .           .     .                      uncheckedEnqueue(c[0]);
             .       .    .              .             .       .              .           .     .                      if (propagate() != CRef_Undef){
             .       .    .              .             .       .              .           .     .                          ok = false;
             .       .    .              .             .       .              .           .     .                          return false;
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                      // delete the clause memory in logic
             .       .    .              .             .       .              .           .     .                      c.mark(1);
-- line 838 ----------------------------------------
-- line 845 ----------------------------------------
             .       .    .              .             .       .              .           .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .     .  //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  //#endif
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .                  else{
             .       .    .              .             .       .              .           .     .                      
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                      nblevels = computeLBD(c);
       462,832       0    0              0             0       0              0           0     0                      if (nblevels < c.lbd()){
             .       .    .              .             .       .              .           .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .       .    .              .             .       .              .           .     .                          c.set_lbd(nblevels);
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                       //duplicate learnts 
             .       .    .              .             .       .              .           .     .                      int id = 0;                    
             .       .    .              .             .       .              .           .     .                      
             .       .    .              .             .       .              .           .     .                      std::vector<uint32_t> tmp;
    14,321,968       0    0     10,594,730             0       0              0           0     0                      for (int i = 0; i < c.size(); i++)                           
     7,371,708       0    0      3,685,854             0       0      3,685,854           0     0                          tmp.push_back(c[i].x);
       925,664       0    0              0             0       0        231,416           0     0                      id = is_duplicate(tmp);
             .       .    .              .             .       .              .           .     .                       
             .       .    .              .             .       .              .           .     .                                          
             .       .    .              .             .       .              .           .     .                      //duplicate learnts 
             .       .    .              .             .       .              .           .     .  
       925,664       4    4        231,416       229,957       0              0           0     0                      if (id < min_number_of_learnts_copies+2){
       642,798       9    4              0             0       0        214,266           0     0                          attachClause(cr);
     1,064,767       0    0        642,798       425,551       0        214,266     192,205     0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
       857,064      41   18        214,266             0       0              0           0     0                          if (id == min_number_of_learnts_copies+1){                            
           449       0    0            449             0       0              0           0     0                              duplicates_added_minimization++;                                  
             .       .    .              .             .       .              .           .     .                          }
       427,634       0    0        213,817       212,524       0              0           0     0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
             .       .    .              .             .       .              .           .     .                          //if (id == min_number_of_learnts_copies+1){
             .       .    .              .             .       .              .           .     .                              cj--;
             1       1    1              0             0       0              0           0     0                              learnts_core.push(cr);
             .       .    .              .             .       .              .           .     .                              c.mark(CORE);
             .       .    .              .             .       .              .           .     .                          }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                          c.setSimplified(true);
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
            41      36   16              0             0       0              0           0     0      learnts_tier2.shrink(ci - cj);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .     .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .     .  
            41       0    0              0             0       0              0           0     0      return true;
             .       .    .              .             .       .              .           .     .  
           328       0    0            287            41       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  bool Solver::simplifyAll()
           205       9    4              0             0       0            123           0     0  {
             .       .    .              .             .       .              .           .     .      ////
            82       0    0              0             0       0             41           0     0      simplified_length_record = original_length_record = 0;
             .       .    .              .             .       .              .           .     .  
           164       0    0             41            19       0              0           0     0      if (!ok || propagate() != CRef_Undef)
             .       .    .              .             .       .              .           .     .          return ok = false;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      //// cleanLearnts(also can delete these code), here just for analyzing
             .       .    .              .             .       .              .           .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .       .    .              .             .       .              .           .     .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
             .       .    .              .             .       .              .           .     .      //local_learnts_dirty = tier2_learnts_dirty = false;
             .       .    .              .             .       .              .           .     .  
           164       0    0              0             0       0             41           0     0      if (!simplifyLearnt_core()) return ok = false;
           164      41   18              0             0       0             41           0     0      if (!simplifyLearnt_tier2()) return ok = false;
             .       .    .              .             .       .              .           .     .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      checkGarbage();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      ////
             .       .    .              .             .       .              .           .     .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
             .       .    .              .             .       .              .           .     .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      return true;
           205       0    0            164             0       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  //=================================================================================================
             .       .    .              .             .       .              .           .     .  // Minor methods:
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
             .       .    .              .             .       .              .           .     .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
             .       .    .              .             .       .              .           .     .  //
             .       .    .              .             .       .              .           .     .  Var Solver::newVar(bool sign, bool dvar)
        35,930       1    1              0             0       0         28,744           0     0  {
             .       .    .              .             .       .              .           .     .      int v = nVars();
             .       .    .              .             .       .              .           .     .      watches_bin.init(mkLit(v, false));
             .       .    .              .             .       .              .           .     .      watches_bin.init(mkLit(v, true ));
             .       .    .              .             .       .              .           .     .      watches  .init(mkLit(v, false));
             .       .    .              .             .       .              .           .     .      watches  .init(mkLit(v, true ));
            18       1    1              0             0       0              0           0     0      assigns  .push(l_Undef);
            18       1    1              0             0       0              0           0     0      vardata  .push(mkVarData(CRef_Undef, 0));
            18       0    0              0             0       0              0           0     0      activity_CHB  .push(0);
        10,815       0    0          3,593           107       0             18           0     0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
             .       .    .              .             .       .              .           .     .  
            18       1    1              0             0       0              0           0     0      picked.push(0);
            18       0    0              0             0       0              0           0     0      conflicted.push(0);
            18       0    0              0             0       0              0           0     0      almost_conflicted.push(0);
             .       .    .              .             .       .              .           .     .  #ifdef ANTI_EXPLORATION
            18       0    0              0             0       0              0           0     0      canceled.push(0);
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .  
            18       0    0              0             0       0              0           0     0      seen     .push(0);
            18       0    0              0             0       0              0           0     0      seen2    .push(0);
            18       0    0              0             0       0              0           0     0      polarity .push(sign);
            18       0    0              0             0       0              0           0     0      decision .push();
        17,965       1    1              0             0       0          7,186         244     0      trail    .capacity(v+1);
             .       .    .              .             .       .              .           .     .      setDecisionVar(v, dvar);
             .       .    .              .             .       .              .           .     .  
            18       0    0              0             0       0              0           0     0      activity_distance.push(0);
            18       1    1              0             0       0              0           0     0      var_iLevel.push(0);
            18       0    0              0             0       0              0           0     0      var_iLevel_tmp.push(0);
            18       0    0              0             0       0              0           0     0      pathCs.push(0);
             .       .    .              .             .       .              .           .     .      return v;
        32,337       0    0         25,151            14       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  bool Solver::addClause_(vec<Lit>& ps)
       113,708       2    1              0             0       0         97,464           7     0  {
             .       .    .              .             .       .              .           .     .      assert(decisionLevel() == 0);
        48,732       2    1         16,244             0       0              0           0     0      if (!ok) return false;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Check if clause is satisfied and remove false/duplicate literals:
             .       .    .              .             .       .              .           .     .      sort(ps);
             .       .    .              .             .       .              .           .     .      Lit p; int i, j;
             .       .    .              .             .       .              .           .     .  
        32,488       0    0         16,244            28       0              0           0     0      if (drup_file){
             .       .    .              .             .       .              .           .     .          add_oc.clear();
        16,244       2    1         16,244             0       0              0           0     0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
             .       .    .              .             .       .              .           .     .  
       189,901       0    0              0             0       0              0           0     0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
       327,959       0    0         52,819             0       0              0           0     0          if (value(ps[i]) == l_True || ps[i] == ~p)
             .       .    .              .             .       .              .           .     .              return true;
       209,078       4    2              0             0       0              0           0     0          else if (value(ps[i]) != l_False && ps[i] != p)
       156,204       0    0         52,068             0       0         52,068           0     0              ps[j++] = p = ps[i];
       127,168       0    0         15,896             0       0              0           0     0      ps.shrink(i - j);
             .       .    .              .             .       .              .           .     .  
        31,792       2    1              0             0       0              0           0     0      if (drup_file && i != j){
             .       .    .              .             .       .              .           .     .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .     .          binDRUP('a', ps, drup_file);
        15,896       0    0         15,896             0       0              0           0     0          binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .     .  #else
             .       .    .              .             .       .              .           .     .          for (int i = 0; i < ps.size(); i++)
             .       .    .              .             .       .              .           .     .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
             .       .    .              .             .       .              .           .     .          fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .     .          for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .     .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .     .          fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .      
        31,792       0    0              0             0       0              0           0     0      if (ps.size() == 0)
             .       .    .              .             .       .              .           .     .          return ok = false;
        31,792       2    1              0             0       0              0           0     0      else if (ps.size() == 1){
         1,488       0    0            496             0       0            248           0     0          uncheckedEnqueue(ps[0]);
           992       0    0              0             0       0            248           0     0          return ok = (propagate() == CRef_Undef);
             .       .    .              .             .       .              .           .     .      }else{
        15,648       0    0              0             0       0         15,648           0     0          CRef cr = ca.alloc(ps, false);
             .       .    .              .             .       .              .           .     .          //auto ca_size=ca.size();
             .       .    .              .             .       .              .           .     .          //printf("ca size:%d\n",ca_size);
        46,944       0    0              0             0       0         15,648           0     0          clauses.push(cr);
        46,944       2    1         15,648             0       0         15,648           0     0          attachClause(cr);
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
        15,648       0    0              0             0       0              0           0     0      return true;
       178,684       0    0        113,708             4       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
    20,982,240       5    3              0             0       0     12,589,344           0     0  void Solver::attachClause(CRef cr) {
             .       .    .              .             .       .              .           .     .      const Clause& c = ca[cr];
             .       .    .              .             .       .              .           .     .      assert(c.size() > 1);
     8,388,821       0    0      2,098,224           123       0              0           0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .     .      ws[~c[0]].push(Watcher(cr, c[1]));
             .       .    .              .             .       .              .           .     .      ws[~c[1]].push(Watcher(cr, c[0]));
     6,277,590       0    0      4,179,366     1,417,854       0              0           0     0      if (c.learnt()) learnts_literals += c.size();
    16,802,874       0    0     14,704,650            12       0              0           0     0      else            clauses_literals += c.size(); }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
    11,870,652     174    5              0             0       0      7,913,768           8     0  void Solver::detachClause(CRef cr, bool strict) {
             .       .    .              .             .       .              .           .     .      const Clause& c = ca[cr];
             .       .    .              .             .       .              .           .     .      assert(c.size() > 1);
     7,913,768       0    0              0             0       0              0           0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .     .      
     7,913,768       0    0              0             0       0              0           0     0      if (strict){
             .       .    .              .             .       .              .           .     .          remove(ws[~c[0]], Watcher(cr, c[1]));
             .       .    .              .             .       .              .           .     .          remove(ws[~c[1]], Watcher(cr, c[0]));
             .       .    .              .             .       .              .           .     .      }else{
             .       .    .              .             .       .              .           .     .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
             .       .    .              .             .       .              .           .     .          ws.smudge(~c[0]);
             .       .    .              .             .       .              .           .     .          ws.smudge(~c[1]);
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
     5,929,381      10    0      3,950,939        32,383       0              0           0     0      if (c.learnt()) learnts_literals -= c.size();
    11,876,597       0    0      9,898,155        12,236       0              0           0     0      else            clauses_literals -= c.size(); }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
    13,644,544     266   13              0             0       0      6,822,272          26     0  void Solver::removeClause(CRef cr) {
             .       .    .              .             .       .              .           .     .      Clause& c = ca[cr];
             .       .    .              .             .       .              .           .     .  
     5,116,704       0    0      1,705,568           150       0              0           0     0      if (drup_file){
             .       .    .              .             .       .              .           .     .          if (c.mark() != 1){
             .       .    .              .             .       .              .           .     .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .     .              binDRUP('d', c, drup_file);
             .       .    .              .             .       .              .           .     .  #else
             .       .    .              .             .       .              .           .     .              fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .     .              for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .     .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .     .              fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .          }else
             .       .    .              .             .       .              .           .     .              printf("c Bug. I don't expect this to happen.\n");
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
     6,822,272     133    5              0             0       0      1,705,568           0     0      detachClause(cr);
             .       .    .              .             .       .              .           .     .      // Don't leave pointers to free'd memory!
             .       .    .              .             .       .              .           .     .      if (locked(c)){
         1,128       0    0            219             0       0              0           0     0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
           690       0    0              0             0       0            345           0     0          vardata[var(implied)].reason = CRef_Undef; }
             .       .    .              .             .       .              .           .     .      c.mark(1);
             .       .    .              .             .       .              .           .     .      ca.free(cr);
    10,233,408       0    0      8,527,840             0       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  bool Solver::satisfied(const Clause& c) const {
     6,214,614      29    2              0             0       0              0           0     0      for (int i = 0; i < c.size(); i++)
     6,680,214       0    0      2,877,193         2,965       0              0           0     0          if (value(c[i]) == l_True)
         2,105       1    1              0             0       0              0           0     0              return true;
        48,833       0    0         25,469             0       0              0           0     0      return false; }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
             .       .    .              .             .       .              .           .     .  //
    16,475,787   5,293    8              0             0       0     10,983,858           0     0  void Solver::cancelUntil(int bLevel) {
             .       .    .              .             .       .              .           .     .  	
     7,330,106      11    2          3,775             0       0      1,830,643           0     0      if (decisionLevel() > bLevel){
             .       .    .              .             .       .              .           .     .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .     .  		std::cout << "bt " << bLevel << "\n";
             .       .    .              .             .       .              .           .     .  #endif				
     3,661,286       0    0              0             0       0      1,830,643     202,213     0  		add_tmp.clear();
 2,534,790,992   6,917    8    510,985,613     2,724,980       0              0           0     0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
             .       .    .              .             .       .              .           .     .          {
             .       .    .              .             .       .              .           .     .              Var      x  = var(trail[c]);
             .       .    .              .             .       .              .           .     .  
 1,003,664,796       0    0    501,832,398   236,643,417       0              0           0     0  			if (level(x) <= bLevel)
             .       .    .              .             .       .              .           .     .  			{
             .       .    .              .             .       .              .           .     .  				add_tmp.push(trail[c]);
             .       .    .              .             .       .              .           .     .  			}
             .       .    .              .             .       .              .           .     .  			else
             .       .    .              .             .       .              .           .     .  			{
 1,003,646,554       0    0    501,823,277         4,947       0              0           0     0  				 if (!VSIDS){
   943,436,388       0    0    628,957,592        51,456       0              0           0     0  					uint32_t age = conflicts - picked[x];
   628,957,592       0    0    314,478,796   139,691,496       3              0           0     0  					if (age > 0){
 3,143,102,670     698   14  1,257,241,068   263,480,444       0              0           0     0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
   314,310,267       0    0    314,310,267   141,330,581      13              0           0     0  						double old_activity = activity_CHB[x];
 2,200,171,869      34   13    628,620,534     1,466,887       0    314,310,267           0     0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
             .       .    .              .             .       .              .           .     .  						if (order_heap_CHB.inHeap(x)){
 1,861,307,208      97   10              0             0       0    930,653,604          96     0  							if (activity_CHB[x] > old_activity)
             .       .    .              .             .       .              .           .     .  								order_heap_CHB.decrease(x);
             .       .    .              .             .       .              .           .     .  							else
             .       .    .              .             .       .              .           .     .  								order_heap_CHB.increase(x);
             .       .    .              .             .       .              .           .     .  						}
             .       .    .              .             .       .              .           .     .  					}
             .       .    .              .             .       .              .           .     .  #ifdef ANTI_EXPLORATION
   628,957,592       0    0    314,478,796       772,233       0    314,478,796 143,312,889     1  					canceled[x] = conflicts;
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .  				}
             .       .    .              .             .       .              .           .     .  				
 1,003,646,554     228   20    501,823,277       164,213       0    501,823,277  72,026,296     0  				assigns [x] = l_Undef;
             .       .    .              .             .       .              .           .     .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .     .  				std::cout << "undo " << x << "\n";
             .       .    .              .             .       .              .           .     .  #endif				
 1,003,646,554       0    0    501,823,277             0       0              0           0     0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
   501,823,277       0    0    501,823,277             0       0              0           0     0  					polarity[x] = sign(trail[c]);
             .       .    .              .             .       .              .           .     .  				insertVarOrder(x);
             .       .    .              .             .       .              .           .     .  			}
             .       .    .              .             .       .              .           .     .          }
     1,830,643       0    0              0             0       0      1,830,643           0     0          qhead = trail_lim[bLevel];
     3,661,286       0    0              0             0       0              0           0     0          trail.shrink(trail.size() - trail_lim[bLevel]);
     5,491,929       0    0      1,830,643             0       0              0           0     0          trail_lim.shrink(trail_lim.size() - bLevel);
     5,510,171       1    1      1,830,643             0       0              0           0     0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
             .       .    .              .             .       .              .           .     .  		{
         1,224       0    0            408             0       0              0           0     0  			trail.push_(add_tmp[nLitId]);
             .       .    .              .             .       .              .           .     .  		}
             .       .    .              .             .       .              .           .     .  		
             .       .    .              .             .       .              .           .     .  		add_tmp.clear();
    14,645,144       0    0     12,814,501     1,172,113       0              0           0     0      } }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  //=================================================================================================
             .       .    .              .             .       .              .           .     .  // Major methods:
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  Lit Solver::pickBranchLit()
    19,876,752     257    1              0             0       0     14,907,564           0     0  {
             .       .    .              .             .       .              .           .     .      Var next = var_Undef;
             .       .    .              .             .       .              .           .     .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
    15,380,961   1,241    3      4,523,555     1,636,249       0              0           0     0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Random decision:
             .       .    .              .             .       .              .           .     .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
             .       .    .              .             .       .              .           .     .          next = order_heap[irand(random_seed,order_heap.size())];
             .       .    .              .             .       .              .           .     .          if (value(next) == l_Undef && decision[next])
             .       .    .              .             .       .              .           .     .              rnd_decisions++; }*/
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Activity based decision:
    53,856,375     507    1     24,443,593     2,843,815      16              0           0     0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    16,989,816       0    0              0             0       0              0           0     0          if (order_heap.empty())
             1       0    0              0             0       0              0           0     0              return lit_Undef;
             .       .    .              .             .       .              .           .     .          else{
             .       .    .              .             .       .              .           .     .  #ifdef ANTI_EXPLORATION
    16,989,814       0    0      8,494,907            81       0              0           0     0              if (!VSIDS){
             .       .    .              .             .       .              .           .     .                  Var v = order_heap_CHB[0];
     8,709,604       0    0      8,709,604        79,500       0              0           0     0                  uint32_t age = conflicts - canceled[v];
    15,020,856       0    0      6,557,920     3,951,023     754        952,508           2     0                  while (age > 0){
             .       .    .              .             .       .              .           .     .                      double decay = pow(0.95, age);
     4,406,236       0    0      2,203,118        53,446       4      2,203,118           0     0                      activity_CHB[v] *= decay;
             .       .    .              .             .       .              .           .     .                      if (order_heap_CHB.inHeap(v))
             .       .    .              .             .       .              .           .     .                          order_heap_CHB.increase(v);
     6,609,354       0    0      4,406,236             0       0      2,203,118           2     0                      canceled[v] = conflicts;
             .       .    .              .             .       .              .           .     .                      v = order_heap_CHB[0];
             .       .    .              .             .       .              .           .     .                      age = conflicts - canceled[v];
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .              next = order_heap.removeMin();
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .  
     9,938,372       0    0      4,969,186     2,201,594       0              0           0     0      return mkLit(next, polarity[next]);
    22,361,345       0    0     17,392,158         7,764       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
             .       .    .              .             .       .              .           .     .  {
             .       .    .              .             .       .              .           .     .  	ConflictData data;
             .       .    .              .             .       .              .           .     .  	Clause& conflCls = ca[cind];
             .       .    .              .             .       .              .           .     .  	data.nHighestLevel = level(var(conflCls[0]));
     7,307,402       0    0      3,653,701        34,367       0              0           0     0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
             .       .    .              .             .       .              .           .     .  	{
             .       .    .              .             .       .              .           .     .  		return data;
             .       .    .              .             .       .              .           .     .  	}
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  	int highestId = 0;
             .       .    .              .             .       .              .           .     .      data.bOnlyOneLitFromHighest = true;
             .       .    .              .             .       .              .           .     .  	// find the largest decision level in the clause
           938       2    1              0             0       0              0           0     0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
             .       .    .              .             .       .              .           .     .  	{
             .       .    .              .             .       .              .           .     .  		int nLevel = level(var(conflCls[nLitId]));
           421       0    0              0             0       0              0           0     0  		if (nLevel > data.nHighestLevel)
             .       .    .              .             .       .              .           .     .  		{
             .       .    .              .             .       .              .           .     .  			highestId = nLitId;
             .       .    .              .             .       .              .           .     .  			data.nHighestLevel = nLevel;
             9       0    0              0             0       0              0           0     0  			data.bOnlyOneLitFromHighest = true;
             .       .    .              .             .       .              .           .     .  		}
             .       .    .              .             .       .              .           .     .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
             .       .    .              .             .       .              .           .     .  		{
           376       0    0              0             0       0              0           0     0  			data.bOnlyOneLitFromHighest = false;
             .       .    .              .             .       .              .           .     .  		}
             .       .    .              .             .       .              .           .     .  	}
             .       .    .              .             .       .              .           .     .  
           136      35    1              0             0       0              0           0     0  	if (highestId != 0)
             .       .    .              .             .       .              .           .     .  	{
             .       .    .              .             .       .              .           .     .  		std::swap(conflCls[0], conflCls[highestId]);
            18       0    0              0             0       0              0           0     0  		if (highestId > 1)
             .       .    .              .             .       .              .           .     .  		{
             8       0    0              0             0       0              0           0     0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .     .  			//ws.smudge(~conflCls[highestId]);
             .       .    .              .             .       .              .           .     .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
             .       .    .              .             .       .              .           .     .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
             .       .    .              .             .       .              .           .     .  		}
             .       .    .              .             .       .              .           .     .  	}
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  	return data;
             .       .    .              .             .       .              .           .     .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
             .       .    .              .             .       .              .           .     .  |  
             .       .    .              .             .       .              .           .     .  |    Post-conditions:
             .       .    .              .             .       .              .           .     .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
             .       .    .              .             .       .              .           .     .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
             .       .    .              .             .       .              .           .     .  |        rest of literals. There may be others from the same level though.
             .       .    .              .             .       .              .           .     .  |  
             .       .    .              .             .       .              .           .     .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .     .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
    23,749,284      96   19              0             0       0     16,441,812           0     0  {
     1,826,868       0    0              0             0       0      1,826,868      11,242     0      int pathC = 0;
     1,826,868       0    0              0             0       0              0           0     0      Lit p     = lit_Undef;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Generate conflict clause:
             .       .    .              .             .       .              .           .     .      //
             .       .    .              .             .       .              .           .     .      out_learnt.push();      // (leave room for the asserting literal)
     3,653,736       0    0      1,826,868             0       0              0           0     0      int index   = trail.size() - 1;
     1,826,868       0    0      1,826,868             0       0              0           0     0      int nDecisionLevel = level(var(ca[confl][0]));
             .       .    .              .             .       .              .           .     .      assert(nDecisionLevel == level(var(ca[confl][0])));
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      do{
             .       .    .              .             .       .              .           .     .          assert(confl != CRef_Undef); // (otherwise should be UIP)
             .       .    .              .             .       .              .           .     .          Clause& c = ca[confl];
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
   532,805,224       0    0              0             0       0              0           0     0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
             .       .    .              .             .       .              .           .     .              assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .     .              Lit tmp = c[0];
     4,425,645       0    0      1,475,215        86,050       6      2,950,430           0     0              c[0] = c[1], c[1] = tmp; }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          // Update LBD if improved.
   400,092,127       1    1     20,201,178             0       0              0           0     0          if (c.learnt() && c.mark() != CORE){
             .       .    .              .             .       .              .           .     .              int lbd = computeLBD(c);
    11,922,300       0    0              0             0       0              0           0     0              if (lbd < c.lbd()){
       851,374       0    0              0             0       0              0           0     0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
             .       .    .              .             .       .              .           .     .                  c.set_lbd(lbd);
       851,374       0    0        425,687       286,579       0              0           0     0                  if (lbd <= core_lbd_cut){
            16       3    0              0             0       0              8           0     0                      learnts_core.push(confl);
             .       .    .              .             .       .              .           .     .                      c.mark(CORE);
     1,246,745       0    0        185,143             0       0              0           0     0                  }else if (lbd <= 6 && c.mark() == LOCAL){
             .       .    .              .             .       .              .           .     .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
             .       .    .              .             .       .              .           .     .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
    13,070,148       5    3              0             0       0      3,794,772   1,795,342     0                      learnts_tier2.push(confl);
             .       .    .              .             .       .              .           .     .                      c.mark(TIER2); }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
    11,691,724       0    0      5,845,862             0       0              0           0     0              if (c.mark() == TIER2)
    12,431,360      39   12      3,107,840       218,179       0      3,107,840     381,642    11                  c.touched() = conflicts;
     5,617,080       0    0      2,808,540             0       0              0           0     0              else if (c.mark() == LOCAL)
             .       .    .              .             .       .              .           .     .                  claBumpActivity(c);
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .  
 2,282,133,096      12    2    611,800,750            35       0    126,439,376          39     0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
   485,361,374       0    0    485,361,374    34,017,762      21              0           0     0              Lit q = c[j];
             .       .    .              .             .       .              .           .     .  
 1,729,223,404       1    1    738,194,926   127,244,768       1              0           0     0              if (!seen[var(q)] && level(var(q)) > 0){
   505,665,618       0    0    252,832,809         3,486       0              0           0     0                  if (VSIDS){
             .       .    .              .             .       .              .           .     .                      varBumpActivity(var(q), .5);
            22       0    0              0             0       0             11           0     0                      add_tmp.push(q);
             .       .    .              .             .       .              .           .     .                  }else
   160,681,682       0    0    160,681,682    58,501,256       0              0           0     0                      conflicted[var(q)]++;
   252,832,809       0    0              0             0       0    252,832,809           9     0                  seen[var(q)] = 1;
   505,665,618       0    0    252,832,809            11       0              0           0     0                  if (level(var(q)) >= nDecisionLevel){
   252,878,752       0    0    252,878,752            20       0              0           0     0                      pathC++;
             .       .    .              .             .       .              .           .     .                  }else
             .       .    .              .             .       .              .           .     .                      out_learnt.push(q);
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          
             .       .    .              .             .       .              .           .     .          // Select next clause to look at:
             .       .    .              .             .       .              .           .     .  		do {
 2,696,321,142       0    0  1,103,816,332    69,547,134       6              0           0     0  			while (!seen[var(trail[index--])]);
             .       .    .              .             .       .              .           .     .  			p  = trail[index+1];
   252,879,144       1    1    126,439,572     3,160,754       0              0           0     0  		} while (level(var(p)) < nDecisionLevel);
             .       .    .              .             .       .              .           .     .  		
   252,878,752       0    0    126,439,376             0       0    126,439,376           0     0          confl = reason(var(p));
   126,439,376       0    0              0             0       0    126,439,376           0     0          seen[var(p)] = 0;
   252,878,752       0    0    252,878,752             1       0              0           0     0          pathC--;
             .       .    .              .             .       .              .           .     .  
   751,328,784       0    0    249,225,016           155       0              0           0     0      }while (pathC > 0);
     1,826,868       0    0      1,826,868           111       0              0           0     0      out_learnt[0] = ~p;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Simplify conflict clause:
             .       .    .              .             .       .              .           .     .      //
             .       .    .              .             .       .              .           .     .      int i, j;
     3,653,736       0    0              0             0       0      1,826,868           0     0      out_learnt.copyTo(analyze_toclear);
     5,480,604       0    0      1,826,868             1       0              0           0     0      if (ccmin_mode == 2){
     1,826,854     406    3              0             0       0              0           0     0          uint32_t abstract_level = 0;
   256,440,602     532    4              0             0       0              0           0     0          for (i = 1; i < out_learnt.size(); i++)
   130,047,141       0    0      1,826,854             0       0              0           0     0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
             .       .    .              .             .       .              .           .     .  
   903,022,571      47    9    377,353,445           376       0      1,826,854           0     0          for (i = j = 1; i < out_learnt.size(); i++)
   906,668,933      36    7    172,302,199     4,589,826       0    112,412,907           0     0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
   179,667,876       9    0     59,889,292            53       0     59,889,292      10,597     0                  out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .     .          
             .       .    .              .             .       .              .           .     .      }else if (ccmin_mode == 1){
             .       .    .              .             .       .              .           .     .          for (i = j = 1; i < out_learnt.size(); i++){
             .       .    .              .             .       .              .           .     .              Var x = var(out_learnt[i]);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              if (reason(x) == CRef_Undef)
             .       .    .              .             .       .              .           .     .                  out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .     .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
             .       .    .              .             .       .              .           .     .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
             .       .    .              .             .       .              .           .     .                          out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .     .                          break; }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }else
             .       .    .              .             .       .              .           .     .          i = j = out_learnt.size();
             .       .    .              .             .       .              .           .     .  
     3,653,736       0    0      1,826,868     1,817,059       1              0           0     0      max_literals += out_learnt.size();
    84,472,048       1    1     20,661,295             0       0              0           0     0      out_learnt.shrink(i - j);
     1,826,868     207    1      1,826,868             0       0              0           0     0      tot_literals += out_learnt.size();
             .       .    .              .             .       .              .           .     .  
     3,653,736       0    0      1,826,868       313,496       0      1,826,868           0     0      out_lbd = computeLBD(out_learnt);
    20,668,758   7,381   24      9,298,894             0       0              0           0     0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
     1,152,270   8,280    4        164,610             0       0        329,220           0     0          if (binResMinimize(out_learnt))
         3,810       0    0          1,270             0       0          1,270           0     0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Find correct backtrack level:
             .       .    .              .             .       .              .           .     .      //
     3,574,244       0    0              0             0       0              0           0     0      if (out_learnt.size() == 1)
            42       0    0             14             0       0             14           0     0          out_btlevel = 0;
             .       .    .              .             .       .              .           .     .      else{
     3,652,530       0    0              0             0       0              0           0     0          int max_i = 1;
             .       .    .              .             .       .              .           .     .          // Find the first literal assigned at the next-highest level:
   236,901,654       0    0              0             0       0              0           0     0          for (int i = 2; i < out_learnt.size(); i++)
   184,780,319       0    0     58,061,157             0       0              0           0     0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
             .       .    .              .             .       .              .           .     .                  max_i = i;
             .       .    .              .             .       .              .           .     .          // Swap-in this literal at index 1:
             .       .    .              .             .       .              .           .     .          Lit p             = out_learnt[max_i];
     3,653,708      11    0      1,826,854             0       0      1,826,854           0     0          out_learnt[max_i] = out_learnt[1];
     1,826,854       0    0              0             0       0      1,826,854           0     0          out_learnt[1]     = p;
     3,653,708       0    0      1,826,854             0       0      1,826,854           0     0          out_btlevel       = level(var(p));
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
     3,653,736   1,998   17      1,826,868       209,089       0              0           0     0      if (VSIDS){
   317,977,525   7,357   12     94,448,419       446,731       0              0           0     0          for (int i = 0; i < add_tmp.size(); i++){
             .       .    .              .             .       .              .           .     .              Var v = var(add_tmp[i]);
   276,453,381       0    0     92,151,127    17,316,071       0              0           0     0              if (level(v) >= out_btlevel - 1)
             .       .    .              .             .       .              .           .     .                  varBumpActivity(v, 1);
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          add_tmp.clear();
             .       .    .              .             .       .              .           .     .      }else{
     2,122,208       0    0      1,061,104             0       0      1,061,104      32,831     0          seen[var(p)] = true;
   122,657,993       0    0      1,061,104             0       0              0           0     0          for(int i = out_learnt.size() - 1; i >= 0; i--){
             .       .    .              .             .       .              .           .     .              Var v = var(out_learnt[i]);
             .       .    .              .             .       .              .           .     .              CRef rea = reason(v);
    73,990,566       0    0              0             0       0              0           0     0              if (rea != CRef_Undef){
             .       .    .              .             .       .              .           .     .                  const Clause& reaC = ca[rea];
   421,254,732       0    0              0             0       0              0           0     0                  for (int i = 0; i < reaC.size(); i++){
             .       .    .              .             .       .              .           .     .                      Lit l = reaC[i];
   309,691,244       0    0    154,845,622       964,392       0              0           0     0                      if (!seen[var(l)]){
    49,818,633       0    0              0             0       0     49,818,633           0     0                          seen[var(l)] = true;
    49,818,633       0    0     49,818,633    29,910,914       0              0           0     0                          almost_conflicted[var(l)]++;
             .       .    .              .             .       .              .           .     .                          analyze_toclear.push(l); } } } } }
             .       .    .              .             .       .              .           .     .  
   970,708,364   3,646    1    482,613,880       116,920       0    240,393,506   4,584,710     0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
    14,614,944       0    0     12,788,076     1,149,293       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  // Try further learnt clause minimization by means of binary clause resolution.
             .       .    .              .             .       .              .           .     .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
       393,345       0    0              0             0       0        314,676           0     0  {
             .       .    .              .             .       .              .           .     .      // Preparation: remember which false variables we have in 'out_learnt'.
       493,830      22   13        164,610             0       0        164,610           0     0      counter++;
     5,915,284       0    0        329,220             0       0              0           0     0      for (int i = 1; i < out_learnt.size(); i++)
     2,464,990       0    0        164,596             0       0      2,300,394   2,027,913 1,080          seen2[var(out_learnt[i])] = counter;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Get the list of binary clauses containing 'out_learnt[0]'.
             .       .    .              .             .       .              .           .     .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
             .       .    .              .             .       .              .           .     .  
        78,669       0    0              0             0       0              0           0     0      int to_remove = 0;
       875,711       1    1        164,610       141,105       0          1,270           0     0      for (int i = 0; i < ws.size(); i++){
       225,011       0    0        225,011        73,541       1              0           0     0          Lit the_other = ws[i].blocker;
             .       .    .              .             .       .              .           .     .          // Does 'the_other' appear negatively in 'out_learnt'?
       902,606       9    4        373,915       111,267     338              0           0     0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
         1,281       0    0              0             0       0              0           0     0              to_remove++;
         3,843       0    0              0             0       0          1,281           0     0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Shrink.
       236,007      15    3              0             0       0              0           0     0      if (to_remove > 0){
         1,270       0    0              0             0       0              0           0     0          int last = out_learnt.size() - 1;
       146,821     126    9          1,270             0       0              0           0     0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
        40,640       0    0         20,320             0       0              0           0     0              if (seen2[var(out_learnt[i])] != counter)
         5,065       0    0          2,026             0       0          1,013           0     0                  out_learnt[i--] = out_learnt[last--];
             .       .    .              .             .       .              .           .     .          out_learnt.shrink(to_remove);
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .      return to_remove != 0;
       479,286       2    2        479,286             0       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
             .       .    .              .             .       .              .           .     .  // visiting literals at levels that cannot be removed later.
             .       .    .              .             .       .              .           .     .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
 1,124,129,070  23,360    2              0             0       0    674,477,442   1,185,420     0  {
   224,825,814       0    0              0             0       0    112,412,907           0     0      analyze_stack.clear(); analyze_stack.push(p);
   337,238,721       0    0    224,825,814             0       0    112,412,907           0     0      int top = analyze_toclear.size();
   671,882,796       0    0              0             0       0              0           0     0      while (analyze_stack.size() > 0){
             .       .    .              .             .       .              .           .     .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
             .       .    .              .             .       .              .           .     .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          // Special handling for binary clauses like in 'analyze()'.
   696,113,088      51   15              0             0       0              0           0     0          if (c.size() == 2 && value(c[0]) == l_False){
             .       .    .              .             .       .              .           .     .              assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .     .              Lit tmp = c[0];
     1,469,652       0    0        489,884        28,342       2        979,768           0     0              c[0] = c[1], c[1] = tmp; }
             .       .    .              .             .       .              .           .     .  
 1,624,542,884       0    0              0             0       0              0           0     0          for (int i = 1; i < c.size(); i++){
   667,362,238     103   14    667,362,238    55,056,629      13              0           0     0              Lit p  = c[i];
 2,573,201,158       0    0  1,334,724,476     9,153,487       0              0           0     0              if (!seen[var(p)] && level(var(p)) > 0){
 1,063,773,008       0    0    285,555,839             0       0              0           0     0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
   239,647,073       0    0              0             0       0    239,647,073           0     0                      seen[var(p)] = 1;
             .       .    .              .             .       .              .           .     .                      analyze_stack.push(p);
             8       0    0              0             0       0              0           0     0                      analyze_toclear.push(p);
             .       .    .              .             .       .              .           .     .                  }else{
   875,686,505   1,144    6    269,110,033            18       0              0           0     0                      for (int j = top; j < analyze_toclear.size(); j++)
   317,635,393       0    0    140,342,892             0       0    177,292,501          30     0                          seen[var(analyze_toclear[j])] = 0;
    91,817,532      24    0     45,908,766             0       0              0           0     0                      analyze_toclear.shrink(analyze_toclear.size() - top);
    45,908,766       0    0              0             0       0              0           0     0                      return false;
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
   133,008,282       0    0              0             0       0              0           0     0      return true;
   899,303,256      10    1    786,890,349           523       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .     .  |
             .       .    .              .             .       .              .           .     .  |  analyzeFinal : (p : Lit)  ->  [void]
             .       .    .              .             .       .              .           .     .  |  
             .       .    .              .             .       .              .           .     .  |  Description:
             .       .    .              .             .       .              .           .     .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      seen[var(p)] = 0;
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 5,018,238,920       6    2              0             0       0  2,509,119,460           2     0  {
             .       .    .              .             .       .              .           .     .      assert(value(p) == l_Undef);
             .       .    .              .             .       .              .           .     .      Var x = var(p);
 1,003,647,784       0    0    501,823,892     4,930,225       0              0           0     0      if (!VSIDS){
   943,446,156       0    0    628,964,104     4,394,372       0    314,482,052 221,180,337 1,009          picked[x] = conflicts;
   628,964,104       0    0    314,482,052             0       0    314,482,052 220,070,847   865          conflicted[x] = 0;
   628,964,104       2    1    314,482,052             0       0    314,482,052 220,871,093   917          almost_conflicted[x] = 0;
             .       .    .              .             .       .              .           .     .  #ifdef ANTI_EXPLORATION
   314,482,052       0    0    314,482,052     2,605,960       0              0           0     0          uint32_t age = conflicts - canceled[var(p)];
   628,964,104       0    0    314,482,052   220,318,517      94              0           0     0          if (age > 0){
             .       .    .              .             .       .              .           .     .              double decay = pow(0.95, age);
   234,337,762       0    0    117,168,881    96,009,185      32    117,168,881           0     0              activity_CHB[var(p)] *= decay;
             .       .    .              .             .       .              .           .     .              if (order_heap_CHB.inHeap(var(p)))
   117,168,881       0    0              0             0       0              0           0     0                  order_heap_CHB.increase(var(p));
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
   501,823,892       1    0    501,823,892         1,233       0              0           0     0      assigns[x] = lbool(!sign(p));
 1,003,647,784       0    0              0             0       0  1,003,647,784 358,460,705   377      vardata[x] = mkVarData(from, level);
   501,823,892       3    1    501,823,892             0       0              0           0     0      trail.push_(p);
 3,512,767,244       0    0  3,010,943,352             0       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  unsigned number_watch_changed_total=0;
             .       .    .              .             .       .              .           .     .  unsigned number_clause_read_total=0;
             .       .    .              .             .       .              .           .     .  unsigned times_only_access_watch=0;
             .       .    .              .             .       .              .           .     .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .     .  |
             .       .    .              .             .       .              .           .     .  |  propagate : [void]  ->  [Clause*]
             .       .    .              .             .       .              .           .     .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
             .       .    .              .             .       .              .           .     .  |  Description:
             .       .    .              .             .       .              .           .     .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
             .       .    .              .             .       .              .           .     .  |    otherwise CRef_Undef.
             .       .    .              .             .       .              .           .     .  |  
             .       .    .              .             .       .              .           .     .  |    Post-conditions:
             .       .    .              .             .       .              .           .     .  |      * the propagation queue is empty, even if there was a conflict.
             .       .    .              .             .       .              .           .     .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .     .  CRef Solver::propagate_()
    34,554,552       5    3              0             0       0     25,915,914           0     0  {
             .       .    .              .             .       .              .           .     .      //auto start_time=std::chrono::steady_clock::now();
     4,319,319       0    0              0             0       0      4,319,319           0     0      CRef    confl     = CRef_Undef;
     4,319,319       0    0              0             0       0      4,319,319           5     0      int     num_props = 0;
     8,638,638       0    0              0             0       0      4,319,319     286,857     0      watches.cleanAll();
     8,638,638       4    2              0             0       0      4,319,319           0     0      watches_bin.cleanAll();
             .       .    .              .             .       .              .           .     .      
 1,676,066,130       2    1  1,212,024,305     2,763,469       1              0           0     0      while (qhead < trail.size()){
 2,289,902,415       0    0    915,960,966    10,826,880       0    457,980,483           0     0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .       .    .              .             .       .              .           .     .          int currLevel = level(var(p));
             .       .    .              .             .       .              .           .     .          vec<Watcher>&  ws  = watches[p];
             .       .    .              .             .       .              .           .     .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          Watcher        *i, *j, *end;
   745,525,030       0    0    745,525,030     3,847,681       0              0           0     0          num_props++;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
             .       .    .              .             .       .              .           .     .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
 2,530,379,311       3    1    457,980,483   443,630,207   2,410              0           0     0          for (int k = 0; k < ws_bin.size(); k++){
   514,169,090       0    0    514,169,090   200,023,639     346              0           0     0              Lit the_other = ws_bin[k].blocker;
20,714,231,745       0    0 19,107,892,649             0       0              0           0     0              if (value(the_other) == l_False){
       239,692       1    0        119,846             0       0        119,846           0     0                  confl = ws_bin[k].cref;
             .       .    .              .             .       .              .           .     .                  //auto end_time=std::chrono::steady_clock::now();
             .       .    .              .             .       .              .           .     .                  //auto duration=end_time-start_time;
             .       .    .              .             .       .              .           .     .  #ifdef LOOSE_PROP_STAT
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                  return confl;
             .       .    .              .             .       .              .           .     .  #else
             .       .    .              .             .       .              .           .     .                  goto ExitProp;
             .       .    .              .             .       .              .           .     .  #endif
   642,508,464       4    1              0             0       0              0           0     0              }else if(value(the_other) == l_Undef)
             .       .    .              .             .       .              .           .     .              {
   621,493,780       2    0    372,896,268             0       0    124,298,756   1,095,211     0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
             .       .    .              .             .       .              .           .     .  #ifdef  PRINT_OUT                
             .       .    .              .             .       .              .           .     .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
             .       .    .              .             .       .              .           .     .  #endif                
             .       .    .              .             .       .              .           .     .  			}
             .       .    .              .             .       .              .           .     .          }
   915,721,274       0    0    915,721,274   393,027,072     700              0           0     0          total_Watchers+=ws.size();
   457,860,637       0    0    457,860,637             0       0              0           0     0          total_indexs++;//number of rounds
             .       .    .              .             .       .              .           .     .          //int count=0;
   446,625,192       0    0              0             0       0              0           0     0          bool no_clause_access=true;
   446,625,192       0    0              0             0       0    446,625,192           0     0          bool no_implication_added=true;
   446,625,192       0    0              0             0       0    446,625,192           0     0          bool no_change_other_watch=true;
50,853,389,281      10    4 24,516,591,089             0       0    457,860,637           0     0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             .       .    .              .             .       .              .           .     .              // Try to avoid inspecting the clause:
             .       .    .              .             .       .              .           .     .              //count++;
24,058,730,452       3    1 24,058,730,452 3,361,544,887  25,408              0           0     0              Lit blocker = i->blocker;
48,117,460,904       0    0 24,058,730,452     1,569,051       1              0           0     0              total_access_watches++;
48,117,460,904       0    0 24,058,730,452   216,301,681      12              0           0     0              if (value(blocker) == l_True){
             .       .    .              .             .       .              .           .     .                  
71,433,724,172       0    0 17,858,431,043             0       0 17,858,431,043   4,100,350     0                  *j++ = *i++; continue; }//no clause accessed
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Make sure the false literal is data[1]:
 6,209,829,102       0    0      1,564,531             0       0              0           0     0              no_clause_access=false;
18,600,898,227       4    2 12,400,598,818     3,220,269       0  6,200,299,409           0     0              total_clause_access_times++;
12,400,598,818       0    0  6,200,299,409             0       0              0           0     0              CRef     cr        = i->cref;
             .       .    .              .             .       .              .           .     .              //std::cout<<"cr: "<<cr<<"\n";
             .       .    .              .             .       .              .           .     .              Clause&  c         = ca[cr];
             .       .    .              .             .       .              .           .     .              Lit      false_lit = ~p;
 6,200,299,409       0    0  6,200,299,409             0       0              0           0     0              total_clause_access_size+=2;
18,600,898,227       0    0 12,400,598,818 5,872,283,822  68,128              0           0     0              if (c[0] == false_lit)
11,477,563,256       0    0  5,738,781,628   167,691,841   1,795  5,738,781,628           0     0                  c[0] = c[1], c[1] = false_lit;
             .       .    .              .             .       .              .           .     .              assert(c[1] == false_lit);
             .       .    .              .             .       .              .           .     .              i++;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // If 0th watch is true, then clause is already satisfied.
             .       .    .              .             .       .              .           .     .              Lit     first = c[0];
             .       .    .              .             .       .              .           .     .              Watcher w     = Watcher(cr, first);
15,702,584,590       0    0  1,650,992,886    13,703,596       0              0           0     0              if (first != blocker && value(first) == l_True){
 3,748,384,818       0    0              0             0       0  2,498,923,212   1,432,854     0                  *j++ = w; continue; }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Look for new watch:
31,177,215,559       3    1              0             0       0              0           0     0              for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .     .              {
55,665,940,528       0    0              0             0       0 11,667,763,997           0     0                  total_clause_access_size++;
36,282,112,088       0    0  3,044,908,488             0       0              0           0     0                  if (value(c[k]) != l_False){
18,303,669,384   7,247    1  9,151,834,692             0       0  9,151,834,692           0     0                      c[1] = c[k]; c[k] = false_lit;
 4,575,917,346       0    0  4,575,917,346             0       0              0           0     0                      total_change_other_watch++;
 4,575,917,346       0    0              0             0       0  4,575,917,346           0     0                      no_change_other_watch=false;
             .       .    .              .             .       .              .           .     .                      watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .     .                      goto NextClause; }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Did not find watch -- clause is unit under assignment:
 1,126,468,409       0    0              0             0       0    749,840,914     137,164     0              *j++ = w;
   749,840,914       0    0              0             0       0              0           0     0              if (value(first) == l_False){
     1,707,038       0    0      1,707,038             0       0              0           0     0                  time_find_conflict++;
    10,242,228       1    0      6,828,152        15,434       0              0           0     0                  total_find_conflict_length+=i-(Watcher*)ws;
     3,414,076       0    0      3,414,076             0       0              0           0     0                  total_find_conflict_allsize+=ws.size();
             .       .    .              .             .       .              .           .     .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
     1,707,038       0    0              0             0       0      1,707,038           0     0                  confl = cr;
     3,414,076       0    0      1,707,038         5,047       0      1,707,038           0     0                  qhead = trail.size();
             .       .    .              .             .       .              .           .     .                  // Copy the remaining watches:
             .       .    .              .             .       .              .           .     .  
   138,106,218       5    3      3,271,569           107       0              0           0     0                  while (i < end)
    64,928,021       0    0     64,928,021     8,071,492     151     64,928,021      99,095     0                      *j++ = *i++;
             .       .    .              .             .       .              .           .     .              }else
             .       .    .              .             .       .              .           .     .              {//new implecate
   373,213,419       0    0              0             0       0    373,213,419           0     0                  no_implication_added=false;
   373,213,419       0    0    373,213,419             0       0              0           0     0                  total_push_new_implication++;
 1,119,640,257       0    0    746,426,838       755,211       0              0           0     0  				if (currLevel == decisionLevel())
             .       .    .              .             .       .              .           .     .  				{
   746,426,838       0    0              0             0       0              0           0     0  					uncheckedEnqueue(first, currLevel, cr);
             .       .    .              .             .       .              .           .     .  #ifdef PRINT_OUT					
             .       .    .              .             .       .              .           .     .  					std::cout << "i " << first << " l " << currLevel << "\n";
             .       .    .              .             .       .              .           .     .  #endif					
             .       .    .              .             .       .              .           .     .  				}
             .       .    .              .             .       .              .           .     .  				else
             .       .    .              .             .       .              .           .     .  				{
             .       .    .              .             .       .              .           .     .  					int nMaxLevel = currLevel;
        13,118       0    0              0             0       0              0           0     0  					int nMaxInd = 1;
             .       .    .              .             .       .              .           .     .  					// pass over all the literals in the clause and find the one with the biggest level
        45,168       0    0          6,559             0       0              0           0     0  					for (int nInd = 2; nInd < c.size(); ++nInd)
             .       .    .              .             .       .              .           .     .  					{
             .       .    .              .             .       .              .           .     .  						int nLevel = level(var(c[nInd]));
        20,558       0    0              0             0       0              0           0     0  						if (nLevel > nMaxLevel)
             .       .    .              .             .       .              .           .     .  						{
             .       .    .              .             .       .              .           .     .  							nMaxLevel = nLevel;
             .       .    .              .             .       .              .           .     .  							nMaxInd = nInd;
             .       .    .              .             .       .              .           .     .  						}
             .       .    .              .             .       .              .           .     .  					}
             .       .    .              .             .       .              .           .     .  
        13,118       2    1              0             0       0              0           0     0  					if (nMaxInd != 1)
             .       .    .              .             .       .              .           .     .  					{
             .       .    .              .             .       .              .           .     .  						std::swap(c[1], c[nMaxInd]);
             .       .    .              .             .       .              .           .     .  						*j--; // undo last watch
           779       0    0            779             0       0              0           0     0                          total_change_other_watch++;
           779       0    0              0             0       0            779           0     0                          no_change_other_watch=false;
             .       .    .              .             .       .              .           .     .  						watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .     .  					}
             .       .    .              .             .       .              .           .     .  					
 1,866,073,654       0    0    373,213,419             0       0    373,213,419   2,645,968     0  					uncheckedEnqueue(first, nMaxLevel, cr);
             .       .    .              .             .       .              .           .     .  #ifdef PRINT_OUT					
             .       .    .              .             .       .              .           .     .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
             .       .    .              .             .       .              .           .     .  #endif	
             .       .    .              .             .       .              .           .     .  				}
             .       .    .              .             .       .              .           .     .  			}
             .       .    .              .             .       .              .           .     .  
     1,564,531     113   12              0             0       0              0           0     0  NextClause:;
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
 2,233,125,960       0    0    446,625,192             0       0              0           0     0          if(no_clause_access==true){
    94,676,557      77    5     94,676,557         1,656       0              0           0     0              total_no_clause_access++;
             .       .    .              .             .       .              .           .     .          }
   976,691,496      24   10    446,625,192             0       0              0           0     0          if(no_implication_added==true){
   246,274,157       1    0    235,038,712            23       0              0           0     0              total_no_implication_added++;
             .       .    .              .             .       .              .           .     .          }
   988,413,341       0    0    446,625,192             0       0              0           0     0          if(no_change_other_watch==true){
   170,196,244     387    4    170,196,244             8       0              0           0     0              total_no_change_other_watch++;
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          ws.shrink(i - j);
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  ExitProp:;
     8,398,946       3    1      8,398,946     1,414,636       0              0           0     0      propagations += num_props;
     4,199,473       0    0      4,199,473             0       0              0           0     0      simpDB_props -= num_props;
             .       .    .              .             .       .              .           .     .  
     4,199,473       0    0      4,199,473             0       0              0           0     0      return confl;
 1,940,483,867   3,491    2     30,235,233     3,222,243       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .     .  |
             .       .    .              .             .       .              .           .     .  |  reduceDB : ()  ->  [void]
             .       .    .              .             .       .              .           .     .  |  
             .       .    .              .             .       .              .           .     .  |  Description:
             .       .    .              .             .       .              .           .     .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
             .       .    .              .             .       .              .           .     .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
             .       .    .              .             .       .              .           .     .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .     .  struct reduceDB_lt { 
             .       .    .              .             .       .              .           .     .      ClauseAllocator& ca;
             .       .    .              .             .       .              .           .     .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    85,971,978     242   47     84,279,840    27,809,299      90              0           0     0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
             .       .    .              .             .       .              .           .     .  };
             .       .    .              .             .       .              .           .     .  void Solver::reduceDB()
           726     111    3              0             0       0            484           0     0  {
             .       .    .              .             .       .              .           .     .      int     i, j;
             .       .    .              .             .       .              .           .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .       .    .              .             .       .              .           .     .      //local_learnts_dirty = false;
             .       .    .              .             .       .              .           .     .  
           121       0    0              0             0       0              0           0     0      sort(learnts_local, reduceDB_lt(ca));
             .       .    .              .             .       .              .           .     .  
           605       0    0            121           121       0              0           0     0      int limit = learnts_local.size() / 2;
     6,884,813     121    6              0             0       0              0           0     0      for (i = j = 0; i < learnts_local.size(); i++){
    10,326,312     121    6      6,884,208       215,276       0              0           0     0          Clause& c = ca[learnts_local[i]];
     6,884,208       0    0      3,442,104     3,393,226      13              0           0     0          if (c.mark() == LOCAL)
    12,996,076       0    0      3,364,559             0       0              0           0     0              if (c.removable() && !locked(c) && i < limit)
     8,505,205       0    0      1,701,041             0       0      1,701,041           0     0                  removeClause(learnts_local[i]);
             .       .    .              .             .       .              .           .     .              else{
       230,433       0    0              0             0       0              0           0     0                  if (!c.removable()) limit++;
             .       .    .              .             .       .              .           .     .                  c.removable(true);
     8,472,680       0    0      1,663,518             0       0      1,663,518     104,165     0                  learnts_local[j++] = learnts_local[i]; }
             .       .    .              .             .       .              .           .     .      }
           121       0    0              0             0       0              0           0     0      learnts_local.shrink(i - j);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      checkGarbage();
           606       0    0            485           121       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  void Solver::reduceDB_Tier2()
         1,092     169    3              0             0       0            910           0     0  {
             .       .    .              .             .       .              .           .     .      int i, j;
     3,899,486     119    3            182           114       0              0           0     0      for (i = j = 0; i < learnts_tier2.size(); i++){
     4,813,380     163    3      3,208,920       100,419     377              0           0     0          Clause& c = ca[learnts_tier2[i]];
     3,208,920       0    0              0             0       0              0           0     0          if (c.mark() == TIER2)
     7,837,550     181    4      3,135,020     1,357,892       0              0           0     0              if (!locked(c) && c.touched() + 30000 < conflicts){
             .       .    .              .             .       .              .           .     .                  learnts_local.push(learnts_tier2[i]);
             .       .    .              .             .       .              .           .     .                  c.mark(LOCAL);
             .       .    .              .             .       .              .           .     .                  //c.removable(true);
             .       .    .              .             .       .              .           .     .                  c.activity() = 0;
             .       .    .              .             .       .              .           .     .                  claBumpActivity(c);
             .       .    .              .             .       .              .           .     .              }else
     6,298,615       0    0      1,259,723             0       0      1,259,723      57,758     0                  learnts_tier2[j++] = learnts_tier2[i];
             .       .    .              .             .       .              .           .     .      }
           182       0    0              0             0       0              0           0     0      learnts_tier2.shrink(i - j);
         1,092       0    0          1,092           182       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::removeSatisfied(vec<CRef>& cs)
           198       0    0              0             0       0             88           0     0  {
             .       .    .              .             .       .              .           .     .      int i, j;
       744,484      12    1        148,906            10       0              0           0     0      for (i = j = 0; i < cs.size(); i++){
       446,649       0    0        297,766         9,318       0              0           0     0          Clause& c = ca[cs[i]];
             .       .    .              .             .       .              .           .     .          if (satisfied(c))
           505       8    1              1             0       0            168          25     0              removeClause(cs[i]);
             .       .    .              .             .       .              .           .     .          else
       297,430       0    0              0             0       0        148,715           0     0              cs[j++] = cs[i];
             .       .    .              .             .       .              .           .     .      }
            22       0    0              0             0       0              0           0     0      cs.shrink(i - j);
           132       4    0            110            33       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
           144       0    0              0             0       0            120           0     0  {
             .       .    .              .             .       .              .           .     .      int i, j;
       122,430      11    1             24            12       0              0           0     0      for (i = j = 0; i < cs.size(); i++){
       178,722       0    0        119,148         3,742       0              0           0     0          Clause& c = ca[cs[i]];
       119,148       0    0              0             0       0              0           0     0          if (c.mark() == valid_mark)
             .       .    .              .             .       .              .           .     .              if (satisfied(c))
             .       .    .              .             .       .              .           .     .                  removeClause(cs[i]);
             .       .    .              .             .       .              .           .     .              else
       290,175       0    0         58,035             0       0         58,035       1,078     0                  cs[j++] = cs[i];
             .       .    .              .             .       .              .           .     .      }
            22       0    0              0             0       0              0           0     0      cs.shrink(i - j);
           144       9    2            144            33       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::rebuildOrderHeap()
           117       3    1              0             0       0             78           0     0  {
             .       .    .              .             .       .              .           .     .      vec<Var> vs;
        93,470       0    0             13             0       0             13           0     0      for (Var v = 0; v < nVars(); v++)
       272,646       0    0        136,323         1,200       0              0           0     0          if (decision[v] && value(v) == l_Undef)
             .       .    .              .             .       .              .           .     .              vs.push(v);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      order_heap_CHB  .build(vs);
             .       .    .              .             .       .              .           .     .      order_heap_VSIDS.build(vs);
             .       .    .              .             .       .              .           .     .      order_heap_distance.build(vs);
           104      13    1             91            25       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .     .  |
             .       .    .              .             .       .              .           .     .  |  simplify : [void]  ->  [bool]
             .       .    .              .             .       .              .           .     .  |  
             .       .    .              .             .       .              .           .     .  |  Description:
             .       .    .              .             .       .              .           .     .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
             .       .    .              .             .       .              .           .     .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
             .       .    .              .             .       .              .           .     .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .     .  bool Solver::simplify()
        22,620     749    3              0             0       0         15,080           0     0  {
             .       .    .              .             .       .              .           .     .      assert(decisionLevel() == 0);
             .       .    .              .             .       .              .           .     .  
        18,850       0    0          3,770         1,737       0              0           0     0      if (!ok || propagate() != CRef_Undef)
             .       .    .              .             .       .              .           .     .          return ok = false;
             .       .    .              .             .       .              .           .     .  
        11,366     179    6          7,568             0       0              0           0     0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
             .       .    .              .             .       .              .           .     .          return true;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Remove satisfied clauses:
            36       0    0              0             0       0             12           0     0      removeSatisfied(learnts_core); // Should clean core first.
            48       0    0              0             0       0             12           0     0      safeRemoveSatisfied(learnts_tier2, TIER2);
            48      12    1              0             0       0             12           0     0      safeRemoveSatisfied(learnts_local, LOCAL);
            24       0    0             12            10       0              0           0     0      if (remove_satisfied)        // Can be turned off.
            44      22    1              0             0       0             11           0     0          removeSatisfied(clauses);
             .       .    .              .             .       .              .           .     .      checkGarbage();
            24       1    1              0             0       0             12           0     0      rebuildOrderHeap();
             .       .    .              .             .       .              .           .     .  
            24       0    0             12            12       0             12           0     0      simpDB_assigns = nAssigns();
            36       0    0             24            12       0             12           0     0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
             .       .    .              .             .       .              .           .     .  
            12       0    0              0             0       0              0           0     0      return true;
        26,390       0    0         18,850             0       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  // pathCs[k] is the number of variables assigned at level k,
             .       .    .              .             .       .              .           .     .  // it is initialized to 0 at the begining and reset to 0 after the function execution
        80,144      11    1              0             0       0         60,108           0     0  bool Solver::collectFirstUIP(CRef confl){
        20,036       0    0              0             0       0         10,018           0     0      involved_lits.clear();
       985,252       9    1              0             0       0              0           0     0      int max_level=1;
             .       .    .              .             .       .              .           .     .      Clause& c=ca[confl]; int minLevel=decisionLevel();
       120,601       0    0         10,018             0       0              0           0     0      for(int i=0; i<c.size(); i++) {
             .       .    .              .             .       .              .           .     .          Var v=var(c[i]);
             .       .    .              .             .       .              .           .     .          //        assert(!seen[v]);
       105,723      58    1         35,241         7,471       0              0           0     0          if (level(v)>0) {
        70,402       0    0         35,201         8,371       0         35,201      23,062     0              seen[v]=1;
        80,420       0    0         45,219        17,814       0         35,201      31,910     0              var_iLevel_tmp[v]=1;
        35,201       0    0         35,201        17,383       0              0           0     0              pathCs[level(v)]++;
             .       .    .              .             .       .              .           .     .              if (minLevel>level(v)) {
             .       .    .              .             .       .              .           .     .                  minLevel=level(v);
             .       .    .              .             .       .              .           .     .                  assert(minLevel>0);
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              //    varBumpActivity(v);
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
        30,054       0    0         20,036         8,499       0              0           0     0      int limit=trail_lim[minLevel-1];
    30,188,280       0    0         10,018             0       0              0           0     0      for(int i=trail.size()-1; i>=limit; i--) {
    15,074,104     327    1     15,074,104       436,822       0              0           0     0          Lit p=trail[i]; Var v=var(p);
    15,074,104       0    0      7,537,052       415,769       0              0           0     0          if (seen[v]) {
             .       .    .              .             .       .              .           .     .              int currentDecLevel=level(v);
             .       .    .              .             .       .              .           .     .              //      if (currentDecLevel==decisionLevel())
             .       .    .              .             .       .              .           .     .              //      	varBumpActivity(v);
       625,206       0    0              0             0       0        625,206           0     0              seen[v]=0;
     1,250,412       0    0        625,206           676       0              0           0     0              if (--pathCs[currentDecLevel]!=0) {
             .       .    .              .             .       .              .           .     .                  Clause& rc=ca[reason(v)];
     1,900,378       7    1      1,387,716         3,162       0              0           0     0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
       925,144       0    0              0             0       0              0           0     0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
     1,266,828       0    0              0             0       0              0           0     0                  if (rc.size()==2 && value(rc[0])==l_False) {
             .       .    .              .             .       .              .           .     .                      // Special case for binary clauses
             .       .    .              .             .       .              .           .     .                      // The first one has to be SAT
             .       .    .              .             .       .              .           .     .                      assert(value(rc[1]) != l_False);
             .       .    .              .             .       .              .           .     .                      Lit tmp = rc[0];
        38,841       0    0         12,947           524       0         25,894           0     0                      rc[0] =  rc[1], rc[1] = tmp;
             .       .    .              .             .       .              .           .     .                  }
     2,431,588       0    0              0             0       0              0           0     0                  for (int j = 1; j < rc.size(); j++){
             .       .    .              .             .       .              .           .     .                      Lit q = rc[j]; Var v1=var(q);
     1,848,128       0    0              0             0       0              0           0     0                      if (level(v1) > 0) {
     1,830,176       0    0              0             0       0              0           0     0                          if (minLevel>level(v1)) {
        94,124       0    0         47,062        17,821       0              0           0     0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
             .       .    .              .             .       .              .           .     .                          }
     2,745,264       0    0      1,830,176        38,063       0              0           0     0                          if (seen[v1]) {
       650,166       0    0        325,083         2,875       0              0           0     0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
       403,610       0    0              0             0       0        201,805           0     0                                  var_iLevel_tmp[v1]=reasonVarLevel;
             .       .    .              .             .       .              .           .     .                          }
             .       .    .              .             .       .              .           .     .                          else {
       590,005       0    0              0             0       0        590,005     351,994     0                              var_iLevel_tmp[v1]=reasonVarLevel;
             .       .    .              .             .       .              .           .     .                              //   varBumpActivity(v1);
       590,005       0    0              0             0       0        590,005           0     0                              seen[v1] = 1;
     1,770,015       4    1      1,180,010        63,001       0              0           0     0                              pathCs[level(v1)]++;
             .       .    .              .             .       .              .           .     .                          }
             .       .    .              .             .       .              .           .     .                      }
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              involved_lits.push(p);
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
        30,054   1,148    1         10,018             0       0         10,018           0     0      double inc=var_iLevel_inc;
             .       .    .              .             .       .              .           .     .      vec<int> level_incs; level_incs.clear();
       772,634       0    0        297,032             0       0              0           0     0      for(int i=0;i<max_level;i++){
       317,068       4    1        158,534             0       0              0           0     0          level_incs.push(inc);
       475,602       0    0        317,068             1       0        158,534           0     0          inc = inc/my_var_decay;
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
     1,290,484       0    0        635,224             0       0              0           0     0      for(int i=0;i<involved_lits.size();i++){
        10,018       0    0         10,018             0       0              0           0     0          Var v =var(involved_lits[i]);
             .       .    .              .             .       .              .           .     .          //        double old_act=activity_distance[v];
             .       .    .              .             .       .              .           .     .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
     5,787,142   5,959    2      1,915,690       518,204       0        635,224           0     0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
             .       .    .              .             .       .              .           .     .  
     1,250,412       0    0              0             0       0              0           0     0          if(activity_distance[v]>1e100){
             .       .    .              .             .       .              .           .     .              for(int vv=0;vv<nVars();vv++)
        50,090   1,167    1         20,036        18,899       0         20,036           0     0                  activity_distance[vv] *= 1e-100;
             .       .    .              .             .       .              .           .     .              var_iLevel_inc*=1e-100;
        27,726      39    1              0             0       0              0           0     0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .          if (order_heap_distance.inHeap(v))
             .       .    .              .             .       .              .           .     .              order_heap_distance.decrease(v);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          //        var_iLevel_inc *= (1 / my_var_decay);
             .       .    .              .             .       .              .           .     .      }
        50,090     128    1         20,036             3       0         10,018           0     0      var_iLevel_inc=level_incs[level_incs.size()-1];
             .       .    .              .             .       .              .           .     .      return true;
        90,162       0    0         70,126         4,348       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  struct UIPOrderByILevel_Lt {
             .       .    .              .             .       .              .           .     .      Solver& solver;
             .       .    .              .             .       .              .           .     .      const vec<double>&  var_iLevel;
             .       .    .              .             .       .              .           .     .      bool operator () (Lit x, Lit y) const
             .       .    .              .             .       .              .           .     .      {
             .       .    .              .             .       .              .           .     .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
             .       .    .              .             .       .              .           .     .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
             .       .    .              .             .       .              .           .     .  |    Search for a model the specified number of conflicts. 
             .       .    .              .             .       .              .           .     .  |  
             .       .    .              .             .       .              .           .     .  |  Output:
             .       .    .              .             .       .              .           .     .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
             .       .    .              .             .       .              .           .     .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
             .       .    .              .             .       .              .           .     .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
             .       .    .              .             .       .              .           .     .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .     .  lbool Solver::search(int& nof_conflicts)
        41,349   3,063    8              0             0       0         26,313          41     0  {
             .       .    .              .             .       .              .           .     .      assert(ok);
             .       .    .              .             .       .              .           .     .      int         backtrack_level;
             .       .    .              .             .       .              .           .     .      int         lbd;
             .       .    .              .             .       .              .           .     .      vec<Lit>    learnt_clause;
             .       .    .              .             .       .              .           .     .      bool        cached = false;
         3,759       0    0          3,759           138       0              0           0     0      starts++;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // simplify
             .       .    .              .             .       .              .           .     .      //
        15,036       3    3         11,277         3,759       4              0           0     0      if (conflicts >= curSimplify * nbconfbeforesimplify){
             .       .    .              .             .       .              .           .     .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
             .       .    .              .             .       .              .           .     .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
             .       .    .              .             .       .              .           .     .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
             .       .    .              .             .       .              .           .     .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
            41      26    9             41            32       0              0           0     0          nbSimplifyAll++;
           123      41   17              0             0       0             41           0     0          if (!simplifyAll()){
             .       .    .              .             .       .              .           .     .              return l_False;
             .       .    .              .             .       .              .           .     .          }
           287       0    0             82             1       0             41           0     0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
           123       0    0             41             0       0             41           0     0          nbconfbeforesimplify += incSimplify;
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      for (;;){
             .       .    .              .             .       .              .           .     .          CRef confl = propagate();
             .       .    .              .             .       .              .           .     .  
     8,630,472       0    0              0             0       0              0           0     0          if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .     .              // CONFLICT
     5,480,652       0    0      1,826,884        14,776       0              0           0     0              if (VSIDS){
     1,531,680       0    0        765,825       751,008       1             30           0     0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
             .       .    .              .             .       .              .           .     .              }else
     4,203,321      31    3      2,462,213     1,047,019       0        340,001           0     0                  if (step_size > min_step_size) step_size -= step_size_dec;
             .       .    .              .             .       .              .           .     .  
     7,307,536     109   37      3,653,768     1,851,874       0      1,826,884           0     0              conflicts++; nof_conflicts--;
             .       .    .              .             .       .              .           .     .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
             .       .    .              .             .       .              .           .     .              ConflictData data = FindConflictLevel(confl);
     3,653,768      34    1              0             0       0              0           0     0              if (data.nHighestLevel == 0) return l_False;
           240       0    0            104             0       0              0           0     0              if (data.bOnlyOneLitFromHighest)
             .       .    .              .             .       .              .           .     .              {
            16       2    0              0             0       0              0           0     0  				cancelUntil(data.nHighestLevel - 1);
             .       .    .              .             .       .              .           .     .  				continue;
             .       .    .              .             .       .              .           .     .  			}
             .       .    .              .             .       .              .           .     .  			
             .       .    .              .             .       .              .           .     .              learnt_clause.clear();
     3,653,736       0    0              0             0       0      1,826,868   1,772,672     0              if(conflicts>50000) DISTANCE=0;
             .       .    .              .             .       .              .           .     .              else DISTANCE=1;
     5,185,264       0    0              0             0       0              0           0     0              if(VSIDS && DISTANCE)
        40,072       7    1              0             0       0         10,018           0     0                  collectFirstUIP(confl);
             .       .    .              .             .       .              .           .     .  
    10,961,208     127    7              0             0       0      1,826,868           0     0              analyze(confl, learnt_clause, backtrack_level, lbd);
             .       .    .              .             .       .              .           .     .              // check chrono backtrack condition
    25,548,159      57   15      9,130,341       827,361       0              0           0     0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
             .       .    .              .             .       .              .           .     .              {
           125       0    0            125             0       0              0           0     0  				++chrono_backtrack;
           125       0    0              0             0       0              0           0     0  				cancelUntil(data.nHighestLevel -1);
             .       .    .              .             .       .              .           .     .  			}
             .       .    .              .             .       .              .           .     .  			else // default behavior
             .       .    .              .             .       .              .           .     .  			{
     1,826,743     566   15      1,826,743         7,029       0              0           0     0  				++non_chrono_backtrack;
             .       .    .              .             .       .              .           .     .  				cancelUntil(backtrack_level);
             .       .    .              .             .       .              .           .     .  			}
             .       .    .              .             .       .              .           .     .  
     5,480,604       0    0      1,826,868     1,134,569       0      1,826,868           0     0              lbd--;
     3,653,736       0    0      1,826,868             0       0              0           0     0              if (VSIDS){
       765,764      21   10              0             0       0        765,764           0     0                  cached = false;
     2,297,292     152    6      2,297,292       840,953       0              0           0     0                  conflicts_VSIDS++;
             .       .    .              .             .       .              .           .     .                  lbd_queue.push(lbd);
     6,126,112       0    0      2,297,292             0       0        765,764           0     0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
             .       .    .              .             .       .              .           .     .  
     5,480,604      46   14      1,826,868             0       0              0           0     0              if (learnt_clause.size() == 1){
            98       0    0             28             7       0             14           0     0                  uncheckedEnqueue(learnt_clause[0]);
             .       .    .              .             .       .              .           .     .              }else{
             .       .    .              .             .       .              .           .     .                  CRef cr = ca.alloc(learnt_clause, true);
     1,826,854       0    0      1,826,854             0       0              0           0     0                  ca[cr].set_lbd(lbd);
             .       .    .              .             .       .              .           .     .                  //duplicate learnts 
             .       .    .              .             .       .              .           .     .                  int  id = 0;
     3,653,708       0    0      1,826,854     1,821,058       0              0           0     0                  if (lbd <= max_lbd_dup){                        
             .       .    .              .             .       .              .           .     .                      std::vector<uint32_t> tmp;
   183,275,215       0    0    128,322,934             0       0      1,391,854           0     0                      for (int i = 0; i < learnt_clause.size(); i++)
   131,106,642       9    2     87,404,428             0       0     43,702,214           0     0                          tmp.push_back(learnt_clause[i].x);
     4,175,562       4    1      1,391,854             0       0      1,391,854           0     0                      id = is_duplicate(tmp);             
     6,959,270       0    0      1,391,854           891       0              0           0     0                      if (id == min_number_of_learnts_copies +1){
            19       0    0             19             7       0              0           0     0                          duplicates_added_conflicts++;                        
             .       .    .              .             .       .              .           .     .                      }                    
     2,783,708       0    0              0             0       0              0           0     0                      if (id == min_number_of_learnts_copies){
           358       0    0            358             0       0              0           0     0                          duplicates_added_tier2++;
             .       .    .              .             .       .              .           .     .                      }                                        
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .                  //duplicate learnts
             .       .    .              .             .       .              .           .     .  
    10,885,872       0    0      3,634,895     1,019,007       1              0           0     0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
            16       1    1              0             0       0              0           0     0                      learnts_core.push(cr);
             .       .    .              .             .       .              .           .     .                      ca[cr].mark(CORE);
     6,608,678   1,968   11              0             0       0              0           0     0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
            21       2    1              0             0       0              0           0     0                      learnts_tier2.push(cr);
             .       .    .              .             .       .              .           .     .                      ca[cr].mark(TIER2);
     1,247,004       0    0        311,751             3       0        311,751         146     0                      ca[cr].touched() = conflicts;
             .       .    .              .             .       .              .           .     .                  }else{
            23      19    1              0             0       0              0           0     0                      learnts_local.push(cr);
             .       .    .              .             .       .              .           .     .                      claBumpActivity(ca[cr]); }
     5,480,562   4,359    6              0             0       0      1,826,854           0     0                  attachClause(cr);
             .       .    .              .             .       .              .           .     .  
    10,961,124       0    0      5,480,562           931       0      1,826,854           0     0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
             .       .    .              .             .       .              .           .     .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .     .                  std::cout << "new " << ca[cr] << "\n";
             .       .    .              .             .       .              .           .     .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
             .       .    .              .             .       .              .           .     .  #endif                
             .       .    .              .             .       .              .           .     .              }
     5,480,604       0    0      1,826,868       541,814       0              0           0     0              if (drup_file){
             .       .    .              .             .       .              .           .     .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .     .                  binDRUP('a', learnt_clause, drup_file);
             .       .    .              .             .       .              .           .     .  #else
             .       .    .              .             .       .              .           .     .                  for (int i = 0; i < learnt_clause.size(); i++)
             .       .    .              .             .       .              .           .     .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
             .       .    .              .             .       .              .           .     .                  fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
     5,480,604   1,189    9      3,653,736       764,251       0              0           0     0              if (VSIDS) varDecayActivity();
             .       .    .              .             .       .              .           .     .              claDecayActivity();
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              /*if (--learntsize_adjust_cnt == 0){
             .       .    .              .             .       .              .           .     .                  learntsize_adjust_confl *= learntsize_adjust_inc;
             .       .    .              .             .       .              .           .     .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
             .       .    .              .             .       .              .           .     .                  max_learnts             *= learntsize_inc;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
             .       .    .              .             .       .              .           .     .                             (int)conflicts,
             .       .    .              .             .       .              .           .     .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
             .       .    .              .             .       .              .           .     .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
             .       .    .              .             .       .              .           .     .              }*/
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .          }else{
             .       .    .              .             .       .              .           .     .              // NO CONFLICT
             .       .    .              .             .       .              .           .     .              bool restart = false;
     7,465,056      41    6      2,488,352       169,957       0              0           0     0              if (!VSIDS)
             .       .    .              .             .       .              .           .     .                  restart = nof_conflicts <= 0;
     2,269,682       1    1      1,134,841       663,374       0              0           0     0              else if (!cached){
     6,339,956       0    0      1,800,538       677,972       0        386,729           0     0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
             .       .    .              .             .       .              .           .     .                  cached = true;
             .       .    .              .             .       .              .           .     .              }
     4,060,533       0    0      1,353,511       955,021       0              0           0     0              if (restart /*|| !withinBudget()*/){
             .       .    .              .             .       .              .           .     .                  lbd_queue.clear();
             .       .    .              .             .       .              .           .     .                  cached = false;
             .       .    .              .             .       .              .           .     .                  // Reached bound on number of conflicts:
        11,274       0    0              0             0       0          7,516           0     0                  progress_estimate = progressEstimate();
             .       .    .              .             .       .              .           .     .                  cancelUntil(0);
         7,516       0    0              0             0       0              0           0     0                  return l_Undef; }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Simplify the set of problem clauses:
     7,809,510     170    7      2,484,594             0       0        344,417           0     0              if (decisionLevel() == 0 && !simplify())
             .       .    .              .             .       .              .           .     .                  return l_False;
             .       .    .              .             .       .              .           .     .  
     7,453,782      93    4      4,969,188         3,052       1              0           0     0              if (conflicts >= next_T2_reduce){
           364       0    0              0             0       0            182           0     0                  next_T2_reduce = conflicts + 10000;
           728       0    0            182             0       0            182           0     0                  reduceDB_Tier2(); }
     4,969,188      42    3      2,484,594             0       0              0           0     0              if (conflicts >= next_L_reduce){
           242       0    0              0             0       0            121           0     0                  next_L_reduce = conflicts + 15000;
           242       0    0              0             0       0            121           0     0                  reduceDB(); }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              Lit next = lit_Undef;
             .       .    .              .             .       .              .           .     .              /*while (decisionLevel() < assumptions.size()){
             .       .    .              .             .       .              .           .     .                  // Perform user provided assumption:
             .       .    .              .             .       .              .           .     .                  Lit p = assumptions[decisionLevel()];
             .       .    .              .             .       .              .           .     .                  if (value(p) == l_True){
             .       .    .              .             .       .              .           .     .                      // Dummy decision level:
             .       .    .              .             .       .              .           .     .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
             .       .    .              .             .       .              .           .     .                  }else{
             .       .    .              .             .       .              .           .     .                      next = p;
             .       .    .              .             .       .              .           .     .                      break;
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              if (next == lit_Undef)*/{
             .       .    .              .             .       .              .           .     .                  // New variable decision:
     2,484,594       0    0      2,484,594           121       0              0           0     0                  decisions++;
     7,453,782     714   15              0             0       0      2,484,594           0     0                  next = pickBranchLit();
             .       .    .              .             .       .              .           .     .  
     4,969,188       0    0              0             0       0              0           0     0                  if (next == lit_Undef)
             .       .    .              .             .       .              .           .     .                      // Model found:
             2       0    0              0             0       0              0           0     0                      return l_True;
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .              // Increase decision level and enqueue 'next'
             .       .    .              .             .       .              .           .     .              newDecisionLevel();
    14,907,558      44   15      2,484,593             0       0      2,484,593           0     0              uncheckedEnqueue(next, decisionLevel());
             .       .    .              .             .       .              .           .     .  #ifdef PRINT_OUT            
             .       .    .              .             .       .              .           .     .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
             .       .    .              .             .       .              .           .     .  #endif            
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
        33,831      98    9         26,313         7,515       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  double Solver::progressEstimate() const
        22,548       4    4              0             0       0         18,790           0     0  {
         7,516       0    0              0             0       0              0           0     0      double  progress = 0;
        18,790       0    0          7,516         2,247       0          3,758           0     0      double  F = 1.0 / nVars();
             .       .    .              .             .       .              .           .     .  
       349,222       3    3              0             0       0              0           0     0      for (int i = 0; i <= decisionLevel(); i++){
       326,674       0    0        212,772             0       0              0           0     0          int beg = i == 0 ? 0 : trail_lim[i - 1];
       436,818       0    0        216,530         7,901       0              0           0     0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
       672,138      24    7        113,902             0       0              0           0     0          progress += pow(F, i) * (end - beg);
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
         7,516       0    0              0             0       0              0           0     0      return progress / nVars();
        26,306       0    0         22,548             0       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  /*
             .       .    .              .             .       .              .           .     .    Finite subsequences of the Luby-sequence:
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .    0: 1
             .       .    .              .             .       .              .           .     .    1: 1 1 2
             .       .    .              .             .       .              .           .     .    2: 1 1 2 1 1 2 4
             .       .    .              .             .       .              .           .     .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .   */
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  static double luby(double y, int x){
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Find the finite subsequence that contains index 'x', and the
             .       .    .              .             .       .              .           .     .      // size of that subsequence:
             .       .    .              .             .       .              .           .     .      int size, seq;
       102,403       0    0              0             0       0              0           0     0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
             .       .    .              .             .       .              .           .     .  
        57,358       4    4              0             0       0              0           0     0      while (size-1 != x){
        32,796       0    0              0             0       0              0           0     0          size = (size-1)>>1;
        16,398       0    0              0             0       0              0           0     0          seq--;
        49,194       0    0              0             0       0              0           0     0          x = x % size;
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      return pow(y, seq);
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  static bool switch_mode = false;
             .       .    .              .             .       .              .           .     .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
             .       .    .              .             .       .              .           .     .  
            16       2    2              0             0       0             12           0     0  uint32_t Solver::reduceduplicates(){
             .       .    .              .             .       .              .           .     .      uint32_t removed_duplicates = 0;
             .       .    .              .             .       .              .           .     .      std::vector<std::vector<uint64_t>> tmp;
             .       .    .              .             .       .              .           .     .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
         9,088       0    0              4             0       0              0           0     0      for (auto & outer_mp: ht){//variables
       101,083       0    0              0             0       0              0           0     0          for (auto &inner_mp:outer_mp.second){//sizes
     2,115,966       0    0              0             0       0              0           0     0              for (auto &in_in_mp: inner_mp.second){
     3,042,741       2    2      1,014,247       977,882 372,699              0           0     0                  if (in_in_mp.second >= 2){
             .       .    .              .             .       .              .           .     .                  //min_number_of_learnts_copies
       658,860       2    2        263,544           611     366        263,544         339     0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
             .       .    .              .             .       .              .           .     .                  }
             .       .    .              .             .       .              .           .     .              }                    
             .       .    .              .             .       .              .           .     .           }
             .       .    .              .             .       .              .           .     .      }          
             6       0    0              2             2       0              2           0     0      removed_duplicates = dupl_db_size-tmp.size();  
             .       .    .              .             .       .              .           .     .      ht.clear();
       461,212       2    2        197,660            25       0              0           0     0      for (auto i=0;i<tmp.size();i++){
       658,860       0    0        329,430        74,163   9,340        197,658          14     0          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .      return removed_duplicates;
            18       0    0             16             6       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  // NOTE: assumptions passed in member-variable 'assumptions'.
             .       .    .              .             .       .              .           .     .  lbool Solver::solve_()
             8       0    0              0             0       0              6           0     0  {
             .       .    .              .             .       .              .           .     .      //signal(SIGALRM, SIGALRM_switch);
             .       .    .              .             .       .              .           .     .      //alarm(2500);
             .       .    .              .             .       .              .           .     .  
             1       1    1              0             0       0              0           0     0      model.clear();
             .       .    .              .             .       .              .           .     .      conflict.clear();
             2       1    1              1             0       0              0           0     0      if (!ok) return l_False;
             .       .    .              .             .       .              .           .     .  
             1       1    1              1             1       0              0           0     0      solves++;
             .       .    .              .             .       .              .           .     .  
             5       0    0              2             0       0              1           0     0      max_learnts               = nClauses() * learntsize_factor;
             3       0    0              1             1       0              0           0     0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
             1       0    0              0             0       0              1           1     0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
             .       .    .              .             .       .              .           .     .      lbool   status            = l_Undef;
             .       .    .              .             .       .              .           .     .  
             3       0    0              1             0       0              0           0     0      if (verbosity >= 1){
             2       0    0              0             0       0              1           0     0          printf("c ============================[ Search Statistics ]==============================\n");
             2       1    1              0             0       0              1           0     0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
             2       0    0              0             0       0              1           0     0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
             2       0    0              0             0       0              1           0     0          printf("c ===============================================================================\n");
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      add_tmp.clear();
             .       .    .              .             .       .              .           .     .  
             1       0    0              0             0       0              1           1     0      VSIDS = true;
             1       1    1              0             0       0              1           0     0      int init = 10000;
           695       0    0            139             0       0              0           0     0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
           556       3    0              0             0       0            139           0     0          status = search(init);
             1       0    0              0             0       0              1           0     0      VSIDS = false;
             .       .    .              .             .       .              .           .     .  
             3       1    1              0             0       0              2           1     0      duplicates_added_conflicts = 0;
             .       .    .              .             .       .              .           .     .      duplicates_added_minimization=0;
             .       .    .              .             .       .              .           .     .      duplicates_added_tier2 =0;    
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      dupl_db_size=0;
             1       0    0              1             1       0              0           0     0      size_t dupl_db_size_limit = dupl_db_init_size;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // Search:
             1       0    0              0             0       0              0           0     0      int curr_restarts = 0;
             1       0    0              0             0       0              0           0     0      uint64_t curr_props = 0;
             .       .    .              .             .       .              .           .     .      uint32_t removed_duplicates =0;
         7,240   1,301    3              0             0       0              0           0     0      while (status == l_Undef /*&& withinBudget()*/){
         7,240       1    1          3,620         1,567       0              0           0     0          if (dupl_db_size >= dupl_db_size_limit){    
             8       2    2              2             0       0              2           0     0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             8       0    0              2             2       0              2           0     0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             8       0    0              2             0       0              2           0     0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             8       2    2              2             1       0              2           0     0              printf("c Duptime: %i\n",duptime.count());
             8       0    0              2             0       0              2           0     0              printf("c Number of conflicts: %i\n",conflicts);
             8       0    0              2             1       0              2           0     0              printf("c Core size: %i\n",learnts_core.size());
             .       .    .              .             .       .              .           .     .              
             4       0    0              0             0       0              2           0     0              removed_duplicates = reduceduplicates();
            16       2    2              4             4       0              0           0     0              dupl_db_size_limit*=1.1;
             4       0    0              2             2       0              0           0     0              dupl_db_size -= removed_duplicates;
            10       0    0              0             0       0              2           0     0              printf("c removed duplicates %i\n",removed_duplicates);
             .       .    .              .             .       .              .           .     .          }   
        21,720     115    7          7,240         4,915       1              0           0     0          if (propagations - curr_props >  VSIDS_props_limit){
             9       0    0              0             0       0              0           0     0              curr_props = propagations;
             9       0    0              0             0       0              9           1     0              switch_mode = true;
            46       0    0              0             0       0              9           0     0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
             .       .    .              .             .       .              .           .     .          }     
         7,240       0    0          3,620             2       0              0           0     0          if (VSIDS){
         1,573       0    0              0             0       0          1,573           0     0              int weighted = INT32_MAX;
         6,292   1,573    3              0             0       0          1,573           0     0              status = search(weighted);
             .       .    .              .             .       .              .           .     .          }else{
        12,282   1,530    7          4,094             0       0          2,047           0     0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
         2,047       0    0              0             0       0              0           0     0              curr_restarts++;
        10,235   2,030    3              0             0       0          2,047           0     0              status = search(nof_conflicts);
             .       .    .              .             .       .              .           .     .          }
         7,240   2,031    4          3,620         3,620       3              0           0     0          if (switch_mode){ 
             9       0    0              0             0       0              9           0     0              switch_mode = false;
             .       .    .              .             .       .              .           .     .              VSIDS = !VSIDS;
            18       0    0              9             0       0              0           0     0              if (VSIDS){
            10       5    5              0             0       0              5           0     0                  printf("c Switched to VSIDS.\n");
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              else{
            12       4    4              0             0       0              4           0     0                 printf("c Switched to LRB.\n");
             .       .    .              .             .       .              .           .     .              }
             .       .    .              .             .       .              .           .     .              //            reduceduplicates();            
            18       4    4              9             9       7              9           0     0              fflush(stdout);
             .       .    .              .             .       .              .           .     .              picked.clear();
             .       .    .              .             .       .              .           .     .              conflicted.clear();
             .       .    .              .             .       .              .           .     .              almost_conflicted.clear();
             .       .    .              .             .       .              .           .     .  #ifdef ANTI_EXPLORATION
             .       .    .              .             .       .              .           .     .              canceled.clear();
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             3       1    1              1             1       0              0           0     0      if (verbosity >= 1)
             2       0    0              0             0       0              1           0     0          printf("c ===============================================================================\n");
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  #ifdef BIN_DRUP
             3       0    0              1             0       0              0           0     0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
             .       .    .              .             .       .              .           .     .  #endif
             .       .    .              .             .       .              .           .     .  
             2       1    1              0             0       0              0           0     0      if (status == l_True){
             .       .    .              .             .       .              .           .     .          // Extend & copy model:
             .       .    .              .             .       .              .           .     .          model.growTo(nVars());
           487       1    1            225            16       4            233           0     0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
             .       .    .              .             .       .              .           .     .      }else if (status == l_False && conflict.size() == 0)
             .       .    .              .             .       .              .           .     .          ok = false;
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      cancelUntil(0);
             1       0    0              0             0       0              0           0     0      return status;
             8       1    1              7             1       1              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  //=================================================================================================
             .       .    .              .             .       .              .           .     .  // Writing CNF to DIMACS:
             .       .    .              .             .       .              .           .     .  // 
             .       .    .              .             .       .              .           .     .  // FIXME: this needs to be rewritten completely.
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  static Var mapVar(Var x, vec<Var>& map, Var& max)
             .       .    .              .             .       .              .           .     .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
             .       .    .              .             .       .              .           .     .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
             .       .    .              .             .       .              .           .     .  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  //=================================================================================================
             .       .    .              .             .       .              .           .     .  // Garbage Collection methods:
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::relocAll(ClauseAllocator& to)
         1,220      85   24              0             0       0            976           0     0  {
             .       .    .              .             .       .              .           .     .      // All watchers:
             .       .    .              .             .       .              .           .     .      //
             .       .    .              .             .       .              .           .     .      // for (int i = 0; i < watches.size(); i++)
           244       0    0              0             0       0            122           0     0      watches.cleanAll();
           244       0    0              0             0       0            122           0     0      watches_bin.cleanAll();
     4,384,192      11    5      3,068,544        17,464       0        438,590         121     0      for (int v = 0; v < nVars(); v++)
     1,753,384       0    0        876,692             0       0              0           0     0          for (int s = 0; s < 2; s++){
             .       .    .              .             .       .              .           .     .              Lit p = mkLit(v, s);
             .       .    .              .             .       .              .           .     .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
             .       .    .              .             .       .              .           .     .              vec<Watcher>& ws = watches[p];
    72,480,946      42   13     38,597,936       219,230   5,580              0           0     0              for (int j = 0; j < ws.size(); j++)
             .       .    .              .             .       .              .           .     .                  ca.reloc(ws[j].cref, to);
             .       .    .              .             .       .              .           .     .              vec<Watcher>& ws_bin = watches_bin[p];
     8,944,655       4    2      3,647,548       232,456   4,740              0           0     0              for (int j = 0; j < ws_bin.size(); j++)
             .       .    .              .             .       .              .           .     .                  ca.reloc(ws_bin[j].cref, to);
             .       .    .              .             .       .              .           .     .          }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // All reasons:
             .       .    .              .             .       .              .           .     .      //
       279,482       0    0            366             0       0              0           0     0      for (int i = 0; i < trail.size(); i++){
             .       .    .              .             .       .              .           .     .          Var v = var(trail[i]);
             .       .    .              .             .       .              .           .     .  
       403,842       0    0         62,546        57,639       0              0           0     0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
       312,974       0    0         62,546             0       0         62,546           0     0              ca.reloc(vardata[v].reason, to);
             .       .    .              .             .       .              .           .     .      }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // All learnt:
             .       .    .              .             .       .              .           .     .      //
    11,412,450     120   10      5,706,163           224       0              0           0     0      for (int i = 0; i < learnts_core.size(); i++)
             .       .    .              .             .       .              .           .     .          ca.reloc(learnts_core[i], to);
     1,976,562     364   24        988,280           482       0              0           0     0      for (int i = 0; i < learnts_tier2.size(); i++)
             .       .    .              .             .       .              .           .     .          ca.reloc(learnts_tier2[i], to);
     3,303,640     122    7      1,651,577           120       0              0           0     0      for (int i = 0; i < learnts_local.size(); i++)
     4,953,999       0    0              0             0       0      1,651,333           0     0          ca.reloc(learnts_local[i], to);
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      // All original:
             .       .    .              .             .       .              .           .     .      //
             .       .    .              .             .       .              .           .     .      int i, j;
     2,719,418     122    5            488           120       0              0           0     0      for (i = j = 0; i < clauses.size(); i++)
     2,718,320       0    0              0             0       0              0           0     0          if (ca[clauses[i]].mark() != 1){
     4,077,724     121    7      1,359,160           120       0      1,359,160           0     0              ca.reloc(clauses[i], to);
    13,591,478     120   10      5,436,518             0       0      1,359,160           0     0              clauses[j++] = clauses[i]; }
           122     121    6              0             0       0              0           0     0      clauses.shrink(i - j);
           976     121    4            854           122       0              0           0     0  }
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .  void Solver::garbageCollect()
             .       .    .              .             .       .              .           .     .  {
             .       .    .              .             .       .              .           .     .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
             .       .    .              .             .       .              .           .     .      // is not precise but should avoid some unnecessary reallocations for the new region:
             .       .    .              .             .       .              .           .     .      ClauseAllocator to(ca.size() - ca.wasted());
             .       .    .              .             .       .              .           .     .  
             .       .    .              .             .       .              .           .     .      relocAll(to);
             .       .    .              .             .       .              .           .     .      if (verbosity >= 2)
             .       .    .              .             .       .              .           .     .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
             .       .    .              .             .       .              .           .     .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
             .       .    .              .             .       .              .           .     .      to.moveTo(ca);
           155      18   18             47             4       4             61           0     0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir            I1mr   ILmr Dr            D1mr        DLmr  Dw            D1mw       DLmw  

-- line 31 ----------------------------------------
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  template<class Comp>
            .      .    .             .           .     .             .          .     .  class Heap {
            .      .    .             .           .     .             .          .     .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
            .      .    .             .           .     .             .          .     .      vec<int> heap;     // Heap of integers
            .      .    .             .           .     .             .          .     .      vec<int> indices;  // Each integers position (index) in the Heap
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .      // Index "traversal" functions
  512,649,100     13    9             0           0     0             0          0     0      static inline int left  (int i) { return i*2+1; }
1,810,435,572     22    8   724,047,974 376,352,876 1,943             0          0     0      static inline int right (int i) { return (i+1)*2; }
  905,712,342     11    7   129,725,671           0     0             0          0     0      static inline int parent(int i) { return (i-1) >> 1; }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
  259,451,342     21   11             0           0     0   259,451,342      2,274     0      void percolateUp(int i)
            .      .    .             .           .     .             .          .     .      {
  672,404,200      0    0   405,324,656  40,331,767   347   137,353,873          0     0          int x  = heap[i];
            .      .    .             .           .     .             .          .     .          int p  = parent(i);
            .      .    .             .           .     .             .          .     .          
2,756,102,937     38   11   923,447,319 167,150,542   297    21,102,353          0     0          while (i != 0 && lt(x, heap[p])){
  181,072,607     44   17             0           0     0   181,072,607          0     0              heap[i]          = heap[p];
  181,072,607      0    0             0           0     0   181,072,607 57,723,096    75              indices[heap[p]] = i;
            .      .    .             .           .     .             .          .     .              i                = p;
  182,927,258      0    0             0           0     0             0          0     0              p                = parent(p);
            .      .    .             .           .     .             .          .     .          }
  275,598,985      9    5    68,683,305           0     0   206,915,680          0     0          heap   [i] = x;
  284,776,365      2    2    68,693,664           0     0   206,927,209          0     0          indices[x] = i;
  507,453,947      0    0   389,177,013           0     0             0          0     0      }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
2,475,538,863      0    0   353,648,409           0     0 2,121,890,454     32,894     0      void percolateDown(int i)
            .      .    .             .           .     .             .          .     .      {
1,084,942,451  3,158   19   718,166,932 198,807,229     8   366,722,860          0     0          int x = heap[i];
1,999,202,725 11,040   15   505,922,452          27     0             0          0     0          while (left(i) < heap.size()){
2,433,211,705     17    3   360,567,132  21,047,175   114             0          0     0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
  997,419,973     29    4             0           0     0             0          0     0              if (!lt(heap[child], x)) break;
  148,101,732      0    0             0           0     0   148,101,732          0     0              heap[i]          = heap[child];
  148,146,543      0    0        44,811           0     0   148,101,732 54,190,972 1,012              indices[heap[i]] = i;
  101,859,700      0    0             0           0     0             0          0     0              i                = child;
            .      .    .             .           .     .             .          .     .          }
  728,935,562     31   10   364,468,479           0     0   364,467,083          0     0          heap   [i] = x;
  385,984,999      1    1    10,803,341           0     0   364,467,083      2,971     0          indices[x] = i;
2,491,613,607      0    0 2,475,538,863           0     0             0          0     0      }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .    public:
            .      .    .             .           .     .             .          .     .      Heap(const Comp& c) : lt(c) { }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .      int  size      ()          const { return heap.size(); }
    8,498,727      1    1     8,498,727   1,058,107     4             0          0     0      bool empty     ()          const { return heap.size() == 0; }
7,794,131,516  3,358   47 4,015,324,884 315,240,235   734             0          0     0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
   17,470,642      7    6    10,912,722     888,260     4             0          0     0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
  666,379,364      0    0   462,915,353          44     0   129,725,671         25     0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
1,887,552,692      7    6 1,180,255,874           0     0   353,648,409          0     0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .      // Safe variant of insert/decrease/increase:
            .      .    .             .           .     .             .          .     .      void update(int n)
            .      .    .             .           .     .             .          .     .      {
            .      .    .             .           .     .             .          .     .          if (!inHeap(n))
            .      .    .             .           .     .             .          .     .              insert(n);
            .      .    .             .           .     .             .          .     .          else {
            .      .    .             .           .     .             .          .     .              percolateUp(indices[n]);
       25,474      0    0        12,737           0     0             0          0     0              percolateDown(indices[n]); }
            .      .    .             .           .     .             .          .     .      }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .      void insert(int n)
            .      .    .             .           .     .             .          .     .      {
    8,506,704      2    2             0           0     0             0          0     0          indices.growTo(n+1, -1);
            .      .    .             .           .     .             .          .     .          assert(!inHeap(n));
            .      .    .             .           .     .             .          .     .  
   17,013,408      1    1     8,506,704           0     0     8,506,704          0     0          indices[n] = heap.size();
       13,143      1    1             0           0     0         8,714          0     0          heap.push(n);
   17,013,408      0    0     8,506,704           1     0             0          0     0          percolateUp(indices[n]); 
            .      .    .             .           .     .             .          .     .      }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .      int  removeMin()
            .      .    .             .           .     .             .          .     .      {
   25,496,178      1    1    16,997,452     680,804     3     8,498,726        181     0          int x            = heap[0];
   16,997,452      0    0     8,498,726   1,659,408    10     8,498,726          0     0          heap[0]          = heap.last();
   16,997,452     21    8     8,498,726           0     0     8,498,726  5,130,177   109          indices[heap[0]] = 0;
    8,498,726      1    1             0           0     0     8,498,726  1,510,839     3          indices[x]       = -1;
            .      .    .             .           .     .             .          .     .          heap.pop();
   16,997,452      0    0             0           0     0             0          0     0          if (heap.size() > 1) percolateDown(0);
            .      .    .             .           .     .             .          .     .          return x; 
            .      .    .             .           .     .             .          .     .      }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .      // Rebuild the heap from scratch, using the elements in 'ns':
            .      .    .             .           .     .             .          .     .      void build(const vec<int>& ns) {
      216,146     20    3       108,073          26     0             0          0     0          for (int i = 0; i < heap.size(); i++)
      108,112     13    1            39           0     0       107,995      8,082     0              indices[heap[i]] = -1;
           39      0    0             0           0     0             0          0     0          heap.clear();
            .      .    .             .           .     .             .          .     .  
      210,873      5    1       105,378          25     0             0          0     0          for (int i = 0; i < ns.size(); i++){
      210,678      0    0       105,339           0     0       105,339      1,435     0              indices[ns[i]] = i;
            .      .    .             .           .     .             .          .     .              heap.push(ns[i]); }
            .      .    .             .           .     .             .          .     .  
      369,016     32    3        52,698           0     0            39          0     0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
            .      .    .             .           .     .             .          .     .              percolateDown(i);
            .      .    .             .           .     .             .          .     .      }
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .      void clear(bool dealloc = false) 
            .      .    .             .           .     .             .          .     .      { 
            4      0    0             2           1     0             0          0     0          for (int i = 0; i < heap.size(); i++)
            .      .    .             .           .     .             .          .     .              indices[heap[i]] = -1;
            .      .    .             .           .     .             .          .     .          heap.clear(dealloc); 
            .      .    .             .           .     .             .          .     .      }
            .      .    .             .           .     .             .          .     .  };
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  
            .      .    .             .           .     .             .          .     .  //=================================================================================================
            .      .    .             .           .     .             .          .     .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr             D1mr          DLmr Dw             D1mw          DLmw    

-- line 40 ----------------------------------------
             .       .    .              .             .    .              .             .       .      int sz;
             .       .    .              .             .    .              .             .       .      int cap;
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Don't allow copying (error prone):
             .       .    .              .             .    .              .             .       .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
             .       .    .              .             .    .              .             .       .               vec        (vec<T>& other) { assert(0); }
             .       .    .              .             .    .              .             .       .               
             .       .    .              .             .    .              .             .       .      // Helpers for calculating next capacity:
     2,749,366      11    9              0             0    0              0             0       0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
             .       .    .              .             .    .              .             .       .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .              .             .    .              .             .       .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  public:
             .       .    .              .             .    .              .             .       .      // Constructors:
       655,368      27   23              2             0    0        637,399        18,281   4,439      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
            48       0    0              0             0    0             48             0       0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
             .       .    .              .             .    .              .             .       .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
             .       .    .              .             .    .              .             .       .     ~vec()                                                          { clear(true); }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Pointer to first element:
             .       .    .              .             .    .              .             .       .      operator T*       (void)           { return data; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Size operations:
             .       .    .              .             .    .              .             .       .      int      size     (void) const     { return sz; }
 1,317,494,303   1,312    2    117,770,495     4,214,389    0     42,729,229             0       0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
             .       .    .              .             .    .              .             .       .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
             .       .    .              .             .    .              .             .       .      int      capacity (void) const     { return cap; }
             .       .    .              .             .    .              .             .       .      void     capacity (int min_cap);
             .       .    .              .             .    .              .             .       .      void     growTo   (int size);
             .       .    .              .             .    .              .             .       .      void     growTo   (int size, const T& pad);
             .       .    .              .             .    .              .             .       .      void     clear    (bool dealloc = false);
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Stack interface:
     7,348,229     423    4      3,672,051         4,307    0      1,834,404           112       0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
77,409,094,703 167,202  167 27,649,010,912 2,115,908,974  457 21,515,342,707 3,049,516,931 449,377      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
 2,258,540,746       0    0    573,715,872            80    0  1,105,923,772    38,858,193     286      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
   565,190,750      12    1      8,498,726             0    0    278,483,167             4       0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
             .       .    .              .             .    .              .             .       .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
             .       .    .              .             .    .              .             .       .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
             .       .    .              .             .    .              .             .       .      // happen given the way capacities are calculated (below). Essentially, all capacities are
             .       .    .              .             .    .              .             .       .      // even, but INT_MAX is odd.
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      const T& last  (void) const        { return data[sz-1]; }
   269,452,905       0    0              0             0    0              0             0       0      T&       last  (void)              { return data[sz-1]; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Vector interface:
48,420,216,676   1,694   45    285,747,313             2    0      8,657,132             4       0      const T& operator [] (int index) const { return data[index]; }
33,416,136,858     674  112  9,306,978,095    14,059,762    0    653,478,792       138,722       0      T&       operator [] (int index)       { return data[index]; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Duplicatation (preferred instead):
   782,109,882      21    6    261,921,206       961,099    0    128,220,301             0       0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
        60,593       1    0         60,524             3    0             46             0       0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
             .       .    .              .             .    .              .             .       .  };
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
       687,234       0    0              0             0    0        343,617             0       0  void vec<T>::capacity(int min_cap) {
     6,672,642      63   12      2,224,214             6    0              0             0       0      if (cap >= min_cap) return;
     2,405,750      11    6              0             0    0             10             0       0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     4,469,401      93   19        343,701            18    0      1,031,020         2,414       0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
             .       .    .              .             .    .              .             .       .          throw OutOfMemoryException();
     2,553,459       2    2      2,553,459             0    0              0             0       0   }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
             .       .    .              .             .    .              .             .       .  void vec<T>::growTo(int size, const T& pad) {
    25,552,449       8    8      8,513,890           354    0              0             0       0      if (sz >= size) return;
        71,860       4    4          7,186             0    0         32,337             0       0      capacity(size);
       406,011       7    7         64,675             1    0         32,338           865       0      for (int i = sz; i < size; i++) data[i] = pad;
    11,620,176       9    6          5,798             0    0         32,337             0       0      sz = size; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
        71,860       1    1              0             0    0         28,744             0       0  void vec<T>::growTo(int size) {
     3,740,021       1    1         25,154            61    0         14,372             0       0      if (sz >= size) return;
     7,314,735   1,504    6              0             0    0      3,657,356             0       0      capacity(size);
    25,863,925      48   16      7,343,456             0    0      3,653,762             0       0      for (int i = sz; i < size; i++) new (&data[i]) T();
     5,556,156       0    0      1,870,054            12    0      1,844,860             3       0      sz = size; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
             .       .    .              .             .    .              .             .       .  void vec<T>::clear(bool dealloc) {
   392,615,011 727,066   60    118,750,729     2,304,753    0          3,232             0       0      if (data != NULL){
         7,191       0    0              1             0    0              0             0       0          for (int i = 0; i < sz; i++) data[i].~T();
   921,694,571       9    3     17,546,526             0    0    138,606,079             5       0          sz = 0;
       167,508       5    5         16,696             0    0        147,555             5       0          if (dealloc) free(data), data = NULL, cap = 0; } }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  //=================================================================================================
             .       .    .              .             .    .              .             .       .  }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  #endif

--------------------------------------------------------------------------------
Ir                I1mr      ILmr  Dr              D1mr           DLmr    Dw              D1mw          DLmw      
--------------------------------------------------------------------------------
1,201,101,524,372 1,336,834 3,251 394,036,353,075 21,603,598,123 833,206 139,168,240,242 4,621,745,473 2,286,797  events annotated

