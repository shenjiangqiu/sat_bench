--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         17825792 B, 64 B, 17-way associative
Command:          ./glucose_release ./cnfs/Grain_no_init_ver1_out200_known_last104_0.cnf
Data file:        Grain_no_init_ver1_out200_known_last104_0.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr       ILmr   Dr                D1mr           DLmr       Dw              D1mw          DLmw       
--------------------------------------------------------------------------------
3,688,296,169,619 12,511,471 35,250 1,226,305,973,017 52,173,469,606 21,395,300 429,551,028,260 9,957,451,849 14,414,426  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                I1mr      ILmr  Dr              D1mr           DLmr      Dw              D1mw          DLmw       file:function
--------------------------------------------------------------------------------
1,904,604,656,760     2,721   179 748,643,343,134 31,670,528,241   233,177 205,729,033,142     8,603,838         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
  765,273,407,460        13     8 105,149,651,633  4,193,165,129    48,120 113,278,740,312             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
  318,008,272,323   780,057   133  60,433,256,512  2,919,655,422     1,218  36,695,781,822 4,731,180,000 2,630,149  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
  101,351,509,180         3     2  99,980,336,133    651,012,742         0   1,371,169,901             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
   51,671,795,740    10,662   192  20,164,706,157  2,630,612,974       172   6,112,735,852   610,288,919        43  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
   49,900,651,204        14    10  21,271,266,948    906,012,906     1,175  15,174,810,465 3,354,509,927     6,611  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   43,597,432,573    19,931 1,081  16,152,914,096    977,503,396       242   2,478,294,778    13,235,268        41  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   36,212,532,700    16,587    97  14,633,051,430  1,286,012,930       923   9,336,786,240    25,006,051         3  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
   35,114,458,326       640   455   8,714,106,310  1,385,775,797   119,387   3,527,352,942    11,737,920       462  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
   33,692,467,788         0     0  16,846,233,894         31,940         0               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
   30,953,514,372 2,788,956 1,297   6,704,290,221    211,506,528       611   3,039,399,758    45,653,062         0  ???:__ieee754_pow_fma
   27,498,343,188       117    21  13,550,585,446    684,167,203       994   1,371,743,369    22,061,268        10  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   24,377,241,269     8,041   482   5,349,081,422      5,191,708         2   2,240,915,130    46,154,435     1,392  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   23,753,079,867       158   122   6,460,114,363    268,565,409    26,283               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
   17,895,980,694        85    56   4,525,072,389     83,569,551     1,037   3,388,710,475   239,782,711   295,442  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
   17,674,873,009       671   263   4,107,586,477    287,413,429     5,803     122,419,577        94,317         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   16,491,127,896     7,476   205   6,143,492,975    104,113,952        14   2,011,773,634     6,699,223         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   13,872,315,377       599   329   6,340,876,168    369,315,217     9,599   1,129,354,554           243         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   13,347,353,385        49    31   5,400,188,933     26,181,555       117               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   11,124,505,020        13    13   3,804,201,774     11,889,268         0   3,516,101,472   104,051,426       451  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   10,548,303,132         0     0   7,032,201,621     51,235,845         0   1,758,050,055   301,310,566       278  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    9,162,029,765     2,803   632   2,198,770,386    175,161,055     3,815     244,347,367        87,199         0  ???:__exp1_fma
    8,865,093,535 2,714,772   123   1,567,629,912              0         0   1,408,153,941    14,087,523       146  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
    8,754,282,089       253    30   2,733,225,185        563,049         0     122,947,382     3,301,686        26  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    7,716,627,907       721   102   3,536,273,997    367,462,312     1,115   1,045,872,300    26,042,471        15  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
    7,032,202,944         0     0   1,758,050,736              0         0   1,758,050,736        26,030         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
    6,897,178,856        29    24   2,319,209,468     84,815,756        13   1,310,838,474    28,078,107        17  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
    6,203,051,978       194   128   1,251,295,184    203,938,785     2,566     676,689,096   125,440,979     1,638  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
    5,223,030,556     3,968   131   1,450,627,503         18,919        24     870,341,955            42         0  ???:pow
    5,045,485,109       688    78   1,062,584,106    283,687,432       134               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
    5,036,398,090     4,084   974   1,259,493,800    131,795,370   423,161     728,451,834    30,222,204 1,478,725  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
    4,610,308,432     8,660 1,739     848,436,523    151,943,162    44,773     136,344,065       950,918     1,401  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h:void Minisat::sort<unsigned int, reduceDB_lt>(unsigned int*, int, reduceDB_lt)
    4,364,484,727         0     0   2,896,403,289    473,684,029       349               0             0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr          DLmr    Dw             D1mw        DLmw      

-- line 54 ----------------------------------------
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  struct Lit {
              .     .    .              .             .       .              .           .         .      int     x;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // Use this as a constructor:
              .     .    .              .             .       .              .           .         .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      bool operator == (Lit p) const { return x == p.x; }
    984,295,018     0    0    492,518,012   239,045,891     504              0           0         0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .             .       .              .           .         .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
        203,238     0    0              0             0       0            424           4         0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 34,927,509,197    67   48 14,103,905,005       636,572     335  2,671,983,684      94,317         0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .             .       .              .           .         .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
260,607,328,169    21   21  7,034,046,731             0       0  3,517,946,621 301,336,596       278  inline  bool sign      (Lit p)              { return p.x & 1; }
413,658,037,600 5,294  371  5,284,953,282    78,217,648   1,510 97,238,035,585           0         0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .             .       .              .           .         .  inline  int  toInt     (Var v)              { return v; } 
          1,434     0    0             24             0       0             24           1         1  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .             .       .              .           .         .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .             .       .              .           .         .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .             .       .              .           .         .  const Lit lit_Error = { -1 };  // }
              .     .    .              .             .       .              .           .         .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .     .    .              .             .       .              .           .         .  #define l_Undef (lbool((uint8_t)2))
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  class lbool {
              .     .    .              .             .       .              .           .         .      uint8_t value;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  public:
              .     .    .              .             .       .              .           .         .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .             .       .              .           .         .  
            624     1    1              0             0       0            160          36        36      lbool()       : value(0) { }
              .     .    .              .             .       .              .           .         .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .             .       .              .           .         .  
  2,115,660,837     1    1              0             0       0              0           0         0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
          7,275     0    0          4,850            39       0              0           0         0      bool  operator != (lbool b) const { return !(*this == b); }
 43,145,610,711    80   56 42,006,954,826    58,198,428      91              0           0         0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      lbool operator && (lbool b) const {
              .     .    .              .             .       .              .           .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .             .       .              .           .         .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .             .       .              .           .         .          return lbool(v); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      lbool operator || (lbool b) const {
              .     .    .              .             .       .              .           .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .             .       .              .           .         .          unsigned simplified : 1;}                            header;
              .     .    .              .             .       .              .           .         .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      friend class ClauseAllocator;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .             .       .              .           .         .      template<class V>
              .     .    .              .             .       .              .           .         .      Clause(const V& ps, bool use_extra, bool learnt) {
    174,820,805     0    0     40,903,719             0       0     52,109,647     478,300         0          header.mark      = 0;
    122,622,216     1    1     40,874,072     2,562,248 125,536              0           0         0          header.learnt    = learnt;
    245,451,961     3    3     40,933,366             0       0     40,903,719           0         0          header.has_extra = learnt | use_extra;
              .     .    .              .             .       .              .           .         .          header.reloced   = 0;
     63,345,220     0    0     11,235,574           601       0     52,109,646   8,912,111   137,776          header.size      = ps.size();
              .     .    .              .             .       .              .           .         .          header.lbd       = 0;
              .     .    .              .             .       .              .           .         .          header.removable = 1;
              .     .    .              .             .       .              .           .         .          //simplify
              .     .    .              .             .       .              .           .         .          //
     52,109,647    13   11     52,109,647     5,811,438 321,673              0           0         0          header.simplified = 0;
              .     .    .              .             .       .              .           .         .  
  1,678,339,714   796  189     11,384,072             0       0              0           0         0          for (int i = 0; i < ps.size(); i++)
    900,448,109   814  172    303,307,602    34,726,625  22,003    382,242,696  40,464,365 2,693,472              data[i].lit = ps[i];
              .     .    .              .             .       .              .           .         .  
    156,328,940    78   57     52,109,646             0       0              0           0         0          if (header.has_extra){
     73,633,572     0    0              0             0       0              0           0         0              if (header.learnt){
     73,533,388     2    2     25,560,748             0       0     36,766,694   2,297,438   140,053                  data[header.size].act = 0;
     73,533,406     0    0              0             0       0     36,766,694   2,297,819   140,279                  data[header.size+1].touched = 0;
              .     .    .              .             .       .              .           .         .              }else
              .     .    .              .             .       .              .           .         .                  calcAbstraction(); }
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  public:
              .     .    .              .             .       .              .           .         .      void calcAbstraction() {
              .     .    .              .             .       .              .           .         .          assert(header.has_extra);
         52,197     0    0              0             0       0              0           0         0          uint32_t abstraction = 0;
      1,022,228     3    2         21,116             0       0              0           0         0          for (int i = 0; i < size(); i++)
      1,639,631     3    2              0             0       0              1           0         0              abstraction |= 1 << (var(data[i].lit) & 31);
        162,943     0    0         20,445             0       0         71,962       2,811     2,811          data[header.size].abs = abstraction;  }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
 32,450,043,883   303  225 15,441,567,101 1,836,726,659  20,953 13,420,878,927          71         0      int          size        ()      const   { return header.size; }
      1,394,673    57   44        348,726        56,074       1        348,726         851         0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .             .       .              .           .         .      void         pop         ()              { shrink(1); }
    334,829,472     5    5     11,178,166             1       0              0           0         0      bool         learnt      ()      const   { return header.learnt; }
         18,402     0    0              0             0       0              0           0         0      bool         has_extra   ()      const   { return header.has_extra; }
    488,602,196   739  161     93,620,050    86,539,963  67,535    109,789,676           0         0      uint32_t     mark        ()      const   { return header.mark; }
    211,506,227   831  130     53,638,242           769       0     52,552,189           0         0      void         mark        (uint32_t m)    { header.mark = m; }
        201,046     0    0              0             0       0        100,523       8,771         0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .             .       .              .           .         .  
    122,829,194     0    0    122,829,194    82,074,194   5,536              0           0         0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .             .       .              .           .         .      CRef         relocation  ()      const   { return data[0].rel; }
    163,496,288    53   39     40,874,072             0       0     81,748,144           0         0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .             .       .              .           .         .  
     89,034,890     0    0     29,672,879             0       0              0           0         0      int          lbd         ()      const   { return header.lbd; }
    253,109,612   424  143     63,591,835             0       0     38,033,155           0         0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .             .       .              .           .         .      bool         removable   ()      const   { return header.removable; }
    165,644,359     3    3     63,401,295             0       0     25,560,766           0         0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .             .       .              .           .         .      //       subsumption operations to behave correctly.
 40,164,515,098   193  119 39,709,994,083 2,863,713,341  54,041              0           0         0      Lit&         operator [] (int i)         { return data[i].lit; }
    487,423,210   947  218    403,571,437    14,296,895  16,447              0           0         0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .             .       .              .           .         .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .             .       .              .           .         .  
     25,822,205     0    0     25,822,205            20       0              0           0         0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     52,582,949     0    0     16,382,853     3,535,013   5,340              0           0         0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .             .       .              .           .         .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .             .       .              .           .         .      void         strengthen  (Lit p);
              .     .    .              .             .       .              .           .         .      // simplify
              .     .    .              .             .       .              .           .         .      //
    179,256,580     0    0     51,287,141             0       0     25,560,766           0         0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .             .       .              .           .         .      bool simplified() { return header.simplified; }
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  //=================================================================================================
              .     .    .              .             .       .              .           .         .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .             .       .              .           .         .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      static int clauseWord32Size(int size, int extras){
    104,141,457     1    1     52,031,793     2,403,405   6,068              0           0         0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .             .       .              .           .         .  public:
              .     .    .              .             .       .              .           .         .      bool extra_clause_field;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0             0       0              1           0         0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void moveTo(ClauseAllocator& to){
          1,498    35   11            749           749       0            749           0         0          to.extra_clause_field = extra_clause_field;
              .     .    .              .             .       .              .           .         .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      template<class Lits>
              .     .    .              .             .       .              .           .         .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .             .       .              .           .         .          assert(sizeof(float)    == sizeof(uint32_t));
     97,091,096   514  139     15,342,952         1,846       0              0           0         0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .             .       .              .           .         .  
     11,265,220     0    0              0             0       0         29,646           0         0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .             .       .              .           .         .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .          return cid;
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    376,144,621   747  195    333,915,267       220,080       0         18,982           0         0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
          9,064     1    1          4,532            76       0              0           0         0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     40,874,072     0    0     40,874,072             0       0              0           0         0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .           .         .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .           .         .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void free(CRef cid)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .          Clause& c = operator[](cid);
     33,491,565     1    1              0             0       0              0           0         0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .             .       .              .           .         .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
    185,177,468   748  157              0             0       0    158,723,544           1         0      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .          Clause& c = operator[](cr);
              .     .    .              .             .       .              .           .         .          
    424,093,438     0    0     81,955,122    12,962,026       0     81,955,122           0         0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .             .       .              .           .         .          
     40,874,073     0    0              1             0       0     40,874,072           0         0          cr = to.alloc(c, c.learnt());
              .     .    .              .             .       .              .           .         .          c.relocate(cr);
              .     .    .              .             .       .              .           .         .          
              .     .    .              .             .       .              .           .         .          // Copy extra data-fields:
              .     .    .              .             .       .              .           .         .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .             .       .              .           .         .          to[cr].mark(c.mark());
     81,748,144     2    2              0             0       0              0           0         0          if (to[cr].learnt()){
    102,243,064     0    0     25,560,766     1,481,859     272     25,560,766           0         0              to[cr].touched() = c.touched();
    102,243,046     0    0     51,121,532     1,483,520     282     25,560,766           0         0              to[cr].activity() = c.activity();
              .     .    .              .             .       .              .           .         .              to[cr].set_lbd(c.lbd());
              .     .    .              .             .       .              .           .         .              to[cr].removable(c.removable());
              .     .    .              .             .       .              .           .         .              // simplify
              .     .    .              .             .       .              .           .         .              //
              .     .    .              .             .       .              .           .         .              to[cr].setSimplified(c.simplified());
              .     .    .              .             .       .              .           .         .          }
     30,626,612 1,239  170              0             0       0              0           0         0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
    211,631,392     0    0    185,177,468             0       0              0           0         0      }
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .             .       .              .           .         .      {
              .     .    .              .             .       .              .           .         .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .             .       .              .           .         .  class OccLists
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      vec<Vec>  occs;
              .     .    .              .             .       .              .           .         .      vec<char> dirty;
              .     .    .              .             .       .              .           .         .      vec<Idx>  dirties;
              .     .    .              .             .       .              .           .         .      Deleted   deleted;
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  public:
              3     0    0              0             0       0              3           0         0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .             .       .              .           .         .      unsigned int size(){
              .     .    .              .             .       .              .           .         .          auto m_size=0;
             40     2    2              4             3       0              0           0         0          for(int i=0;i<occs.size();i++){
         53,424    14   14         19,404         4,852       0              0           0         0              m_size+=occs[i].size();
              .     .    .              .             .       .              .           .         .          }
              .     .    .              .             .       .              .           .         .          
              .     .    .              .             .       .              .           .         .          return m_size;
              .     .    .              .             .       .              .           .         .      }
         26,675     1    1              0             0       0          4,850           0         0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .             .       .              .           .         .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
  1,389,661,820    38   11  1,389,661,820     9,469,876       0              0           0         0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
        115,524     1    1         58,457         3,473       0          1,762           1         0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void  cleanAll  ();
              .     .    .              .             .       .              .           .         .      void  clean     (const Idx& idx);
              .     .    .              .             .       .              .           .         .      void  smudge    (const Idx& idx){
     67,037,120     0    0     44,676,281       184,810   5,961              0           0         0          if (dirty[toInt(idx)] == 0){
        283,421   725   72              0             0       0        283,421           0         0              dirty[toInt(idx)] = 1;
             48     1    1              0             0       0              0           0         0              dirties.push(idx);
              .     .    .              .             .       .              .           .         .          }
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .      void  clear(bool free = true){
              .     .    .              .             .       .              .           .         .          occs   .clear(free);
              .     .    .              .             .       .              .           .         .          dirty  .clear(free);
              .     .    .              .             .       .              .           .         .          dirties.clear(free);
              .     .    .              .             .       .              .           .         .      }
              .     .    .              .             .       .              .           .         .  };
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  template<class Idx, class Vec, class Deleted>
          3,004     0    0              0             0       0          2,253           0         0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .             .       .              .           .         .  {
    200,280,397    98    6     99,855,230     5,805,665      16              0           0         0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .             .       .              .           .         .          // Dirties may contain duplicates so check here if a variable is already cleaned:
        850,263     0    0        566,842       211,387       0              0           0         0          if (dirty[toInt(dirties[i])])
              .     .    .              .             .       .              .           .         .              clean(dirties[i]);
              .     .    .              .             .       .              .           .         .      dirties.clear();
          3,004     0    0          3,004           751       0              0           0         0  }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  template<class Idx, class Vec, class Deleted>
              .     .    .              .             .       .              .           .         .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      Vec& vec = occs[toInt(idx)];
              .     .    .              .             .       .              .           .         .      int  i, j;
    247,499,488     2    2      1,121,201       303,909      19              0           0         0      for (i = j = 0; i < vec.size(); i++)
    148,850,779     0    0        291,417        12,494       0              0           0         0          if (!deleted(vec[i]))
    362,393,302     4    2    103,503,911           852       0     51,831,590     973,329         0              vec[j++] = vec[i];
        281,989   748  183              0             0       0              0           0         0      vec.shrink(i - j);
      1,136,025     1    1        566,842        35,583       0        284,373      35,465         0      dirty[toInt(idx)] = 0;
              .     .    .              .             .       .              .           .         .  }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  //=================================================================================================
              .     .    .              .             .       .              .           .         .  // CMap -- a class for mapping clauses to values:
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .             .       .              .           .         .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .             .       .              .           .         .  |________________________________________________________________________________________________@*/
              .     .    .              .             .       .              .           .         .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .             .       .              .           .         .  {
              .     .    .              .             .       .              .           .         .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .             .       .              .           .         .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .             .       .              .           .         .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .             .       .              .           .         .      assert(header.has_extra); assert(other.header.has_extra);
     16,064,883     0    0      5,354,961        49,656       0              0           0         0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .             .       .              .           .         .          return lit_Error;
              .     .    .              .             .       .              .           .         .  
        803,111     0    0              0             0       0              0           0         0      Lit        ret = lit_Undef;
              .     .    .              .             .       .              .           .         .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .             .       .              .           .         .      const Lit* d   = (const Lit*)other;
              .     .    .              .             .       .              .           .         .  
      9,877,448     1    1      2,068,370             0       0              0           0         0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .             .       .              .           .         .          // search for c[i] or ~c[i]
     24,843,483     2    2        803,111             0       0        803,111          28         0          for (unsigned j = 0; j < other.header.size; j++)
     40,225,582     0    0      9,431,039             0       0              0           0         0              if (c[i] == d[j])
              .     .    .              .             .       .              .           .         .                  goto ok;
      4,760,913     0    0              0             0       0              0           0         0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .             .       .              .           .         .                  ret = c[i];
              .     .    .              .             .       .              .           .         .                  goto ok;
              .     .    .              .             .       .              .           .         .              }
              .     .    .              .             .       .              .           .         .  
              .     .    .              .             .       .              .           .         .          // did not find it
              .     .    .              .             .       .              .           .         .          return lit_Error;
              .     .    .              .             .       .              .           .         .  ok:;
              .     .    .              .             .       .              .           .         .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h
--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr          D1mr       DLmr   Dw         D1mw    DLmw  

-- line 36 ----------------------------------------
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  template <class T, class LessThan>
            .     .    .           .          .      .          .       .     .  void selectionSort(T* array, int size, LessThan lt)
            .     .    .           .          .      .          .       .     .  {
            .     .    .           .          .      .          .       .     .      int     i, j, best_i;
            .     .    .           .          .      .          .       .     .      T       tmp;
            .     .    .           .          .      .          .       .     .  
   57,979,790   465   71  20,070,044          0      0  2,382,360  16,026     0      for (i = 0; i < size-1; i++){
            .     .    .           .          .      .          .       .     .          best_i = i;
  318,281,387 1,205  275  20,574,800      3,644      0          0       0     0          for (j = i+1; j < size; j++){
1,090,005,914 5,034  954 108,125,352      1,261      0          0       0     0              if (lt(array[j], array[best_i]))
            .     .    .           .          .      .          .       .     .                  best_i = j;
            .     .    .           .          .      .          .       .     .          }
   80,532,977     0    0     252,801          0      0 40,140,088       0     0          tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
            .     .    .           .          .      .          .       .     .      }
            .     .    .           .          .      .          .       .     .  }
            .     .    .           .          .      .          .       .     .  template <class T> static inline void selectionSort(T* array, int size) {
            .     .    .           .          .      .          .       .     .      selectionSort(array, size, LessThan_default<T>()); }
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  template <class T, class LessThan>
   25,808,764   466  161           0          0      0 18,055,228 576,474 1,127  void sort(T* array, int size, LessThan lt)
            .     .    .           .          .      .          .       .     .  {
   13,182,122   748   87           0          0      0          0       0     0      if (size <= 15)
            .     .    .           .          .      .          .       .     .          selectionSort(array, size, lt);
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .      else{
   12,737,045     0    0   2,547,409    163,277     19          0       0     0          T           pivot = array[size / 2];
            .     .    .           .          .      .          .       .     .          T           tmp;
    2,547,409     0    0           0          0      0          0       0     0          int         i = -1;
            .     .    .           .          .      .          .       .     .          int         j = size;
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .          for(;;){
  935,913,529   362   97 271,603,272 73,497,866 38,048          0       0     0              do i++; while(lt(array[i], pivot));
1,634,755,648    52   17 408,688,912 78,218,177  6,706          0       0     0              do j--; while(lt(pivot, array[j]));
            .     .    .           .          .      .          .       .     .  
   79,037,536     0    0           0          0      0          0       0     0              if (i >= j) break;
            .     .    .           .          .      .          .       .     .  
  340,451,172   342   85           0          0      0 73,942,718  70,202     0              tmp = array[i]; array[i] = array[j]; array[j] = tmp;
            .     .    .           .          .      .          .       .     .          }
            .     .    .           .          .      .          .       .     .  
    7,642,227     0    0           0          0      0  2,547,409 288,216   274          sort(array    , i     , lt);
    2,547,409     0    0           0          0      0          0       0     0          sort(&array[i], size-i, lt);
            .     .    .           .          .      .          .       .     .      }
   20,712,452     0    0  18,109,762     58,937      0          0       0     0  }
            .     .    .           .          .      .          .       .     .  template <class T> static inline void sort(T* array, int size) {
            .     .    .           .          .      .          .       .     .      sort(array, size, LessThan_default<T>()); }
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  //=================================================================================================
            .     .    .           .          .      .          .       .     .  // For 'vec's:
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {
      165,843   463   82     110,562        563      0     55,281      18     0      sort((T*)v, v.size(), lt); }
            .     .    .           .          .      .          .       .     .  template <class T> void sort(vec<T>& v) {
            .     .    .           .          .      .          .       .     .      sort(v, LessThan_default<T>()); }
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  //=================================================================================================
            .     .    .           .          .      .          .       .     .  }
            .     .    .           .          .      .          .       .     .  
            .     .    .           .          .      .          .       .     .  #endif
-- line 98 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr             D1mr          DLmr  Dw            D1mw        DLmw  

-- line 31 ----------------------------------------
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  template<class Comp>
             .      .    .              .             .     .             .           .     .  class Heap {
             .      .    .              .             .     .             .           .     .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
             .      .    .              .             .     .             .           .     .      vec<int> heap;     // Heap of integers
             .      .    .              .             .     .             .           .     .      vec<int> indices;  // Each integers position (index) in the Heap
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .      // Index "traversal" functions
 1,344,247,227      7    7              0             0     0             0           0     0      static inline int left  (int i) { return i*2+1; }
 5,045,104,859     18   14  2,017,946,696   985,644,553 3,032             0           0     0      static inline int right (int i) { return (i+1)*2; }
 2,034,333,764      6    6    257,943,295             0     0             0           0     0      static inline int parent(int i) { return (i-1) >> 1; }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
   515,886,590     18   14              0             0     0   515,886,590           0     0      void percolateUp(int i)
             .      .    .              .             .     .             .           .     .      {
 1,535,762,481      0    0    909,889,950    53,713,455   792   367,929,236           0     0          int x  = heap[i];
             .      .    .              .             .     .             .           .     .          int p  = parent(i);
             .      .    .              .             .     .             .           .     .          
 6,410,677,221     34   21  2,119,153,506   233,740,504   305    45,927,598           0     0          while (i != 0 && lt(x, heap[p])){
   420,231,286     21   16              0             0     0   420,231,286           0     0              heap[i]          = heap[p];
   420,231,286      0    0              0             0     0   420,231,286  76,183,520    42              indices[heap[p]] = i;
             .      .    .              .             .     .             .           .     .              i                = p;
   502,865,346      0    0              0             0     0             0           0     0              p                = parent(p);
             .      .    .              .             .     .             .           .     .          }
   651,946,655     10   10    183,983,692             0     0   467,962,963           0     0          heap   [i] = x;
   678,646,454      2    2    184,020,390             0     0   468,000,386           0     0          indices[x] = i;
   957,374,169      0    0    773,829,885             0     0             0           0     0      }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
 7,191,738,596      0    0  1,027,391,228             0     0 6,164,347,368           0     0      void percolateDown(int i)
             .      .    .              .             .     .             .           .     .      {
 3,140,163,853    975   69  2,082,948,255   411,092,971   194 1,057,211,002           0     0          int x = heap[i];
 5,081,686,827 15,607   29  1,320,318,163             3     0             0           0     0          while (left(i) < heap.size()){
 6,250,276,163      3    3    999,162,885    62,733,203   178             0           0     0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
 2,780,557,335     15   11              0             0     0             0           0     0              if (!lt(heap[child], x)) break;
   288,815,672      0    0              0             0     0   288,815,672           0     0              heap[i]          = heap[child];
   288,815,672      0    0              0             0     0   288,815,672 121,089,357 1,348              indices[heap[i]] = i;
   243,656,376      0    0              0             0     0             0           0     0              i                = child;
             .      .    .              .             .     .             .           .     .          }
 2,110,818,347     36   23  1,055,409,545             0     0 1,055,408,802           0     0          heap   [i] = x;
 1,111,106,911      5    5     27,833,356             0     0 1,055,408,802         138     0          indices[x] = i;
 7,204,514,560      0    0  7,191,738,596             0     0             0           0     0      }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .    public:
             .      .    .              .             .     .             .           .     .      Heap(const Comp& c) : lt(c) { }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .      int  size      ()          const { return heap.size(); }
    26,029,006      3    1     26,029,006     6,871,746     8             0           0     0      bool empty     ()          const { return heap.size() == 0; }
24,495,142,718  1,043  122 12,536,544,950 1,106,500,046 1,756             0           0     0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
    38,876,648     14   14     25,318,564     4,625,514     9             0           0     0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
 1,249,856,390      0    0    882,871,490             2     0   257,943,295           4     0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
 5,588,146,765     10   10  3,533,364,308             0     0 1,027,391,228          22     0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .      // Safe variant of insert/decrease/increase:
             .      .    .              .             .     .             .           .     .      void update(int n)
             .      .    .              .             .     .             .           .     .      {
             .      .    .              .             .     .             .           .     .          if (!inHeap(n))
             .      .    .              .             .     .             .           .     .              insert(n);
             .      .    .              .             .     .             .           .     .          else {
             .      .    .              .             .     .             .           .     .              percolateUp(indices[n]);
        76,296      0    0         38,148             0     0             0           0     0              percolateDown(indices[n]); }
             .      .    .              .             .     .             .           .     .      }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .      void insert(int n)
             .      .    .              .             .     .             .           .     .      {
    26,035,976      2    2              0             0     0             0           0     0          indices.growTo(n+1, -1);
             .      .    .              .             .     .             .           .     .          assert(!inHeap(n));
             .      .    .              .             .     .             .           .     .  
    52,071,952      1    1     26,035,976        52,691     0    26,035,976           0     0          indices[n] = heap.size();
        27,671      1    1              0             0     0        18,402           0     0          heap.push(n);
    52,071,952      0    0     26,035,976             0     0             0           0     0          percolateUp(indices[n]); 
             .      .    .              .             .     .             .           .     .      }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .      int  removeMin()
             .      .    .              .             .     .             .           .     .      {
    78,087,015      1    1     52,058,010     4,865,829    13    26,029,005           0     0          int x            = heap[0];
    52,058,010      0    0     26,029,005     9,099,502    43    26,029,005           0     0          heap[0]          = heap.last();
    52,058,010     39   29     26,029,005     4,932,874     4    26,029,005  20,231,816   276          indices[heap[0]] = 0;
    26,029,005      1    1              0             0     0    26,029,005   9,133,557    17          indices[x]       = -1;
             .      .    .              .             .     .             .           .     .          heap.pop();
    52,058,010      0    0              0             0     0             0           0     0          if (heap.size() > 1) percolateDown(0);
             .      .    .              .             .     .             .           .     .          return x; 
             .      .    .              .             .     .             .           .     .      }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .      // Rebuild the heap from scratch, using the elements in 'ns':
             .      .    .              .             .     .             .           .     .      void build(const vec<int>& ns) {
        25,038      6    3         12,519             2     0             0           0     0          for (int i = 0; i < heap.size(); i++)
        12,525      2    1              6             2     0        12,507         864     0              indices[heap[i]] = -1;
             6      0    0              0             0     0             0           0     0          heap.clear();
             .      .    .              .             .     .             .           .     .  
        18,414      2    1          9,198             0     0             0           0     0          for (int i = 0; i < ns.size(); i++){
        18,384      0    0          9,192             0     0         9,192           0     0              indices[ns[i]] = i;
             .      .    .              .             .     .             .           .     .              heap.push(ns[i]); }
             .      .    .              .             .     .             .           .     .  
        32,234      6    3          4,602             0     0             6           0     0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
             .      .    .              .             .     .             .           .     .              percolateDown(i);
             .      .    .              .             .     .             .           .     .      }
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .      void clear(bool dealloc = false) 
             .      .    .              .             .     .             .           .     .      { 
             4      0    0              2             0     0             0           0     0          for (int i = 0; i < heap.size(); i++)
             .      .    .              .             .     .             .           .     .              indices[heap[i]] = -1;
             .      .    .              .             .     .             .           .     .          heap.clear(dealloc); 
             .      .    .              .             .     .             .           .     .      }
             .      .    .              .             .     .             .           .     .  };
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  
             .      .    .              .             .     .             .           .     .  //=================================================================================================
             .      .    .              .             .     .             .           .     .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr             D1mr        DLmr  Dw            D1mw   DLmw 

-- line 77 ----------------------------------------
             .      .    .              .           .     .             .      .    .  private:
             .      .    .              .           .     .             .      .    .      template<typename T>
             .      .    .              .           .     .             .      .    .      class MyQueue {
             .      .    .              .           .     .             .      .    .          int max_sz, q_sz;
             .      .    .              .           .     .             .      .    .          int ptr;
             .      .    .              .           .     .             .      .    .          int64_t sum;
             .      .    .              .           .     .             .      .    .          vec<T> q;
             .      .    .              .           .     .             .      .    .      public:
             4      1    1              0           0     0             3      0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .      .    .              .           .     .             .      .    .          inline bool   full () const { return q_sz == max_sz; }
             .      .    .              .           .     .             .      .    .  #ifdef INT_QUEUE_AVG
    11,662,520     47   10      2,915,630           0     0             0      0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .      .    .              .           .     .             .      .    .  #else
             .      .    .              .           .     .             .      .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .      .    .              .           .     .             .      .    .  #endif
        19,612     33   24              0           0     0        19,612  7,417    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .      .    .              .           .     .             .      .    .          void push(T e) {
    35,417,992      0    0     17,628,246           0     0        80,750      0    0              if (q_sz < max_sz) q_sz++;
    17,385,996     14   14      5,795,332   5,751,008     0             0      0    0              else sum -= q[ptr];
    17,628,246     42   35              0           0     0     5,876,082      0    0              sum += e;
    17,628,246      0    0              0           0     0    11,752,164 80,253   45              q[ptr++] = e;
    17,745,442      0    0     11,752,164           0     0       117,196      0    0              if (ptr == max_sz) ptr = 0;
             .      .    .              .           .     .             .      .    .          }
             .      .    .              .           .     .             .      .    .      };
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  public:
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .      // Constructor/Destructor:
             .      .    .              .           .     .             .      .    .      //
             .      .    .              .           .     .             .      .    .      Solver();
             .      .    .              .           .     .             .      .    .      virtual ~Solver();
            10      2    2              0           0     0             4      0    0      void print_size(std::ostream &os)
             .      .    .              .           .     .             .      .    .      {
             4      2    2              0           0     0             4      1    0          program_end_time=std::chrono::steady_clock::now();
             2      0    0              0           0     0             2      0    0          total_work_time=program_end_time-program_start_time;
             4      0    0              2           1     0             0      0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2      0    0              2           1     0             0      0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4      0    0              2           0     0             0      0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4      0    0              2           1     0             0      0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4      0    0              2           0     0             0      0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4      0    0              2           2     0             0      0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .      .    .              .           .     .             .      .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .      .    .              .           .     .             .      .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2      0    0              2           2     0             0      0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2      0    0              2           0     0             0      0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2      0    0              2           0     0             0      0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4      0    0              2           0     0             0      0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4      0    0              2           2     0             0      0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4      0    0              2           0     0             0      0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4      0    0              2           0     0             0      0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .      .    .              .           .     .             .      .    .          os << "total_Watchers: " << total_Watchers << "\n";
             .      .    .              .           .     .             .      .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .      .    .              .           .     .             .      .    .          os << "total_indexs: " << total_indexs << "\n";
             .      .    .              .           .     .             .      .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .      .    .              .           .     .             .      .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .      .    .              .           .     .             .      .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .      .    .              .           .     .             .      .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .      .    .              .           .     .             .      .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .      .    .              .           .     .             .      .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .      .    .              .           .     .             .      .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .      .    .              .           .     .             .      .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .      .    .              .           .     .             .      .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .      .    .              .           .     .             .      .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .      .    .              .           .     .             .      .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .      .    .              .           .     .             .      .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .      .    .              .           .     .             .      .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6      0    0              4           0     0             0      0    0      }
             .      .    .              .           .     .             .      .    .      using ull=unsigned long long;
             .      .    .              .           .     .             .      .    .      ull total_Watchers = 0;
             .      .    .              .           .     .             .      .    .      ull total_act_watchers = 0;
             .      .    .              .           .     .             .      .    .      ull total_indexs = 0;
             .      .    .              .           .     .             .      .    .      ull time_find_conflict = 0;
             .      .    .              .           .     .             .      .    .      ull total_find_conflict_length = 0;
             .      .    .              .           .     .             .      .    .      ull total_find_conflict_allsize = 0;
             .      .    .              .           .     .             .      .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .      .    .              .           .     .             .      .    .      {
             .      .    .              .           .     .             .      .    .          const ClauseAllocator& ca;
             .      .    .              .           .     .             .      .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .      .    .              .           .     .             .      .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .      .    .              .           .     .             .      .    .      };
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .      struct VarOrderLt {
             .      .    .              .           .     .             .      .    .          const vec<double>&  activity;
 6,711,468,653    240   72  4,600,061,619 592,192,877 2,363   180,009,847      0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .      .    .              .           .     .             .      .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .      .    .              .           .     .             .      .    .      };
             .      .    .              .           .     .             .      .    .      
             .      .    .              .           .     .             .      .    .      struct ConflictData
             .      .    .              .           .     .             .      .    .  	{
             .      .    .              .           .     .             .      .    .  		ConflictData() :
             .      .    .              .           .     .             .      .    .  			nHighestLevel(-1),
             .      .    .              .           .     .             .      .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .      .    .              .           .     .             .      .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .      .    .              .           .     .             .      .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .      .    .              .           .     .             .      .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .      .    .              .           .     .             .      .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .      .    .              .           .     .             .      .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .      .    .              .           .     .             .      .    .      std::chrono::nanoseconds total_duration;
             .      .    .              .           .     .             .      .    .      CRef     propagate(){
             .      .    .              .           .     .             .      .    .  
    46,234,456 11,211  117              0           0     0    23,117,228      0    0          auto start_time=std::chrono::steady_clock::now();
    69,351,684      0    0              0           0     0    23,117,228      0    0          auto ref= propagate_();
    23,117,228      0    0              0           0     0    23,117,228      0    0          auto end_time=std::chrono::steady_clock::now();
             .      .    .              .           .     .             .      .    .          auto duration=end_time-start_time;
             .      .    .              .           .     .             .      .    .          total_duration+=duration;
             .      .    .              .           .     .             .      .    .          return ref;
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .      }
             .      .    .              .           .     .             .      .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .      .    .              .           .     .             .      .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .      .    .              .           .     .             .      .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .      .    .              .           .     .             .      .    .      
             .      .    .              .           .     .             .      .    .  public:
             .      .    .              .           .     .             .      .    .      int      level            (Var x) const;
             .      .    .              .           .     .             .      .    .  protected:
             .      .    .              .           .     .             .      .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .      .    .              .           .     .             .      .    .      bool     withinBudget     ()      const;
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .      template<class V> int computeLBD(const V& c) {
   338,013,390     79   60              0           0     0             0      0    0          int lbd = 0;
             .      .    .              .           .     .             .      .    .  
    63,306,617     85   64     52,100,689   4,870,000     6             0      0    0          counter++;
 1,437,650,350      0    0     11,208,126           0     0             0      0    0          for (int i = 0; i < c.size(); i++){
             .      .    .              .           .     .             .      .    .              int l = level(var(c[i]));
 3,259,354,220      0    0  1,303,741,688  34,979,492    66             0      0    0              if (l != 0 && seen2[l] != counter){
   433,397,532      0    0              0           0     0   433,397,532      0    0                  seen2[l] = counter;
   648,162,741      0    0              0           0     0             0      0    0                  lbd++; } }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .          return lbd;
             .      .    .              .           .     .             .      .    .      }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  #ifdef BIN_DRUP
             .      .    .              .           .     .             .      .    .      static int buf_len;
             .      .    .              .           .     .             .      .    .      static unsigned char drup_buf[];
             .      .    .              .           .     .             .      .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .      .    .              .           .     .             .      .    .      }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .      template<class V>
             .      .    .              .           .     .             .      .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .      .    .              .           .     .             .      .    .          assert(op == 'a' || op == 'd');
             .      .    .              .           .     .             .      .    .          *buf_ptr++ = op; buf_len++;
             .      .    .              .           .     .             .      .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .      .    .              .           .     .             .      .    .          *buf_ptr++ = 0; buf_len++;
       141,524     76   57              0           0     0       141,524      0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .      .    .              .           .     .             .      .    .      }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .      .    .              .           .     .             .      .    .          *buf_ptr++ = 'a'; buf_len++;
             .      .    .              .           .     .             .      .    .          for (int i = 0; i < c.size(); i++)
             .      .    .              .           .     .             .      .    .              if (c[i] != l) byteDRUP(c[i]);
             .      .    .              .           .     .             .      .    .          *buf_ptr++ = 0; buf_len++;
             .      .    .              .           .     .             .      .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .      .    .              .           .     .             .      .    .      double    my_var_decay;
             .      .    .              .           .     .             .      .    .      bool   DISTANCE;
             .      .    .              .           .     .             .      .    .  };
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  //=================================================================================================
             .      .    .              .           .     .             .      .    .  // Implementation of inline methods:
             .      .    .              .           .     .             .      .    .  
   564,974,818      0    0    564,974,818   2,736,276 4,172             0      0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
 7,939,119,568     85   58  6,538,164,355 828,574,018     8 1,371,169,901      0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  inline void Solver::insertVarOrder(Var x) {
             .      .    .              .           .     .             .      .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
11,433,144,384     48   30  3,512,006,190     765,051     0             0      0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    78,078,774      1    1     52,052,516  22,765,560   117             0      0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  inline void Solver::varDecayActivity() {
    23,504,328      0    0     11,752,164   2,251,871     0     5,876,082      0    0      var_inc *= (1 / var_decay); }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  inline void Solver::varBumpActivity(Var v, double mult) {
 3,266,471,299     19   19  1,977,977,440 214,850,798   313   491,692,878      0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .      .    .              .           .     .             .      .    .          // Rescale:
        13,382    137   80              1           0     0             0      0    0          for (int i = 0; i < nVars(); i++)
     6,491,976      0    0      1,624,332     349,646 2,297     1,622,994      0    0              activity_VSIDS[i] *= 1e-100;
         2,676      0    0          1,338           0     0         1,338      0    0          var_inc *= 1e-100; }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .      // Update order_heap with respect to new activity:
   297,803,380      0    0              0           0     0             0      0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .      .    .              .           .     .             .      .    .  
    44,823,712     90    0     22,411,856         223     0    11,205,928      0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .      .    .              .           .     .             .      .    .  inline void Solver::claBumpActivity (Clause& c) {
   295,641,776  1,220  128     88,532,060  10,653,377    18    29,644,414  7,033   29      if ( (c.activity() += cla_inc) > 1e20 ) {
             .      .    .              .           .     .             .      .    .          // Rescale:
    16,338,810    184  144            729           0     0             0      0    0          for (int i = 0; i < learnts_local.size(); i++)
    38,119,354     59    4      5,445,622   4,786,661 6,905     5,445,622      0    0              ca[learnts_local[i]].activity() *= 1e-20;
       803,093    669   54        401,182           0     0           243    243    0          cla_inc *= 1e-20; } }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .      .    .              .           .     .             .      .    .  inline void Solver::checkGarbage(double gf){
        23,319    683   12          7,773         844     0             0      0    0      if (ca.wasted() > ca.size() * gf)
         2,991      1    1          1,496       1,496    51             1      1    0          garbageCollect(); }
             .      .    .              .           .     .             .      .    .  
             .      .    .              .           .     .             .      .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
             .      .    .              .           .     .             .      .    .  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .      .    .              .           .     .             .      .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .      .    .              .           .     .             .      .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .      .    .              .           .     .             .      .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .      .    .              .           .     .             .      .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .      .    .              .           .     .             .      .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .      .    .              .           .     .             .      .    .  inline bool     Solver::locked          (const Clause& c) const {
   138,648,721    747   92     53,765,825   1,280,287     0             0      0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
   182,164,418    749  188     35,394,428     234,748     0             0      0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .      .    .              .           .     .             .      .    .  }
    23,781,829      1    1     11,890,908           0     0             0      0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .      .    .              .           .     .             .      .    .  
       435,677      1    1        227,790           0     0       207,887      0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
 1,541,056,178  3,558   53    358,571,352     312,206     0             0      0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
    26,035,237      1    1     26,035,221         866     0             0      0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
98,606,750,502     83   61 98,606,750,502         602     0             0      0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .      .    .              .           .     .             .      .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .      .    .              .           .     .             .      .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .      .    .              .           .     .             .      .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3      0    0              2           0     0             1      1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .      .    .              .           .     .             .      .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
     3,260,865      1    1          9,957           3     0             1      0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6      1    1              3           3     0             0      0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .      .    .              .           .     .             .      .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .      .    .              .           .     .             .      .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .      .    .              .           .     .             .      .    .  { 
        14,550      0    0          7,275          23     0             0      0    0      if      ( b && !decision[v]) dec_vars++;
         1,272      0    0            848         296     0             0      0    0      else if (!b &&  decision[v]) dec_vars--;
             .      .    .              .           .     .             .      .    .  
         2,849      0    0              0           0     0         2,849      0    0      decision[v] = b;
             .      .    .              .           .     .             .      .    .      if (b && !order_heap_CHB.inHeap(v)){
             .      .    .              .           .     .             .      .    .          order_heap_CHB.insert(v);
             .      .    .              .           .     .             .      .    .          order_heap_VSIDS.insert(v);
             .      .    .              .           .     .             .      .    .          order_heap_distance.insert(v);}
             .      .    .              .           .     .             .      .    .  }
             .      .    .              .           .     .             .      .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .      .    .              .           .     .             .      .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .      .    .              .           .     .             .      .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr       DLmr    Dw          D1mw  DLmw 

-- line 40 ----------------------------------------
             .     .    .              .          .       .           .     .    .      void capacity(uint32_t min_cap);
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .   public:
             .     .    .              .          .       .           .     .    .      // TODO: make this a class for better type-checking?
             .     .    .              .          .       .           .     .    .      typedef uint32_t Ref;
             .     .    .              .          .       .           .     .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .              .          .       .           .     .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .              .          .       .           .     .    .  
         3,751     1    1              0          0       0       3,000   748    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .              .          .       .           .     .    .      ~RegionAllocator()
             .     .    .              .          .       .           .     .    .      {
             .     .    .              .          .       .           .     .    .          if (memory != NULL)
             .     .    .              .          .       .           .     .    .              ::free(memory);
             .     .    .              .          .       .           .     .    .      }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .      uint32_t size      () const      { return sz; }
             .     .    .              .          .       .           .     .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .      Ref      alloc     (int size); 
    33,473,163     0    0     11,157,721          0       0  11,157,721     0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
38,435,381,225 1,753  244 18,921,818,752 14,924,068 560,111     199,388     0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    73,984,643     0    0     73,984,643  9,474,866  69,506           0     0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .              .          .       .           .     .    .  
   167,534,869 4,149   45     11,235,575          0       0           0     0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
    19,948,588     0    0              0          0       0           0     0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .              .          .       .           .     .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .              .          .       .           .     .    .          return  (Ref)(t - &memory[0]); }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .      void     moveTo(RegionAllocator& to) {
         2,996     0    0            749          0       0         749     0    0          if (to.memory != NULL) ::free(to.memory);
         1,498     0    0            749          0       0         749     0    0          to.memory = memory;
         1,498     0    0            749          0       0         749     0    0          to.sz = sz;
             .     .    .              .          .       .           .     .    .          to.cap = cap;
         1,498     0    0            749          0       0         749     0    0          to.wasted_ = wasted_;
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .          memory = NULL;
             .     .    .              .          .       .           .     .    .          sz = cap = wasted_ = 0;
             .     .    .              .          .       .           .     .    .      }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  };
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  template<class T>
         8,202   266   71              0          0       0       2,734     0    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .              .          .       .           .     .    .  {
   156,331,191     3    2     52,110,397          0       0           0     0    0      if (cap >= min_cap) return;
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .      uint32_t prev_cap = cap;
        42,875     0    0              0          0       0       1,367     0    0      while (cap < min_cap){
             .     .    .              .          .       .           .     .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .              .          .       .           .     .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .              .          .       .           .     .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .              .          .       .           .     .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
       124,524     0    0              0          0       0           0     0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
        20,754     0    0              0          0       0           0     0    0          cap += delta;
             .     .    .              .          .       .           .     .    .  
        41,508     0    0              0          0       0           0     0    0          if (cap <= prev_cap)
             .     .    .              .          .       .           .     .    .              throw OutOfMemoryException();
             .     .    .              .          .       .           .     .    .      }
             .     .    .              .          .       .           .     .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .      assert(cap > 0);
         2,734     3    1              0          0       0       1,367   601    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
         5,468     0    0          4,101          0       0           0     0    0  }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  template<class T>
             .     .    .              .          .       .           .     .    .  typename RegionAllocator<T>::Ref
       118,584     2    1              0          0       0      88,938     0    0  RegionAllocator<T>::alloc(int size)
             .     .    .              .          .       .           .     .    .  { 
             .     .    .              .          .       .           .     .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .              .          .       .           .     .    .      assert(size > 0);
   278,921,511     0    0     52,109,647  4,800,090       0 133,828,126 2,636    0      capacity(sz + size);
             .     .    .              .          .       .           .     .    .  
   167,445,915     0    0     92,954,055          0       0           0     0    0      uint32_t prev_sz = sz;
    52,109,647     2    1              0          0       0  52,109,647     0    0      sz += size;
             .     .    .              .          .       .           .     .    .      
             .     .    .              .          .       .           .     .    .      // Handle overflow:
   226,841,506   453  115     40,874,071          0       0           0     0    0      if (sz < prev_sz)
             2     1    1              1          1       0           0     0    0          throw OutOfMemoryException();
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .      return prev_sz;
       118,584     0    0        118,584          0       0           0     0    0  }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  //=================================================================================================
             .     .    .              .          .       .           .     .    .  }
             .     .    .              .          .       .           .     .    .  
             .     .    .              .          .       .           .     .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir              I1mr      ILmr Dr             D1mr          DLmr  Dw             D1mw          DLmw      

-- line 40 ----------------------------------------
              .         .    .              .             .     .              .             .         .      int sz;
              .         .    .              .             .     .              .             .         .      int cap;
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .      // Don't allow copying (error prone):
              .         .    .              .             .     .              .             .         .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              .         .    .              .             .     .              .             .         .               vec        (vec<T>& other) { assert(0); }
              .         .    .              .             .     .              .             .         .               
              .         .    .              .             .     .              .             .         .      // Helpers for calculating next capacity:
      1,413,057        25   16              0             0     0              0             0         0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
              .         .    .              .             .     .              .             .         .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .         .    .              .             .     .              .             .         .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  public:
              .         .    .              .             .     .              .             .         .      // Constructors:
        411,034        24   23              2             0     0        398,905         3,101     2,328      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
             50         0    0              0             0     0             50             0         0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
              .         .    .              .             .     .              .             .         .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
              .         .    .              .             .     .              .             .         .     ~vec()                                                          { clear(true); }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .      // Pointer to first element:
              .         .    .              .             .     .              .             .         .      operator T*       (void)           { return data; }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .      // Size operations:
              .         .    .              .             .     .              .             .         .      int      size     (void) const     { return sz; }
  3,131,503,241     2,000  129     15,710,352     2,791,549     0     65,694,656             3         0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
              .         .    .              .             .     .              .             .         .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
              .         .    .              .             .     .              .             .         .      int      capacity (void) const     { return cap; }
              .         .    .              .             .     .              .             .         .      void     capacity (int min_cap);
              .         .    .              .             .     .              .             .         .      void     growTo   (int size);
              .         .    .              .             .     .              .             .         .      void     growTo   (int size, const T& pad);
              .         .    .              .             .     .              .             .         .      void     clear    (bool dealloc = false);
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .      // Stack interface:
     44,902,129       528   19     22,438,762         2,141     0     11,225,559             0         0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
150,713,206,882   785,225  882 55,074,103,727 3,009,522,506 2,264 41,133,577,903 5,075,980,750 2,954,781      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
  7,066,367,705         0    0  1,767,856,083             8     0  3,530,505,148   105,124,239       519      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
    663,187,781         1    1     26,029,005             0     0    318,659,021             7         0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
              .         .    .              .             .     .              .             .         .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
              .         .    .              .             .     .              .             .         .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
              .         .    .              .             .     .              .             .         .      // happen given the way capacities are calculated (below). Essentially, all capacities are
              .         .    .              .             .     .              .             .         .      // even, but INT_MAX is odd.
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .      const T& last  (void) const        { return data[sz-1]; }
    292,341,876         0    0              0             0     0              0             0         0      T&       last  (void)              { return data[sz-1]; }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .      // Vector interface:
154,111,542,736       353  104    173,764,945             0     0     26,189,764             0         0      const T& operator [] (int index) const { return data[index]; }
 74,734,596,825     2,467  533 20,635,735,686    30,082,271     0  1,779,055,125           745         0      T&       operator [] (int index)       { return data[index]; }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .      // Duplicatation (preferred instead):
  2,297,105,176         5    5    773,172,344        17,571     0    369,777,280             0         0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
         52,684         1    0         52,612             4     0             48             0         0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
              .         .    .              .             .     .              .             .         .  };
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  template<class T>
        353,148         0    0              0             0     0        176,574             0         0  void vec<T>::capacity(int min_cap) {
     34,256,148        57   19     11,418,716             0     0              0             0         0      if (cap >= min_cap) return;
      1,236,482         7    5              0             0     0             26             0         0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
      2,304,162       125   63        176,695             3     0        529,906           614         0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
              .         .    .              .             .     .              .             .         .          throw OutOfMemoryException();
     11,585,590         8    8     11,585,590            14     0              0             0         0   }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  template<class T>
              .         .    .              .             .     .              .             .         .  void vec<T>::growTo(int size, const T& pad) {
     78,129,753         6    6     26,040,826            28     0              0             0         0      if (sz >= size) return;
         48,500         4    4          4,850             0     0         21,825             0         0      capacity(size);
        274,027         7    7         43,651             0     0         21,826           208         0      for (int i = sz; i < size; i++) data[i] = pad;
     21,565,253        13   13         13,795             0     0         21,825             0         0      sz = size; }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  template<class T>
         48,500         1    1              0             0     0         19,400             0         0  void vec<T>::growTo(int size) {
     22,470,111         1    1         16,978            40     0          9,700             0         0      if (sz >= size) return;
     44,828,642     3,551   68              0             0     0     22,414,309             0         0      capacity(size);
    157,077,336        71   50     44,848,018             0     0     22,411,883             0         0      for (int i = sz; i < size; i++) new (&data[i]) T();
     33,668,812         0    0     11,235,101            14     0     11,218,081             4         0      sz = size; }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  template<class T>
              .         .    .              .             .     .              .             .         .  void vec<T>::clear(bool dealloc) {
    906,905,811 2,714,933  384    265,172,611    10,936,778     0          1,762             0         0      if (data != NULL){
          4,856         0    0              1             0     0              0             0         0          for (int i = 0; i < sz; i++) data[i].~T();
  1,439,717,062         4    3     49,926,864             1     0    332,004,064     1,111,146         0          sz = 0;
         53,976         5    5          8,832             1     0         43,633            37         0          if (dealloc) free(data), data = NULL, cap = 0; } }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  //=================================================================================================
              .         .    .              .             .     .              .             .         .  }
              .         .    .              .             .     .              .             .         .  
              .         .    .              .             .     .              .             .         .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir              I1mr      ILmr Dr             D1mr           DLmr      Dw             D1mw          DLmw  

-- line 51 ----------------------------------------
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  //=================================================================================================
              .         .    .              .              .         .              .             .     .  // Options:
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  static const char* _cat = "CORE";
              .         .    .              .              .         .              .             .     .  
              4         0    0              0              0         0              1             0     0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
              4         0    0              0              0         0              1             0     0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
              4         0    0              0              0         0              1             0     0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
              4         1    1              0              0         0              1             0     0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
              4         0    0              0              0         0              1             0     0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
              4         0    0              0              0         0              1             0     0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
              4         0    0              0              0         0              1             0     0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
              4         0    0              0              0         0              1             0     0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
              4         0    0              0              0         0              1             0     0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
              4         1    1              0              0         0              1             0     0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
              4         0    0              0              0         0              1             0     0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
              4         1    1              0              0         0              1             0     0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
              4         1    1              0              0         0              1             0     0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
              4         1    1              0              0         0              1             0     0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
              4         1    1              0              0         0              1             0     0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
              .         .    .              .              .         .              .             .     .  
              4         1    1              0              0         0              1             0     0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
              1         1    1              0              0         0              1             0     0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
              4         0    0              0              0         0              1             0     0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
              .         .    .              .              .         .              .             .     .  
              4         1    1              0              0         0              1             0     0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  //VSIDS_props_limit
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  //=================================================================================================
              .         .    .              .              .         .              .             .     .  // Constructor/Destructor:
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              4         1    1              0              0         0              2             0     0  Solver::Solver() :
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Parameters (user settable):
              .         .    .              .              .         .              .             .     .      //
              .         .    .              .              .         .              .             .     .      drup_file        (NULL)
              .         .    .              .              .         .              .             .     .    , verbosity        (0)
              .         .    .              .              .         .              .             .     .    , step_size        (opt_step_size)
              .         .    .              .              .         .              .             .     .    , step_size_dec    (opt_step_size_dec)
              .         .    .              .              .         .              .             .     .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
              .         .    .              .              .         .              .             .     .    , garbage_frac     (opt_garbage_frac)
              .         .    .              .              .         .              .             .     .    , restart_first    (opt_restart_first)
              .         .    .              .              .         .              .             .     .    , restart_inc      (opt_restart_inc)
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .    , min_number_of_learnts_copies(opt_min_dupl_app)  
              .         .    .              .              .         .              .             .     .    , max_lbd_dup(opt_max_lbd_dup)
              .         .    .              .              .         .              .             .     .    , dupl_db_init_size(opt_dupl_db_init_size)
              3         1    1              1              0         0              1             0     0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .    // Parameters (the rest):
              .         .    .              .              .         .              .             .     .    //
              .         .    .              .              .         .              .             .     .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .    // Parameters (experimental):
              .         .    .              .              .         .              .             .     .    //
              .         .    .              .              .         .              .             .     .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
              .         .    .              .              .         .              .             .     .    //
              .         .    .              .              .         .              .             .     .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
              .         .    .              .              .         .              .             .     .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
              .         .    .              .              .         .              .             .     .    , chrono_backtrack(0), non_chrono_backtrack(0)
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .    , ok                 (true)
              .         .    .              .              .         .              .             .     .    , cla_inc            (1)
              .         .    .              .              .         .              .             .     .    , var_inc            (1)
              1         0    0              0              0         0              0             0     0    , watches_bin        (WatcherDeleted(ca))
              .         .    .              .              .         .              .             .     .    , watches            (WatcherDeleted(ca))
              .         .    .              .              .         .              .             .     .    , qhead              (0)
              .         .    .              .              .         .              .             .     .    , simpDB_assigns     (-1)
              .         .    .              .              .         .              .             .     .    , simpDB_props       (0)
              .         .    .              .              .         .              .             .     .    , order_heap_CHB     (VarOrderLt(activity_CHB))
              .         .    .              .              .         .              .             .     .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
              .         .    .              .              .         .              .             .     .    , progress_estimate  (0)
              .         .    .              .              .         .              .             .     .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
              .         .    .              .              .         .              .             .     .    // simplifyAll adjust occasion
              .         .    .              .              .         .              .             .     .    , curSimplify(1)
              .         .    .              .              .         .              .             .     .    , nbconfbeforesimplify(1000)
              .         .    .              .              .         .              .             .     .    , incSimplify(1000)
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .    , my_var_decay       (0.6)
              .         .    .              .              .         .              .             .     .    , DISTANCE           (true)
              .         .    .              .              .         .              .             .     .    , var_iLevel_inc     (1)
             94         8    8             25              2         2             63             1     0    , order_heap_distance(VarOrderLt(activity_distance))
              .         .    .              .              .         .              .             .     .  
              4         0    0              3              0         0              0             0     0  {}
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  Solver::~Solver()
              .         .    .              .              .         .              .             .     .  {
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  // simplify All
              .         .    .              .              .         .              .             .     .  //
              .         .    .              .              .         .              .             .     .  CRef Solver::simplePropagate()
     14,766,640         5    2              0              0         0     11,074,980        17,087     0  {
      1,845,830         0    0              0              0         0      1,845,830             0     0      CRef    confl = CRef_Undef;
      1,845,830         0    0              0              0         0      1,845,830             0     0      int     num_props = 0;
      3,691,660         0    0              0              0         0      1,845,830        13,795     0      watches.cleanAll();
      5,537,490        78   59      1,845,830              0         0      1,845,830             0     0      watches_bin.cleanAll();
     17,585,044         0    0      8,792,522             32         0              0             0     0      while (qhead < trail.size())
              .         .    .              .              .         .              .             .     .      {
     34,734,375         1    1     13,893,750        516,170         0     13,893,750             0     0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .         .    .              .              .         .              .             .     .          vec<Watcher>&  ws = watches[p];
              .         .    .              .              .         .              .             .     .          Watcher        *i, *j, *end;
      6,946,692         0    0      6,946,692              0         0              0             0     0          num_props++;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          // First, Propagate binary clauses
              .         .    .              .              .         .              .             .     .          vec<Watcher>&  wbin = watches_bin[p];
              .         .    .              .              .         .              .             .     .  
     32,369,500         0    0      6,946,875      6,912,185     1,564              0             0     0          for (int k = 0; k<wbin.size(); k++)
              .         .    .              .              .         .              .             .     .          {
              .         .    .              .              .         .              .             .     .  
      6,134,540         0    0      4,231,163      1,315,203       181              0             0     0              Lit imp = wbin[k].blocker;
              .         .    .              .              .         .              .             .     .  
      6,134,540         0    0              0              0         0              0             0     0              if (value(imp) == l_False)
              .         .    .              .              .         .              .             .     .              {
            366         0    0            183              0         0            183             0     0                  return wbin[k].cref;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
      6,134,174        12   12              0              0         0              0             0     0              if (value(imp) == l_Undef)
              .         .    .              .              .         .              .             .     .              {
      2,602,108         0    0      2,602,108              0         0              0             0     0                  simpleUncheckEnqueue(imp, wbin[k].cref);
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
  2,797,926,348        74   53  1,379,237,980      4,698,260       363     12,715,929             0     0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
              .         .    .              .              .         .              .             .     .          {
              .         .    .              .              .         .              .             .     .              // Try to avoid inspecting the clause:
  1,365,344,596        62   42  1,365,344,596    170,377,059    30,981              0             0     0              Lit blocker = i->blocker;
  2,730,689,192         0    0  1,365,344,596      8,973,356        50              0             0     0              if (value(blocker) == l_True)
              .         .    .              .              .         .              .             .     .              {
              .         .    .              .              .         .              .             .     .                  *j++ = *i++; continue;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Make sure the false literal is data[1]:
  2,387,845,720         0    0  1,193,922,860              0         0              0             0     0              CRef     cr = i->cref;
              .         .    .              .              .         .              .             .     .              Clause&  c = ca[cr];
              .         .    .              .              .         .              .             .     .              Lit      false_lit = ~p;
  3,581,768,580         0    0  1,193,922,860  1,162,379,873    83,097              0             0     0              if (c[0] == false_lit)
  1,362,310,206         0    0    454,103,402     27,125,826     3,067    908,206,804             0     0                  c[0] = c[1], c[1] = false_lit;
              .         .    .              .              .         .              .             .     .              assert(c[1] == false_lit);
              .         .    .              .              .         .              .             .     .              //  i++;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // If 0th watch is true, then clause is already satisfied.
              .         .    .              .              .         .              .             .     .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
              .         .    .              .              .         .              .             .     .              // why not simply do i->blocker=first in this case?
              .         .    .              .              .         .              .             .     .              Lit     first = c[0];
              .         .    .              .              .         .              .             .     .              //  Watcher w     = Watcher(cr, first);
  3,029,676,832         0    0    320,915,556        514,215         3              0             0     0              if (first != blocker && value(first) == l_True)
              .         .    .              .              .         .              .             .     .              {
     67,435,365         0    0              0              0         0     67,435,365             0     0                  i->blocker = first;
    955,428,404         0    0    238,857,101              0         0    238,857,101     6,387,190     0                  *j++ = *i++; continue;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Look for new watch:
              .         .    .              .              .         .              .             .     .              //if (incremental)
              .         .    .              .              .         .              .             .     .              //{ // ----------------- INCREMENTAL MODE
              .         .    .              .              .         .              .             .     .              //	int choosenPos = -1;
              .         .    .              .              .         .              .             .     .              //	for (int k = 2; k < c.size(); k++)
              .         .    .              .              .         .              .             .     .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
              .         .    .              .              .         .              .             .     .              //		Watcher w = Watcher(cr, first); i++;
              .         .    .              .              .         .              .             .     .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
              .         .    .              .              .         .              .             .     .              //		watches[~c[1]].push(w);
              .         .    .              .              .         .              .             .     .              //		goto NextClause;
              .         .    .              .              .         .              .             .     .              //	}
              .         .    .              .              .         .              .             .     .              //}
              .         .    .              .              .         .              .             .     .              else
              .         .    .              .              .         .              .             .     .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
  3,386,724,883        80   58              0              0         0              0             0     0                  for (int k = 2; k < c.size(); k++)
              .         .    .              .              .         .              .             .     .                  {
              .         .    .              .              .         .              .             .     .  
  6,738,093,086         0    0              0              0         0              0             0     0                      if (value(c[k]) != l_False)
              .         .    .              .              .         .              .             .     .                      {
              .         .    .              .              .         .              .             .     .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
              .         .    .              .              .         .              .             .     .                          // the blocker is first in the watcher. However,
              .         .    .              .              .         .              .             .     .                          // the blocker in the corresponding watcher in ~first is not c[1]
              .         .    .              .              .         .              .             .     .                          Watcher w = Watcher(cr, first); i++;
  4,494,738,212         0    0  1,123,684,553              0         0  2,247,369,106             0     0                          c[1] = c[k]; c[k] = false_lit;
              .         .    .              .              .         .              .             .     .                          watches[~c[1]].push(w);
  1,123,684,553         0    0              0              0         0              0             0     0                          goto NextClause;
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Did not find watch -- clause is unit under assignment:
      2,802,942         0    0              0              0         0      2,802,942             0     0              i->blocker = first;
     11,211,768         1    0      2,802,942              0         0      2,802,942        77,865     0              *j++ = *i++;
      5,605,884        80   56              0              0         0              0             0     0              if (value(first) == l_False)
              .         .    .              .              .         .              .             .     .              {
        323,776         3    1              0              0         0         50,443            30     0                  confl = cr;
        100,886        77   58         50,443              0         0         50,443         2,857     0                  qhead = trail.size();
              .         .    .              .              .         .              .             .     .                  // Copy the remaining watches:
      8,291,768         7    3         95,021          7,114         0              0             0     0                  while (i < end)
      4,000,420         0    0      4,000,420        493,981        81      4,000,420        59,634     0                      *j++ = *i++;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              else
              .         .    .              .              .         .              .             .     .              {
              .         .    .              .              .         .              .             .     .                  simpleUncheckEnqueue(first, cr);
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  NextClause:;
              .         .    .              .              .         .              .             .     .          }
     11,538,474        80   57              0              0         0              0             0     0          ws.shrink(i - j);
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
      3,691,294         0    0      3,691,294      1,012,926         0              0             0     0      s_propagations += num_props;
              .         .    .              .              .         .              .             .     .  
      1,845,647         0    0      1,845,647              0         0              0             0     0      return confl;
    884,234,381        80   53     12,920,810      1,044,978         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
              .         .    .              .              .         .              .             .     .      assert(value(p) == l_Undef);
      5,354,607         0    0              0              0         0      5,354,607             0     0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
     14,400,874        80   61      7,200,437        420,858         0      7,200,437     6,929,549   557      vardata[var(p)].reason = from;
      4,598,329         0    0      4,598,329              0         0              0             0     0      trail.push_(p);
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::cancelUntilTrailRecord()
              .         .    .              .              .         .              .             .     .  {
     15,189,759         0    0        315,554          6,574         0              0             0     0      for (int c = trail.size() - 1; c >= trailRecord; c--)
              .         .    .              .              .         .              .             .     .      {
        157,777        80   58        157,777              0         0              0             0     0          Var x = var(trail[c]);
      7,673,768         0    0        157,777              0         0      7,200,437       272,192     0          assigns[x] = l_Undef;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      }
        157,777         0    0              0              0         0        157,777             0     0      qhead = trailRecord;
        315,554         0    0              0              0         0              0             0     0      trail.shrink(trail.size() - trailRecord);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::litsEnqueue(int cutP, Clause& c)
              .         .    .              .              .         .              .             .     .  {
              .         .    .              .              .         .              .             .     .      for (int i = cutP; i < c.size(); i++)
              .         .    .              .              .         .              .             .     .      {
              .         .    .              .              .         .              .             .     .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  bool Solver::removed(CRef cr) {
              .         .    .              .              .         .              .             .     .      return ca[cr].mark() == 1;
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
      1,662,639        73   53              0              0         0        906,894             0     0  {
        151,149         0    0              0              0         0              0             0     0      int pathC = 0;
        151,149         0    0              0              0         0              0             0     0      Lit p = lit_Undef;
        453,447         0    0        151,149              0         0              0             0     0      int index = trail.size() - 1;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      do{
      4,931,768        80   55              0              0         0              0             0     0          if (confl != CRef_Undef){
              .         .    .              .              .         .              .             .     .              reason_clause.push(confl);
              .         .    .              .              .         .              .             .     .              Clause& c = ca[confl];
              .         .    .              .              .         .              .             .     .              // Special case for binary clauses
              .         .    .              .              .         .              .             .     .              // The first one has to be SAT
      2,755,034        80   57              0              0         0              0             0     0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                  assert(value(c[1]) == l_True);
              .         .    .              .              .         .              .             .     .                  Lit tmp = c[0];
         16,416         0    0          5,472            372         0         10,944             0     0                  c[0] = c[1], c[1] = tmp;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              // if True_confl==true, then choose p begin with the 1th index of c;
     10,474,583         0    0      2,549,763        150,218         0              0             0     0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
              .         .    .              .              .         .              .             .     .                  Lit q = c[j];
      6,442,808         0    0      3,221,404      1,168,519        26              0             0     0                  if (!seen[var(q)]){
      2,314,735         0    0              0              0         0      2,314,735             0     0                      seen[var(q)] = 1;
      6,944,205         0    0      2,314,735              0         0              0             0     0                      pathC++;
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          else if (confl == CRef_Undef){
              .         .    .              .              .         .              .             .     .              out_learnt.push(~p);
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
      8,549,282        80   56      2,314,735              0         0              0             0     0          if (pathC == 0) break;
              .         .    .              .              .         .              .             .     .          // Select next clause to look at:
     48,653,877         0    0     16,217,959      1,719,908        56              0             0     0          while (!seen[var(trail[index--])]);
              .         .    .              .              .         .              .             .     .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
              .         .    .              .              .         .              .             .     .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
      4,629,470         0    0      2,314,735        150,071         0              0             0     0          if (trailRecord > index + 1) break;
              .         .    .              .              .         .              .             .     .          p = trail[index + 1];
              .         .    .              .              .         .              .             .     .          confl = reason(var(p));
      2,314,735         0    0              0              0         0      2,314,735             0     0          seen[var(p)] = 0;
      2,314,735         0    0              0              0         0              0             0     0          pathC--;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      } while (pathC >= 0);
      1,511,490        80   55      1,058,043              1         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::simplifyLearnt(Clause& c)
      1,419,993       160  113              0              0         0        946,662        12,487     0  {
              .         .    .              .              .         .              .             .     .      ////
        157,777         0    0        157,777         22,254         0              0             0     0      original_length_record += c.size();
              .         .    .              .              .         .              .             .     .  
        315,554         0    0        157,777         12,664         0        157,777        28,897     0      trailRecord = trail.size();// record the start pointer
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      vec<Lit> falseLit;
              .         .    .              .              .         .              .             .     .      falseLit.clear();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
              .         .    .              .              .         .              .             .     .  
        101,252        74   54              0              0         0              0             0     0      bool True_confl = false;
              .         .    .              .              .         .              .             .     .      int beforeSize, afterSize;
              .         .    .              .              .         .              .             .     .      beforeSize = c.size();
              .         .    .              .              .         .              .             .     .      int i, j;
              .         .    .              .              .         .              .             .     .      CRef confl;
              .         .    .              .              .         .              .             .     .  
      6,376,053        80   60              0              0         0              0             0     0      for (i = 0, j = 0; i < c.size(); i++){
      3,921,892         0    0              0              0         0              0             0     0          if (value(c[i]) == l_Undef){
              .         .    .              .              .         .              .             .     .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
              .         .    .              .              .         .              .             .     .              simpleUncheckEnqueue(~c[i]);
      7,332,694         0    0      1,845,830              0         0      1,845,830           528     0              c[j++] = c[i];
      5,537,490         0    0              0              0         0      1,845,830         1,518     0              confl = simplePropagate();
      5,537,490        80   54      1,845,830        981,891         0              0             0     0              if (confl != CRef_Undef){
              .         .    .              .              .         .              .             .     .                  break;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          else{
        230,232         0    0              0              0         0              0             0     0              if (value(c[i]) == l_True){
              .         .    .              .              .         .              .             .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
        402,092        62   42        100,523              0         0        100,523           188     0                  c[j++] = c[i];
        100,523        47   35              0              0         0              0             0     0                  True_confl = true;
              .         .    .              .              .         .              .             .     .                  confl = reason(var(c[i]));
              .         .    .              .              .         .              .             .     .                  break;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              else{
              .         .    .              .              .         .              .             .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
              .         .    .              .              .         .              .             .     .                  falseLit.push(c[i]);
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .      c.shrink(c.size() - j);
              .         .    .              .              .         .              .             .     .      afterSize = c.size();
              .         .    .              .              .         .              .             .     .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      if (confl != CRef_Undef || True_confl == true){
        151,149         0    0              0              0         0              0             0     0          simp_learnt_clause.clear();
        151,149         0    0              0              0         0              0             0     0          simp_reason_clause.clear();
        302,298         0    0              0              0         0              0             0     0          if (True_confl == true){
              .         .    .              .              .         .              .             .     .              simp_learnt_clause.push(c.last());
              .         .    .              .              .         .              .             .     .          }
      1,058,043        33   24              0              0         0        151,149             0     0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
              .         .    .              .              .         .              .             .     .  
        453,447         0    0        151,149              0         0              0             0     0          if (simp_learnt_clause.size() < c.size()){
        440,668        80   57        188,648              0         0              0             0     0              for (i = 0; i < simp_learnt_clause.size(); i++){
        691,220         0    0        172,805              0         0        172,805         1,481     0                  c[i] = simp_learnt_clause[i];
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              c.shrink(c.size() - i);
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      cancelUntilTrailRecord();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      ////
        157,777         0    0        157,777              0         0              0             0     0      simplified_length_record += c.size();
              .         .    .              .              .         .              .             .     .  
      1,262,216         0    0      1,104,439        156,502         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
              .         .    .              .              .         .              .             .     .  {
              .         .    .              .              .         .              .             .     .      int beforeSize, afterSize;
              .         .    .              .              .         .              .             .     .      int learnts_x_size_before = learnts_x.size();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      int ci, cj, li, lj;
              .         .    .              .              .         .              .             .     .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .         .    .              .              .         .              .             .     .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      return true;
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  bool Solver::simplifyLearnt_core()
            880         0    0              0              0         0            480             0     0  {
              .         .    .              .              .         .              .             .     .      int beforeSize, afterSize;
              .         .    .              .              .         .              .             .     .      int learnts_core_size_before = learnts_core.size();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      int ci, cj, li, lj;
              .         .    .              .              .         .              .             .     .      bool sat, false_lit;
              .         .    .              .              .         .              .             .     .      unsigned int nblevels;
              .         .    .              .              .         .              .             .     .      ////
              .         .    .              .              .         .              .             .     .      //printf("learnts_x size : %d\n", learnts_x.size());
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      ////
              .         .    .              .              .         .              .             .     .      int nbSimplified = 0;
              .         .    .              .              .         .              .             .     .      int nbSimplifing = 0;
              .         .    .              .              .         .              .             .     .  
      1,828,801        76   51             80              0         0              0             0     0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
      2,742,747        80   54      1,828,498         57,203     3,794              0             0     0          CRef cr = learnts_core[ci];
              .         .    .              .              .         .              .             .     .          Clause& c = ca[cr];
              .         .    .              .              .         .              .             .     .  
      1,828,498         0    0              0              0         0              0             0     0          if (removed(cr)) continue;
      1,828,498         0    0        914,249        108,228     4,339              0             0     0          else if (c.simplified()){
      1,795,992         0    0              0              0         0        897,996             0     0              learnts_core[cj++] = learnts_core[ci];
              .         .    .              .              .         .              .             .     .              ////
      2,693,988         0    0        897,996              0         0              0             0     0              nbSimplified++;
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          else{
              .         .    .              .              .         .              .             .     .              int saved_size=c.size();
              .         .    .              .              .         .              .             .     .              //         if (drup_file){
              .         .    .              .              .         .              .             .     .              //                 add_oc.clear();
              .         .    .              .              .         .              .             .     .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .         .    .              .              .         .              .             .     .              ////
              .         .    .              .              .         .              .             .     .              nbSimplifing++;
         16,253         0    0              0              0         0              0             0     0              sat = false_lit = false;
        356,134         0    0              0              0         0              0             0     0              for (int i = 0; i < c.size(); i++){
        356,134         0    0              0              0         0              0             0     0                  if (value(c[i]) == l_True){
              .         .    .              .              .         .              .             .     .                      sat = true;
              .         .    .              .              .         .              .             .     .                      break;
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .                  else if (value(c[i]) == l_False){
        388,640        80   55              0              0         0         16,253             0     0                      false_lit = true;
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              if (sat){
              .         .    .              .              .         .              .             .     .                  removeClause(cr);
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              else{
         97,518         0    0              0              0         0         48,759             0     0                  detachClause(cr, true);
              .         .    .              .              .         .              .             .     .  
         65,012        80   58         32,506              0         0              0             0     0                  if (false_lit){
              .         .    .              .              .         .              .             .     .                      for (li = lj = 0; li < c.size(); li++){
              .         .    .              .              .         .              .             .     .                          if (value(c[li]) != l_False){
              .         .    .              .              .         .              .             .     .                              c[lj++] = c[li];
              .         .    .              .              .         .              .             .     .                          }
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                      c.shrink(li - lj);
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                  beforeSize = c.size();
              .         .    .              .              .         .              .             .     .                  assert(c.size() > 1);
              .         .    .              .              .         .              .             .     .                  // simplify a learnt clause c
         65,012         0    0              0              0         0         32,506             0     0                  simplifyLearnt(c);
              .         .    .              .              .         .              .             .     .                  assert(c.size() > 0);
              .         .    .              .              .         .              .             .     .                  afterSize = c.size();
              .         .    .              .              .         .              .             .     .                  
         69,216         0    0         48,759         16,105         3              0             0     0                  if(drup_file && saved_size !=c.size()){
              .         .    .              .              .         .              .             .     .  #ifdef BIN_DRUP
              .         .    .              .              .         .              .             .     .                      binDRUP('a', c , drup_file);
              .         .    .              .              .         .              .             .     .                      //                    binDRUP('d', add_oc, drup_file);
              .         .    .              .              .         .              .             .     .  #else
              .         .    .              .              .         .              .             .     .                      for (int i = 0; i < c.size(); i++)
              .         .    .              .              .         .              .             .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .         .    .              .              .         .              .             .     .                      fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
              .         .    .              .              .         .              .             .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .         .    .              .              .         .              .             .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .         .    .              .              .         .              .             .     .                      //                    fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .         .    .              .              .         .              .             .     .  
         32,506         0    0              0              0         0              0             0     0                  if (c.size() == 1){
              .         .    .              .              .         .              .             .     .                      // when unit clause occur, enqueue and propagate
              .         .    .              .              .         .              .             .     .                      uncheckedEnqueue(c[0]);
              .         .    .              .              .         .              .             .     .                      if (propagate() != CRef_Undef){
              .         .    .              .              .         .              .             .     .                          ok = false;
              .         .    .              .              .         .              .             .     .                          return false;
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                      // delete the clause memory in logic
              .         .    .              .              .         .              .             .     .                      c.mark(1);
-- line 671 ----------------------------------------
-- line 675 ----------------------------------------
              .         .    .              .              .         .              .             .     .  //#else
              .         .    .              .              .         .              .             .     .  //                    fprintf(drup_file, "d ");
              .         .    .              .              .         .              .             .     .  //                    for (int i = 0; i < c.size(); i++)
              .         .    .              .              .         .              .             .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .         .    .              .              .         .              .             .     .  //                    fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  //#endif
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .                  else{
         48,759         0    0              0              0         0         16,253             0     0                      attachClause(cr);
         97,518        79   55         48,759         32,224         0         16,253             0     0                      learnts_core[cj++] = learnts_core[ci];
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                      nblevels = computeLBD(c);
         32,506        77   52              0              0         0              0             0     0                      if (nblevels < c.lbd()){
              .         .    .              .              .         .              .             .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .         .    .              .              .         .              .             .     .                          c.set_lbd(nblevels);
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                      c.setSimplified(true);
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
             80         0    0              0              0         0              0             0     0      learnts_core.shrink(ci - cj);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .         .    .              .              .         .              .             .     .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
              .         .    .              .              .         .              .             .     .  
             80        64   45              0              0         0              0             0     0      return true;
              .         .    .              .              .         .              .             .     .  
            640         0    0            560             80         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
     54,487,368         2    2              0              0         0     36,324,912             0     0  int Solver::is_duplicate(std::vector<uint32_t>&c){
     12,108,304         0    0              0              0         0     12,108,304        20,964     0     auto time_point_0 = std::chrono::high_resolution_clock::now();
      6,054,152         0    0      6,054,152      3,022,117         0              0             0     0      dupl_db_size++;
     15,143,353       158   10      3,334,245              0         0              0             0     0      int res = 0;    
              .         .    .              .              .         .              .             .     .      
     12,108,304         0    0     12,108,304              0         0              0             0     0      int sz = c.size();
              .         .    .              .              .         .              .             .     .      std::vector<uint32_t> tmp(c);    
              .         .    .              .              .         .              .             .     .      sort(tmp.begin(),tmp.end());
              .         .    .              .              .         .              .             .     .      
      6,054,152 1,528,934    7              0              0         0      6,054,152             0     0      uint64_t hash = 0;    
              .         .    .              .              .         .              .             .     .      
    260,721,700     9,728   59              0              0         0      6,054,152             0     0      for (int i =0; i<sz; i++) {
  1,061,442,420         0    0    106,144,242              0         0              0             0     0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
              .         .    .              .              .         .              .             .     .      }    
              .         .    .              .              .         .              .             .     .      
      6,054,152         0    0              0              0         0      6,054,152             0     0      int32_t head = tmp[0];
              .         .    .              .              .         .              .             .     .      auto it0 = ht.find(head);
     30,269,419         0    0      6,054,143              0         0              0             0     0      if (it0 != ht.end()){
              .         .    .              .              .         .              .             .     .          auto it1=ht[head].find(sz);
     12,107,422         0    0              0              0         0              0             0     0          if (it1 != ht[head].end()){
      6,043,721         0    0              0              0         0      6,043,721             0     0              auto it2 = ht[head][sz].find(hash);
     18,131,163         0    0              0              0         0      6,043,721             0     0              if (it2 != ht[head][sz].end()){
        448,794         0    0        149,598         37,631    10,833        149,598             0     0                  it2->second++;
        149,598         0    0              0              0         0              0             0     0                  res = it2->second;            
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              else{
      5,894,123         0    0              0              0         0      5,894,123             0     0                  ht[head][sz][hash]=1;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          else{            
         19,980         2    1              0              0         0          9,990             0     0              ht[head][sz][hash]=1;
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }else{        
      5,904,995       390    2              0              0         0      5,904,995           752     0          ht[head][sz][hash]=1;
              .         .    .              .              .         .              .             .     .      } 
      6,054,152        41    1              0              0         0      6,054,152             0     0      auto time_point_1 = std::chrono::high_resolution_clock::now();
              .         .    .              .              .         .              .             .     .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
              .         .    .              .              .         .              .             .     .      return res;
     54,487,368         0    0     42,379,064          7,609         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  bool Solver::simplifyLearnt_tier2()
            880        80   58              0              0         0            480             0     0  {
              .         .    .              .              .         .              .             .     .      int beforeSize, afterSize;
              .         .    .              .              .         .              .             .     .      int learnts_tier2_size_before = learnts_tier2.size();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      int ci, cj, li, lj;
              .         .    .              .              .         .              .             .     .      bool sat, false_lit;
              .         .    .              .              .         .              .             .     .      unsigned int nblevels;
              .         .    .              .              .         .              .             .     .      ////
              .         .    .              .              .         .              .             .     .      //printf("learnts_x size : %d\n", learnts_x.size());
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      ////
              .         .    .              .              .         .              .             .     .      int nbSimplified = 0;
              .         .    .              .              .         .              .             .     .      int nbSimplifing = 0;
              .         .    .              .              .         .              .             .     .  
        399,014        48   20             80              0         0              0             0     0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
        598,161         0    0        398,774         20,392       503              0             0     0          CRef cr = learnts_tier2[ci];
              .         .    .              .              .         .              .             .     .          Clause& c = ca[cr];
              .         .    .              .              .         .              .             .     .  
        398,774         0    0              0              0         0              0             0     0          if (removed(cr)) continue;
        398,774         0    0        199,387         24,141         0              0             0     0          else if (c.simplified()){
        115,726         0    0              0              0         0         57,863            84     0              learnts_tier2[cj++] = learnts_tier2[ci];
              .         .    .              .              .         .              .             .     .              ////
        456,637         0    0         57,863              0         0              0             0     0              nbSimplified++;
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          else{
              .         .    .              .              .         .              .             .     .              int saved_size=c.size();
              .         .    .              .              .         .              .             .     .              //            if (drup_file){
              .         .    .              .              .         .              .             .     .              //                    add_oc.clear();
              .         .    .              .              .         .              .             .     .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .         .    .              .              .         .              .             .     .              ////
              .         .    .              .              .         .              .             .     .              nbSimplifing++;
        141,524         0    0              0              0         0              0             0     0              sat = false_lit = false;
      3,990,010         0    0              0              0         0              0             0     0              for (int i = 0; i < c.size(); i++){
      3,990,010         0    0              0              0         0              0             0     0                  if (value(c[i]) == l_True){
              .         .    .              .              .         .              .             .     .                      sat = true;
              .         .    .              .              .         .              .             .     .                      break;
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .                  else if (value(c[i]) == l_False){
      4,273,058        21   16              0              0         0        141,524             0     0                      false_lit = true;
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              if (sat){
              .         .    .              .              .         .              .             .     .                  removeClause(cr);
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              else{
        849,144        63   49              0              0         0        424,572            59     0                  detachClause(cr, true);
              .         .    .              .              .         .              .             .     .  
        566,096         0    0        283,048         11,707         0              0             0     0                  if (false_lit){
              .         .    .              .              .         .              .             .     .                      for (li = lj = 0; li < c.size(); li++){
              .         .    .              .              .         .              .             .     .                          if (value(c[li]) != l_False){
              .         .    .              .              .         .              .             .     .                              c[lj++] = c[li];
              .         .    .              .              .         .              .             .     .                          }
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                      c.shrink(li - lj);
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                  beforeSize = c.size();
              .         .    .              .              .         .              .             .     .                  assert(c.size() > 1);
              .         .    .              .              .         .              .             .     .                  // simplify a learnt clause c
        707,620         0    0              0              0         0        424,572             0     0                  simplifyLearnt(c);
              .         .    .              .              .         .              .             .     .                  assert(c.size() > 0);
              .         .    .              .              .         .              .             .     .                  afterSize = c.size();
              .         .    .              .              .         .              .             .     .                  
        566,096        79   56        283,048        141,026         0              0             0     0                  if(drup_file && saved_size!=c.size()){
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  #ifdef BIN_DRUP
              .         .    .              .              .         .              .             .     .                      binDRUP('a', c , drup_file);
              .         .    .              .              .         .              .             .     .                      //                    binDRUP('d', add_oc, drup_file);
              .         .    .              .              .         .              .             .     .  #else
              .         .    .              .              .         .              .             .     .                      for (int i = 0; i < c.size(); i++)
              .         .    .              .              .         .              .             .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .         .    .              .              .         .              .             .     .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
              .         .    .              .              .         .              .             .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .         .    .              .              .         .              .             .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .         .    .              .              .         .              .             .     .                      //                    fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .         .    .              .              .         .              .             .     .  
        283,048         0    0              0              0         0              0             0     0                  if (c.size() == 1){
              .         .    .              .              .         .              .             .     .                      // when unit clause occur, enqueue and propagate
              .         .    .              .              .         .              .             .     .                      uncheckedEnqueue(c[0]);
              .         .    .              .              .         .              .             .     .                      if (propagate() != CRef_Undef){
              .         .    .              .              .         .              .             .     .                          ok = false;
              .         .    .              .              .         .              .             .     .                          return false;
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                      // delete the clause memory in logic
              .         .    .              .              .         .              .             .     .                      c.mark(1);
-- line 838 ----------------------------------------
-- line 845 ----------------------------------------
              .         .    .              .              .         .              .             .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .         .    .              .              .         .              .             .     .  //                    fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  //#endif
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .                  else{
              .         .    .              .              .         .              .             .     .                      
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                      nblevels = computeLBD(c);
        283,048         0    0              0              0         0              0             0     0                      if (nblevels < c.lbd()){
              .         .    .              .              .         .              .             .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .         .    .              .              .         .              .             .     .                          c.set_lbd(nblevels);
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                       //duplicate learnts 
              .         .    .              .              .         .              .             .     .                      int id = 0;                    
              .         .    .              .              .         .              .             .     .                      
              .         .    .              .              .         .              .             .     .                      std::vector<uint32_t> tmp;
      6,707,097         0    0      4,944,419              0         0              0             0     0                      for (int i = 0; i < c.size(); i++)                           
      3,484,978         0    0      1,742,489              0         0      1,742,489             0     0                          tmp.push_back(c[i].x);
        566,096         0    0              0              0         0        141,524             0     0                      id = is_duplicate(tmp);
              .         .    .              .              .         .              .             .     .                       
              .         .    .              .              .         .              .             .     .                                          
              .         .    .              .              .         .              .             .     .                      //duplicate learnts 
              .         .    .              .              .         .              .             .     .  
        566,096        11   10        141,524              0         0              0             0     0                      if (id < min_number_of_learnts_copies+2){
        399,309         6    3              0              0         0        133,103             0     0                          attachClause(cr);
        658,833         0    0        399,309        265,226         0        133,103       117,215     0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
        532,412        79   60        133,103              0         0              0             0     0                          if (id == min_number_of_learnts_copies+1){                            
          6,434         4    4          6,434              0         0              0             0     0                              duplicates_added_minimization++;                                  
              .         .    .              .              .         .              .             .     .                          }
        253,338         0    0        126,669        126,060         3              0             0     0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
              .         .    .              .              .         .              .             .     .                          //if (id == min_number_of_learnts_copies+1){
              .         .    .              .              .         .              .             .     .                              cj--;
              2         2    2              0              0         0              0             0     0                              learnts_core.push(cr);
              .         .    .              .              .         .              .             .     .                              c.mark(CORE);
              .         .    .              .              .         .              .             .     .                          }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                          c.setSimplified(true);
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
             80        71   58              0              0         0              0             0     0      learnts_tier2.shrink(ci - cj);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .         .    .              .              .         .              .             .     .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
              .         .    .              .              .         .              .             .     .  
             80         0    0              0              0         0              0             0     0      return true;
              .         .    .              .              .         .              .             .     .  
            640         0    0            560             80         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  bool Solver::simplifyAll()
            400        15   15              0              0         0            240             0     0  {
              .         .    .              .              .         .              .             .     .      ////
            160         0    0              0              0         0             80             0     0      simplified_length_record = original_length_record = 0;
              .         .    .              .              .         .              .             .     .  
            320         0    0             80             80         3              0             0     0      if (!ok || propagate() != CRef_Undef)
              .         .    .              .              .         .              .             .     .          return ok = false;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      //// cleanLearnts(also can delete these code), here just for analyzing
              .         .    .              .              .         .              .             .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .         .    .              .              .         .              .             .     .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
              .         .    .              .              .         .              .             .     .      //local_learnts_dirty = tier2_learnts_dirty = false;
              .         .    .              .              .         .              .             .     .  
            320         0    0              0              0         0             80             0     0      if (!simplifyLearnt_core()) return ok = false;
            320        80   60              0              0         0             80             0     0      if (!simplifyLearnt_tier2()) return ok = false;
              .         .    .              .              .         .              .             .     .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      checkGarbage();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      ////
              .         .    .              .              .         .              .             .     .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
              .         .    .              .              .         .              .             .     .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      return true;
            400         0    0            320             80         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  //=================================================================================================
              .         .    .              .              .         .              .             .     .  // Minor methods:
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
              .         .    .              .              .         .              .             .     .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
              .         .    .              .              .         .              .             .     .  //
              .         .    .              .              .         .              .             .     .  Var Solver::newVar(bool sign, bool dvar)
         24,250         1    1              0              0         0         19,400             0     0  {
              .         .    .              .              .         .              .             .     .      int v = nVars();
              .         .    .              .              .         .              .             .     .      watches_bin.init(mkLit(v, false));
              .         .    .              .              .         .              .             .     .      watches_bin.init(mkLit(v, true ));
              .         .    .              .              .         .              .             .     .      watches  .init(mkLit(v, false));
              .         .    .              .              .         .              .             .     .      watches  .init(mkLit(v, true ));
             17         1    1              0              0         0              0             0     0      assigns  .push(l_Undef);
             17         1    1              0              0         0              0             0     0      vardata  .push(mkVarData(CRef_Undef, 0));
             17         0    0              0              0         0              0             0     0      activity_CHB  .push(0);
          7,309         0    0          2,425             20         0             17             0     0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
              .         .    .              .              .         .              .             .     .  
             17         1    1              0              0         0              0             0     0      picked.push(0);
             17         0    0              0              0         0              0             0     0      conflicted.push(0);
             17         0    0              0              0         0              0             0     0      almost_conflicted.push(0);
              .         .    .              .              .         .              .             .     .  #ifdef ANTI_EXPLORATION
             17         0    0              0              0         0              0             0     0      canceled.push(0);
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .  
             17         0    0              0              0         0              0             0     0      seen     .push(0);
             17         0    0              0              0         0              0             0     0      seen2    .push(0);
             17         0    0              0              0         0              0             0     0      polarity .push(sign);
             17         0    0              0              0         0              0             0     0      decision .push();
         12,125         1    1              0              0         0          4,850            49     0      trail    .capacity(v+1);
              .         .    .              .              .         .              .             .     .      setDecisionVar(v, dvar);
              .         .    .              .              .         .              .             .     .  
             17         0    0              0              0         0              0             0     0      activity_distance.push(0);
             17         1    1              0              0         0              0             0     0      var_iLevel.push(0);
             17         0    0              0              0         0              0             0     0      var_iLevel_tmp.push(0);
             17         0    0              0              0         0              0             0     0      pathCs.push(0);
              .         .    .              .              .         .              .             .     .      return v;
         21,825         0    0         16,975             15         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  bool Solver::addClause_(vec<Lit>& ps)
        381,738         2    1              0              0         0        327,204             0     0  {
              .         .    .              .              .         .              .             .     .      assert(decisionLevel() == 0);
        163,602         1    1         54,534              0         0              0             0     0      if (!ok) return false;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Check if clause is satisfied and remove false/duplicate literals:
              .         .    .              .              .         .              .             .     .      sort(ps);
              .         .    .              .              .         .              .             .     .      Lit p; int i, j;
              .         .    .              .              .         .              .             .     .  
        109,068         0    0         54,534             16         0              0             0     0      if (drup_file){
              .         .    .              .              .         .              .             .     .          add_oc.clear();
         54,534         2    1         54,534              0         0              0             0     0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
              .         .    .              .              .         .              .             .     .  
        646,824         0    0              0              0         0              0             0     0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
      1,139,161         0    0        203,459              0         0              0             0     0          if (value(ps[i]) == l_True || ps[i] == ~p)
              .         .    .              .              .         .              .             .     .              return true;
        668,892         4    2              0              0         0              0             0     0          else if (value(ps[i]) != l_False && ps[i] != p)
        465,582         0    0        155,194              0         0        155,194             0     0              ps[j++] = p = ps[i];
        242,616         0    0         30,327              0         0              0             0     0      ps.shrink(i - j);
              .         .    .              .              .         .              .             .     .  
         60,654         2    1              0              0         0              0             0     0      if (drup_file && i != j){
              .         .    .              .              .         .              .             .     .  #ifdef BIN_DRUP
              .         .    .              .              .         .              .             .     .          binDRUP('a', ps, drup_file);
         30,327         0    0         30,327              0         0              0             0     0          binDRUP('d', add_oc, drup_file);
              .         .    .              .              .         .              .             .     .  #else
              .         .    .              .              .         .              .             .     .          for (int i = 0; i < ps.size(); i++)
              .         .    .              .              .         .              .             .     .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
              .         .    .              .              .         .              .             .     .          fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          fprintf(drup_file, "d ");
              .         .    .              .              .         .              .             .     .          for (int i = 0; i < add_oc.size(); i++)
              .         .    .              .              .         .              .             .     .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .         .    .              .              .         .              .             .     .          fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .      
         60,654         0    0              0              0         0              0             0     0      if (ps.size() == 0)
              .         .    .              .              .         .              .             .     .          return ok = false;
         60,654         2    1              0              0         0              0             0     0      else if (ps.size() == 1){
          4,086         1    1          1,362              0         0            681             0     0          uncheckedEnqueue(ps[0]);
          2,724         0    0              0              0         0            681             0     0          return ok = (propagate() == CRef_Undef);
              .         .    .              .              .         .              .             .     .      }else{
         29,646         0    0              0              0         0         29,646             0     0          CRef cr = ca.alloc(ps, false);
              .         .    .              .              .         .              .             .     .          //auto ca_size=ca.size();
              .         .    .              .              .         .              .             .     .          //printf("ca size:%d\n",ca_size);
         88,938         0    0              0              0         0         29,646             0     0          clauses.push(cr);
         88,938         1    0         29,646              0         0         29,646             0     0          attachClause(cr);
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
         29,646         0    0              0              0         0              0             0     0      return true;
        599,874         0    0        381,738              5         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
    113,856,730         8    6              0              0         0     68,314,038            18     0  void Solver::attachClause(CRef cr) {
              .         .    .              .              .         .              .             .     .      const Clause& c = ca[cr];
              .         .    .              .              .         .              .             .     .      assert(c.size() > 1);
     45,541,379         0    0     11,385,673             35         0              0             0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .         .    .              .              .         .              .             .     .      ws[~c[0]].push(Watcher(cr, c[1]));
              .         .    .              .              .         .              .             .     .      ws[~c[1]].push(Watcher(cr, c[0]));
     34,126,630         0    0     22,740,957      6,166,556         0              0             0     0      if (c.learnt()) learnts_literals += c.size();
     91,115,773         2    0     79,730,100             16         0              0             0     0      else            clauses_literals += c.size(); }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
     67,897,446       828   42              0              0         0     45,264,964            71     0  void Solver::detachClause(CRef cr, bool strict) {
              .         .    .              .              .         .              .             .     .      const Clause& c = ca[cr];
              .         .    .              .              .         .              .             .     .      assert(c.size() > 1);
     45,264,964         0    0              0              0         0              0             0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .         .    .              .              .         .              .             .     .      
     45,264,964         0    0              0              0         0              0             0     0      if (strict){
              .         .    .              .              .         .              .             .     .          remove(ws[~c[0]], Watcher(cr, c[1]));
              .         .    .              .              .         .              .             .     .          remove(ws[~c[1]], Watcher(cr, c[0]));
              .         .    .              .              .         .              .             .     .      }else{
              .         .    .              .              .         .              .             .     .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
              .         .    .              .              .         .              .             .     .          ws.smudge(~c[0]);
              .         .    .              .              .         .              .             .     .          ws.smudge(~c[1]);
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
     33,938,779         6    2     22,622,538         27,565         3              0             0     0      if (c.learnt()) learnts_literals -= c.size();
     67,907,390         0    0     56,591,149         13,902         0              0             0     0      else            clauses_literals -= c.size(); }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
     89,261,768     1,497  173              0              0         0     44,630,884             0     0  void Solver::removeClause(CRef cr) {
              .         .    .              .              .         .              .             .     .      Clause& c = ca[cr];
              .         .    .              .              .         .              .             .     .  
     33,473,163         0    0     11,157,721            750         0              0             0     0      if (drup_file){
              .         .    .              .              .         .              .             .     .          if (c.mark() != 1){
              .         .    .              .              .         .              .             .     .  #ifdef BIN_DRUP
              .         .    .              .              .         .              .             .     .              binDRUP('d', c, drup_file);
              .         .    .              .              .         .              .             .     .  #else
              .         .    .              .              .         .              .             .     .              fprintf(drup_file, "d ");
              .         .    .              .              .         .              .             .     .              for (int i = 0; i < c.size(); i++)
              .         .    .              .              .         .              .             .     .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .         .    .              .              .         .              .             .     .              fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .          }else
              .         .    .              .              .         .              .             .     .              printf("c Bug. I don't expect this to happen.\n");
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
     44,630,884       508   64              0              0         0     11,157,721             0     0      detachClause(cr);
              .         .    .              .              .         .              .             .     .      // Don't leave pointers to free'd memory!
              .         .    .              .              .         .              .             .     .      if (locked(c)){
              .         .    .              .              .         .              .             .     .          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
              .         .    .              .              .         .              .             .     .          vardata[var(implied)].reason = CRef_Undef; }
              .         .    .              .              .         .              .             .     .      c.mark(1);
              .         .    .              .              .         .              .             .     .      ca.free(cr);
     66,946,326         0    0     55,788,605              0         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  bool Solver::satisfied(const Clause& c) const {
        268,508         0    0              0              0         0              0             0     0      for (int i = 0; i < c.size(); i++)
        316,118         0    0        111,979             96         0              0             0     0          if (value(c[i]) == l_True)
            843         1    1              0              0         0              0             0     0              return true;
         45,393         0    0         23,118              0         0              0             0     0      return false; }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
              .         .    .              .              .         .              .             .     .  //
    100,941,759     4,874   68              0              0         0     67,294,506             0     0  void Solver::cancelUntil(int bLevel) {
              .         .    .              .              .         .              .             .     .  	
     44,882,634         5    2          9,823              0         0     11,215,751             0     0      if (decisionLevel() > bLevel){
              .         .    .              .              .         .              .             .     .  #ifdef PRINT_OUT
              .         .    .              .              .         .              .             .     .  		std::cout << "bt " << bLevel << "\n";
              .         .    .              .              .         .              .             .     .  #endif				
     22,431,502         0    0              0              0         0     11,215,751             0     0  		add_tmp.clear();
  8,947,277,794     5,638   52  1,814,130,211     15,619,627        22              0             0     0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
              .         .    .              .              .         .              .             .     .          {
              .         .    .              .              .         .              .             .     .              Var      x  = var(trail[c]);
              .         .    .              .              .         .              .             .     .  
  3,516,102,912         0    0  1,758,051,456    902,024,606         1              0             0     0  			if (level(x) <= bLevel)
              .         .    .              .              .         .              .             .     .  			{
              .         .    .              .              .         .              .             .     .  				add_tmp.push(trail[c]);
              .         .    .              .              .         .              .             .     .  			}
              .         .    .              .              .         .              .             .     .  			else
              .         .    .              .              .         .              .             .     .  			{
  3,516,100,110         0    0  1,758,050,055            225         0              0             0     0  				 if (!VSIDS){
  2,580,352,968         0    0  1,720,235,312          3,091         0              0             0     0  					uint32_t age = conflicts - picked[x];
  1,720,235,312         0    0    860,117,656    436,564,513        19              0             0     0  					if (age > 0){
  8,598,445,400        54   26  3,439,378,160    829,701,244         0              0             0     0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
    859,844,540         0    0    859,844,540    440,145,785       130              0             0     0  						double old_activity = activity_CHB[x];
  6,018,911,780        17   12  1,719,689,080      1,782,913         0    859,844,540             0     0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
              .         .    .              .              .         .              .             .     .  						if (order_heap_CHB.inHeap(x)){
  5,089,995,186        21   11              0              0         0  2,544,997,593             0     0  							if (activity_CHB[x] > old_activity)
              .         .    .              .              .         .              .             .     .  								order_heap_CHB.decrease(x);
              .         .    .              .              .         .              .             .     .  							else
              .         .    .              .              .         .              .             .     .  								order_heap_CHB.increase(x);
              .         .    .              .              .         .              .             .     .  						}
              .         .    .              .              .         .              .             .     .  					}
              .         .    .              .              .         .              .             .     .  #ifdef ANTI_EXPLORATION
  1,720,235,312         0    0    860,117,656              0         0    860,117,656   442,201,338    43  					canceled[x] = conflicts;
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .  				}
              .         .    .              .              .         .              .             .     .  				
  3,516,100,110        56   21  1,758,050,055              0         0  1,758,050,055   168,087,581     0  				assigns [x] = l_Undef;
              .         .    .              .              .         .              .             .     .  #ifdef PRINT_OUT
              .         .    .              .              .         .              .             .     .  				std::cout << "undo " << x << "\n";
              .         .    .              .              .         .              .             .     .  #endif				
  3,516,100,110         0    0  1,758,050,055              0         0              0             0     0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
  1,758,050,055         0    0  1,758,050,055              0         0              0             0     0  					polarity[x] = sign(trail[c]);
              .         .    .              .              .         .              .             .     .  				insertVarOrder(x);
              .         .    .              .              .         .              .             .     .  			}
              .         .    .              .              .         .              .             .     .          }
     11,215,751         0    0              0              0         0     11,215,751             0     0          qhead = trail_lim[bLevel];
     22,431,502         0    0              0              0         0              0             0     0          trail.shrink(trail.size() - trail_lim[bLevel]);
     33,647,253         0    0     11,215,751              0         0              0             0     0          trail_lim.shrink(trail_lim.size() - bLevel);
     33,650,055         2    2     11,215,751              0         0              0             0     0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
              .         .    .              .              .         .              .             .     .  		{
            321         0    0            107              0         0              0             0     0  			trail.push_(add_tmp[nLitId]);
              .         .    .              .              .         .              .             .     .  		}
              .         .    .              .              .         .              .             .     .  		
              .         .    .              .              .         .              .             .     .  		add_tmp.clear();
     89,726,008         0    0     78,510,257      4,770,970         0              0             0     0      } }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  //=================================================================================================
              .         .    .              .              .         .              .             .     .  // Major methods:
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  Lit Solver::pickBranchLit()
     95,127,272        34   11              0              0         0     71,345,454         1,115     0  {
              .         .    .              .              .         .              .             .     .      Var next = var_Undef;
              .         .    .              .              .         .              .             .     .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
     82,344,176       434   83     23,419,984      9,947,322         8              0             0     0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Random decision:
              .         .    .              .              .         .              .             .     .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
              .         .    .              .              .         .              .             .     .          next = order_heap[irand(random_seed,order_heap.size())];
              .         .    .              .              .         .              .             .     .          if (value(next) == l_Undef && decision[next])
              .         .    .              .              .         .              .             .     .              rnd_decisions++; }*/
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Activity based decision:
    199,233,515       310    1     87,725,848     11,600,728       139              0             0     0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
     52,053,126         0    0              0              0         0              0             0     0          if (order_heap.empty())
              1         0    0              0              0         0              0             0     0              return lit_Undef;
              .         .    .              .              .         .              .             .     .          else{
              .         .    .              .              .         .              .             .     .  #ifdef ANTI_EXPLORATION
     52,053,124         0    0     26,026,562             10         0              0             0     0              if (!VSIDS){
              .         .    .              .              .         .              .             .     .                  Var v = order_heap_CHB[0];
     23,520,960         0    0     23,520,960        772,445         0              0             0     0                  uint32_t age = conflicts - canceled[v];
     29,243,454         0    0     13,558,084     10,858,555       745      1,063,643             0     0                  while (age > 0){
              .         .    .              .              .         .              .             .     .                      double decay = pow(0.95, age);
      3,595,208         0    0      1,797,604        107,513         8      1,797,604             0     0                      activity_CHB[v] *= decay;
              .         .    .              .              .         .              .             .     .                      if (order_heap_CHB.inHeap(v))
              .         .    .              .              .         .              .             .     .                          order_heap_CHB.increase(v);
      5,392,812         0    0      3,595,208              0         0      1,797,604             0     0                      canceled[v] = conflicts;
              .         .    .              .              .         .              .             .     .                      v = order_heap_CHB[0];
              .         .    .              .              .         .              .             .     .                      age = conflicts - canceled[v];
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .              next = order_heap.removeMin();
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .  
     47,563,632         0    0     23,781,816     11,356,135        93              0             0     0      return mkLit(next, polarity[next]);
    107,018,180         0    0     83,236,363             17         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
              .         .    .              .              .         .              .             .     .  {
              .         .    .              .              .         .              .             .     .  	ConflictData data;
              .         .    .              .              .         .              .             .     .  	Clause& conflCls = ca[cind];
              .         .    .              .              .         .              .             .     .  	data.nHighestLevel = level(var(conflCls[0]));
     44,823,712         0    0     22,411,856        229,880         0              0             0     0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
              .         .    .              .              .         .              .             .     .  	{
              .         .    .              .              .         .              .             .     .  		return data;
              .         .    .              .              .         .              .             .     .  	}
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  	int highestId = 0;
              .         .    .              .              .         .              .             .     .      data.bOnlyOneLitFromHighest = true;
              .         .    .              .              .         .              .             .     .  	// find the largest decision level in the clause
            496         1    1              0              0         0              0             0     0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
              .         .    .              .              .         .              .             .     .  	{
              .         .    .              .              .         .              .             .     .  		int nLevel = level(var(conflCls[nLitId]));
            243         0    0              0              0         0              0             0     0  		if (nLevel > data.nHighestLevel)
              .         .    .              .              .         .              .             .     .  		{
              .         .    .              .              .         .              .             .     .  			highestId = nLitId;
              .         .    .              .              .         .              .             .     .  			data.nHighestLevel = nLevel;
              9         0    0              0              0         0              0             0     0  			data.bOnlyOneLitFromHighest = true;
              .         .    .              .              .         .              .             .     .  		}
              .         .    .              .              .         .              .             .     .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
              .         .    .              .              .         .              .             .     .  		{
            198         0    0              0              0         0              0             0     0  			data.bOnlyOneLitFromHighest = false;
              .         .    .              .              .         .              .             .     .  		}
              .         .    .              .              .         .              .             .     .  	}
              .         .    .              .              .         .              .             .     .  
             70         6    1              0              0         0              0             0     0  	if (highestId != 0)
              .         .    .              .              .         .              .             .     .  	{
              .         .    .              .              .         .              .             .     .  		std::swap(conflCls[0], conflCls[highestId]);
             16         0    0              0              0         0              0             0     0  		if (highestId > 1)
              .         .    .              .              .         .              .             .     .  		{
             12         0    0              0              0         0              0             0     0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
              .         .    .              .              .         .              .             .     .  			//ws.smudge(~conflCls[highestId]);
              .         .    .              .              .         .              .             .     .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
              .         .    .              .              .         .              .             .     .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
              .         .    .              .              .         .              .             .     .  		}
              .         .    .              .              .         .              .             .     .  	}
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  	return data;
              .         .    .              .              .         .              .             .     .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
              .         .    .              .              .         .              .             .     .  |  
              .         .    .              .              .         .              .             .     .  |    Post-conditions:
              .         .    .              .              .         .              .             .     .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
              .         .    .              .              .         .              .             .     .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
              .         .    .              .              .         .              .             .     .  |        rest of literals. There may be others from the same level though.
              .         .    .              .              .         .              .             .     .  |  
              .         .    .              .              .         .              .             .     .  |________________________________________________________________________________________________@*/
              .         .    .              .              .         .              .             .     .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
    145,677,064        70   48              0              0         0    100,853,352             0     0  {
     11,205,928         0    0              0              0         0     11,205,928             0     0      int pathC = 0;
     11,205,928         0    0              0              0         0              0             0     0      Lit p     = lit_Undef;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Generate conflict clause:
              .         .    .              .              .         .              .             .     .      //
              .         .    .              .              .         .              .             .     .      out_learnt.push();      // (leave room for the asserting literal)
     22,411,856         0    0     11,205,928             30         0              0             0     0      int index   = trail.size() - 1;
     11,205,928         0    0     11,205,928              0         0              0             0     0      int nDecisionLevel = level(var(ca[confl][0]));
              .         .    .              .              .         .              .             .     .      assert(nDecisionLevel == level(var(ca[confl][0])));
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      do{
              .         .    .              .              .         .              .             .     .          assert(confl != CRef_Undef); // (otherwise should be UIP)
              .         .    .              .              .         .              .             .     .          Clause& c = ca[confl];
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
    969,112,838         0    0              0              0         0              0             0     0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
              .         .    .              .              .         .              .             .     .              assert(value(c[1]) == l_True);
              .         .    .              .              .         .              .             .     .              Lit tmp = c[0];
        610,332         0    0        203,444         11,597         0        406,888             0     0              c[0] = c[1], c[1] = tmp; }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          // Update LBD if improved.
    719,324,639         0    0      7,965,880              0         0              0             0     0          if (c.learnt() && c.mark() != CORE){
              .         .    .              .              .         .              .             .     .              int lbd = computeLBD(c);
     59,059,914         0    0              0              0         0              0             0     0              if (lbd < c.lbd()){
      2,500,912         0    0              0              0         0              0             0     0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
              .         .    .              .              .         .              .             .     .                  c.set_lbd(lbd);
      2,500,912         0    0      1,250,456      1,008,475         0              0             0     0                  if (lbd <= core_lbd_cut){
             26         5    1              0              0         0             13             0     0                      learnts_core.push(confl);
              .         .    .              .              .         .              .             .     .                      c.mark(CORE);
      3,356,942         0    0        352,619              0         0              0             0     0                  }else if (lbd <= 6 && c.mark() == LOCAL){
              .         .    .              .              .         .              .             .     .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
              .         .    .              .              .         .              .             .     .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     79,135,564        11   10              0              0         0     22,758,890    10,950,223     0                      learnts_tier2.push(confl);
              .         .    .              .              .         .              .             .     .                      c.mark(TIER2); }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
     58,684,570         0    0     29,342,285              0         0              0             0     0              if (c.mark() == TIER2)
     44,839,204        49   33     11,209,801          7,488         0     11,209,801     1,388,300    41                  c.touched() = conflicts;
     36,612,002         0    0     18,306,001              0         0              0             0     0              else if (c.mark() == LOCAL)
              .         .    .              .              .         .              .             .     .                  claBumpActivity(c);
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .  
  5,223,538,900         3    3  1,585,897,769             44         0    245,888,503           243     0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
  1,340,009,266         0    0  1,340,009,266     75,632,919         7              0             0     0              Lit q = c[j];
              .         .    .              .              .         .              .             .     .  
  4,493,398,097         4    4  1,944,469,121    434,618,863        44              0             0     0              if (!seen[var(q)] && level(var(q)) > 0){
  1,208,919,710         0    0    604,459,855          1,408         0              0             0     0                  if (VSIDS){
              .         .    .              .              .         .              .             .     .                      varBumpActivity(var(q), .5);
             14         1    1              0              0         0              7             0     0                      add_tmp.push(q);
              .         .    .              .              .         .              .             .     .                  }else
    299,351,752         0    0    299,351,752    163,961,954         0              0             0     0                      conflicted[var(q)]++;
    604,459,855         0    0              0              0         0    604,459,855             0     0                  seen[var(q)] = 1;
  1,208,919,710         0    0    604,459,855              0         0              0             0     0                  if (level(var(q)) >= nDecisionLevel){
    491,777,006         0    0    491,777,006              0         0              0             0     0                      pathC++;
              .         .    .              .              .         .              .             .     .                  }else
              .         .    .              .              .         .              .             .     .                      out_learnt.push(q);
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          
              .         .    .              .              .         .              .             .     .          // Select next clause to look at:
              .         .    .              .              .         .              .             .     .  		do {
  9,189,101,846         0    0  3,724,818,439    257,391,798       186              0             0     0  			while (!seen[var(trail[index--])]);
              .         .    .              .              .         .              .             .     .  			p  = trail[index+1];
    491,777,198         0    0    245,888,599         85,043         0              0             0     0  		} while (level(var(p)) < nDecisionLevel);
              .         .    .              .              .         .              .             .     .  		
    491,777,006         0    0    245,888,503              0         0    245,888,503           187     0          confl = reason(var(p));
    245,888,503         0    0              0              0         0    245,888,503             0     0          seen[var(p)] = 0;
    491,777,006         0    0    491,777,006              0         0              0             0     0          pathC--;
              .         .    .              .              .         .              .             .     .  
  1,430,507,306         0    0    469,365,150            240         0              0             0     0      }while (pathC > 0);
     11,205,928         0    0     11,205,928            161         0              0             0     0      out_learnt[0] = ~p;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Simplify conflict clause:
              .         .    .              .              .         .              .             .     .      //
              .         .    .              .              .         .              .             .     .      int i, j;
     22,411,856         0    0              0              0         0     11,205,928             0     0      out_learnt.copyTo(analyze_toclear);
     33,617,784         0    0     11,205,928             29         0              0             0     0      if (ccmin_mode == 2){
     11,205,928       520  199              0              0         0              0             0     0          uint32_t abstract_level = 0;
    739,554,560       962  162              0              0         0              0             0     0          for (i = 1; i < out_learnt.size(); i++)
    380,983,208         0    0     11,205,928              0         0              0             0     0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
              .         .    .              .              .         .              .             .     .  
  2,622,058,744       130   50  1,064,508,128              0         0     11,205,928             0     0          for (i = j = 1; i < out_learnt.size(); i++)
  2,023,766,080        81   56    434,498,360          2,110         0    230,953,872             0     0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
    610,633,464        54    9    203,544,488              0         0    203,544,488             1     0                  out_learnt[j++] = out_learnt[i];
              .         .    .              .              .         .              .             .     .          
              .         .    .              .              .         .              .             .     .      }else if (ccmin_mode == 1){
              .         .    .              .              .         .              .             .     .          for (i = j = 1; i < out_learnt.size(); i++){
              .         .    .              .              .         .              .             .     .              Var x = var(out_learnt[i]);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              if (reason(x) == CRef_Undef)
              .         .    .              .              .         .              .             .     .                  out_learnt[j++] = out_learnt[i];
              .         .    .              .              .         .              .             .     .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
              .         .    .              .              .         .              .             .     .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
              .         .    .              .              .         .              .             .     .                          out_learnt[j++] = out_learnt[i];
              .         .    .              .              .         .              .             .     .                          break; }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }else
              .         .    .              .              .         .              .             .     .          i = j = out_learnt.size();
              .         .    .              .              .         .              .             .     .  
     22,411,856         0    0     11,205,928     11,106,485         5              0             0     0      max_literals += out_learnt.size();
    184,837,500         1    1     43,407,893              0         0              0             0     0      out_learnt.shrink(i - j);
     11,205,928       123   26     11,205,928              0         0              0             0     0      tot_literals += out_learnt.size();
              .         .    .              .              .         .              .             .     .  
     22,411,856         0    0     11,205,928          3,496         0     11,205,928             0     0      out_lbd = computeLBD(out_learnt);
    123,561,323     6,168  217     56,127,859              0         0              0             0     0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
        687,533     2,963  136         98,219              0         0        196,438             0     0          if (binResMinimize(out_learnt))
          3,297         0    0          1,099              0         0          1,099             0     0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Find correct backtrack level:
              .         .    .              .              .         .              .             .     .      //
     22,410,398         0    0              0              0         0              0             0     0      if (out_learnt.size() == 1)
              .         .    .              .              .         .              .             .     .          out_btlevel = 0;
              .         .    .              .              .         .              .             .     .      else{
     22,411,848         0    0              0              0         0              0             0     0          int max_i = 1;
              .         .    .              .              .         .              .             .     .          // Find the first literal assigned at the next-highest level:
    790,652,306         0    0              0              0         0              0             0     0          for (int i = 2; i < out_learnt.size(); i++)
    671,097,294         0    0    192,337,458              0         0              0             0     0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
              .         .    .              .              .         .              .             .     .                  max_i = i;
              .         .    .              .              .         .              .             .     .          // Swap-in this literal at index 1:
              .         .    .              .              .         .              .             .     .          Lit p             = out_learnt[max_i];
     22,411,856         0    0     11,205,928              0         0     11,205,928             0     0          out_learnt[max_i] = out_learnt[1];
     11,205,928         0    0              0              0         0     11,205,928             0     0          out_learnt[1]     = p;
     22,411,856         0    0     11,205,928              0         0     11,205,928             0     0          out_btlevel       = level(var(p));
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
     22,411,856       197   31     11,205,928          9,120         0              0             0     0      if (VSIDS){
  1,112,663,296     4,483   87    322,736,349        176,103         0              0             0     0          for (int i = 0; i < add_tmp.size(); i++){
              .         .    .              .              .         .              .             .     .              Var v = var(add_tmp[i]);
    915,324,309         0    0    305,108,103      2,298,747         0              0             0     0              if (level(v) >= out_btlevel - 1)
              .         .    .              .              .         .              .             .     .                  varBumpActivity(v, 1);
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          add_tmp.clear();
              .         .    .              .              .         .              .             .     .      }else{
     10,659,692         0    0      5,329,846              0         0      5,329,846             4     0          seen[var(p)] = true;
    361,298,351         0    0      5,329,846              0         0              0             0     0          for(int i = out_learnt.size() - 1; i >= 0; i--){
              .         .    .              .              .         .              .             .     .              Var v = var(out_learnt[i]);
              .         .    .              .              .         .              .             .     .              CRef rea = reason(v);
    201,780,030         0    0              0              0         0              0             0     0              if (rea != CRef_Undef){
              .         .    .              .              .         .              .             .     .                  const Clause& reaC = ca[rea];
    675,449,892         0    0              0              0         0              0             0     0                  for (int i = 0; i < reaC.size(); i++){
              .         .    .              .              .         .              .             .     .                      Lit l = reaC[i];
    531,991,480         0    0    265,995,740        303,186         0              0             0     0                      if (!seen[var(l)]){
     40,761,179         0    0              0              0         0     40,761,179             0     0                          seen[var(l)] = true;
     40,761,179         0    0     40,761,179     30,371,871         0              0             0     0                          almost_conflicted[var(l)]++;
              .         .    .              .              .         .              .             .     .                          analyze_toclear.push(l); } } } } }
              .         .    .              .              .         .              .             .     .  
  1,822,877,820     4,106    7    894,630,018              0         0    441,712,045       896,310     0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
     89,647,424         0    0     78,441,496        512,229         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  // Try further learnt clause minimization by means of binary clause resolution.
              .         .    .              .              .         .              .             .     .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
        247,445         0    0              0              0         0        197,956            16     0  {
              .         .    .              .              .         .              .             .     .      // Preparation: remember which false variables we have in 'out_learnt'.
        294,657        23   18         98,219              0         0         98,219             0     0      counter++;
      3,138,616         0    0        196,438              0         0              0             0     0      for (int i = 1; i < out_learnt.size(); i++)
      1,274,659         0    0         98,219              0         0      1,176,440     1,113,011 2,312          seen2[var(out_learnt[i])] = counter;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Get the list of binary clauses containing 'out_learnt[0]'.
              .         .    .              .              .         .              .             .     .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
              .         .    .              .              .         .              .             .     .  
         49,489         0    0              0              0         0              0             0     0      int to_remove = 0;
        602,921         4    3         98,219         79,470         2          1,099             0     0      for (int i = 0; i < ws.size(); i++){
        178,018         0    0        178,018         42,562         5              0             0     0          Lit the_other = ws[i].blocker;
              .         .    .              .              .         .              .             .     .          // Does 'the_other' appear negatively in 'out_learnt'?
        714,276        20   16        308,751        115,165       671              0             0     0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
          1,102         0    0              0              0         0              0             0     0              to_remove++;
          3,306         0    0              0              0         0          1,102             0     0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Shrink.
        148,467        15   10              0              0         0              0             0     0      if (to_remove > 0){
          1,099         0    0              0              0         0              0             0     0          int last = out_learnt.size() - 1;
        106,720       182   77          1,099              0         0              0             0     0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
         29,522         0    0         14,761              0         0              0             0     0              if (seen2[var(out_learnt[i])] != counter)
          5,335         0    0          2,134              0         0          1,067             0     0                  out_learnt[i--] = out_learnt[last--];
              .         .    .              .              .         .              .             .     .          out_learnt.shrink(to_remove);
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .      return to_remove != 0;
        296,175         8    7        296,175              0         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
              .         .    .              .              .         .              .             .     .  // visiting literals at levels that cannot be removed later.
              .         .    .              .              .         .              .             .     .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
  2,309,538,720     4,426    9              0              0         0  1,385,723,232     6,699,223     0  {
    461,907,744         0    0              0              0         0    230,953,872             0     0      analyze_stack.clear(); analyze_stack.push(p);
    692,861,616         0    0    461,907,744              0         0    230,953,872             0     0      int top = analyze_toclear.size();
    894,678,188         0    0              0              0         0              0             0     0      while (analyze_stack.size() > 0){
              .         .    .              .              .         .              .             .     .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
              .         .    .              .              .         .              .             .     .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          // Special handling for binary clauses like in 'analyze()'.
    619,810,906        96   58              0              0         0              0             0     0          if (c.size() == 2 && value(c[0]) == l_False){
              .         .    .              .              .         .              .             .     .              assert(value(c[1]) == l_True);
              .         .    .              .              .         .              .             .     .              Lit tmp = c[0];
        151,989         0    0         50,663          3,035         0        101,326             0     0              c[0] = c[1], c[1] = tmp; }
              .         .    .              .              .         .              .             .     .  
  2,773,066,984         0    0              0              0         0              0             0     0          for (int i = 1; i < c.size(); i++){
  1,187,741,493        85   28  1,187,741,493    102,141,748        12              0             0     0              Lit p  = c[i];
  3,910,293,413         0    0  2,375,482,986      1,969,169         2              0             0     0              if (!seen[var(p)] && level(var(p)) > 0){
    547,839,400         0    0    173,534,467              0         0              0             0     0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
     97,607,459         0    0              0              0         0     97,607,459             0     0                      seen[var(p)] = 1;
              .         .    .              .              .         .              .             .     .                      analyze_stack.push(p);
              2         0    0              0              0         0              0             0     0                      analyze_toclear.push(p);
              .         .    .              .              .         .              .             .     .                  }else{
    509,846,760     2,582   87    218,287,889              0         0              0             0     0                      for (int j = top; j < analyze_toclear.size(); j++)
    100,317,494         0    0     33,883,621              0         0     66,433,873             0     0                          seen[var(analyze_toclear[j])] = 0;
    151,854,016       158   14     75,927,008              0         0              0             0     0                      analyze_toclear.shrink(analyze_toclear.size() - top);
     75,927,008         0    0              0              0         0              0             0     0                      return false;
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
    310,053,728         0    0              0              0         0              0             0     0      return true;
  1,847,630,976       129    9  1,616,677,104              0         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  /*_________________________________________________________________________________________________
              .         .    .              .              .         .              .             .     .  |
              .         .    .              .              .         .              .             .     .  |  analyzeFinal : (p : Lit)  ->  [void]
              .         .    .              .              .         .              .             .     .  |  
              .         .    .              .              .         .              .             .     .  |  Description:
              .         .    .              .              .         .              .             .     .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      seen[var(p)] = 0;
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 17,580,507,360         4    2              0              0         0  8,790,253,680             0     0  {
              .         .    .              .              .         .              .             .     .      assert(value(p) == l_Undef);
              .         .    .              .              .         .              .             .     .      Var x = var(p);
  3,516,101,472         0    0  1,758,050,736      5,848,410         0              0             0     0      if (!VSIDS){
  2,580,355,011         0    0  1,720,236,674      5,603,394         0    860,118,337   648,845,479 1,676          picked[x] = conflicts;
  1,720,236,674         0    0    860,118,337              0         0    860,118,337   648,115,793 1,723          conflicted[x] = 0;
  1,720,236,674         2    2    860,118,337              0         0    860,118,337   647,290,180 1,768          almost_conflicted[x] = 0;
              .         .    .              .              .         .              .             .     .  #ifdef ANTI_EXPLORATION
    860,118,337         0    0    860,118,337              0         0              0             0     0          uint32_t age = conflicts - canceled[var(p)];
  1,720,236,674         0    0    860,118,337    643,525,926       933              0             0     0          if (age > 0){
              .         .    .              .              .         .              .             .     .              double decay = pow(0.95, age);
    576,200,604         0    0    288,100,302    251,030,676       242    288,100,302             0     0              activity_CHB[var(p)] *= decay;
              .         .    .              .              .         .              .             .     .              if (order_heap_CHB.inHeap(var(p)))
    288,100,302         0    0              0              0         0              0             0     0                  order_heap_CHB.increase(var(p));
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
  1,758,050,736         3    2  1,758,050,736          4,500         0              0             0     0      assigns[x] = lbool(!sign(p));
  3,516,101,472         0    0              0              0         0  3,516,101,472 1,410,258,475 1,444      vardata[x] = mkVarData(from, level);
  1,758,050,736         5    4  1,758,050,736              0         0              0             0     0      trail.push_(p);
 12,306,355,152         0    0 10,548,304,416              0         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  unsigned number_watch_changed_total=0;
              .         .    .              .              .         .              .             .     .  unsigned number_clause_read_total=0;
              .         .    .              .              .         .              .             .     .  unsigned times_only_access_watch=0;
              .         .    .              .              .         .              .             .     .  /*_________________________________________________________________________________________________
              .         .    .              .              .         .              .             .     .  |
              .         .    .              .              .         .              .             .     .  |  propagate : [void]  ->  [Clause*]
              .         .    .              .              .         .              .             .     .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
              .         .    .              .              .         .              .             .     .  |  Description:
              .         .    .              .              .         .              .             .     .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
              .         .    .              .              .         .              .             .     .  |    otherwise CRef_Undef.
              .         .    .              .              .         .              .             .     .  |  
              .         .    .              .              .         .              .             .     .  |    Post-conditions:
              .         .    .              .              .         .              .             .     .  |      * the propagation queue is empty, even if there was a conflict.
              .         .    .              .              .         .              .             .     .  |________________________________________________________________________________________________@*/
              .         .    .              .              .         .              .             .     .  CRef Solver::propagate_()
    184,937,824        11    9              0              0         0    138,703,368             0     0  {
              .         .    .              .              .         .              .             .     .      //auto start_time=std::chrono::steady_clock::now();
     23,117,228         0    0              0              0         0     23,117,228             0     0      CRef    confl     = CRef_Undef;
     23,117,228         0    0              0              0         0     23,117,228             1     0      int     num_props = 0;
     46,234,456         0    0              0              0         0     23,117,228       707,191     0      watches.cleanAll();
     46,234,456         7    5              0              0         0     23,117,228             0     0      watches_bin.cleanAll();
              .         .    .              .              .         .              .             .     .      
  4,959,550,486         1    1  3,555,123,807      2,594,316        16              0             0     0      while (qhead < trail.size()){
  6,855,849,505         0    0  2,742,339,802     25,682,164         0  1,371,169,901             0     0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .         .    .              .              .         .              .             .     .          int currLevel = level(var(p));
              .         .    .              .              .         .              .             .     .          vec<Watcher>&  ws  = watches[p];
              .         .    .              .              .         .              .             .     .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          Watcher        *i, *j, *end;
  2,137,768,090         0    0  2,137,768,090     13,588,013         0              0             0     0          num_props++;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
              .         .    .              .              .         .              .             .     .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
  5,276,390,426         2    1  1,371,169,901  1,350,958,581     3,939              0             0     0          for (int k = 0; k < ws_bin.size(); k++){
    487,707,193         0    0    487,707,193    170,065,460       489              0             0     0              Lit the_other = ws_bin[k].blocker;
 85,283,368,725         0    0 83,858,017,820              0         0              0             0     0              if (value(the_other) == l_False){
         97,280         0    0         48,640              0         0         48,640             0     0                  confl = ws_bin[k].cref;
              .         .    .              .              .         .              .             .     .                  //auto end_time=std::chrono::steady_clock::now();
              .         .    .              .              .         .              .             .     .                  //auto duration=end_time-start_time;
              .         .    .              .              .         .              .             .     .  #ifdef LOOSE_PROP_STAT
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                  return confl;
              .         .    .              .              .         .              .             .     .  #else
              .         .    .              .              .         .              .             .     .                  goto ExitProp;
              .         .    .              .              .         .              .             .     .  #endif
    675,270,810         2    1              0              0         0              0             0     0              }else if(value(the_other) == l_Undef)
              .         .    .              .              .         .              .             .     .              {
    705,103,030         3    3    423,061,818              0         0    141,020,606             0     0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
              .         .    .              .              .         .              .             .     .  #ifdef  PRINT_OUT                
              .         .    .              .              .         .              .             .     .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
              .         .    .              .              .         .              .             .     .  #endif                
              .         .    .              .              .         .              .             .     .  			}
              .         .    .              .              .         .              .             .     .          }
  2,742,242,522         0    0  2,742,242,522  1,167,568,573     2,384              0             0     0          total_Watchers+=ws.size();
  1,371,121,261         0    0  1,371,121,261              0         0              0             0     0          total_indexs++;//number of rounds
              .         .    .              .              .         .              .             .     .          //int count=0;
  1,330,388,878         0    0              0              0         0              0             0     0          bool no_clause_access=true;
  1,330,388,878         0    0              0              0         0  1,330,388,878             0     0          bool no_implication_added=true;
  1,330,388,878         0    0              0              0         0  1,330,388,878             0     0          bool no_change_other_watch=true;
202,661,975,559        12    9 98,609,111,449              0         0  1,371,121,261             0     0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
              .         .    .              .              .         .              .             .     .              // Try to avoid inspecting the clause:
              .         .    .              .              .         .              .             .     .              //count++;
 97,237,990,188         2    1 97,237,990,188 13,200,862,457    78,862              0             0     0              Lit blocker = i->blocker;
194,475,980,376         0    0 97,237,990,188      7,103,487         8              0             0     0              total_access_watches++;
194,475,980,376         0    0 97,237,990,188    331,268,317       176              0             0     0              if (value(blocker) == l_True){
              .         .    .              .              .         .              .             .     .                  
321,567,025,176         0    0 80,391,756,294              0         0 80,391,756,294     5,039,861     0                  *j++ = *i++; continue; }//no clause accessed
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Make sure the false literal is data[1]:
 16,909,921,058         0    0     10,505,972            312         0              0             0     0              no_clause_access=false;
 50,538,701,682         3    2 33,692,467,788      6,054,859         8 16,846,233,894             0     0              total_clause_access_times++;
 33,692,467,788         0    0 16,846,233,894              0         0              0             0     0              CRef     cr        = i->cref;
              .         .    .              .              .         .              .             .     .              //std::cout<<"cr: "<<cr<<"\n";
              .         .    .              .              .         .              .             .     .              Clause&  c         = ca[cr];
              .         .    .              .              .         .              .             .     .              Lit      false_lit = ~p;
 16,846,233,894         0    0 16,846,233,894              0         0              0             0     0              total_clause_access_size+=2;
 50,538,701,682         0    0 33,692,467,788 14,853,551,577   141,407              0             0     0              if (c[0] == false_lit)
 30,709,500,204         0    0 15,354,750,102    423,606,000     5,044 15,354,750,102             0     0                  c[0] = c[1], c[1] = false_lit;
              .         .    .              .              .         .              .             .     .              assert(c[1] == false_lit);
              .         .    .              .              .         .              .             .     .              i++;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // If 0th watch is true, then clause is already satisfied.
              .         .    .              .              .         .              .             .     .              Lit     first = c[0];
              .         .    .              .              .         .              .             .     .              Watcher w     = Watcher(cr, first);
 42,241,875,436         0    0  4,274,703,824      9,484,916         0              0             0     0              if (first != blocker && value(first) == l_True){
 10,398,784,578         0    0              0              0         0  6,932,523,052     2,051,258     0                  *j++ = w; continue; }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Look for new watch:
105,950,045,870         2    1              0              0         0              0             0     0              for (int k = 2; k < c.size(); k++)
              .         .    .              .              .         .              .             .     .              {
190,206,592,245         0    0              0              0         0 38,171,582,829             0     0                  total_clause_access_size++;
112,975,259,195         0    0  9,872,148,801              0         0              0             0     0                  if (value(c[k]) != l_False){
 47,099,529,804     1,507    2 23,549,764,902              0         0 23,549,764,902             0     0                      c[1] = c[k]; c[k] = false_lit;
 11,774,882,451         0    0 11,774,882,451              0         0              0             0     0                      total_change_other_watch++;
 11,774,882,451         0    0              0              0         0 11,774,882,451           412     0                      no_change_other_watch=false;
              .         .    .              .              .         .              .             .     .                      watches[~c[1]].push(w);
              .         .    .              .              .         .              .             .     .                      goto NextClause; }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Did not find watch -- clause is unit under assignment:
  4,826,427,055         0    0              0              0         0  3,210,179,834       617,471     0              *j++ = w;
  3,210,179,834         0    0              0              0         0              0             0     0              if (value(first) == l_False){
     11,157,304         0    0     11,157,304        263,259         0              0             0     0                  time_find_conflict++;
     66,943,824         0    0     44,629,216        237,528         0              0             0     0                  total_find_conflict_length+=i-(Watcher*)ws;
     22,314,608         0    0     22,314,608              0         0              0             0     0                  total_find_conflict_allsize+=ws.size();
              .         .    .              .              .         .              .             .     .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
     11,157,304         0    0              0              0         0     11,157,304             0     0                  confl = cr;
     22,314,608         0    0     11,157,304              0         0     11,157,304         9,310     0                  qhead = trail.size();
              .         .    .              .              .         .              .             .     .                  // Copy the remaining watches:
              .         .    .              .              .         .              .             .     .  
  1,078,222,366         9    7     21,663,276            318         0              0             0     0                  while (i < end)
    511,869,255         0    0    511,869,255     63,594,127       836    511,869,255       178,334     0                      *j++ = *i++;
              .         .    .              .              .         .              .             .     .              }else
              .         .    .              .              .         .              .             .     .              {//new implecate
  1,593,932,613         0    0              0              0         0  1,593,932,613             0     0                  no_implication_added=false;
  1,593,932,613         0    0  1,593,932,613      9,757,604         0              0             0     0                  total_push_new_implication++;
  4,781,797,839         0    0  3,187,865,226      1,683,104         0              0             0     0  				if (currLevel == decisionLevel())
              .         .    .              .              .         .              .             .     .  				{
  3,187,865,226         0    0              0              0         0              0             0     0  					uncheckedEnqueue(first, currLevel, cr);
              .         .    .              .              .         .              .             .     .  #ifdef PRINT_OUT					
              .         .    .              .              .         .              .             .     .  					std::cout << "i " << first << " l " << currLevel << "\n";
              .         .    .              .              .         .              .             .     .  #endif					
              .         .    .              .              .         .              .             .     .  				}
              .         .    .              .              .         .              .             .     .  				else
              .         .    .              .              .         .              .             .     .  				{
              .         .    .              .              .         .              .             .     .  					int nMaxLevel = currLevel;
          3,146         0    0              0              0         0              0             0     0  					int nMaxInd = 1;
              .         .    .              .              .         .              .             .     .  					// pass over all the literals in the clause and find the one with the biggest level
         12,286         0    0          1,573              0         0              0             0     0  					for (int nInd = 2; nInd < c.size(); ++nInd)
              .         .    .              .              .         .              .             .     .  					{
              .         .    .              .              .         .              .             .     .  						int nLevel = level(var(c[nInd]));
          6,534         0    0              0              0         0              0             0     0  						if (nLevel > nMaxLevel)
              .         .    .              .              .         .              .             .     .  						{
              .         .    .              .              .         .              .             .     .  							nMaxLevel = nLevel;
              .         .    .              .              .         .              .             .     .  							nMaxInd = nInd;
              .         .    .              .              .         .              .             .     .  						}
              .         .    .              .              .         .              .             .     .  					}
              .         .    .              .              .         .              .             .     .  
          3,146         1    1              0              0         0              0             0     0  					if (nMaxInd != 1)
              .         .    .              .              .         .              .             .     .  					{
              .         .    .              .              .         .              .             .     .  						std::swap(c[1], c[nMaxInd]);
              .         .    .              .              .         .              .             .     .  						*j--; // undo last watch
            251         0    0            251              0         0              0             0     0                          total_change_other_watch++;
            251         0    0              0              0         0            251             0     0                          no_change_other_watch=false;
              .         .    .              .              .         .              .             .     .  						watches[~c[1]].push(w);
              .         .    .              .              .         .              .             .     .  					}
              .         .    .              .              .         .              .             .     .  					
  7,969,664,638         0    0  1,593,932,613              0         0  1,593,932,613             0     0  					uncheckedEnqueue(first, nMaxLevel, cr);
              .         .    .              .              .         .              .             .     .  #ifdef PRINT_OUT					
              .         .    .              .              .         .              .             .     .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
              .         .    .              .              .         .              .             .     .  #endif	
              .         .    .              .              .         .              .             .     .  				}
              .         .    .              .              .         .              .             .     .  			}
              .         .    .              .              .         .              .             .     .  
     10,505,972       199   70              0              0         0              0             0     0  NextClause:;
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
  6,651,944,390         0    0  1,330,388,878              0         0              0             0     0          if(no_clause_access==true){
    448,985,030       370   33    448,985,030        397,152         3              0             0     0              total_no_clause_access++;
              .         .    .              .              .         .              .             .     .          }
  3,069,030,403        16   10  1,330,388,878              0         0              0             0     0          if(no_implication_added==true){
  1,069,232,657         4    3  1,028,500,274      1,851,933         5              0             0     0              total_no_implication_added++;
              .         .    .              .              .         .              .             .     .          }
  3,192,036,265         0    0  1,330,388,878              0         0              0             0     0          if(no_change_other_watch==true){
    604,474,432        17    7    604,474,432            328         0              0             0     0              total_no_change_other_watch++;
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          ws.shrink(i - j);
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  ExitProp:;
     46,137,176         4    2     46,137,176     11,006,554         0              0             0     0      propagations += num_props;
     23,068,588         0    0     23,068,588              0         0              0             0     0      simpDB_props -= num_props;
              .         .    .              .              .         .              .             .     .  
     23,068,588         0    0     23,068,588              0         0              0             0     0      return confl;
  3,692,761,391       549   11    161,820,596     19,347,302         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  /*_________________________________________________________________________________________________
              .         .    .              .              .         .              .             .     .  |
              .         .    .              .              .         .              .             .     .  |  reduceDB : ()  ->  [void]
              .         .    .              .              .         .              .             .     .  |  
              .         .    .              .              .         .              .             .     .  |  Description:
              .         .    .              .              .         .              .             .     .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
              .         .    .              .              .         .              .             .     .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
              .         .    .              .              .         .              .             .     .  |________________________________________________________________________________________________@*/
              .         .    .              .              .         .              .             .     .  struct reduceDB_lt { 
              .         .    .              .              .         .              .             .     .      ClauseAllocator& ca;
              .         .    .              .              .         .              .             .     .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    572,819,707     1,494  187    561,012,370    175,218,591     7,694              0             0     0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
              .         .    .              .              .         .              .             .     .  };
              .         .    .              .              .         .              .             .     .  void Solver::reduceDB()
          4,482       394   52              0              0         0          2,988             0     0  {
              .         .    .              .              .         .              .             .     .      int     i, j;
              .         .    .              .              .         .              .             .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .         .    .              .              .         .              .             .     .      //local_learnts_dirty = false;
              .         .    .              .              .         .              .             .     .  
            747         0    0              0              0         0              0             0     0      sort(learnts_local, reduceDB_lt(ca));
              .         .    .              .              .         .              .             .     .  
          3,735         0    0            747            747         0              0             0     0      int limit = learnts_local.size() / 2;
     44,734,533       747  164              0              0         0              0             0     0      for (i = j = 0; i < learnts_local.size(); i++){
     67,096,197       747   86     44,730,798      1,398,576         0              0             0     0          Clause& c = ca[learnts_local[i]];
     44,730,798         0    0     22,365,399     21,981,602        60              0             0     0          if (c.mark() == LOCAL)
     86,978,990         0    0     22,190,180              0         0              0             0     0              if (c.removable() && !locked(c) && i < limit)
     55,742,600         0    0     11,148,520              0         0     11,148,520             0     0                  removeClause(learnts_local[i]);
              .         .    .              .              .         .              .             .     .              else{
        886,128         0    0              0              0         0              0             0     0                  if (!c.removable()) limit++;
              .         .    .              .              .         .              .             .     .                  c.removable(true);
     55,558,738         0    0     11,041,660              0         0     11,041,660       691,281     0                  learnts_local[j++] = learnts_local[i]; }
              .         .    .              .              .         .              .             .     .      }
            747         0    0              0              0         0              0             0     0      learnts_local.shrink(i - j);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      checkGarbage();
          3,735         0    0          2,988            747         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  void Solver::reduceDB_Tier2()
          6,720       803  147              0              0         0          5,600             0     0  {
              .         .    .              .              .         .              .             .     .      int i, j;
      6,724,146       112    6          1,120          1,117         0              0             0     0      for (i = j = 0; i < learnts_tier2.size(); i++){
      8,835,279       544  102      5,890,186        185,098     1,194              0             0     0          Clause& c = ca[learnts_tier2[i]];
      5,890,186         0    0              0              0         0              0             0     0          if (c.mark() == TIER2)
     14,649,085       966   63      5,859,634      2,359,081     4,250              0             0     0              if (!locked(c) && c.touched() + 30000 < conflicts){
              .         .    .              .              .         .              .             .     .                  learnts_local.push(learnts_tier2[i]);
              .         .    .              .              .         .              .             .     .                  c.mark(LOCAL);
              .         .    .              .              .         .              .             .     .                  //c.removable(true);
              .         .    .              .              .         .              .             .     .                  c.activity() = 0;
              .         .    .              .              .         .              .             .     .                  claBumpActivity(c);
              .         .    .              .              .         .              .             .     .              }else
     12,657,365         0    0      2,531,473              0         0      2,531,473        60,507     0                  learnts_tier2[j++] = learnts_tier2[i];
              .         .    .              .              .         .              .             .     .      }
          1,120         0    0              0              0         0              0             0     0      learnts_tier2.shrink(i - j);
          6,720         0    0          6,720          1,120         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::removeSatisfied(vec<CRef>& cs)
              .         .    .              .              .         .              .             .     .  {
              .         .    .              .              .         .              .             .     .      int i, j;
              3         1    1              1              1         0              0             0     0      for (i = j = 0; i < cs.size(); i++){
              .         .    .              .              .         .              .             .     .          Clause& c = ca[cs[i]];
              .         .    .              .              .         .              .             .     .          if (satisfied(c))
              1         1    1              1              0         0              0             0     0              removeClause(cs[i]);
              .         .    .              .              .         .              .             .     .          else
              .         .    .              .              .         .              .             .     .              cs[j++] = cs[i];
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .      cs.shrink(i - j);
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
             12         0    0              0              0         0             10             0     0  {
              .         .    .              .              .         .              .             .     .      int i, j;
              6         0    0              2              1         0              0             0     0      for (i = j = 0; i < cs.size(); i++){
              .         .    .              .              .         .              .             .     .          Clause& c = ca[cs[i]];
              .         .    .              .              .         .              .             .     .          if (c.mark() == valid_mark)
              .         .    .              .              .         .              .             .     .              if (satisfied(c))
              .         .    .              .              .         .              .             .     .                  removeClause(cs[i]);
              .         .    .              .              .         .              .             .     .              else
              .         .    .              .              .         .              .             .     .                  cs[j++] = cs[i];
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .      cs.shrink(i - j);
             12         2    2             12              0         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::rebuildOrderHeap()
             18         1    1              0              0         0             12             0     0  {
              .         .    .              .              .         .              .             .     .      vec<Var> vs;
          9,708         0    0              2              0         0              2             0     0      for (Var v = 0; v < nVars(); v++)
         28,252         0    0         14,126            161         0              0             0     0          if (decision[v] && value(v) == l_Undef)
              .         .    .              .              .         .              .             .     .              vs.push(v);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      order_heap_CHB  .build(vs);
              .         .    .              .              .         .              .             .     .      order_heap_VSIDS.build(vs);
              .         .    .              .              .         .              .             .     .      order_heap_distance.build(vs);
             16         2    1             14              2         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  /*_________________________________________________________________________________________________
              .         .    .              .              .         .              .             .     .  |
              .         .    .              .              .         .              .             .     .  |  simplify : [void]  ->  [bool]
              .         .    .              .              .         .              .             .     .  |  
              .         .    .              .              .         .              .             .     .  |  Description:
              .         .    .              .              .         .              .             .     .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
              .         .    .              .              .         .              .             .     .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
              .         .    .              .              .         .              .             .     .  |________________________________________________________________________________________________@*/
              .         .    .              .              .         .              .             .     .  bool Solver::simplify()
         58,848     1,468   14              0              0         0         39,232             0     0  {
              .         .    .              .              .         .              .             .     .      assert(decisionLevel() == 0);
              .         .    .              .              .         .              .             .     .  
         49,040         0    0          9,808          9,709         5              0             0     0      if (!ok || propagate() != CRef_Undef)
              .         .    .              .              .         .              .             .     .          return ok = false;
              .         .    .              .              .         .              .             .     .  
         29,426       465   68         19,617              0         0              0             0     0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
              .         .    .              .              .         .              .             .     .          return true;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Remove satisfied clauses:
              3         0    0              0              0         0              1             0     0      removeSatisfied(learnts_core); // Should clean core first.
              4         0    0              0              0         0              1             0     0      safeRemoveSatisfied(learnts_tier2, TIER2);
              4         1    1              0              0         0              1             0     0      safeRemoveSatisfied(learnts_local, LOCAL);
              2         0    0              1              1         0              0             0     0      if (remove_satisfied)        // Can be turned off.
              .         .    .              .              .         .              .             .     .          removeSatisfied(clauses);
              .         .    .              .              .         .              .             .     .      checkGarbage();
              2         1    1              0              0         0              1             0     0      rebuildOrderHeap();
              .         .    .              .              .         .              .             .     .  
              2         0    0              1              1         0              1             1     0      simpDB_assigns = nAssigns();
              3         0    0              2              2         0              1             0     0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
              .         .    .              .              .         .              .             .     .  
              1         0    0              0              0         0              0             0     0      return true;
         68,656         0    0         49,040              1         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  // pathCs[k] is the number of variables assigned at level k,
              .         .    .              .              .         .              .             .     .  // it is initialized to 0 at the begining and reset to 0 after the function execution
         80,776         4    1              0              0         0         60,582             0     0  bool Solver::collectFirstUIP(CRef confl){
         20,194         0    0              0              0         0         10,097             0     0      involved_lits.clear();
        382,134         1    1              0              0         0              0             0     0      int max_level=1;
              .         .    .              .              .         .              .             .     .      Clause& c=ca[confl]; int minLevel=decisionLevel();
        142,719         0    0         10,097              0         0              0             0     0      for(int i=0; i<c.size(); i++) {
              .         .    .              .              .         .              .             .     .          Var v=var(c[i]);
              .         .    .              .              .         .              .             .     .          //        assert(!seen[v]);
        138,351         9    1         46,117         18,482         0              0             0     0          if (level(v)>0) {
         92,234         0    0         46,117          9,417         0         46,117        36,008     0              seen[v]=1;
        102,331         0    0         56,214         18,968         0         46,117        43,533     0              var_iLevel_tmp[v]=1;
         46,117         0    0         46,117         24,699         0              0             0     0              pathCs[level(v)]++;
              .         .    .              .              .         .              .             .     .              if (minLevel>level(v)) {
              .         .    .              .              .         .              .             .     .                  minLevel=level(v);
              .         .    .              .              .         .              .             .     .                  assert(minLevel>0);
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              //    varBumpActivity(v);
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
         30,291         0    0         20,194          9,934         0              0             0     0      int limit=trail_lim[minLevel-1];
     15,910,740         0    0         10,097              0         0              0             0     0      for(int i=trail.size()-1; i>=limit; i--) {
      7,935,176        49    1      7,935,176        224,345         0              0             0     0          Lit p=trail[i]; Var v=var(p);
      7,935,176         0    0      3,967,588        255,982         0              0             0     0          if (seen[v]) {
              .         .    .              .              .         .              .             .     .              int currentDecLevel=level(v);
              .         .    .              .              .         .              .             .     .              //      if (currentDecLevel==decisionLevel())
              .         .    .              .              .         .              .             .     .              //      	varBumpActivity(v);
        484,726         0    0              0              0         0        484,726             0     0              seen[v]=0;
        969,452         0    0        484,726             20         0              0             0     0              if (--pathCs[currentDecLevel]!=0) {
              .         .    .              .              .         .              .             .     .                  Clause& rc=ca[reason(v)];
        693,589         6    1        482,328             11         0              0             0     0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
        321,552         0    0              0              0         0              0             0     0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
        326,884         0    0              0              0         0              0             0     0                  if (rc.size()==2 && value(rc[0])==l_False) {
              .         .    .              .              .         .              .             .     .                      // Special case for binary clauses
              .         .    .              .              .         .              .             .     .                      // The first one has to be SAT
              .         .    .              .              .         .              .             .     .                      assert(value(rc[1]) != l_False);
              .         .    .              .              .         .              .             .     .                      Lit tmp = rc[0];
            783         0    0            261             17         0            522             0     0                      rc[0] =  rc[1], rc[1] = tmp;
              .         .    .              .              .         .              .             .     .                  }
      1,874,912         0    0              0              0         0              0             0     0                  for (int j = 1; j < rc.size(); j++){
              .         .    .              .              .         .              .             .     .                      Lit q = rc[j]; Var v1=var(q);
      1,558,692         0    0              0              0         0              0             0     0                      if (level(v1) > 0) {
      1,558,692         0    0              0              0         0              0             0     0                          if (minLevel>level(v1)) {
        107,980         0    0         53,990         22,607         0              0             0     0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
              .         .    .              .              .         .              .             .     .                          }
      2,338,038         0    0      1,558,692         39,562         0              0             0     0                          if (seen[v1]) {
        681,474         0    0        340,737             32         0              0             0     0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
        504,268         0    0              0              0         0        252,134             0     0                                  var_iLevel_tmp[v1]=reasonVarLevel;
              .         .    .              .              .         .              .             .     .                          }
              .         .    .              .              .         .              .             .     .                          else {
        438,609         0    0              0              0         0        438,609       328,737     0                              var_iLevel_tmp[v1]=reasonVarLevel;
              .         .    .              .              .         .              .             .     .                              //   varBumpActivity(v1);
        438,609         0    0              0              0         0        438,609             0     0                              seen[v1] = 1;
      1,315,827         5    1        877,218        104,459         0              0             0     0                              pathCs[level(v1)]++;
              .         .    .              .              .         .              .             .     .                          }
              .         .    .              .              .         .              .             .     .                      }
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              involved_lits.push(p);
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
         30,291       308    1         10,097              0         0         10,097             0     0      double inc=var_iLevel_inc;
              .         .    .              .              .         .              .             .     .      vec<int> level_incs; level_incs.clear();
        425,846         0    0        158,222              0         0              0             0     0      for(int i=0;i<max_level;i++){
        178,416         2    1         89,208              0         0              0             0     0          level_incs.push(inc);
        267,624         0    0        178,416              3         0         89,208             0     0          inc = inc/my_var_decay;
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
      1,009,840         0    0        494,823              0         0              0             0     0      for(int i=0;i<involved_lits.size();i++){
         10,097         0    0         10,097              3         0              0             0     0          Var v =var(involved_lits[i]);
              .         .    .              .              .         .              .             .     .          //        double old_act=activity_distance[v];
              .         .    .              .              .         .              .             .     .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
      4,524,086     3,005    2      1,494,566        387,879         0        494,823             0     0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
              .         .    .              .              .         .              .             .     .  
        969,452         0    0              0              0         0              0             0     0          if(activity_distance[v]>1e100){
              .         .    .              .              .         .              .             .     .              for(int vv=0;vv<nVars();vv++)
         50,485       278    1         20,194         19,002         0         20,194             0     0                  activity_distance[vv] *= 1e-100;
              .         .    .              .              .         .              .             .     .              var_iLevel_inc*=1e-100;
          1,911        52    1              0              0         0              0             0     0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .          if (order_heap_distance.inHeap(v))
              .         .    .              .              .         .              .             .     .              order_heap_distance.decrease(v);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          //        var_iLevel_inc *= (1 / my_var_decay);
              .         .    .              .              .         .              .             .     .      }
         50,485        26    1         20,194              0         0         10,097             7     0      var_iLevel_inc=level_incs[level_incs.size()-1];
              .         .    .              .              .         .              .             .     .      return true;
         90,873         0    0         70,679          1,539         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  struct UIPOrderByILevel_Lt {
              .         .    .              .              .         .              .             .     .      Solver& solver;
              .         .    .              .              .         .              .             .     .      const vec<double>&  var_iLevel;
              .         .    .              .              .         .              .             .     .      bool operator () (Lit x, Lit y) const
              .         .    .              .              .         .              .             .     .      {
              .         .    .              .              .         .              .             .     .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
              .         .    .              .              .         .              .             .     .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
              .         .    .              .              .         .              .             .     .  |    Search for a model the specified number of conflicts. 
              .         .    .              .              .         .              .             .     .  |  
              .         .    .              .              .         .              .             .     .  |  Output:
              .         .    .              .              .         .              .             .     .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
              .         .    .              .              .         .              .             .     .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
              .         .    .              .              .         .              .             .     .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
              .         .    .              .              .         .              .             .     .  |________________________________________________________________________________________________@*/
              .         .    .              .              .         .              .             .     .  lbool Solver::search(int& nof_conflicts)
        107,877     8,451   67              0              0         0         68,649             0     0  {
              .         .    .              .              .         .              .             .     .      assert(ok);
              .         .    .              .              .         .              .             .     .      int         backtrack_level;
              .         .    .              .              .         .              .             .     .      int         lbd;
              .         .    .              .              .         .              .             .     .      vec<Lit>    learnt_clause;
              .         .    .              .              .         .              .             .     .      bool        cached = false;
          9,807         0    0          9,807             59         0              0             0     0      starts++;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // simplify
              .         .    .              .              .         .              .             .     .      //
         39,228         9    9         29,421          9,807        77              0             0     0      if (conflicts >= curSimplify * nbconfbeforesimplify){
              .         .    .              .              .         .              .             .     .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
              .         .    .              .              .         .              .             .     .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
              .         .    .              .              .         .              .             .     .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
              .         .    .              .              .         .              .             .     .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
             80        49   43             80             80        61              0             0     0          nbSimplifyAll++;
            240        80   62              0              0         0             80             0     0          if (!simplifyAll()){
              .         .    .              .              .         .              .             .     .              return l_False;
              .         .    .              .              .         .              .             .     .          }
            560         0    0            160            160         0             80             0     0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
            240         0    0             80              0         0             80             0     0          nbconfbeforesimplify += incSimplify;
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      for (;;){
              .         .    .              .              .         .              .             .     .          CRef confl = propagate();
              .         .    .              .              .         .              .             .     .  
     46,213,318         0    0              0              0         0              0             0     0          if (confl != CRef_Undef){
              .         .    .              .              .         .              .             .     .              // CONFLICT
     33,617,832         0    0     11,205,944         30,109         0              0             0     0              if (VSIDS){
     11,752,320         0    0      5,876,145      5,709,600         2             30             0     0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
              .         .    .              .              .         .              .             .     .              }else
     17,009,541         6    0     10,999,693      5,260,673         3        340,001             0     0                  if (step_size > min_step_size) step_size -= step_size_dec;
              .         .    .              .              .         .              .             .     .  
     44,823,776       192  132     22,411,888     10,998,594         0     11,205,944             0     0              conflicts++; nof_conflicts--;
              .         .    .              .              .         .              .             .     .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
              .         .    .              .              .         .              .             .     .              ConflictData data = FindConflictLevel(confl);
     22,411,888         5    1              0              0         0              0             0     0              if (data.nHighestLevel == 0) return l_False;
            108         0    0             38              0         0              0             0     0              if (data.bOnlyOneLitFromHighest)
              .         .    .              .              .         .              .             .     .              {
             16         0    0              0              0         0              0             0     0  				cancelUntil(data.nHighestLevel - 1);
              .         .    .              .              .         .              .             .     .  				continue;
              .         .    .              .              .         .              .             .     .  			}
              .         .    .              .              .         .              .             .     .  			
              .         .    .              .              .         .              .             .     .              learnt_clause.clear();
     22,411,856         0    0              0              0         0     11,205,928    10,811,762     0              if(conflicts>50000) DISTANCE=0;
              .         .    .              .              .         .              .             .     .              else DISTANCE=1;
     34,164,020         0    0              0              0         0              0             0     0              if(VSIDS && DISTANCE)
         40,388         4    1              0              0         0         10,097             0     0                  collectFirstUIP(confl);
              .         .    .              .              .         .              .             .     .  
     67,235,568       444  215              0              0         0     11,205,928             0     0              analyze(confl, learnt_clause, backtrack_level, lbd);
              .         .    .              .              .         .              .             .     .              // check chrono backtrack condition
    156,854,999        97   69     56,025,641        214,534         0              0             0     0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
              .         .    .              .              .         .              .             .     .              {
             22         0    0             22              0         0              0             0     0  				++chrono_backtrack;
             22         0    0              0              0         0              0             0     0  				cancelUntil(data.nHighestLevel -1);
              .         .    .              .              .         .              .             .     .  			}
              .         .    .              .              .         .              .             .     .  			else // default behavior
              .         .    .              .              .         .              .             .     .  			{
     11,205,906       125   33     11,205,906            736         0              0             0     0  				++non_chrono_backtrack;
              .         .    .              .              .         .              .             .     .  				cancelUntil(backtrack_level);
              .         .    .              .              .         .              .             .     .  			}
              .         .    .              .              .         .              .             .     .  
     33,617,784         0    0     11,205,928      4,282,017         0     11,205,928             0     0              lbd--;
     22,411,856         0    0     11,205,928              0         0              0             0     0              if (VSIDS){
      5,876,082        43   38              0              0         0      5,876,082             0     0                  cached = false;
     17,628,246        57   40     17,628,246      5,563,431         0              0             0     0                  conflicts_VSIDS++;
              .         .    .              .              .         .              .             .     .                  lbd_queue.push(lbd);
     47,008,656         0    0     17,628,246              0         0      5,876,082             0     0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
              .         .    .              .              .         .              .             .     .  
     33,617,784        41   28     11,205,928              0         0              0             0     0              if (learnt_clause.size() == 1){
              .         .    .              .              .         .              .             .     .                  uncheckedEnqueue(learnt_clause[0]);
              .         .    .              .              .         .              .             .     .              }else{
              .         .    .              .              .         .              .             .     .                  CRef cr = ca.alloc(learnt_clause, true);
     11,205,928         0    0     11,205,928              0         0              0             0     0                  ca[cr].set_lbd(lbd);
              .         .    .              .              .         .              .             .     .                  //duplicate learnts 
              .         .    .              .              .         .              .             .     .                  int  id = 0;
     22,411,856         0    0     11,205,928     11,161,814         0              0             0     0                  if (lbd <= max_lbd_dup){                        
              .         .    .              .              .         .              .             .     .                      std::vector<uint32_t> tmp;
    453,489,894         0    0    301,380,003              0         0      5,912,628             0     0                      for (int i = 0; i < learnt_clause.size(); i++)
    313,205,259        13    6    208,803,506              0         0    104,401,753             0     0                          tmp.push_back(learnt_clause[i].x);
     17,737,884         7    4      5,912,628              0         0      5,912,628             0     0                      id = is_duplicate(tmp);             
     29,563,140         0    0      5,912,628              0         0              0             0     0                      if (id == min_number_of_learnts_copies +1){
          5,935         0    0          5,935          1,516         0              0             0     0                          duplicates_added_conflicts++;                        
              .         .    .              .              .         .              .             .     .                      }                    
     11,825,256         0    0              0              0         0              0             0     0                      if (id == min_number_of_learnts_copies){
         17,055         0    0         17,055          4,041         0              0             0     0                          duplicates_added_tier2++;
              .         .    .              .              .         .              .             .     .                      }                                        
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .                  //duplicate learnts
              .         .    .              .              .         .              .             .     .  
     67,230,216         0    0     22,410,518      5,281,139         0              0             0     0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
              8         5    3              0              0         0              0             0     0                      learnts_core.push(cr);
              .         .    .              .              .         .              .             .     .                      ca[cr].mark(CORE);
     44,292,248       910   58              0              0         0              0             0     0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
             18         1    1              0              0         0              0             0     0                      learnts_tier2.push(cr);
              .         .    .              .              .         .              .             .     .                      ca[cr].mark(TIER2);
      1,045,756         0    0        261,439            318         0        261,439           188     0                      ca[cr].touched() = conflicts;
              .         .    .              .              .         .              .             .     .                  }else{
             23        17    1              0              0         0              0             0     0                      learnts_local.push(cr);
              .         .    .              .              .         .              .             .     .                      claBumpActivity(ca[cr]); }
     33,617,784     4,517   52              0              0         0     11,205,928             0     0                  attachClause(cr);
              .         .    .              .              .         .              .             .     .  
     67,235,568         0    0     33,617,784          4,475         0     11,205,928             0     0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
              .         .    .              .              .         .              .             .     .  #ifdef PRINT_OUT
              .         .    .              .              .         .              .             .     .                  std::cout << "new " << ca[cr] << "\n";
              .         .    .              .              .         .              .             .     .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
              .         .    .              .              .         .              .             .     .  #endif                
              .         .    .              .              .         .              .             .     .              }
     33,617,784         0    0     11,205,928      3,450,848         0              0             0     0              if (drup_file){
              .         .    .              .              .         .              .             .     .  #ifdef BIN_DRUP
              .         .    .              .              .         .              .             .     .                  binDRUP('a', learnt_clause, drup_file);
              .         .    .              .              .         .              .             .     .  #else
              .         .    .              .              .         .              .             .     .                  for (int i = 0; i < learnt_clause.size(); i++)
              .         .    .              .              .         .              .             .     .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
              .         .    .              .              .         .              .             .     .                  fprintf(drup_file, "0\n");
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
     33,617,784       234   41     22,411,856      5,830,179         4              0             0     0              if (VSIDS) varDecayActivity();
              .         .    .              .              .         .              .             .     .              claDecayActivity();
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              /*if (--learntsize_adjust_cnt == 0){
              .         .    .              .              .         .              .             .     .                  learntsize_adjust_confl *= learntsize_adjust_inc;
              .         .    .              .              .         .              .             .     .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
              .         .    .              .              .         .              .             .     .                  max_learnts             *= learntsize_inc;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
              .         .    .              .              .         .              .             .     .                             (int)conflicts,
              .         .    .              .              .         .              .             .     .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
              .         .    .              .              .         .              .             .     .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
              .         .    .              .              .         .              .             .     .              }*/
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .          }else{
              .         .    .              .              .         .              .             .     .              // NO CONFLICT
              .         .    .              .              .         .              .             .     .              bool restart = false;
     35,702,145        29   15     11,900,715      1,424,208         0              0             0     0              if (!VSIDS)
              .         .    .              .              .         .              .             .     .                  restart = nof_conflicts <= 0;
     12,366,580         1    1      6,183,290              0         0              0             0     0              else if (!cached){
     52,643,848         1    0     14,659,404      5,493,808         2      2,956,257             0     0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
              .         .    .              .              .         .              .             .     .                  cached = true;
              .         .    .              .              .         .              .             .     .              }
     17,152,275         0    0      5,717,425      4,632,731         0              0             0     0              if (restart /*|| !withinBudget()*/){
              .         .    .              .              .         .              .             .     .                  lbd_queue.clear();
              .         .    .              .              .         .              .             .     .                  cached = false;
              .         .    .              .              .         .              .             .     .                  // Reached bound on number of conflicts:
         29,418         0    0              0              0         0         19,612         9,669    17                  progress_estimate = progressEstimate();
              .         .    .              .              .         .              .             .     .                  cancelUntil(0);
         19,612         0    0              0              0         0              0             0     0                  return l_Undef; }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Simplify the set of problem clauses:
     38,625,971       283   67     11,890,909              0         0      2,923,823             0     0              if (decisionLevel() == 0 && !simplify())
              .         .    .              .              .         .              .             .     .                  return l_False;
              .         .    .              .              .         .              .             .     .  
     35,672,727        12    1     23,781,818      6,565,465         3              0             0     0              if (conflicts >= next_T2_reduce){
          2,240         0    0              0              0         0          1,120             0     0                  next_T2_reduce = conflicts + 10000;
          4,480         0    0          1,120              0         0          1,120             0     0                  reduceDB_Tier2(); }
     23,781,818        13    4     11,890,909          8,282         0              0             0     0              if (conflicts >= next_L_reduce){
          1,494         0    0              0              0         0            747             0     0                  next_L_reduce = conflicts + 15000;
          1,494         0    0              0              0         0            747             0     0                  reduceDB(); }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              Lit next = lit_Undef;
              .         .    .              .              .         .              .             .     .              /*while (decisionLevel() < assumptions.size()){
              .         .    .              .              .         .              .             .     .                  // Perform user provided assumption:
              .         .    .              .              .         .              .             .     .                  Lit p = assumptions[decisionLevel()];
              .         .    .              .              .         .              .             .     .                  if (value(p) == l_True){
              .         .    .              .              .         .              .             .     .                      // Dummy decision level:
              .         .    .              .              .         .              .             .     .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
              .         .    .              .              .         .              .             .     .                  }else{
              .         .    .              .              .         .              .             .     .                      next = p;
              .         .    .              .              .         .              .             .     .                      break;
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              if (next == lit_Undef)*/{
              .         .    .              .              .         .              .             .     .                  // New variable decision:
     11,890,909         0    0     11,890,909            747         0              0             0     0                  decisions++;
     35,672,727       131   16              0              0         0     11,890,909             0     0                  next = pickBranchLit();
              .         .    .              .              .         .              .             .     .  
     23,781,818         0    0              0              0         0              0             0     0                  if (next == lit_Undef)
              .         .    .              .              .         .              .             .     .                      // Model found:
              2         0    0              0              0         0              0             0     0                      return l_True;
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .              // Increase decision level and enqueue 'next'
              .         .    .              .              .         .              .             .     .              newDecisionLevel();
     71,345,448        21   11     11,890,908              0         0     11,890,908             0     0              uncheckedEnqueue(next, decisionLevel());
              .         .    .              .              .         .              .             .     .  #ifdef PRINT_OUT            
              .         .    .              .              .         .              .             .     .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
              .         .    .              .              .         .              .             .     .  #endif            
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
         88,263       125   69         68,649          9,807        54              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  double Solver::progressEstimate() const
         58,836        10   10              0              0         0         49,030             0     0  {
         19,612         0    0              0              0         0              0             0     0      double  progress = 0;
         49,030         0    0         19,612          5,561         0          9,806             0     0      double  F = 1.0 / nVars();
              .         .    .              .              .         .              .             .     .  
        672,691         3    3              0              0         0              0             0     0      for (int i = 0; i <= decisionLevel(); i++){
        613,855         0    0        396,162              0         0              0             0     0          int beg = i == 0 ? 0 : trail_lim[i - 1];
        821,742         0    0        405,968         23,013        34              0             0     0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
      1,276,740        23   19        217,693              0         0              0             0     0          progress += pow(F, i) * (end - beg);
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
         19,612         0    0              0              0         0              0             0     0      return progress / nVars();
         68,642         0    0         58,836              0         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  /*
              .         .    .              .              .         .              .             .     .    Finite subsequences of the Luby-sequence:
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .    0: 1
              .         .    .              .              .         .              .             .     .    1: 1 1 2
              .         .    .              .              .         .              .             .     .    2: 1 1 2 1 1 2 4
              .         .    .              .              .         .              .             .     .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .   */
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  static double luby(double y, int x){
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Find the finite subsequence that contains index 'x', and the
              .         .    .              .              .         .              .             .     .      // size of that subsequence:
              .         .    .              .              .         .              .             .     .      int size, seq;
        491,593         0    0              0              0         0              0             0     0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
              .         .    .              .              .         .              .             .     .  
        278,587         8    8              0              0         0              0             0     0      while (size-1 != x){
        163,898         0    0              0              0         0              0             0     0          size = (size-1)>>1;
         81,949         0    0              0              0         0              0             0     0          seq--;
        245,847         0    0              0              0         0              0             0     0          x = x % size;
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      return pow(y, seq);
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  static bool switch_mode = false;
              .         .    .              .              .         .              .             .     .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
              .         .    .              .              .         .              .             .     .  
             64         8    8              0              0         0             48             0     0  uint32_t Solver::reduceduplicates(){
              .         .    .              .              .         .              .             .     .      uint32_t removed_duplicates = 0;
              .         .    .              .              .         .              .             .     .      std::vector<std::vector<uint64_t>> tmp;
              .         .    .              .              .         .              .             .     .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
          5,556         0    0             16              0         0              0             0     0      for (auto & outer_mp: ht){//variables
         57,494         0    0              0              0         0              0             0     0          for (auto &inner_mp:outer_mp.second){//sizes
     11,818,116         0    0              0              0         0              0             0     0              for (auto &in_in_mp: inner_mp.second){
     17,653,308         8    8      5,884,436      5,605,272 2,986,283              0             0     0                  if (in_in_mp.second >= 2){
              .         .    .              .              .         .              .             .     .                  //min_number_of_learnts_copies
      5,684,600         8    8      2,273,840          3,332       618      2,273,840         1,114     0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
              .         .    .              .              .         .              .             .     .                  }
              .         .    .              .              .         .              .             .     .              }                    
              .         .    .              .              .         .              .             .     .           }
              .         .    .              .              .         .              .             .     .      }          
             24         0    0              8              8         8              8             0     0      removed_duplicates = dupl_db_size-tmp.size();  
              .         .    .              .              .         .              .             .     .      ht.clear();
      3,979,260         8    8      1,705,388            382         8              0             0     0      for (auto i=0;i<tmp.size();i++){
      5,684,600         0    0      2,842,300        639,855   638,494      1,705,380           245     8          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .      return removed_duplicates;
             72         0    0             64             16         8              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  // NOTE: assumptions passed in member-variable 'assumptions'.
              .         .    .              .              .         .              .             .     .  lbool Solver::solve_()
              8         0    0              0              0         0              6             0     0  {
              .         .    .              .              .         .              .             .     .      //signal(SIGALRM, SIGALRM_switch);
              .         .    .              .              .         .              .             .     .      //alarm(2500);
              .         .    .              .              .         .              .             .     .  
              1         1    1              0              0         0              0             0     0      model.clear();
              .         .    .              .              .         .              .             .     .      conflict.clear();
              2         1    1              1              0         0              0             0     0      if (!ok) return l_False;
              .         .    .              .              .         .              .             .     .  
              1         1    1              1              0         0              0             0     0      solves++;
              .         .    .              .              .         .              .             .     .  
              5         0    0              2              1         0              1             0     0      max_learnts               = nClauses() * learntsize_factor;
              3         0    0              1              1         0              0             0     0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
              1         0    0              0              0         0              1             1     0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
              .         .    .              .              .         .              .             .     .      lbool   status            = l_Undef;
              .         .    .              .              .         .              .             .     .  
              3         0    0              1              0         0              0             0     0      if (verbosity >= 1){
              2         0    0              0              0         0              1             0     0          printf("c ============================[ Search Statistics ]==============================\n");
              2         1    1              0              0         0              1             0     0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
              2         0    0              0              0         0              1             0     0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
              2         0    0              0              0         0              1             0     0          printf("c ===============================================================================\n");
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      add_tmp.clear();
              .         .    .              .              .         .              .             .     .  
              1         0    0              0              0         0              1             0     0      VSIDS = true;
              1         1    1              0              0         0              1             0     0      int init = 10000;
            295         0    0             59             59         0              0             0     0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
            236         3    0              0              0         0             59             0     0          status = search(init);
              1         0    0              0              0         0              1             0     0      VSIDS = false;
              .         .    .              .              .         .              .             .     .  
              3         1    1              0              0         0              2             2     0      duplicates_added_conflicts = 0;
              .         .    .              .              .         .              .             .     .      duplicates_added_minimization=0;
              .         .    .              .              .         .              .             .     .      duplicates_added_tier2 =0;    
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      dupl_db_size=0;
              1         0    0              1              1         0              0             0     0      size_t dupl_db_size_limit = dupl_db_init_size;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // Search:
              1         0    0              0              0         0              0             0     0      int curr_restarts = 0;
              1         0    0              0              0         0              0             0     0      uint64_t curr_props = 0;
              .         .    .              .              .         .              .             .     .      uint32_t removed_duplicates =0;
         19,496     2,741   58              0              0         0              0             0     0      while (status == l_Undef /*&& withinBudget()*/){
         19,496         1    1          9,748          1,547         0              0             0     0          if (dupl_db_size >= dupl_db_size_limit){    
             32         8    8              8              8         0              8             0     0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             32         0    0              8              0         0              8             0     0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             32         0    0              8              0         0              8             0     0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             32         8    8              8              8         0              8             0     0              printf("c Duptime: %i\n",duptime.count());
             32         0    0              8              2         0              8             0     0              printf("c Number of conflicts: %i\n",conflicts);
             32         0    0              8              8         0              8             0     0              printf("c Core size: %i\n",learnts_core.size());
              .         .    .              .              .         .              .             .     .              
             16         0    0              0              0         0              8             0     0              removed_duplicates = reduceduplicates();
             64         8    8             16             16        16              0             0     0              dupl_db_size_limit*=1.1;
             16         0    0              8              8         8              0             0     0              dupl_db_size -= removed_duplicates;
             40         0    0              0              0         0              8             0     0              printf("c removed duplicates %i\n",removed_duplicates);
              .         .    .              .              .         .              .             .     .          }   
         58,488       362   72         19,496         10,911        16              0             0     0          if (propagations - curr_props >  VSIDS_props_limit){
             17         0    0              0              0         0              0             0     0              curr_props = propagations;
             17         0    0              0              0         0             17             2     2              switch_mode = true;
             86         0    0              0              0         0             17             0     0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
              .         .    .              .              .         .              .             .     .          }     
         19,496         0    0          9,748              8         8              0             0     0          if (VSIDS){
          1,556         0    0              0              0         0          1,556         1,536     4              int weighted = INT32_MAX;
          6,224     1,553   40              0              0         0          1,556             0     0              status = search(weighted);
              .         .    .              .              .         .              .             .     .          }else{
         49,152     1,674   36         16,384              0         0          8,192         7,429     4              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          8,192         0    0              0              0         0              0             0     0              curr_restarts++;
         40,960     8,177   24              0              0         0          8,192             0     0              status = search(nof_conflicts);
              .         .    .              .              .         .              .             .     .          }
         19,496     8,177   21          9,748          9,748        57              0             0     0          if (switch_mode){ 
             17         0    0              0              0         0             17             0     0              switch_mode = false;
              .         .    .              .              .         .              .             .     .              VSIDS = !VSIDS;
             34         0    0             17              0         0              0             0     0              if (VSIDS){
             18         9    9              0              0         0              9             0     0                  printf("c Switched to VSIDS.\n");
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              else{
             24         8    8              0              0         0              8             0     0                 printf("c Switched to LRB.\n");
              .         .    .              .              .         .              .             .     .              }
              .         .    .              .              .         .              .             .     .              //            reduceduplicates();            
             34         8    8             17             17        13             17             0     0              fflush(stdout);
              .         .    .              .              .         .              .             .     .              picked.clear();
              .         .    .              .              .         .              .             .     .              conflicted.clear();
              .         .    .              .              .         .              .             .     .              almost_conflicted.clear();
              .         .    .              .              .         .              .             .     .  #ifdef ANTI_EXPLORATION
              .         .    .              .              .         .              .             .     .              canceled.clear();
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              3         1    1              1              1         0              0             0     0      if (verbosity >= 1)
              2         0    0              0              0         0              1             0     0          printf("c ===============================================================================\n");
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  #ifdef BIN_DRUP
              3         0    0              1              0         0              0             0     0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
              .         .    .              .              .         .              .             .     .  #endif
              .         .    .              .              .         .              .             .     .  
              2         1    1              0              0         0              0             0     0      if (status == l_True){
              .         .    .              .              .         .              .             .     .          // Extend & copy model:
              .         .    .              .              .         .              .             .     .          model.growTo(nVars());
            341         1    1            152              8         3            160             0     0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
              .         .    .              .              .         .              .             .     .      }else if (status == l_False && conflict.size() == 0)
              .         .    .              .              .         .              .             .     .          ok = false;
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      cancelUntil(0);
              1         0    0              0              0         0              0             0     0      return status;
              8         1    1              7              2         1              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  //=================================================================================================
              .         .    .              .              .         .              .             .     .  // Writing CNF to DIMACS:
              .         .    .              .              .         .              .             .     .  // 
              .         .    .              .              .         .              .             .     .  // FIXME: this needs to be rewritten completely.
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  static Var mapVar(Var x, vec<Var>& map, Var& max)
              .         .    .              .              .         .              .             .     .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
              .         .    .              .              .         .              .             .     .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
              .         .    .              .              .         .              .             .     .  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  //=================================================================================================
              .         .    .              .              .         .              .             .     .  // Garbage Collection methods:
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::relocAll(ClauseAllocator& to)
          7,490       179  131              0              0         0          5,992             0     0  {
              .         .    .              .              .         .              .             .     .      // All watchers:
              .         .    .              .              .         .              .             .     .      //
              .         .    .              .              .         .              .             .     .      // for (int i = 0; i < watches.size(); i++)
          1,498         0    0              0              0         0            749             1     0      watches.cleanAll();
          1,498         0    0              0              0         0            749             0     0      watches_bin.cleanAll();
     18,167,744        16   13     12,715,024         47,024         0      1,817,823           748     0      for (int v = 0; v < nVars(); v++)
      7,265,300         0    0      3,632,650              0         0              0             0     0          for (int s = 0; s < 2; s++){
              .         .    .              .              .         .              .             .     .              Lit p = mkLit(v, s);
              .         .    .              .              .         .              .             .     .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
              .         .    .              .              .         .              .             .     .              vec<Watcher>& ws = watches[p];
    320,931,926        85   60    165,979,702        908,537   104,683              0             0     0              for (int j = 0; j < ws.size(); j++)
              .         .    .              .              .         .              .             .     .                  ca.reloc(ws[j].cref, to);
              .         .    .              .              .         .              .             .     .              vec<Watcher>& ws_bin = watches_bin[p];
     31,356,850        10    9     12,047,110        945,853    23,082              0             0     0              for (int j = 0; j < ws_bin.size(); j++)
              .         .    .              .              .         .              .             .     .                  ca.reloc(ws_bin[j].cref, to);
              .         .    .              .              .         .              .             .     .          }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // All reasons:
              .         .    .              .              .         .              .             .     .      //
      1,243,590         0    0          2,247            749         0              0             0     0      for (int i = 0; i < trail.size(); i++){
              .         .    .              .              .         .              .             .     .          Var v = var(trail[i]);
              .         .    .              .              .         .              .             .     .  
      1,437,014         0    0         98,959         82,003         0              0             0     0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
        496,293         0    0         98,959              0         0         98,959            10     0              ca.reloc(vardata[v].reason, to);
              .         .    .              .              .         .              .             .     .      }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // All learnt:
              .         .    .              .              .         .              .             .     .      //
     25,261,989       464   80     12,630,619            889         0              0             0     0      for (int i = 0; i < learnts_core.size(); i++)
              .         .    .              .              .         .              .             .     .          ca.reloc(learnts_core[i], to);
      3,798,862     2,245  158      1,899,430          1,490         0              0             0     0      for (int i = 0; i < learnts_tier2.size(); i++)
              .         .    .              .              .         .              .             .     .          ca.reloc(learnts_tier2[i], to);
     22,089,310       749   72     11,043,158            749         0              0             0     0      for (int i = 0; i < learnts_local.size(); i++)
     33,124,980         0    0              0              0         0     11,041,660           747     0          ca.reloc(learnts_local[i], to);
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      // All original:
              .         .    .              .              .         .              .             .     .      //
              .         .    .              .              .         .              .             .     .      int i, j;
     30,633,351       749   58          2,996          1,496         0              0             0     0      for (i = j = 0; i < clauses.size(); i++)
     30,626,610         0    0              0              0         0              0             0     0          if (ca[clauses[i]].mark() != 1){
     45,941,413       748   58     15,313,305              0         0     15,313,305             1     0              ca.reloc(clauses[i], to);
    153,132,301       463   83     61,252,471              0         0     15,313,305             0     0              clauses[j++] = clauses[i]; }
            749       748   69              0              0         0              0             0     0      clauses.shrink(i - j);
          5,992       748   80          5,243            749         0              0             0     0  }
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .  void Solver::garbageCollect()
              .         .    .              .              .         .              .             .     .  {
              .         .    .              .              .         .              .             .     .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
              .         .    .              .              .         .              .             .     .      // is not precise but should avoid some unnecessary reallocations for the new region:
              .         .    .              .              .         .              .             .     .      ClauseAllocator to(ca.size() - ca.wasted());
              .         .    .              .              .         .              .             .     .  
              .         .    .              .              .         .              .             .     .      relocAll(to);
              .         .    .              .              .         .              .             .     .      if (verbosity >= 2)
              .         .    .              .              .         .              .             .     .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
              .         .    .              .              .         .              .             .     .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
              .         .    .              .              .         .              .             .     .      to.moveTo(ca);
            155        18   18             47              4         4             61             0     0  }

--------------------------------------------------------------------------------
Ir                I1mr      ILmr   Dr                D1mr           DLmr      Dw              D1mw          DLmw      
--------------------------------------------------------------------------------
3,613,003,670,047 5,223,265 17,108 1,206,110,821,418 51,207,149,389 5,495,583 418,491,221,920 9,787,201,674 6,085,091  events annotated

