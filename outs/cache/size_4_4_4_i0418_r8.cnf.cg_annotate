--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/size_4_4_4_i0418_r8.cnf
Data file:        size_4_4_4_i0418_r8.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr      ILmr  Dr              D1mr           DLmr      Dw              D1mw          DLmw      
--------------------------------------------------------------------------------
1,161,328,868,886 4,567,655 8,608 377,173,721,357 16,816,631,891 2,409,295 134,185,736,650 3,406,713,773 3,832,493  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr              D1mr          DLmr    Dw             D1mw          DLmw     file:function
--------------------------------------------------------------------------------
550,742,899,700   3,926   57 208,300,337,932 9,585,038,104 175,361 61,890,832,721     8,438,326       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
223,679,184,885      10    5  37,025,405,949 1,582,063,058  40,608 31,346,185,680             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
110,902,446,752 215,284    7  24,609,647,545 1,279,091,857     295 14,811,729,933 2,128,203,309 484,555  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
 42,572,162,329     458   88  11,421,003,306 1,536,493,106       0  4,264,320,125    16,979,343       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
 27,826,275,655     102   28   6,945,452,073   287,638,889       0              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
 26,496,141,620       1    1  26,221,312,351    94,474,607       0    274,829,269             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
 19,861,276,773      60   13   4,909,203,472   223,520,425       0  3,664,950,719   441,916,605  29,819  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
 14,822,092,587  18,086  127   5,330,169,990   201,921,808      40    987,478,691     3,991,334      25  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 11,912,957,550       0    0   5,956,478,775         7,046       0              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
 10,354,072,226   8,608   47   4,024,031,551   195,802,099       3  1,247,602,112    50,555,375       1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
  9,608,968,303       8    4   4,127,239,529   165,686,319      11  2,923,077,716   498,641,374     634  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  9,063,277,603 981,075  188   1,951,729,028    70,199,293      71    876,680,763     8,995,101       0  ???:__ieee754_pow_fma
  8,510,053,670   6,542   67   2,129,622,601     3,325,097       2    820,862,681    17,298,010   3,515  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  8,120,088,667   8,066   47   2,762,772,672    43,438,882      19  1,019,696,333     1,913,926       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  7,230,473,425  22,696   20   2,871,235,141   186,731,311      41  1,889,801,830    15,181,625       6  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  6,198,843,659     640   63   1,680,900,384   106,161,496     539     59,979,450        31,953       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  5,842,326,722     210   18   2,757,597,590    56,586,999      10    352,832,458     2,566,034       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  5,487,008,398 921,820   23   1,293,896,848             0       0    956,773,134     6,229,461      40  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  4,923,650,439     432   37   2,237,376,706    95,679,478   1,087    356,004,310            73       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  2,868,676,896     140   48     579,179,403    49,167,678     274    308,003,626    30,698,278     176  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
  2,801,531,576   2,425   76     672,314,264    53,044,480   1,121     74,719,096     5,205,349       0  ???:__exp1_fma
  2,700,547,625     298    7     821,165,146   158,130,203     193              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  2,651,538,075      36   17     873,850,280    26,394,610       2    506,068,818    10,614,663       2  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
  2,524,921,472       0    0   1,262,460,736        27,023       0              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::simplePropagate()
  2,506,183,547     142    8   1,042,427,621     7,093,134      39              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  2,472,551,641     667   32   1,124,726,361    82,836,020      13    338,759,895     7,311,281       4  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  2,122,788,154       5    5     732,633,164     3,944,193       0    657,521,826    22,343,278      97  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  2,034,605,053     386   67     471,228,419    39,378,767       0    157,527,511             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h:Minisat::Solver::detachClause(unsigned int, bool)
  1,975,750,373       0    0   1,975,750,373            38       0              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::simplePropagate()
  1,972,563,486       0    0   1,315,042,324     7,011,796       0    328,760,581    37,827,289      18  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  1,868,762,857   1,543  141     481,115,424    51,705,871 181,513    282,697,180    11,251,231 691,822  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
  1,842,703,805     338   18     562,895,470       136,766       0     50,078,874     1,645,164       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  1,407,039,973   2,168   22     390,752,673           527      12    234,436,812        75,988       0  ???:pow
  1,315,043,652       0    0     328,760,913             0       0    328,760,913         6,280       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  1,308,427,443   3,272   79     237,206,406    47,367,249  12,547     42,304,340       275,223      82  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h:void Minisat::sort<unsigned int, reduceDB_lt>(unsigned int*, int, reduceDB_lt)
  1,234,131,114   4,971  110     356,910,318     2,527,445   5,713    207,221,181        78,323   5,875  ???:_int_free

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr            D1mr      DLmr   Dw         D1mw DLmw 

-- line 40 ----------------------------------------
             .     .    .             .         .      .          .    .    .      void capacity(uint32_t min_cap);
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .   public:
             .     .    .             .         .      .          .    .    .      // TODO: make this a class for better type-checking?
             .     .    .             .         .      .          .    .    .      typedef uint32_t Ref;
             .     .    .             .         .      .          .    .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .             .         .      .          .    .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .             .         .      .          .    .    .  
         1,166     1    1             0         0      0        932    0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .             .         .      .          .    .    .      ~RegionAllocator()
             .     .    .             .         .      .          .    .    .      {
             .     .    .             .         .      .          .    .    .          if (memory != NULL)
             .     .    .             .         .      .          .    .    .              ::free(memory);
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      uint32_t size      () const      { return sz; }
             .     .    .             .         .      .          .    .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      Ref      alloc     (int size); 
    10,048,492     0    0     3,349,495         0      0  3,349,495    0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
15,488,584,141   665   48 7,690,239,548 4,736,042 15,845    399,695    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    43,298,295     0    0    43,298,295 5,575,018  1,787          0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .             .         .      .          .    .    .  
    55,172,007 4,825   10     3,409,953         0      0          0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     5,585,339     0    0             0         0      0          0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .             .         .      .          .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .             .         .      .          .    .    .          return  (Ref)(t - &memory[0]); }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      void     moveTo(RegionAllocator& to) {
           928     0    0           232         0      0        232    0    0          if (to.memory != NULL) ::free(to.memory);
           464     0    0           232         0      0        232    0    0          to.memory = memory;
           464     0    0           232         0      0        232    0    0          to.sz = sz;
             .     .    .             .         .      .          .    .    .          to.cap = cap;
           464     0    0           232         0      0        232    0    0          to.wasted_ = wasted_;
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .          memory = NULL;
             .     .    .             .         .      .          .    .    .          sz = cap = wasted_ = 0;
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  };
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  template<class T>
         2,580    61   18             0         0      0        860  223    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .             .         .      .          .    .    .  {
    51,770,391     1    0    17,256,797         0      0          0    0    0      if (cap >= min_cap) return;
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      uint32_t prev_cap = cap;
        13,400     0    0             0         0      0        430    0    0      while (cap < min_cap){
             .     .    .             .         .      .          .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .             .         .      .          .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .             .         .      .          .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .             .         .      .          .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        38,910     0    0             0         0      0          0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         6,485     0    0             0         0      0          0    0    0          cap += delta;
             .     .    .             .         .      .          .    .    .  
        12,970     0    0             0         0      0          0    0    0          if (cap <= prev_cap)
             .     .    .             .         .      .          .    .    .              throw OutOfMemoryException();
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      assert(cap > 0);
           860     2    1             0         0      0        430  183    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
         1,720     0    0         1,290         0      0          0    0    0  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  template<class T>
             .     .    .             .         .      .          .    .    .  typename RegionAllocator<T>::Ref
        30,548     2    1             0         0      0     22,911    0    0  RegionAllocator<T>::alloc(int size)
             .     .    .             .         .      .          .    .    .  { 
             .     .    .             .         .      .          .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .             .         .      .          .    .    .      assert(size > 0);
    93,301,888     0    0    17,256,564   454,641      0 44,941,948  252    0      capacity(sz + size);
             .     .    .             .         .      .          .    .    .  
    55,148,898     0    0    31,095,338         0      0          0    0    0      uint32_t prev_sz = sz;
    17,256,564     2    1             0         0      0 17,256,564    0    0      sz += size;
             .     .    .             .         .      .          .    .    .      
             .     .    .             .         .      .          .    .    .      // Handle overflow:
    76,052,957   214   30    13,846,610         0      0          0    0    0      if (sz < prev_sz)
             2     1    1             1         1      0          0    0    0          throw OutOfMemoryException();
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      return prev_sz;
        30,548     0    0        30,548         0      0          0    0    0  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  //=================================================================================================
             .     .    .             .         .      .          .    .    .  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr          DLmr    Dw             D1mw       DLmw      

-- line 54 ----------------------------------------
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  struct Lit {
              .     .    .              .             .       .              .          .         .      int     x;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // Use this as a constructor:
              .     .    .              .             .       .              .          .         .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      bool operator == (Lit p) const { return x == p.x; }
    367,785,268     0    0    185,538,234    89,358,417     384              0          0         0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .             .       .              .          .         .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
         57,520     0    0              0             0       0            469          0         0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 16,011,006,600    47   19  7,307,843,036       209,951     193    549,853,855     31,953         0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .             .       .              .          .         .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 76,302,019,578    21   11  1,317,949,063             0       0    660,427,901 37,833,569        18  inline  bool sign      (Lit p)              { return p.x & 1; }
123,006,438,136 5,244   64  2,016,339,586    18,237,596      25 25,671,663,870          0         0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .             .       .              .          .         .  inline  int  toInt     (Var v)              { return v; } 
          1,039     0    0            108             0       0            108          3         2  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .             .       .              .          .         .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .             .       .              .          .         .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .             .       .              .          .         .  const Lit lit_Error = { -1 };  // }
              .     .    .              .             .       .              .          .         .  
-- line 82 ----------------------------------------
-- line 104 ----------------------------------------
              .     .    .              .             .       .              .          .         .      uint8_t value;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  public:
              .     .    .              .             .       .              .          .         .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      lbool()       : value(0) { }
              .     .    .              .             .       .              .          .         .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .             .       .              .          .         .  
  2,766,358,885     1    1              0             0       0              0          0         0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
              .     .    .              .             .       .              .          .         .      bool  operator != (lbool b) const { return !(*this == b); }
 16,700,656,742    56   11 15,437,805,147    35,968,897      12              0          0         0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      lbool operator && (lbool b) const {
              .     .    .              .             .       .              .          .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .             .       .              .          .         .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .             .       .              .          .         .          return lbool(v); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      lbool operator || (lbool b) const {
              .     .    .              .             .       .              .          .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .             .       .              .          .         .          unsigned simplified : 1;}                            header;
              .     .    .              .             .       .              .          .         .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      friend class ClauseAllocator;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .             .       .              .          .         .      template<class V>
              .     .    .              .             .       .              .          .         .      Clause(const V& ps, bool use_extra, bool learnt) {
     58,819,312     0    0     13,854,249             0       0     17,256,564    113,492         0          header.mark      = 0;
     41,539,833     1    1     13,846,611       868,421  56,257              0          0         0          header.learnt    = learnt;
     83,133,132     4    4     13,861,887             2       0     13,854,249          0         0          header.has_extra = learnt | use_extra;
              .     .    .              .             .       .              .          .         .          header.reloced   = 0;
     20,666,515     0    0      3,409,952           183       0     17,256,563  2,249,438    32,174          header.size      = ps.size();
              .     .    .              .             .       .              .          .         .          header.lbd       = 0;
              .     .    .              .             .       .              .          .         .          header.removable = 1;
              .     .    .              .             .       .              .          .         .          //simplify
              .     .    .              .             .       .              .          .         .          //
     17,256,564    14    9     17,256,564     1,942,695 127,793              0          0         0          header.simplified = 0;
              .     .    .              .             .       .              .          .         .  
    574,360,748   294   31      3,433,234             0       0              0          0         0          for (int i = 0; i < ps.size(); i++)
    322,060,664   323   15    109,887,084     9,218,478  11,748    134,607,932 14,470,204 1,001,689              data[i].lit = ps[i];
              .     .    .              .             .       .              .          .         .  
     51,769,691    77   30     17,256,563             0       0              0          0         0          if (header.has_extra){
     32,865,812    20    2              0             0       0              0          0         0              if (header.learnt){
     32,842,654     3    3     13,018,812             0       0     16,421,327  1,027,448    67,541                  data[header.size].act = 0;
     32,842,854     0    0              0             0       0     16,421,327  1,026,813    67,717                  data[header.size+1].touched = 0;
              .     .    .              .             .       .              .          .         .              }else
              .     .    .              .             .       .              .          .         .                  calcAbstraction(); }
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  public:
              .     .    .              .             .       .              .          .         .      void calcAbstraction() {
              .     .    .              .             .       .              .          .         .          assert(header.has_extra);
         11,835     0    0              0             0       0              0          0         0          uint32_t abstraction = 0;
        166,499     5    4          4,057             0       0              0          0         0          for (int i = 0; i < size(); i++)
        246,002     3    2              0             0       0              1          0         0              abstraction |= 1 << (var(data[i].lit) & 31);
         35,173     0    0          3,941             0       0         15,713        725       719          data[header.size].abs = abstraction;  }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
 13,269,311,795   218   67  6,758,556,624   858,632,437  11,830  5,142,001,002         54         0      int          size        ()      const   { return header.size; }
      2,925,856    32   10        732,094       132,805       0        732,094     10,468         0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .             .       .              .          .         .      void         pop         ()              { shrink(1); }
    117,762,697     9    9      3,353,436             1       0              0          0         0      bool         learnt      ()      const   { return header.learnt; }
         10,350     0    0              0             0       0              0          0         0      bool         has_extra   ()      const   { return header.has_extra; }
    237,037,373   256    9     49,127,759    46,124,446  18,627     55,517,612          0         0      uint32_t     mark        ()      const   { return header.mark; }
     72,181,215   306   21     18,791,157         1,538       0     17,742,727          0         0      void         mark        (uint32_t m)    { header.mark = m; }
        330,698     0    0              0             0       0        165,349          0         0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .             .       .              .          .         .  
     41,620,594     0    0     41,620,594    35,212,195     384              0          0         0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .             .       .              .          .         .      CRef         relocation  ()      const   { return data[0].rel; }
     55,386,444    19    9     13,846,611             0       0     27,693,222          0         0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .             .       .              .          .         .  
     34,119,815     0    0     11,360,920             0       0              0          0         0      int          lbd         ()      const   { return header.lbd; }
    113,007,193   186   22     30,414,172             0       0     17,395,777          0         0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .             .       .              .          .         .      bool         removable   ()      const   { return header.removable; }
     82,108,988     4    4     30,032,940             0       0     13,019,012          0         0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .             .       .              .          .         .      //       subsumption operations to behave correctly.
 15,170,063,061   197   34 14,750,071,941 1,139,679,509  29,269              0          0         0      Lit&         operator [] (int i)         { return data[i].lit; }
    232,738,355   369   29    204,183,089     6,889,865   1,920              0          0         0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .             .       .              .          .         .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .             .       .              .          .         .  
     13,404,361     0    0     13,404,361            19       0              0          0         0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     14,688,156     0    0      4,507,244     1,102,605     133              0          0         0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .             .       .              .          .         .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .             .       .              .          .         .      void         strengthen  (Lit p);
              .     .    .              .             .       .              .          .         .      // simplify
              .     .    .              .             .       .              .          .         .      //
     91,722,914     3    1     26,332,939             0       0     13,019,012          0         0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .             .       .              .          .         .      bool simplified() { return header.simplified; }
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  //=================================================================================================
              .     .    .              .             .       .              .          .         .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .             .       .              .          .         .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      static int clauseWord32Size(int size, int extras){
     34,452,874     4    4     17,196,111       806,356     526              0          0         0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .             .       .              .          .         .  public:
              .     .    .              .             .       .              .          .         .      bool extra_clause_field;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0             0       0              1          0         0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void moveTo(ClauseAllocator& to){
            464    21    4            232             1       0            232          0         0          to.extra_clause_field = extra_clause_field;
              .     .    .              .             .       .              .          .         .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      template<class Lits>
              .     .    .              .             .       .              .          .         .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .             .       .              .          .         .          assert(sizeof(float)    == sizeof(uint32_t));
     28,528,458   191   20        835,236           200       0              0          0         0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .             .       .              .          .         .  
      3,417,589     0    0              0             0       0          7,637          0         0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .             .       .              .          .         .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .          return cid;
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    120,520,525   226    5    108,415,714        61,767       0          7,912          0         0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
          4,072     1    1          2,036             0       0              0          0         0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     13,846,611     0    0     13,846,611             0       0              0          0         0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .          .         .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .          .         .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void free(CRef cid)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .          Clause& c = operator[](cid);
     10,058,835     8    3              0             0       0              0          0         0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .             .       .              .          .         .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
     27,790,455   231    5              0             0       0     23,820,390        452         0      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .          Clause& c = operator[](cr);
              .     .    .              .             .       .              .          .         .          
    148,733,766     0    0     27,773,983     4,866,997       0     27,773,983          0         0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .             .       .              .          .         .          
     13,846,612     0    0              1             0       0     13,846,611          0         0          cr = to.alloc(c, c.learnt());
              .     .    .              .             .       .              .          .         .          c.relocate(cr);
              .     .    .              .             .       .              .          .         .          
              .     .    .              .             .       .              .          .         .          // Copy extra data-fields:
              .     .    .              .             .       .              .          .         .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .             .       .              .          .         .          to[cr].mark(c.mark());
     27,693,222     3    3              0             0       0              0          0         0          if (to[cr].learnt()){
     52,076,048     0    0     13,019,012       732,351     335     13,019,012          0         0              to[cr].touched() = c.touched();
     52,075,848     0    0     26,038,024       734,312     362     13,019,012          0         0              to[cr].activity() = c.activity();
              .     .    .              .             .       .              .          .         .              to[cr].set_lbd(c.lbd());
              .     .    .              .             .       .              .          .         .              to[cr].removable(c.removable());
              .     .    .              .             .       .              .          .         .              // simplify
              .     .    .              .             .       .              .          .         .              //
              .     .    .              .             .       .              .          .         .              to[cr].setSimplified(c.simplified());
              .     .    .              .             .       .              .          .         .          }
      1,655,198   462   12              0             0       0              0          0         0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     31,760,520     0    0     27,790,455             0       0              0          0         0      }
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .             .       .              .          .         .      {
              .     .    .              .             .       .              .          .         .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .             .       .              .          .         .  class OccLists
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      vec<Vec>  occs;
              .     .    .              .             .       .              .          .         .      vec<char> dirty;
              .     .    .              .             .       .              .          .         .      vec<Idx>  dirties;
              .     .    .              .             .       .              .          .         .      Deleted   deleted;
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  public:
              3     0    0              0             0       0              3          0         0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .             .       .              .          .         .      unsigned int size(){
              .     .    .              .             .       .              .          .         .          auto m_size=0;
             64     2    2              4             2       0              0          0         0          for(int i=0;i<occs.size();i++){
         25,148    14   14          9,124         2,280       0              0          0         0              m_size+=occs[i].size();
              .     .    .              .             .       .              .          .         .          }
              .     .    .              .             .       .              .          .         .          
              .     .    .              .             .       .              .          .         .          return m_size;
              .     .    .              .             .       .              .          .         .      }
         12,540     1    1              0             0       0          2,280          0         0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .             .       .              .          .         .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
    305,700,050    35    5    305,700,050     1,252,046       0              0          0         0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
         31,625     1    1         16,144           748       0          1,076          0         0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void  cleanAll  ();
              .     .    .              .             .       .              .          .         .      void  clean     (const Idx& idx);
              .     .    .              .             .       .              .          .         .      void  smudge    (const Idx& idx){
     20,117,054     0    0     13,408,017        54,538     165              0          0         0          if (dirty[toInt(idx)] == 0){
        206,307   258    5              0             0       0        206,307          0         0              dirty[toInt(idx)] = 1;
             46     1    1              0             0       0              0          0         0              dirties.push(idx);
              .     .    .              .             .       .              .          .         .          }
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .      void  clear(bool free = true){
              .     .    .              .             .       .              .          .         .          occs   .clear(free);
              .     .    .              .             .       .              .          .         .          dirty  .clear(free);
              .     .    .              .             .       .              .          .         .          dirties.clear(free);
              .     .    .              .             .       .              .          .         .      }
              .     .    .              .             .       .              .          .         .  };
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  template<class Idx, class Vec, class Deleted>
         11,516     0    0              0             0       0          8,637          1         0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .             .       .              .          .         .  {
     83,100,544   172    4     41,341,990        21,870       5              0          0         0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .             .       .              .          .         .          // Dirties may contain duplicates so check here if a variable is already cleaned:
        618,921     0    0        412,614       138,461       0              0          0         0          if (dirty[toInt(dirties[i])])
              .     .    .              .             .       .              .          .         .              clean(dirties[i]);
              .     .    .              .             .       .              .          .         .      dirties.clear();
         11,516     0    0         11,516         2,883       0              0          0         0  }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  template<class Idx, class Vec, class Deleted>
              .     .    .              .             .       .              .          .         .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      Vec& vec = occs[toInt(idx)];
              .     .    .              .             .       .              .          .         .      int  i, j;
    138,705,008     2    2        816,199       213,664       0              0          0         0      for (i = j = 0; i < vec.size(); i++)
     86,699,436     0    0         33,993         1,461       0              0          0         0          if (!deleted(vec[i]))
    255,983,782     3    2     73,221,070            93       0     36,618,766    212,238         0              vec[j++] = vec[i];
        204,550   245    5              0             0       0              0          0         0      vec.shrink(i - j);
        826,296     1    1        412,614        31,833       0        206,671     15,806         0      dirty[toInt(idx)] = 0;
              .     .    .              .             .       .              .          .         .  }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  //=================================================================================================
              .     .    .              .             .       .              .          .         .  // CMap -- a class for mapping clauses to values:
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .             .       .              .          .         .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .             .       .              .          .         .  |________________________________________________________________________________________________@*/
              .     .    .              .             .       .              .          .         .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .             .       .              .          .         .  {
              .     .    .              .             .       .              .          .         .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .             .       .              .          .         .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .             .       .              .          .         .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .             .       .              .          .         .      assert(header.has_extra); assert(other.header.has_extra);
        859,557     0    0        286,519         3,625       0              0          0         0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .             .       .              .          .         .          return lit_Error;
              .     .    .              .             .       .              .          .         .  
         25,287     0    0              0             0       0              0          0         0      Lit        ret = lit_Undef;
              .     .    .              .             .       .              .          .         .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .             .       .              .          .         .      const Lit* d   = (const Lit*)other;
              .     .    .              .             .       .              .          .         .  
        209,610     1    1         39,823             0       0              0          0         0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .             .       .              .          .         .          // search for c[i] or ~c[i]
        662,218     2    2         25,287             0       0         25,287          0         0          for (unsigned j = 0; j < other.header.size; j++)
        835,375     0    0        181,820             0       0              0          0         0              if (c[i] == d[j])
              .     .    .              .             .       .              .          .         .                  goto ok;
        138,664     0    0              0             0       0              0          0         0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .             .       .              .          .         .                  ret = c[i];
              .     .    .              .             .       .              .          .         .                  goto ok;
              .     .    .              .             .       .              .          .         .              }
              .     .    .              .             .       .              .          .         .  
              .     .    .              .             .       .              .          .         .          // did not find it
              .     .    .              .             .       .              .          .         .          return lit_Error;
              .     .    .              .             .       .              .          .         .  ok:;
              .     .    .              .             .       .              .          .         .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr             D1mr          DLmr    Dw             D1mw        DLmw 

-- line 51 ----------------------------------------
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Options:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static const char* _cat = "CORE";
             .       .    .              .             .       .              .           .    .  
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
             4       1    1              0             0       0              1           0    0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
             4       0    0              0             0       0              1           0    0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
             4       0    0              0             0       0              1           0    0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
             4       1    1              0             0       0              1           0    0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
             4       0    0              0             0       0              1           0    0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
             4       1    1              0             0       0              1           0    0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
             4       1    1              0             0       0              1           0    0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
             4       1    1              0             0       0              1           0    0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
             4       1    1              0             0       0              1           0    0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
             .       .    .              .             .       .              .           .    .  
             4       1    1              0             0       0              1           0    0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
             1       1    1              0             0       0              1           0    0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
             4       0    0              0             0       0              1           0    0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
             .       .    .              .             .       .              .           .    .  
             4       1    1              0             0       0              1           0    0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //VSIDS_props_limit
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Constructor/Destructor:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             4       1    1              0             0       0              2           0    0  Solver::Solver() :
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Parameters (user settable):
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      drup_file        (NULL)
             .       .    .              .             .       .              .           .    .    , verbosity        (0)
             .       .    .              .             .       .              .           .    .    , step_size        (opt_step_size)
             .       .    .              .             .       .              .           .    .    , step_size_dec    (opt_step_size_dec)
             .       .    .              .             .       .              .           .    .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
             .       .    .              .             .       .              .           .    .    , garbage_frac     (opt_garbage_frac)
             .       .    .              .             .       .              .           .    .    , restart_first    (opt_restart_first)
             .       .    .              .             .       .              .           .    .    , restart_inc      (opt_restart_inc)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    , min_number_of_learnts_copies(opt_min_dupl_app)  
             .       .    .              .             .       .              .           .    .    , max_lbd_dup(opt_max_lbd_dup)
             .       .    .              .             .       .              .           .    .    , dupl_db_init_size(opt_dupl_db_init_size)
             3       1    1              1             0       0              1           0    0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    // Parameters (the rest):
             .       .    .              .             .       .              .           .    .    //
             .       .    .              .             .       .              .           .    .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    // Parameters (experimental):
             .       .    .              .             .       .              .           .    .    //
             .       .    .              .             .       .              .           .    .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
             .       .    .              .             .       .              .           .    .    //
             .       .    .              .             .       .              .           .    .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
             .       .    .              .             .       .              .           .    .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
             .       .    .              .             .       .              .           .    .    , chrono_backtrack(0), non_chrono_backtrack(0)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    , ok                 (true)
             .       .    .              .             .       .              .           .    .    , cla_inc            (1)
             .       .    .              .             .       .              .           .    .    , var_inc            (1)
             1       0    0              0             0       0              0           0    0    , watches_bin        (WatcherDeleted(ca))
             .       .    .              .             .       .              .           .    .    , watches            (WatcherDeleted(ca))
             .       .    .              .             .       .              .           .    .    , qhead              (0)
             .       .    .              .             .       .              .           .    .    , simpDB_assigns     (-1)
             .       .    .              .             .       .              .           .    .    , simpDB_props       (0)
             .       .    .              .             .       .              .           .    .    , order_heap_CHB     (VarOrderLt(activity_CHB))
             .       .    .              .             .       .              .           .    .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
             .       .    .              .             .       .              .           .    .    , progress_estimate  (0)
             .       .    .              .             .       .              .           .    .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
             .       .    .              .             .       .              .           .    .    // simplifyAll adjust occasion
             .       .    .              .             .       .              .           .    .    , curSimplify(1)
             .       .    .              .             .       .              .           .    .    , nbconfbeforesimplify(1000)
             .       .    .              .             .       .              .           .    .    , incSimplify(1000)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    , my_var_decay       (0.6)
             .       .    .              .             .       .              .           .    .    , DISTANCE           (true)
             .       .    .              .             .       .              .           .    .    , var_iLevel_inc     (1)
            94       8    8             25             2       2             63           1    0    , order_heap_distance(VarOrderLt(activity_distance))
             .       .    .              .             .       .              .           .    .  
             4       0    0              3             0       0              0           0    0  {}
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  Solver::~Solver()
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // simplify All
             .       .    .              .             .       .              .           .    .  //
             .       .    .              .             .       .              .           .    .  CRef Solver::simplePropagate()
    23,251,256       8    4              0             0       0     17,438,442      19,946    0  {
     2,906,407       0    0              0             0       0      2,906,407           0    0      CRef    confl = CRef_Undef;
     2,906,407       0    0              0             0       0      2,906,407       2,334    0      int     num_props = 0;
     5,812,814       0    0              0             0       0      2,906,407      17,098    0      watches.cleanAll();
     8,719,221      55   11      2,906,407         2,375       0      2,906,407           0    0      watches_bin.cleanAll();
    59,630,408       0    0     29,815,204             0       0              0           0    0      while (qhead < trail.size())
             .       .    .              .             .       .              .           .    .      {
   134,570,595       1    1     53,828,238     1,018,705       0     53,828,238           0    0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .       .    .              .             .       .              .           .    .          vec<Watcher>&  ws = watches[p];
             .       .    .              .             .       .              .           .    .          Watcher        *i, *j, *end;
    26,908,797       0    0     26,908,797         1,504       0              0           0    0          num_props++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // First, Propagate binary clauses
             .       .    .              .             .       .              .           .    .          vec<Watcher>&  wbin = watches_bin[p];
             .       .    .              .             .       .              .           .    .  
   185,341,455       0    0     26,914,119    23,137,311       0              0           0    0          for (int k = 0; k<wbin.size(); k++)
             .       .    .              .             .       .              .           .    .          {
             .       .    .              .             .       .              .           .    .  
    60,067,500       0    0     37,292,479     9,984,384       0              0           0    0              Lit imp = wbin[k].blocker;
             .       .    .              .             .       .              .           .    .  
    60,067,500       0    0              0             0       0              0           0    0              if (value(imp) == l_False)
             .       .    .              .             .       .              .           .    .              {
        10,644       0    0          5,322             0       0          5,322           0    0                  return wbin[k].cref;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
    60,056,856       7    5              0             0       0              0           0    0              if (value(imp) == l_Undef)
             .       .    .              .             .       .              .           .    .              {
    12,420,728       0    0     12,420,728             0       0              0           0    0                  simpleUncheckEnqueue(imp, wbin[k].cref);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
 4,204,391,431      36    6  2,022,309,238    16,252,247       0     52,533,136           0    0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
             .       .    .              .             .       .              .           .    .          {
             .       .    .              .             .       .              .           .    .              // Try to avoid inspecting the clause:
 1,968,491,644      53   11  1,968,491,644   256,569,478       0              0           0    0              Lit blocker = i->blocker;
 3,936,983,288       0    0  1,968,491,644     6,047,074       0              0           0    0              if (value(blocker) == l_True)
             .       .    .              .             .       .              .           .    .              {
             .       .    .              .             .       .              .           .    .                  *j++ = *i++; continue;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Make sure the false literal is data[1]:
 2,524,921,472       0    0  1,262,460,736             0       0              0           0    0              CRef     cr = i->cref;
             .       .    .              .             .       .              .           .    .              Clause&  c = ca[cr];
             .       .    .              .             .       .              .           .    .              Lit      false_lit = ~p;
 3,787,382,208       0    0  1,262,460,736 1,194,469,201       0              0           0    0              if (c[0] == false_lit)
 1,259,241,060       0    0    419,747,020    24,666,449       0    839,494,040           0    0                  c[0] = c[1], c[1] = false_lit;
             .       .    .              .             .       .              .           .    .              assert(c[1] == false_lit);
             .       .    .              .             .       .              .           .    .              //  i++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // If 0th watch is true, then clause is already satisfied.
             .       .    .              .             .       .              .           .    .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
             .       .    .              .             .       .              .           .    .              // why not simply do i->blocker=first in this case?
             .       .    .              .             .       .              .           .    .              Lit     first = c[0];
             .       .    .              .             .       .              .           .    .              //  Watcher w     = Watcher(cr, first);
 3,091,489,172       0    0    283,283,850       910,046       0              0           0    0              if (first != blocker && value(first) == l_True)
             .       .    .              .             .       .              .           .    .              {
    53,680,830       0    0              0             0       0     53,680,830           0    0                  i->blocker = first;
 3,038,846,952       0    0    759,711,738             0       0    759,711,738   3,334,961    0                  *j++ = *i++; continue;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Look for new watch:
             .       .    .              .             .       .              .           .    .              //if (incremental)
             .       .    .              .             .       .              .           .    .              //{ // ----------------- INCREMENTAL MODE
             .       .    .              .             .       .              .           .    .              //	int choosenPos = -1;
             .       .    .              .             .       .              .           .    .              //	for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .    .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
             .       .    .              .             .       .              .           .    .              //		Watcher w = Watcher(cr, first); i++;
             .       .    .              .             .       .              .           .    .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
             .       .    .              .             .       .              .           .    .              //		watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .    .              //		goto NextClause;
             .       .    .              .             .       .              .           .    .              //	}
             .       .    .              .             .       .              .           .    .              //}
             .       .    .              .             .       .              .           .    .              else
             .       .    .              .             .       .              .           .    .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
 3,642,678,815      56   10              0             0       0              0           0    0                  for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .    .                  {
             .       .    .              .             .       .              .           .    .  
 7,220,581,387       0    0              0             0       0              0           0    0                      if (value(c[k]) != l_False)
             .       .    .              .             .       .              .           .    .                      {
             .       .    .              .             .       .              .           .    .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
             .       .    .              .             .       .              .           .    .                          // the blocker is first in the watcher. However,
             .       .    .              .             .       .              .           .    .                          // the blocker in the corresponding watcher in ~first is not c[1]
             .       .    .              .             .       .              .           .    .                          Watcher w = Watcher(cr, first); i++;
 4,783,475,308       2    1  1,195,868,827             0       0  2,391,737,654           0    0                          c[1] = c[k]; c[k] = false_lit;
             .       .    .              .             .       .              .           .    .                          watches[~c[1]].push(w);
 1,195,868,827       0    0              0             0       0              0           0    0                          goto NextClause;
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Did not find watch -- clause is unit under assignment:
    12,911,079       0    0              0             0       0     12,911,079           0    0              i->blocker = first;
    51,644,316       3    0     12,911,079             0       0     12,911,079      64,708    0              *j++ = *i++;
    25,822,158      56    9              0             0       0              0           0    0              if (value(first) == l_False)
             .       .    .              .             .       .              .           .    .              {
       755,205      15    2              0             0       0        114,640           4    0                  confl = cr;
       229,280      52    7        114,640         3,003       0        114,640           0    0                  qhead = trail.size();
             .       .    .              .             .       .              .           .    .                  // Copy the remaining watches:
    16,227,580       3    0        219,825         1,118       0              0           0    0                  while (i < end)
     7,779,325       0    0      7,779,325       961,159       0      7,779,325      38,469    0                      *j++ = *i++;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else
             .       .    .              .             .       .              .           .    .              {
             .       .    .              .             .       .              .           .    .                  simpleUncheckEnqueue(first, cr);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  NextClause:;
             .       .    .              .             .       .              .           .    .          }
    51,248,678      56    9              0             0       0              0           0    0          ws.shrink(i - j);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
     5,802,170       0    0      5,802,170     1,094,102       0              0           0    0      s_propagations += num_props;
             .       .    .              .             .       .              .           .    .  
     2,901,085       0    0      2,901,085             0       0              0           0    0      return confl;
   957,690,531      55   12     20,344,849     1,119,869       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
             .       .    .              .             .       .              .           .    .      assert(value(p) == l_Undef);
    25,217,167       0    0              0             0       0     25,217,167           0    0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
    56,247,148      56   11     28,123,574       255,081       0     28,123,574  15,940,157    0      vardata[var(p)].reason = from;
    15,702,846       0    0     15,702,846             0       0              0           0    0      trail.push_(p);
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::cancelUntilTrailRecord()
             .       .    .              .             .       .              .           .    .  {
    57,685,428       0    0        575,312             0       0              0           0    0      for (int c = trail.size() - 1; c >= trailRecord; c--)
             .       .    .              .             .       .              .           .    .      {
       287,656      56   12        287,656             0       0              0           0    0          Var x = var(trail[c]);
    28,986,542       0    0        287,656             4       0     28,123,574     150,086    0          assigns[x] = l_Undef;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      }
       287,656       0    0              0             0       0        287,656           0    0      qhead = trailRecord;
       575,312       0    0              0             0       0              0           0    0      trail.shrink(trail.size() - trailRecord);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::litsEnqueue(int cutP, Clause& c)
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .      for (int i = cutP; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .      {
             .       .    .              .             .       .              .           .    .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::removed(CRef cr) {
             .       .    .              .             .       .              .           .    .      return ca[cr].mark() == 1;
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
     3,138,421      53   11              0             0       0      1,711,866           0    0  {
       285,311       0    0              0             0       0              0           0    0      int pathC = 0;
       285,311       0    0              0             0       0              0           0    0      Lit p = lit_Undef;
       855,933       0    0        285,311             0       0              0           0    0      int index = trail.size() - 1;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      do{
    11,895,170      56   12              0             0       0              0           0    0          if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .    .              reason_clause.push(confl);
             .       .    .              .             .       .              .           .    .              Clause& c = ca[confl];
             .       .    .              .             .       .              .           .    .              // Special case for binary clauses
             .       .    .              .             .       .              .           .    .              // The first one has to be SAT
    13,915,216      61   10              0             0       0              0           0    0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .    .                  Lit tmp = c[0];
       321,483       0    0        107,161         5,383       0        214,322           0    0                  c[0] = c[1], c[1] = tmp;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              // if True_confl==true, then choose p begin with the 1th index of c;
    33,388,622       0    0      7,323,756       281,566       0              0           0    0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
             .       .    .              .             .       .              .           .    .                  Lit q = c[j];
    19,482,466       0    0      9,741,233     1,300,972       0              0           0    0                  if (!seen[var(q)]){
     5,662,372       0    0              0             0       0      5,662,372           0    0                      seen[var(q)] = 1;
    16,987,116       0    0      5,662,372             0       0              0           0    0                      pathC++;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else if (confl == CRef_Undef){
             .       .    .              .             .       .              .           .    .              out_learnt.push(~p);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
    19,960,252      56   12      5,662,357             0       0              0           0    0          if (pathC == 0) break;
             .       .    .              .             .       .              .           .    .          // Select next clause to look at:
   183,107,824       0    0     61,035,969     3,129,658       0              0           0    0          while (!seen[var(trail[index--])]);
             .       .    .              .             .       .              .           .    .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
             .       .    .              .             .       .              .           .    .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
    11,324,714       0    0      5,662,357             0       0              0           0    0          if (trailRecord > index + 1) break;
             .       .    .              .             .       .              .           .    .          p = trail[index + 1];
             .       .    .              .             .       .              .           .    .          confl = reason(var(p));
     5,662,274       0    0              0             0       0      5,662,274           0    0          seen[var(p)] = 0;
     5,662,274       0    0              0             0       0              0           0    0          pathC--;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      } while (pathC >= 0);
     2,853,110      56   11      1,997,177           116       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::simplifyLearnt(Clause& c)
     2,588,904     112   23              0             0       0      1,725,936         471    0  {
             .       .    .              .             .       .              .           .    .      ////
       287,656       0    0        287,656        21,900       0              0           0    0      original_length_record += c.size();
             .       .    .              .             .       .              .           .    .  
       575,312       0    0        287,656        18,179       0        287,656           0    0      trailRecord = trail.size();// record the start pointer
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      vec<Lit> falseLit;
             .       .    .              .             .       .              .           .    .      falseLit.clear();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
             .       .    .              .             .       .              .           .    .  
       239,924      52   11              0             0       0              0           0    0      bool True_confl = false;
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      beforeSize = c.size();
             .       .    .              .             .       .              .           .    .      int i, j;
             .       .    .              .             .       .              .           .    .      CRef confl;
             .       .    .              .             .       .              .           .    .  
    10,761,270      56   12              0             0       0              0           0    0      for (i = 0, j = 0; i < c.size(); i++){
     6,594,178       0    0              0             0       0              0           0    0          if (value(c[i]) == l_Undef){
             .       .    .              .             .       .              .           .    .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
             .       .    .              .             .       .              .           .    .              simpleUncheckEnqueue(~c[i]);
    11,505,666       0    0      2,906,407             0       0      2,906,407       7,885    0              c[j++] = c[i];
     8,719,221       0    0              0             0       0      2,906,407           0    0              confl = simplePropagate();
     8,719,221      56   11      2,906,407     1,135,754       0              0           0    0              if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .    .                  break;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{
       781,364       0    0              0             0       0              0           0    0              if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .    .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
       661,396      44   10        165,349             0       0        165,349       1,429    0                  c[j++] = c[i];
       165,349      34    6              0             0       0              0           0    0                  True_confl = true;
             .       .    .              .             .       .              .           .    .                  confl = reason(var(c[i]));
             .       .    .              .             .       .              .           .    .                  break;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
             .       .    .              .             .       .              .           .    .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
             .       .    .              .             .       .              .           .    .                  falseLit.push(c[i]);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      c.shrink(c.size() - j);
             .       .    .              .             .       .              .           .    .      afterSize = c.size();
             .       .    .              .             .       .              .           .    .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      if (confl != CRef_Undef || True_confl == true){
       285,311       0    0              0             0       0              0           0    0          simp_learnt_clause.clear();
       285,311       0    0              0             0       0              0           0    0          simp_reason_clause.clear();
       570,622       0    0              0             0       0              0           0    0          if (True_confl == true){
             .       .    .              .             .       .              .           .    .              simp_learnt_clause.push(c.last());
             .       .    .              .             .       .              .           .    .          }
     1,997,177      22    3              0             0       0        285,311           0    0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
             .       .    .              .             .       .              .           .    .  
       855,933       0    0        285,311             0       0              0           0    0          if (simp_learnt_clause.size() < c.size()){
     1,999,302      56   10        848,421             0       0              0           0    0              for (i = 0; i < simp_learnt_clause.size(); i++){
     3,091,224       0    0        772,806             0       0        772,806       7,040    0                  c[i] = simp_learnt_clause[i];
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              c.shrink(c.size() - i);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      cancelUntilTrailRecord();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
       287,656       0    0        287,656             0       0              0           0    0      simplified_length_record += c.size();
             .       .    .              .             .       .              .           .    .  
     2,301,248       0    0      2,013,592       282,688       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      int learnts_x_size_before = learnts_x.size();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .    .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .    .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      return true;
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyLearnt_core()
           616       0    0              0             0       0            336           0    0  {
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      int learnts_core_size_before = learnts_core.size();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .    .      bool sat, false_lit;
             .       .    .              .             .       .              .           .    .      unsigned int nblevels;
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      //printf("learnts_x size : %d\n", learnts_x.size());
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      int nbSimplified = 0;
             .       .    .              .             .       .              .           .    .      int nbSimplifing = 0;
             .       .    .              .             .       .              .           .    .  
     2,913,889      55   11             56             0       0              0           0    0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     4,370,517      56   12      2,913,678        91,107       0              0           0    0          CRef cr = learnts_core[ci];
             .       .    .              .             .       .              .           .    .          Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .  
     2,913,678       0    0              0             0       0              0           0    0          if (removed(cr)) continue;
     2,913,678       0    0      1,456,839       175,639       0              0           0    0          else if (c.simplified()){
     2,839,304       0    0              0             0       0      1,419,652          12    0              learnts_core[cj++] = learnts_core[ci];
             .       .    .              .             .       .              .           .    .              ////
     4,259,220       0    0      1,419,652             0       0              0           0    0              nbSimplified++;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{
             .       .    .              .             .       .              .           .    .              int saved_size=c.size();
             .       .    .              .             .       .              .           .    .              //         if (drup_file){
             .       .    .              .             .       .              .           .    .              //                 add_oc.clear();
             .       .    .              .             .       .              .           .    .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .       .    .              .             .       .              .           .    .              ////
             .       .    .              .             .       .              .           .    .              nbSimplifing++;
        37,153       0    0              0             0       0              0           0    0              sat = false_lit = false;
       656,424       0    0              0             0       0              0           0    0              for (int i = 0; i < c.size(); i++){
       656,614       0    0              0             0       0              0           0    0                  if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .    .                      sat = true;
             .       .    .              .             .       .              .           .    .                      break;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else if (value(c[i]) == l_False){
       730,662      56   11              0             0       0         37,153          54    0                      false_lit = true;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              if (sat){
           903       2    2            258             0       0            258           0    0                  removeClause(cr);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
       222,348       0    0              0             0       0        111,174           0    0                  detachClause(cr, true);
             .       .    .              .             .       .              .           .    .  
       148,232      56   10         74,116           347       0              0           0    0                  if (false_lit){
        13,513       0    0            918             1       0              0           0    0                      for (li = lj = 0; li < c.size(); li++){
         9,382       0    0              0             0       0              0           0    0                          if (value(c[li]) != l_False){
        12,255       0    0              0             0       0          4,085           0    0                              c[lj++] = c[li];
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      c.shrink(li - lj);
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  beforeSize = c.size();
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 1);
             .       .    .              .             .       .              .           .    .                  // simplify a learnt clause c
       148,232       0    0              0             0       0         74,116           0    0                  simplifyLearnt(c);
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 0);
             .       .    .              .             .       .              .           .    .                  afterSize = c.size();
             .       .    .              .             .       .              .           .    .                  
       177,300       0    0        111,174        72,028       0              0           0    0                  if(drup_file && saved_size !=c.size()){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .                      binDRUP('a', c , drup_file);
             .       .    .              .             .       .              .           .    .                      //                    binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                      for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .                      fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
             .       .    .              .             .       .              .           .    .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .    .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .    .                      //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .       .    .              .             .       .              .           .    .  
        74,116       0    0              0             0       0              0           0    0                  if (c.size() == 1){
             .       .    .              .             .       .              .           .    .                      // when unit clause occur, enqueue and propagate
            15       3    3              3             0       0              3           0    0                      uncheckedEnqueue(c[0]);
             9       0    0              3             0       0              0           0    0                      if (propagate() != CRef_Undef){
             .       .    .              .             .       .              .           .    .                          ok = false;
             .       .    .              .             .       .              .           .    .                          return false;
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      // delete the clause memory in logic
             .       .    .              .             .       .              .           .    .                      c.mark(1);
             .       .    .              .             .       .              .           .    .                      ca.free(cr);
             .       .    .              .             .       .              .           .    .  //#ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
             .       .    .              .             .       .              .           .    .  //#else
             .       .    .              .             .       .              .           .    .  //                    fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .    .  //                    for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .  //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  //#endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else{
       111,165       0    0              0             0       0         37,055           0    0                      attachClause(cr);
       222,330      56    9        111,165        72,156       0         37,055       1,327    0                      learnts_core[cj++] = learnts_core[ci];
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                      nblevels = computeLBD(c);
        74,110      43    9              0             0       0              0           0    0                      if (nblevels < c.lbd()){
             .       .    .              .             .       .              .           .    .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .       .    .              .             .       .              .           .    .                          c.set_lbd(nblevels);
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                      c.setSimplified(true);
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
            56       0    0              0             0       0              0           0    0      learnts_core.shrink(ci - cj);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .    .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .    .  
            56      41    8              0             0       0              0           0    0      return true;
             .       .    .              .             .       .              .           .    .  
           448       0    0            392            56       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    22,644,342       2    2              0             0       0     15,096,228           0    0  int Solver::is_duplicate(std::vector<uint32_t>&c){
     5,032,076       0    0              0             0       0      5,032,076       1,264    0     auto time_point_0 = std::chrono::high_resolution_clock::now();
     2,516,038       0    0      2,516,038     1,320,766       0              0           0    0      dupl_db_size++;
     6,096,427     216    5      1,252,611             0       0              0           0    0      int res = 0;    
             .       .    .              .             .       .              .           .    .      
     5,032,076       0    0      5,032,076             0       0              0           0    0      int sz = c.size();
             .       .    .              .             .       .              .           .    .      std::vector<uint32_t> tmp(c);    
             .       .    .              .             .       .              .           .    .      sort(tmp.begin(),tmp.end());
             .       .    .              .             .       .              .           .    .      
     2,516,038 445,803    1              0             0       0      2,516,038           0    0      uint64_t hash = 0;    
             .       .    .              .             .       .              .           .    .      
   113,530,446   5,257    5              0             0       0      2,516,038           0    0      for (int i =0; i<sz; i++) {
   467,010,710       0    0     46,701,071             0       0              0           0    0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
             .       .    .              .             .       .              .           .    .      }    
             .       .    .              .             .       .              .           .    .      
     2,516,038       0    0              0             0       0      2,516,038           0    0      int32_t head = tmp[0];
             .       .    .              .             .       .              .           .    .      auto it0 = ht.find(head);
    12,577,606       0    0      2,516,027             0       0              0           0    0      if (it0 != ht.end()){
             .       .    .              .             .       .              .           .    .          auto it1=ht[head].find(sz);
     5,030,368       0    0              0             0       0              0           0    0          if (it1 != ht[head].end()){
     2,497,697       0    0              0             0       0      2,497,697           0    0              auto it2 = ht[head][sz].find(hash);
     7,493,091       0    0              0             0       0      2,497,697           0    0              if (it2 != ht[head][sz].end()){
       282,390       0    0         94,130        20,895     160         94,130           0    0                  it2->second++;
        94,130       0    0              0             0       0              0           0    0                  res = it2->second;            
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
     2,403,567       0    0              0             0       0      2,403,567           0    0                  ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{            
        34,974       4    1              0             0       0         17,487           0    0              ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }else{        
     2,422,762     678   11              0             0       0      2,422,762         374    0          ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .    .      } 
     2,516,038      48    1              0             0       0      2,516,038           0    0      auto time_point_1 = std::chrono::high_resolution_clock::now();
             .       .    .              .             .       .              .           .    .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
             .       .    .              .             .       .              .           .    .      return res;
    22,644,342       0    0     17,612,266         1,977       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyLearnt_tier2()
           616      56   13              0             0       0            336           0    0  {
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      int learnts_tier2_size_before = learnts_tier2.size();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .    .      bool sat, false_lit;
             .       .    .              .             .       .              .           .    .      unsigned int nblevels;
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      //printf("learnts_x size : %d\n", learnts_x.size());
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      int nbSimplified = 0;
             .       .    .              .             .       .              .           .    .      int nbSimplifing = 0;
             .       .    .              .             .       .              .           .    .  
       799,556      37    2             56            56       0              0           0    0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
     1,199,082       0    0        799,388        52,195       0              0           0    0          CRef cr = learnts_tier2[ci];
             .       .    .              .             .       .              .           .    .          Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .  
       799,388       0    0              0             0       0              0           0    0          if (removed(cr)) continue;
       799,340       0    0        399,670        48,067       0              0           0    0          else if (c.simplified()){
       288,672       0    0              0             0       0        144,336         652    0              learnts_tier2[cj++] = learnts_tier2[ci];
             .       .    .              .             .       .              .           .    .              ////
       943,720       0    0        144,336             0       0              0           0    0              nbSimplified++;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{
             .       .    .              .             .       .              .           .    .              int saved_size=c.size();
             .       .    .              .             .       .              .           .    .              //            if (drup_file){
             .       .    .              .             .       .              .           .    .              //                    add_oc.clear();
             .       .    .              .             .       .              .           .    .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .       .    .              .             .       .              .           .    .              ////
             .       .    .              .             .       .              .           .    .              nbSimplifing++;
       254,432       0    0              0             0       0              0           0    0              sat = false_lit = false;
     7,500,682       0    0              0             0       0              0           0    0              for (int i = 0; i < c.size(); i++){
     7,508,350       0    0              0             0       0              0           0    0                  if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .    .                      sat = true;
             .       .    .              .             .       .              .           .    .                      break;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else if (value(c[i]) == l_False){
     8,007,742      17    8              0             0       0        254,432           0    0                      false_lit = true;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              if (sat){
        23,680       0    0          4,736             0       0          4,736           0    0                  removeClause(cr);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
     1,503,588      43   12              0             0       0        751,794          54    0                  detachClause(cr, true);
             .       .    .              .             .       .              .           .    .  
     1,002,392       0    0        501,196        16,133       0              0           0    0                  if (false_lit){
        94,651       7    6          4,378             9       0              0           0    0                      for (li = lj = 0; li < c.size(); li++){
        74,950       0    0              0             0       0              0           0    0                          if (value(c[li]) != l_False){
       105,264       0    0              0             0       0         35,088           0    0                              c[lj++] = c[li];
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      c.shrink(li - lj);
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  beforeSize = c.size();
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 1);
             .       .    .              .             .       .              .           .    .                  // simplify a learnt clause c
     1,252,990       0    0              0             0       0        751,794           0    0                  simplifyLearnt(c);
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 0);
             .       .    .              .             .       .              .           .    .                  afterSize = c.size();
             .       .    .              .             .       .              .           .    .                  
     1,002,392      56   14        501,196       495,347       0              0           0    0                  if(drup_file && saved_size!=c.size()){
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .                      binDRUP('a', c , drup_file);
             .       .    .              .             .       .              .           .    .                      //                    binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                      for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
             .       .    .              .             .       .              .           .    .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .    .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .    .                      //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .       .    .              .             .       .              .           .    .  
       501,196       0    0              0             0       0              0           0    0                  if (c.size() == 1){
             .       .    .              .             .       .              .           .    .                      // when unit clause occur, enqueue and propagate
            10       0    0              2             0       0              2           0    0                      uncheckedEnqueue(c[0]);
             6       0    0              2             0       0              0           0    0                      if (propagate() != CRef_Undef){
             .       .    .              .             .       .              .           .    .                          ok = false;
             .       .    .              .             .       .              .           .    .                          return false;
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      // delete the clause memory in logic
             .       .    .              .             .       .              .           .    .                      c.mark(1);
             .       .    .              .             .       .              .           .    .                      ca.free(cr);
             .       .    .              .             .       .              .           .    .  //#ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .  //                    binDRUP('d', c, drup_file);
-- line 841 ----------------------------------------
-- line 845 ----------------------------------------
             .       .    .              .             .       .              .           .    .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .  //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  //#endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else{
             .       .    .              .             .       .              .           .    .                      
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                      nblevels = computeLBD(c);
       501,192       0    0              0             0       0              0           0    0                      if (nblevels < c.lbd()){
             .       .    .              .             .       .              .           .    .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .       .    .              .             .       .              .           .    .                          c.set_lbd(nblevels);
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                       //duplicate learnts 
             .       .    .              .             .       .              .           .    .                      int id = 0;                    
             .       .    .              .             .       .              .           .    .                      
             .       .    .              .             .       .              .           .    .                      std::vector<uint32_t> tmp;
     9,925,259       0    0      7,270,155             0       0              0           0    0                      for (int i = 0; i < c.size(); i++)                           
     5,180,898       0    0      2,590,449             0       0      2,590,449           0    0                          tmp.push_back(c[i].x);
     1,002,384       0    0              0             0       0        250,596           0    0                      id = is_duplicate(tmp);
             .       .    .              .             .       .              .           .    .                       
             .       .    .              .             .       .              .           .    .                                          
             .       .    .              .             .       .              .           .    .                      //duplicate learnts 
             .       .    .              .             .       .              .           .    .  
     1,002,384       7    5        250,596       249,060       0              0           0    0                      if (id < min_number_of_learnts_copies+2){
       662,415      12    7              0             0       0        220,805           0    0                          attachClause(cr);
     1,099,139       0    0        662,415       438,990       0        220,805     196,697    0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
       883,220      55   16        220,805             0       0              0           0    0                          if (id == min_number_of_learnts_copies+1){                            
         1,159       0    0          1,159             0       0              0           0    0                              duplicates_added_minimization++;                                  
             .       .    .              .             .       .              .           .    .                          }
       439,292       0    0        219,646       218,338       0              0           0    0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
             .       .    .              .             .       .              .           .    .                          //if (id == min_number_of_learnts_copies+1){
             .       .    .              .             .       .              .           .    .                              cj--;
             .       .    .              .             .       .              .           .    .                              learnts_core.push(cr);
             .       .    .              .             .       .              .           .    .                              c.mark(CORE);
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                          c.setSimplified(true);
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
            56      33   12              0             0       0              0           0    0      learnts_tier2.shrink(ci - cj);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .    .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .    .  
            56       0    0              0             0       0              0           0    0      return true;
             .       .    .              .             .       .              .           .    .  
           448       0    0            392            56       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyAll()
           280      11    9              0             0       0            168           0    0  {
             .       .    .              .             .       .              .           .    .      ////
           112       0    0              0             0       0             56           0    0      simplified_length_record = original_length_record = 0;
             .       .    .              .             .       .              .           .    .  
           224       0    0             56            24       0              0           0    0      if (!ok || propagate() != CRef_Undef)
             .       .    .              .             .       .              .           .    .          return ok = false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //// cleanLearnts(also can delete these code), here just for analyzing
             .       .    .              .             .       .              .           .    .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .       .    .              .             .       .              .           .    .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
             .       .    .              .             .       .              .           .    .      //local_learnts_dirty = tier2_learnts_dirty = false;
             .       .    .              .             .       .              .           .    .  
           224       0    0              0             0       0             56           0    0      if (!simplifyLearnt_core()) return ok = false;
           224      56   15              0             0       0             56           0    0      if (!simplifyLearnt_tier2()) return ok = false;
             .       .    .              .             .       .              .           .    .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      checkGarbage();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
             .       .    .              .             .       .              .           .    .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      return true;
           280       0    0            224             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Minor methods:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
             .       .    .              .             .       .              .           .    .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
             .       .    .              .             .       .              .           .    .  //
             .       .    .              .             .       .              .           .    .  Var Solver::newVar(bool sign, bool dvar)
        11,400       1    1              0             0       0          9,120           0    0  {
             .       .    .              .             .       .              .           .    .      int v = nVars();
             .       .    .              .             .       .              .           .    .      watches_bin.init(mkLit(v, false));
             .       .    .              .             .       .              .           .    .      watches_bin.init(mkLit(v, true ));
             .       .    .              .             .       .              .           .    .      watches  .init(mkLit(v, false));
             .       .    .              .             .       .              .           .    .      watches  .init(mkLit(v, true ));
            15       1    1              0             0       0              0           0    0      assigns  .push(l_Undef);
            15       1    1              0             0       0              0           0    0      vardata  .push(mkVarData(CRef_Undef, 0));
            15       0    0              0             0       0              0           0    0      activity_CHB  .push(0);
         3,450       0    0          1,140            16       0             15           0    0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
             .       .    .              .             .       .              .           .    .  
            15       1    1              0             0       0              0           0    0      picked.push(0);
            15       0    0              0             0       0              0           0    0      conflicted.push(0);
            15       0    0              0             0       0              0           0    0      almost_conflicted.push(0);
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
            15       0    0              0             0       0              0           0    0      canceled.push(0);
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .  
            15       0    0              0             0       0              0           0    0      seen     .push(0);
            15       0    0              0             0       0              0           0    0      seen2    .push(0);
            15       0    0              0             0       0              0           0    0      polarity .push(sign);
            15       0    0              0             0       0              0           0    0      decision .push();
         5,700       1    1              0             0       0          2,280          35    0      trail    .capacity(v+1);
             .       .    .              .             .       .              .           .    .      setDecisionVar(v, dvar);
             .       .    .              .             .       .              .           .    .  
            15       0    0              0             0       0              0           0    0      activity_distance.push(0);
            15       1    1              0             0       0              0           0    0      var_iLevel.push(0);
            15       0    0              0             0       0              0           0    0      var_iLevel_tmp.push(0);
            15       0    0              0             0       0              0           0    0      pathCs.push(0);
             .       .    .              .             .       .              .           .    .      return v;
        10,260       0    0          7,980            10       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::addClause_(vec<Lit>& ps)
        53,907       2    1              0             0       0         46,206           0    0  {
             .       .    .              .             .       .              .           .    .      assert(decisionLevel() == 0);
        23,103       1    1          7,701             0       0              0           0    0      if (!ok) return false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Check if clause is satisfied and remove false/duplicate literals:
             .       .    .              .             .       .              .           .    .      sort(ps);
             .       .    .              .             .       .              .           .    .      Lit p; int i, j;
             .       .    .              .             .       .              .           .    .  
        15,402       0    0          7,701            17       0              0           0    0      if (drup_file){
             .       .    .              .             .       .              .           .    .          add_oc.clear();
         7,701       2    1          7,701             0       0              0           0    0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
             .       .    .              .             .       .              .           .    .  
        85,437       0    0              0             0       0              0           0    0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
       147,529       0    0         23,345             0       0              0           0    0          if (value(ps[i]) == l_True || ps[i] == ~p)
             .       .    .              .             .       .              .           .    .              return true;
        93,380       4    2              0             0       0              0           0    0          else if (value(ps[i]) != l_False && ps[i] != p)
        70,035       0    0         23,345             0       0         23,345           0    0              ps[j++] = p = ps[i];
        61,608       0    0          7,701             0       0              0           0    0      ps.shrink(i - j);
             .       .    .              .             .       .              .           .    .  
        15,402       2    1              0             0       0              0           0    0      if (drup_file && i != j){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .          binDRUP('a', ps, drup_file);
         7,701       0    0          7,701             0       0              0           0    0          binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .          for (int i = 0; i < ps.size(); i++)
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
             .       .    .              .             .       .              .           .    .          fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .    .          for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .    .          fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      
        15,402       0    0              0             0       0              0           0    0      if (ps.size() == 0)
             .       .    .              .             .       .              .           .    .          return ok = false;
        15,402       2    1              0             0       0              0           0    0      else if (ps.size() == 1){
           384       0    0            128             0       0             64           0    0          uncheckedEnqueue(ps[0]);
           256       0    0              0             0       0             64           0    0          return ok = (propagate() == CRef_Undef);
             .       .    .              .             .       .              .           .    .      }else{
         7,637       0    0              0             0       0          7,637           0    0          CRef cr = ca.alloc(ps, false);
             .       .    .              .             .       .              .           .    .          //auto ca_size=ca.size();
             .       .    .              .             .       .              .           .    .          //printf("ca size:%d\n",ca_size);
        22,911       0    0              0             0       0          7,637           0    0          clauses.push(cr);
        22,911       2    1          7,637             0       0          7,637           0    0          attachClause(cr);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
         7,637       0    0              0             0       0              0           0    0      return true;
        84,711       0    0         53,907             2       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    36,679,400       7    5              0             0       0     22,007,640           0    0  void Solver::attachClause(CRef cr) {
             .       .    .              .             .       .              .           .    .      const Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .      assert(c.size() > 1);
    14,668,515       0    0      3,667,940           151       0              0           0    0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .    .      ws[~c[0]].push(Watcher(cr, c[1]));
             .       .    .              .             .       .              .           .    .      ws[~c[1]].push(Watcher(cr, c[0]));
    10,996,055       0    0      7,328,115     1,101,335       0              0           0    0      if (c.learnt()) learnts_literals += c.size();
    29,351,285       1    0     25,683,345             9       0              0           0    0      else            clauses_literals += c.size(); }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    21,823,644     293    5              0             0       0     14,549,096           1    0  void Solver::detachClause(CRef cr, bool strict) {
             .       .    .              .             .       .              .           .    .      const Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .      assert(c.size() > 1);
    14,549,096       0    0              0             0       0              0           0    0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .    .      
    14,549,096       0    0              0             0       0              0           0    0      if (strict){
             .       .    .              .             .       .              .           .    .          remove(ws[~c[0]], Watcher(cr, c[1]));
             .       .    .              .             .       .              .           .    .          remove(ws[~c[1]], Watcher(cr, c[0]));
             .       .    .              .             .       .              .           .    .      }else{
             .       .    .              .             .       .              .           .    .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
             .       .    .              .             .       .              .           .    .          ws.smudge(~c[0]);
             .       .    .              .             .       .              .           .    .          ws.smudge(~c[1]);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
    10,906,519       9    0      7,269,245        52,021       0              0           0    0      if (c.learnt()) learnts_literals -= c.size();
    21,828,947       0    0     18,191,673        16,668       0              0           0    0      else            clauses_literals -= c.size(); }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    26,795,920     501   10              0             0       0     13,397,960         266    0  void Solver::removeClause(CRef cr) {
             .       .    .              .             .       .              .           .    .      Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .  
    10,048,470       0    0      3,349,490           562       0              0           0    0      if (drup_file){
             .       .    .              .             .       .              .           .    .          if (c.mark() != 1){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .              binDRUP('d', c, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .    .              for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .          }else
             .       .    .              .             .       .              .           .    .              printf("c Bug. I don't expect this to happen.\n");
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
    13,397,960     236    5              0             0       0      3,349,490           0    0      detachClause(cr);
             .       .    .              .             .       .              .           .    .      // Don't leave pointers to free'd memory!
             .       .    .              .             .       .              .           .    .      if (locked(c)){
           498       0    0            112             0       0              0           0    0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
           274       0    0              0             0       0            137           0    0          vardata[var(implied)].reason = CRef_Undef; }
             .       .    .              .             .       .              .           .    .      c.mark(1);
             .       .    .              .             .       .              .           .    .      ca.free(cr);
    20,096,940       0    0     16,747,450             3       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::satisfied(const Clause& c) const {
    17,074,198      42   14              0             0       0              0           0    0      for (int i = 0; i < c.size(); i++)
    19,136,936       0    0      7,825,512         1,694       0              0           0    0          if (value(c[i]) == l_True)
           128       1    1              0             0       0              0           0    0              return true;
         8,378       0    0          4,253             0       0              0           0    0      return false; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
             .       .    .              .             .       .              .           .    .  //
    30,669,246   3,303    5              0             0       0     20,446,164           0    0  void Solver::cancelUntil(int bLevel) {
             .       .    .              .             .       .              .           .    .  	
    13,641,497       5    2          5,360             0       0      3,407,694           0    0      if (decisionLevel() > bLevel){
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .    .  		std::cout << "bt " << bLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif				
     6,815,388       0    0              0             0       0      3,407,694         475    0  		add_tmp.clear();
 1,691,510,621   5,007    4    345,799,051     3,141,831       0              0           0    0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
             .       .    .              .             .       .              .           .    .          {
             .       .    .              .             .       .              .           .    .              Var      x  = var(trail[c]);
             .       .    .              .             .       .              .           .    .  
   657,521,162       0    0    328,760,581    50,479,428       0              0           0    0  			if (level(x) <= bLevel)
             .       .    .              .             .       .              .           .    .  			{
             .       .    .              .             .       .              .           .    .  				add_tmp.push(trail[c]);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  			else
             .       .    .              .             .       .              .           .    .  			{
   657,521,162       0    0    328,760,581           175       0              0           0    0  				 if (!VSIDS){
   546,639,174       0    0    364,426,116         1,433       0              0           0    0  					uint32_t age = conflicts - picked[x];
   364,426,116       0    0    182,213,058    42,563,325       0              0           0    0  					if (age > 0){
 1,821,297,310     104    7    728,518,924    55,513,872       0              0           0    0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
   182,129,731       0    0    182,129,731    42,810,171       3              0           0    0  						double old_activity = activity_CHB[x];
 1,274,908,117      31    7    364,259,462       942,581       0    182,129,731           0    0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
             .       .    .              .             .       .              .           .    .  						if (order_heap_CHB.inHeap(x)){
 1,054,474,380      53    5              0             0       0    527,237,190           0    0  							if (activity_CHB[x] > old_activity)
             .       .    .              .             .       .              .           .    .  								order_heap_CHB.decrease(x);
             .       .    .              .             .       .              .           .    .  							else
             .       .    .              .             .       .              .           .    .  								order_heap_CHB.increase(x);
             .       .    .              .             .       .              .           .    .  						}
             .       .    .              .             .       .              .           .    .  					}
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
   364,426,116       0    0    182,213,058       272,505       0    182,213,058  43,875,834    1  					canceled[x] = conflicts;
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .  				}
             .       .    .              .             .       .              .           .    .  				
   657,521,162     109   18    328,760,581           113       0    328,760,581   6,679,066    0  				assigns [x] = l_Undef;
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .    .  				std::cout << "undo " << x << "\n";
             .       .    .              .             .       .              .           .    .  #endif				
   657,521,162       0    0    328,760,581             0       0              0           0    0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
   328,760,581       0    0    328,760,581             0       0              0           0    0  					polarity[x] = sign(trail[c]);
             .       .    .              .             .       .              .           .    .  				insertVarOrder(x);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .          }
     3,407,694       0    0              0             0       0      3,407,694           0    0          qhead = trail_lim[bLevel];
     6,815,388       0    0              0             0       0              0           0    0          trail.shrink(trail.size() - trail_lim[bLevel]);
    10,223,082       0    0      3,407,694             0       0              0           0    0          trail_lim.shrink(trail_lim.size() - bLevel);
    10,223,082       1    1      3,407,694             0       0              0           0    0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
             .       .    .              .             .       .              .           .    .  		{
             .       .    .              .             .       .              .           .    .  			trail.push_(add_tmp[nLitId]);
             .       .    .              .             .       .              .           .    .  		}
             .       .    .              .             .       .              .           .    .  		
             .       .    .              .             .       .              .           .    .  		add_tmp.clear();
    27,261,552       0    0     23,853,858        76,665       0              0           0    0      } }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Major methods:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  Lit Solver::pickBranchLit()
    32,125,264     119    6              0             0       0     24,093,948           0    0  {
             .       .    .              .             .       .              .           .    .      Var next = var_Undef;
             .       .    .              .             .       .              .           .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
    27,183,592     183    9      7,866,666     2,512,737       1              0           0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Random decision:
             .       .    .              .             .       .              .           .    .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
             .       .    .              .             .       .              .           .    .          next = order_heap[irand(random_seed,order_heap.size())];
             .       .    .              .             .       .              .           .    .          if (value(next) == l_Undef && decision[next])
             .       .    .              .             .       .              .           .    .              rnd_decisions++; }*/
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Activity based decision:
    80,723,600     229    1     36,346,142     3,408,963      18              0           0    0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    24,299,168       0    0              0             0       0              0           0    0          if (order_heap.empty())
             .       .    .              .             .       .              .           .    .              return lit_Undef;
             .       .    .              .             .       .              .           .    .          else{
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
    24,299,168       0    0     12,149,584             7       0              0           0    0              if (!VSIDS){
             .       .    .              .             .       .              .           .    .                  Var v = order_heap_CHB[0];
    12,994,748       0    0     12,994,748       371,222       0              0           0    0                  uint32_t age = conflicts - canceled[v];
    21,763,946       0    0      9,393,210     4,864,594     148      1,488,763           3    0                  while (age > 0){
             .       .    .              .             .       .              .           .    .                      double decay = pow(0.95, age);
     5,791,672       0    0      2,895,836        97,126       2      2,895,836           0    0                      activity_CHB[v] *= decay;
             .       .    .              .             .       .              .           .    .                      if (order_heap_CHB.inHeap(v))
             .       .    .              .             .       .              .           .    .                          order_heap_CHB.increase(v);
     8,687,508       0    0      5,791,672             0       0      2,895,836           0    0                      canceled[v] = conflicts;
             .       .    .              .             .       .              .           .    .                      v = order_heap_CHB[0];
             .       .    .              .             .       .              .           .    .                      age = conflicts - canceled[v];
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .              next = order_heap.removeMin();
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  
    16,062,632       0    0      8,031,316     3,187,669      10              0           0    0      return mkLit(next, polarity[next]);
    36,140,922       0    0     28,109,606             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .  	ConflictData data;
             .       .    .              .             .       .              .           .    .  	Clause& conflCls = ca[cind];
             .       .    .              .             .       .              .           .    .  	data.nHighestLevel = level(var(conflCls[0]));
    13,609,344       0    0      6,804,672        37,606       0              0           0    0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
             .       .    .              .             .       .              .           .    .  	{
             .       .    .              .             .       .              .           .    .  		return data;
             .       .    .              .             .       .              .           .    .  	}
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  	int highestId = 0;
             .       .    .              .             .       .              .           .    .      data.bOnlyOneLitFromHighest = true;
             .       .    .              .             .       .              .           .    .  	// find the largest decision level in the clause
             .       .    .              .             .       .              .           .    .  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
-- line 1190 ----------------------------------------
-- line 1231 ----------------------------------------
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |    Post-conditions:
             .       .    .              .             .       .              .           .    .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
             .       .    .              .             .       .              .           .    .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
             .       .    .              .             .       .              .           .    .  |        rest of literals. There may be others from the same level though.
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
    44,230,355      79   18              0             0       0     30,621,015           0    0  {
     3,402,335       0    0              0             0       0      3,402,335      46,060    0      int pathC = 0;
     3,402,335       0    0              0             0       0              0           0    0      Lit p     = lit_Undef;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Generate conflict clause:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      out_learnt.push();      // (leave room for the asserting literal)
     6,804,670       0    0      3,402,335             0       0              0           0    0      int index   = trail.size() - 1;
     3,402,335       0    0      3,402,335             2       0              0           0    0      int nDecisionLevel = level(var(ca[confl][0]));
             .       .    .              .             .       .              .           .    .      assert(nDecisionLevel == level(var(ca[confl][0])));
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      do{
             .       .    .              .             .       .              .           .    .          assert(confl != CRef_Undef); // (otherwise should be UIP)
             .       .    .              .             .       .              .           .    .          Clause& c = ca[confl];
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
   366,504,354       0    0              0             0       0              0           0    0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
             .       .    .              .             .       .              .           .    .              assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .    .              Lit tmp = c[0];
     1,716,489       0    0        572,163        32,430       7      1,144,326           0    0              c[0] = c[1], c[1] = tmp; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // Update LBD if improved.
   301,507,150       0    0      7,634,828             0       0              0           0    0          if (c.learnt() && c.mark() != CORE){
             .       .    .              .             .       .              .           .    .              int lbd = computeLBD(c);
    22,208,438       0    0              0             0       0              0           0    0              if (lbd < c.lbd()){
     1,828,518       0    0              0             0       0              0           0    0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
             .       .    .              .             .       .              .           .    .                  c.set_lbd(lbd);
     1,828,518       0    0        914,259       617,271       0              0           0    0                  if (lbd <= core_lbd_cut){
            20       4    0              0             0       0             10           0    0                      learnts_core.push(confl);
             .       .    .              .             .       .              .           .    .                      c.mark(CORE);
     2,652,003       0    0        355,923             0       0              0           0    0                  }else if (lbd <= 6 && c.mark() == LOCAL){
             .       .    .              .             .       .              .           .    .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
             .       .    .              .             .       .              .           .    .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
    24,397,321       6    6              0             0       0      7,095,158   3,242,503    0                      learnts_tier2.push(confl);
             .       .    .              .             .       .              .           .    .                      c.mark(TIER2); }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
    21,818,910       0    0     10,909,455             0       0              0           0    0              if (c.mark() == TIER2)
    21,478,704      57   12      5,369,676         3,260       0      5,369,676     634,734   25                  c.touched() = conflicts;
    11,370,046       0    0      5,685,023             0       0              0           0    0              else if (c.mark() == LOCAL)
             .       .    .              .             .       .              .           .    .                  claBumpActivity(c);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  
 1,871,880,234      15    7    535,136,388            12       0     91,123,517          73    0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
   444,012,871       0    0    444,012,871    23,589,415       7              0           0    0              Lit q = c[j];
             .       .    .              .             .       .              .           .    .  
 1,568,374,559       1    1    670,795,810    85,737,188      14              0           0    0              if (!seen[var(q)] && level(var(q)) > 0){
   452,435,406       0    0    226,217,703           951       0              0           0    0                  if (VSIDS){
             .       .    .              .             .       .              .           .    .                      varBumpActivity(var(q), .5);
            18       1    1              0             0       0              9           0    0                      add_tmp.push(q);
             .       .    .              .             .       .              .           .    .                  }else
   128,099,049       0    0    128,099,049    36,616,965       0              0           0    0                      conflicted[var(q)]++;
   226,217,703       0    0              0             0       0    226,217,703           0    0                  seen[var(q)] = 1;
   452,435,406       0    0    226,217,703             0       0              0           0    0                  if (level(var(q)) >= nDecisionLevel){
   182,247,034       0    0    182,247,034            36       0              0           0    0                      pathC++;
             .       .    .              .             .       .              .           .    .                  }else
             .       .    .              .             .       .              .           .    .                      out_learnt.push(q);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          
             .       .    .              .             .       .              .           .    .          // Select next clause to look at:
             .       .    .              .             .       .              .           .    .  		do {
 1,758,200,579       0    0    721,504,935    33,501,977       9              0           0    0  			while (!seen[var(trail[index--])]);
             .       .    .              .             .       .              .           .    .  			p  = trail[index+1];
   182,247,034       1    1     91,123,517        11,096       0              0           0    0  		} while (level(var(p)) < nDecisionLevel);
             .       .    .              .             .       .              .           .    .  		
   182,247,034       0    0     91,123,517             0       0     91,123,517           0    0          confl = reason(var(p));
    91,123,517       0    0              0             0       0     91,123,517           0    0          seen[var(p)] = 0;
   182,247,034       0    0    182,247,034             7       0              0           0    0          pathC--;
             .       .    .              .             .       .              .           .    .  
   533,131,762       0    0    175,442,364            76       0              0           0    0      }while (pathC > 0);
     3,402,335       0    0      3,402,335            12       0              0           0    0      out_learnt[0] = ~p;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Simplify conflict clause:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      int i, j;
     6,804,670       0    0              0             0       0      3,402,335           0    0      out_learnt.copyTo(analyze_toclear);
    10,207,005       0    0      3,402,335             5       0              0           0    0      if (ccmin_mode == 2){
     3,402,315     469    5              0             0       0              0           0    0          uint32_t abstract_level = 0;
   276,993,042     572    4              0             0       0              0           0    0          for (i = 1; i < out_learnt.size(); i++)
   141,898,816       0    0      3,402,315             0       0              0           0    0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
             .       .    .              .             .       .              .           .    .  
   979,682,452      75    4    401,880,243             2       0      3,402,315           0    0          for (i = j = 1; i < out_learnt.size(); i++)
   874,360,865      58    8    177,868,220        11,923       0    103,724,885           0    0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
   222,430,005      40    2     74,143,335             1       0     74,143,335          28    0                  out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .    .          
             .       .    .              .             .       .              .           .    .      }else if (ccmin_mode == 1){
             .       .    .              .             .       .              .           .    .          for (i = j = 1; i < out_learnt.size(); i++){
             .       .    .              .             .       .              .           .    .              Var x = var(out_learnt[i]);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              if (reason(x) == CRef_Undef)
             .       .    .              .             .       .              .           .    .                  out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .    .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
             .       .    .              .             .       .              .           .    .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
             .       .    .              .             .       .              .           .    .                          out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .    .                          break; }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }else
             .       .    .              .             .       .              .           .    .          i = j = out_learnt.size();
             .       .    .              .             .       .              .           .    .  
     6,804,670       0    0      3,402,335     3,312,587       3              0           0    0      max_literals += out_learnt.size();
    70,073,439       1    1     16,667,776             0       0              0           0    0      out_learnt.shrink(i - j);
     3,402,335     108    2      3,402,335             0       0              0           0    0      tot_literals += out_learnt.size();
             .       .    .              .             .       .              .           .    .  
     6,804,670       0    0      3,402,335        10,127       0      3,402,335           0    0      out_lbd = computeLBD(out_learnt);
    38,087,436   5,520   23     17,230,264             0       0              0           0    0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
     1,530,683   3,005    4        218,669             0       0        437,338           0    0          if (binResMinimize(out_learnt))
         8,982       0    0          2,994             0       0          2,994           0    0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Find correct backtrack level:
             .       .    .              .             .       .              .           .    .      //
     6,798,766       0    0              0             0       0              0           0    0      if (out_learnt.size() == 1)
            60       0    0             20             0       0             20           0    0          out_btlevel = 0;
             .       .    .              .             .       .              .           .    .      else{
     6,804,168       0    0              0             0       0              0           0    0          int max_i = 1;
             .       .    .              .             .       .              .           .    .          // Find the first literal assigned at the next-highest level:
   289,849,308       0    0              0             0       0              0           0    0          for (int i = 2; i < out_learnt.size(); i++)
   239,054,963       0    0     70,737,737             0       0              0           0    0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
             .       .    .              .             .       .              .           .    .                  max_i = i;
             .       .    .              .             .       .              .           .    .          // Swap-in this literal at index 1:
             .       .    .              .             .       .              .           .    .          Lit p             = out_learnt[max_i];
     6,804,630       0    0      3,402,315             0       0      3,402,315           0    0          out_learnt[max_i] = out_learnt[1];
     3,402,315       0    0              0             0       0      3,402,315           0    0          out_learnt[1]     = p;
     6,804,630       0    0      3,402,315             0       0      3,402,315           0    0          out_btlevel       = level(var(p));
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
     6,804,670     321   15      3,402,335         7,345       0              0           0    0      if (VSIDS){
   357,563,147   5,166   11    102,765,195       125,150       0              0           0    0          for (int i = 0; i < add_tmp.size(); i++){
             .       .    .              .             .       .              .           .    .              Var v = var(add_tmp[i]);
   294,355,962       0    0     98,118,654       538,408       0              0           0    0              if (level(v) >= out_btlevel - 1)
             .       .    .              .             .       .              .           .    .                  varBumpActivity(v, 1);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          add_tmp.clear();
             .       .    .              .             .       .              .           .    .      }else{
     3,706,976       0    0      1,853,488             0       0      1,853,488           9    0          seen[var(p)] = true;
   146,561,228       0    0      1,853,488             0       0              0           0    0          for(int i = out_learnt.size() - 1; i >= 0; i--){
             .       .    .              .             .       .              .           .    .              Var v = var(out_learnt[i]);
             .       .    .              .             .       .              .           .    .              CRef rea = reason(v);
    84,115,240       0    0              0             0       0              0           0    0              if (rea != CRef_Undef){
             .       .    .              .             .       .              .           .    .                  const Clause& reaC = ca[rea];
   392,738,008       0    0              0             0       0              0           0    0                  for (int i = 0; i < reaC.size(); i++){
             .       .    .              .             .       .              .           .    .                      Lit l = reaC[i];
   304,934,444       0    0    152,467,222       306,401       0              0           0    0                      if (!seen[var(l)]){
    35,254,708       0    0              0             0       0     35,254,708           0    0                          seen[var(l)] = true;
    35,254,708       0    0     35,254,708    17,324,669       0              0           0    0                          almost_conflicted[var(l)]++;
             .       .    .              .             .       .              .           .    .                          analyze_toclear.push(l); } } } } }
             .       .    .              .             .       .              .           .    .  
   834,720,515   2,587    2    412,256,755             0       0    204,427,210      67,927    0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
    27,218,680       0    0     23,816,345       174,492       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Try further learnt clause minimization by means of binary clause resolution.
             .       .    .              .             .       .              .           .    .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
       226,370       0    0              0             0       0        181,096           0    0  {
             .       .    .              .             .       .              .           .    .      // Preparation: remember which false variables we have in 'out_learnt'.
       656,007      20   10        218,669             0       0        218,669           0    0      counter++;
     6,313,948       0    0        437,338             0       0              0           0    0      for (int i = 1; i < out_learnt.size(); i++)
     2,501,441       0    0        218,649             0       0      2,282,792   1,677,308  211          seen2[var(out_learnt[i])] = counter;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Get the list of binary clauses containing 'out_learnt[0]'.
             .       .    .              .             .       .              .           .    .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
             .       .    .              .             .       .              .           .    .  
        45,274       0    0              0             0       0              0           0    0      int to_remove = 0;
     1,503,066       2    2        218,669       153,756       0          2,994           0    0      for (int i = 0; i < ws.size(); i++){
       378,560       0    0        378,560        59,926       0              0           0    0          Lit the_other = ws[i].blocker;
             .       .    .              .             .       .              .           .    .          // Does 'the_other' appear negatively in 'out_learnt'?
     1,520,806      12    7        718,412       139,215      74              0           0    0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
         3,283       0    0              0             0       0              0           0    0              to_remove++;
         9,849       0    0              0             0       0          3,283           0    0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Shrink.
       135,822      23    6              0             0       0              0           0    0      if (to_remove > 0){
         2,994       0    0              0             0       0              0           0    0          int last = out_learnt.size() - 1;
       255,442      89   12          2,994             0       0              0           0    0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
        70,364       0    0         35,182             0       0              0           0    0              if (seen2[var(out_learnt[i])] != counter)
        14,660       0    0          5,864             0       0          2,932           0    0                  out_learnt[i--] = out_learnt[last--];
             .       .    .              .             .       .              .           .    .          out_learnt.shrink(to_remove);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      return to_remove != 0;
       399,765       3    3        399,765             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
             .       .    .              .             .       .              .           .    .  // visiting literals at levels that cannot be removed later.
             .       .    .              .             .       .              .           .    .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
 1,037,248,850   6,506    5              0             0       0    622,349,310   1,913,926    0  {
   207,449,770       0    0              0             0       0    103,724,885           0    0      analyze_stack.clear(); analyze_stack.push(p);
   311,174,655       0    0    207,449,770             0       0    103,724,885           0    0      int top = analyze_toclear.size();
   479,075,158       0    0              0             0       0              0           0    0      while (analyze_stack.size() > 0){
             .       .    .              .             .       .              .           .    .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
             .       .    .              .             .       .              .           .    .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // Special handling for binary clauses like in 'analyze()'.
   441,573,070      67   16              0             0       0              0           0    0          if (c.size() == 2 && value(c[0]) == l_False){
             .       .    .              .             .       .              .           .    .              assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .    .              Lit tmp = c[0];
       623,598       0    0        207,866        11,949       1        415,732           0    0              c[0] = c[1], c[1] = tmp; }
             .       .    .              .             .       .              .           .    .  
 1,131,063,874       0    0              0             0       0              0           0    0          for (int i = 1; i < c.size(); i++){
   471,919,050      86   15    471,919,050    40,206,494       9              0           0    0              Lit p  = c[i];
 1,722,529,892       0    0    943,838,100     3,220,430       9              0           0    0              if (!seen[var(p)] && level(var(p)) > 0){
   532,434,886       0    0    152,852,785             0       0              0           0    0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
   110,078,751       0    0              0             0       0    110,078,751           0    0                      seen[var(p)] = 1;
             .       .    .              .             .       .              .           .    .                      analyze_stack.push(p);
             4       0    0              0             0       0              0           0    0                      analyze_toclear.push(p);
             .       .    .              .             .       .              .           .    .                  }else{
   462,785,421   1,305    8    164,950,838             0       0              0           0    0                      for (int j = top; j < analyze_toclear.size(); j++)
   132,108,804       0    0     52,706,034             0       0     79,402,770           0    0                          seen[var(analyze_toclear[j])] = 0;
    85,548,068      75    3     42,774,034             0       0              0           0    0                      analyze_toclear.shrink(analyze_toclear.size() - top);
    42,774,034       0    0              0             0       0              0           0    0                      return false;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
   121,901,702       0    0              0             0       0              0           0    0      return true;
   829,799,080      27    0    726,074,195             9       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  analyzeFinal : (p : Lit)  ->  [void]
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      seen[var(p)] = 0;
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 3,287,609,130       4    2              0             0       0  1,643,804,565           0    0  {
             .       .    .              .             .       .              .           .    .      assert(value(p) == l_Undef);
             .       .    .              .             .       .              .           .    .      Var x = var(p);
   657,521,826       0    0    328,760,913     6,207,288       0              0           0    0      if (!VSIDS){
   546,639,987       0    0    364,426,658     6,496,092       0    182,213,329  98,012,418  156          picked[x] = conflicts;
   364,426,658       0    0    182,213,329             0       0    182,213,329 100,435,620  169          conflicted[x] = 0;
   364,426,658       1    1    182,213,329             0       0    182,213,329 100,069,150  205          almost_conflicted[x] = 0;
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
   182,213,329       0    0    182,213,329     2,979,651       0              0           0    0          uint32_t age = conflicts - canceled[var(p)];
   364,426,658       0    0    182,213,329    99,395,860       0              0           0    0          if (age > 0){
             .       .    .              .             .       .              .           .    .              double decay = pow(0.95, age);
   150,222,676       0    0     75,111,338    50,605,220      11     75,111,338           0    0              activity_CHB[var(p)] *= decay;
             .       .    .              .             .       .              .           .    .              if (order_heap_CHB.inHeap(var(p)))
    75,111,338       0    0              0             0       0              0           0    0                  order_heap_CHB.increase(var(p));
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
   328,760,913       1    0    328,760,913         2,208       0              0           0    0      assigns[x] = lbool(!sign(p));
   657,521,826       0    0              0             0       0    657,521,826 200,124,186  104      vardata[x] = mkVarData(from, level);
   328,760,913       2    1    328,760,913             0       0              0           0    0      trail.push_(p);
 2,301,326,391       0    0  1,972,565,478             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  unsigned number_watch_changed_total=0;
             .       .    .              .             .       .              .           .    .  unsigned number_clause_read_total=0;
             .       .    .              .             .       .              .           .    .  unsigned times_only_access_watch=0;
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  propagate : [void]  ->  [Clause*]
             .       .    .              .             .       .              .           .    .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
             .       .    .              .             .       .              .           .    .  |    otherwise CRef_Undef.
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |    Post-conditions:
             .       .    .              .             .       .              .           .    .  |      * the propagation queue is empty, even if there was a conflict.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  CRef Solver::propagate_()
    59,430,864       7    5              0             0       0     44,573,148           0    0  {
             .       .    .              .             .       .              .           .    .      //auto start_time=std::chrono::steady_clock::now();
     7,428,858       0    0              0             0       0      7,428,858           0    0      CRef    confl     = CRef_Undef;
     7,428,858       0    0              0             0       0      7,428,858          10    0      int     num_props = 0;
    14,857,716       0    0              0             0       0      7,428,858     563,153    0      watches.cleanAll();
    14,857,716       4    2              0             0       0      7,428,858           0    0      watches_bin.cleanAll();
             .       .    .              .             .       .              .           .    .      
 1,072,360,370       1    1    787,758,796     1,545,999       2              0           0    0      while (qhead < trail.size()){
 1,374,146,345       0    0    549,658,538     5,921,418       0    274,829,269           0    0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .       .    .              .             .       .              .           .    .          int currLevel = level(var(p));
             .       .    .              .             .       .              .           .    .          vec<Watcher>&  ws  = watches[p];
             .       .    .              .             .       .              .           .    .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          Watcher        *i, *j, *end;
   498,152,502       0    0    498,152,502     2,088,385       0              0           0    0          num_props++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
             .       .    .              .             .       .              .           .    .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
 1,354,514,892       2    1    274,829,269   261,108,497     913              0           0    0          for (int k = 0; k < ws_bin.size(); k++){
   211,913,525       0    0    211,913,525    63,362,636     229              0           0    0              Lit the_other = ws_bin[k].blocker;
21,125,355,790       0    0 20,543,573,466             0       0              0           0    0              if (value(the_other) == l_False){
       161,382       0    0         80,691             0       0         80,691           0    0                  confl = ws_bin[k].cref;
             .       .    .              .             .       .              .           .    .                  //auto end_time=std::chrono::steady_clock::now();
             .       .    .              .             .       .              .           .    .                  //auto duration=end_time-start_time;
             .       .    .              .             .       .              .           .    .  #ifdef LOOSE_PROP_STAT
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  return confl;
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                  goto ExitProp;
             .       .    .              .             .       .              .           .    .  #endif
   318,274,942       3    1              0             0       0              0           0    0              }else if(value(the_other) == l_Undef)
             .       .    .              .             .       .              .           .    .              {
   211,206,050       2    0    126,723,630             0       0     42,241,210     515,588    0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
             .       .    .              .             .       .              .           .    .  #ifdef  PRINT_OUT                
             .       .    .              .             .       .              .           .    .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif                
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .          }
   549,497,156       0    0    549,497,156   189,910,417     148              0           0    0          total_Watchers+=ws.size();
   274,748,578       0    0    274,748,578             0       0              0           0    0          total_indexs++;//number of rounds
             .       .    .              .             .       .              .           .    .          //int count=0;
   273,225,760       0    0              0             0       0              0           0    0          bool no_clause_access=true;
   273,225,760       0    0              0             0       0    273,225,760           0    0          bool no_implication_added=true;
   273,225,760       0    0              0             0       0    273,225,760           0    0          bool no_change_other_watch=true;
52,990,276,276       5    4 25,946,402,391             0       0    274,748,578           0    0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             .       .    .              .             .       .              .           .    .              // Try to avoid inspecting the clause:
             .       .    .              .             .       .              .           .    .              //count++;
25,671,653,813       1    1 25,671,653,813 3,411,782,322  43,538              0           0    0              Lit blocker = i->blocker;
51,343,307,626       0    0 25,671,653,813     1,142,466       2              0           0    0              total_access_watches++;
51,343,307,626       0    0 25,671,653,813    36,320,218      11              0           0    0              if (value(blocker) == l_True){
             .       .    .              .             .       .              .           .    .                  
78,860,700,152       0    0 19,715,175,038             0       0 19,715,175,038   2,681,776    0                  *j++ = *i++; continue; }//no clause accessed
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Make sure the false literal is data[1]:
 5,975,560,140       0    0      3,151,944             0       0              0           0    0              no_clause_access=false;
17,869,436,325       2    2 11,912,957,550     2,648,779       3  5,956,478,775           0    0              total_clause_access_times++;
11,912,957,550       0    0  5,956,478,775             0       0              0           0    0              CRef     cr        = i->cref;
             .       .    .              .             .       .              .           .    .              //std::cout<<"cr: "<<cr<<"\n";
             .       .    .              .             .       .              .           .    .              Clause&  c         = ca[cr];
             .       .    .              .             .       .              .           .    .              Lit      false_lit = ~p;
 5,956,478,775       0    0  5,956,478,775             0       0              0           0    0              total_clause_access_size+=2;
17,869,436,325       0    0 11,912,957,550 5,451,865,447 125,249              0           0    0              if (c[0] == false_lit)
 8,867,355,924       0    0  4,433,677,962   125,992,703   4,239  4,433,677,962           0    0                  c[0] = c[1], c[1] = false_lit;
             .       .    .              .             .       .              .           .    .              assert(c[1] == false_lit);
             .       .    .              .             .       .              .           .    .              i++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // If 0th watch is true, then clause is already satisfied.
             .       .    .              .             .       .              .           .    .              Lit     first = c[0];
             .       .    .              .             .       .              .           .    .              Watcher w     = Watcher(cr, first);
14,600,682,470       0    0  1,343,862,460     2,649,241       3              0           0    0              if (first != blocker && value(first) == l_True){
 2,485,195,284       0    0              0             0       0  1,656,796,856     936,582    0                  *j++ = w; continue; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Look for new watch:
34,983,159,004       1    1              0             0       0              0           0    0              for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .    .              {
63,327,090,202       0    0              0             0       0 13,087,989,831           0    0                  total_clause_access_size++;
39,749,985,878       0    0  3,317,845,522             0       0              0           0    0                  if (value(c[k]) != l_False){
19,382,628,244   1,574    1  9,691,314,122             0       0  9,691,314,122           0    0                      c[1] = c[k]; c[k] = false_lit;
 4,845,657,061       0    0  4,845,657,061             0       0              0           0    0                      total_change_other_watch++;
 4,845,657,061       0    0              0             0       0  4,845,657,061           0    0                      no_change_other_watch=false;
             .       .    .              .             .       .              .           .    .                      watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .    .                      goto NextClause; }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Did not find watch -- clause is unit under assignment:
   850,591,503       0    0              0             0       0    564,846,572      84,090    0              *j++ = w;
   564,846,572       0    0              0             0       0              0           0    0              if (value(first) == l_False){
     3,321,645       0    0      3,321,645             0       0              0           0    0                  time_find_conflict++;
    19,929,870       0    0     13,286,580        19,574       0              0           0    0                  total_find_conflict_length+=i-(Watcher*)ws;
     6,643,290       0    0      6,643,290             0       0              0           0    0                  total_find_conflict_allsize+=ws.size();
             .       .    .              .             .       .              .           .    .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
     3,321,645       0    0              0             0       0      3,321,645           0    0                  confl = cr;
     6,643,290       0    0      3,321,645         5,587       0      3,321,645           0    0                  qhead = trail.size();
             .       .    .              .             .       .              .           .    .                  // Copy the remaining watches:
             .       .    .              .             .       .              .           .    .  
   339,088,991       8    7      6,473,589           118       0              0           0    0                  while (i < end)
   161,410,084       0    0    161,410,084    19,971,115   1,024    161,410,084      94,414    0                      *j++ = *i++;
             .       .    .              .             .       .              .           .    .              }else
             .       .    .              .             .       .              .           .    .              {//new implecate
   279,101,641       0    0              0             0       0    279,101,641           0    0                  no_implication_added=false;
   279,101,641       0    0    279,101,641             0       0              0           0    0                  total_push_new_implication++;
   837,304,923       0    0    558,203,282       359,134       0              0           0    0  				if (currLevel == decisionLevel())
             .       .    .              .             .       .              .           .    .  				{
   558,203,282       0    0              0             0       0              0           0    0  					uncheckedEnqueue(first, currLevel, cr);
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT					
             .       .    .              .             .       .              .           .    .  					std::cout << "i " << first << " l " << currLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif					
             .       .    .              .             .       .              .           .    .  				}
             .       .    .              .             .       .              .           .    .  				else
             .       .    .              .             .       .              .           .    .  				{
             .       .    .              .             .       .              .           .    .  					int nMaxLevel = currLevel;
             .       .    .              .             .       .              .           .    .  					int nMaxInd = 1;
-- line 1652 ----------------------------------------
-- line 1665 ----------------------------------------
             .       .    .              .             .       .              .           .    .  					{
             .       .    .              .             .       .              .           .    .  						std::swap(c[1], c[nMaxInd]);
             .       .    .              .             .       .              .           .    .  						*j--; // undo last watch
             .       .    .              .             .       .              .           .    .                          total_change_other_watch++;
             .       .    .              .             .       .              .           .    .                          no_change_other_watch=false;
             .       .    .              .             .       .              .           .    .  						watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .    .  					}
             .       .    .              .             .       .              .           .    .  					
 1,395,508,205       0    0    279,101,641             0       0    279,101,641   3,562,713    0  					uncheckedEnqueue(first, nMaxLevel, cr);
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT					
             .       .    .              .             .       .              .           .    .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif	
             .       .    .              .             .       .              .           .    .  				}
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  
     3,151,944     145    6              0             0       0              0           0    0  NextClause:;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
 1,366,128,800       0    0    273,225,760             0       0              0           0    0          if(no_clause_access==true){
    29,759,645     344    2     29,759,645           954       0              0           0    0              total_no_clause_access++;
             .       .    .              .             .       .              .           .    .          }
   574,688,347      38   13    273,225,760             0       0              0           0    0          if(no_implication_added==true){
   140,964,360       2    1    139,441,542            44       0              0           0    0              total_no_implication_added++;
             .       .    .              .             .       .              .           .    .          }
   578,248,451       0    0    273,225,760             0       0              0           0    0          if(no_change_other_watch==true){
    51,344,654   1,151    5     51,344,654            18       0              0           0    0              total_no_change_other_watch++;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          ws.shrink(i - j);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  ExitProp:;
    14,696,334       4    2     14,696,334     2,962,929       0              0           0    0      propagations += num_props;
     7,348,167       0    0      7,348,167             0       0              0           0    0      simpDB_props -= num_props;
             .       .    .              .             .       .              .           .    .  
     7,348,167       0    0      7,348,167             0       0              0           0    0      return confl;
 1,869,665,689     632    2     52,002,006     5,380,103       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  reduceDB : ()  ->  [void]
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
             .       .    .              .             .       .              .           .    .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  struct reduceDB_lt { 
             .       .    .              .             .       .              .           .    .      ClauseAllocator& ca;
             .       .    .              .             .       .              .           .    .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
   160,970,560     452   10    157,660,245    51,842,907   4,163              0           0    0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
             .       .    .              .             .       .              .           .    .  };
             .       .    .              .             .       .              .           .    .  void Solver::reduceDB()
         1,356     203    4              0             0       0            904           0    0  {
             .       .    .              .             .       .              .           .    .      int     i, j;
             .       .    .              .             .       .              .           .    .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .       .    .              .             .       .              .           .    .      //local_learnts_dirty = false;
             .       .    .              .             .       .              .           .    .  
           226       0    0              0             0       0              0           0    0      sort(learnts_local, reduceDB_lt(ca));
             .       .    .              .             .       .              .           .    .  
         1,130       0    0            226           226       0              0           0    0      int limit = learnts_local.size() / 2;
    12,824,302     226    5              0             0       0              0           0    0      for (i = j = 0; i < learnts_local.size(); i++){
    19,234,758     226    5     12,823,172       400,837       0              0           0    0          Clause& c = ca[learnts_local[i]];
    12,823,172       0    0      6,411,586     6,342,437      46              0           0    0          if (c.mark() == LOCAL)
    23,875,220       0    0      6,263,996             0       0              0           0    0              if (c.removable() && !locked(c) && i < limit)
    15,852,635       0    0      3,170,527             0       0      3,170,527           0    0                  removeClause(learnts_local[i]);
             .       .    .              .             .       .              .           .    .              else{
       589,013       0    0              0             0       0              0           0    0                  if (!c.removable()) limit++;
             .       .    .              .             .       .              .           .    .                  c.removable(true);
    15,762,525       0    0      3,093,469             0       0      3,093,469     193,509    0                  learnts_local[j++] = learnts_local[i]; }
             .       .    .              .             .       .              .           .    .      }
           226       0    0              0             0       0              0           0    0      learnts_local.shrink(i - j);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      checkGarbage();
         1,134       0    0            908           226       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  void Solver::reduceDB_Tier2()
         2,040     235    5              0             0       0          1,700           0    0  {
             .       .    .              .             .       .              .           .    .      int i, j;
     6,484,140      54    2            340           213       0              0           0    0      for (i = j = 0; i < learnts_tier2.size(); i++){
     8,404,455     190    7      5,602,970       175,419   1,014              0           0    0          Clause& c = ca[learnts_tier2[i]];
     5,602,970       0    0              0             0       0              0           0    0          if (c.mark() == TIER2)
    13,796,020     186    4      5,518,408     2,174,018   3,263              0           0    0              if (!locked(c) && c.touched() + 30000 < conflicts){
             .       .    .              .             .       .              .           .    .                  learnts_local.push(learnts_tier2[i]);
             .       .    .              .             .       .              .           .    .                  c.mark(LOCAL);
             .       .    .              .             .       .              .           .    .                  //c.removable(true);
             .       .    .              .             .       .              .           .    .                  c.activity() = 0;
             .       .    .              .             .       .              .           .    .                  claBumpActivity(c);
             .       .    .              .             .       .              .           .    .              }else
    11,809,600       0    0      2,361,920             0       0      2,361,920      80,750    0                  learnts_tier2[j++] = learnts_tier2[i];
             .       .    .              .             .       .              .           .    .      }
           340       0    0              0             0       0              0           0    0      learnts_tier2.shrink(i - j);
         2,040       0    0          2,040           340       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::removeSatisfied(vec<CRef>& cs)
           252       0    0              0             0       0            112           0    0  {
             .       .    .              .             .       .              .           .    .      int i, j;
     2,877,897       9    5        575,591            14       0              0           0    0      for (i = j = 0; i < cs.size(); i++){
     1,726,686       0    0      1,151,124        36,006       0              0           0    0          Clause& c = ca[cs[i]];
             .       .    .              .             .       .              .           .    .          if (satisfied(c))
       126,541      14    5              1             0       0         42,180         197    0              removeClause(cs[i]);
             .       .    .              .             .       .              .           .    .          else
     1,066,764       0    0              0             0       0        533,382      21,129    0              cs[j++] = cs[i];
             .       .    .              .             .       .              .           .    .      }
            28       0    0              0             0       0              0           0    0      cs.shrink(i - j);
           168       1    0            140            35       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
           180       0    0              0             0       0            150           0    0  {
             .       .    .              .             .       .              .           .    .      int i, j;
       886,090      14    5             30            15       0              0           0    0      for (i = j = 0; i < cs.size(); i++){
       925,506       0    0        617,004        19,302       0              0           0    0          Clause& c = ca[cs[i]];
       617,004       0    0              0             0       0              0           0    0          if (c.mark() == valid_mark)
             .       .    .              .             .       .              .           .    .              if (satisfied(c))
       512,888       5    2        128,222             0       0        128,222          43    0                  removeClause(cs[i]);
             .       .    .              .             .       .              .           .    .              else
       870,400       0    0        174,080             0       0        174,080       6,595    0                  cs[j++] = cs[i];
             .       .    .              .             .       .              .           .    .      }
            28       0    0              0             0       0              0           0    0      cs.shrink(i - j);
           180       3    2            180            32       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::rebuildOrderHeap()
           144       6    5              0             0       0             96           0    0  {
             .       .    .              .             .       .              .           .    .      vec<Var> vs;
        36,545       0    0             16             0       0             16           0    0      for (Var v = 0; v < nVars(); v++)
        95,370       0    0         47,685           506      10              0           0    0          if (decision[v] && value(v) == l_Undef)
             .       .    .              .             .       .              .           .    .              vs.push(v);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      order_heap_CHB  .build(vs);
             .       .    .              .             .       .              .           .    .      order_heap_VSIDS.build(vs);
             .       .    .              .             .       .              .           .    .      order_heap_distance.build(vs);
           128      16    5            112             5       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  simplify : [void]  ->  [bool]
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
             .       .    .              .             .       .              .           .    .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  bool Solver::simplify()
        32,280     993    4              0             0       0         21,520           0    0  {
             .       .    .              .             .       .              .           .    .      assert(decisionLevel() == 0);
             .       .    .              .             .       .              .           .    .  
        26,900       0    0          5,380         1,821       2              0           0    0      if (!ok || propagate() != CRef_Undef)
             .       .    .              .             .       .              .           .    .          return ok = false;
             .       .    .              .             .       .              .           .    .  
        16,222     349    5         10,801             0       0              0           0    0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
             .       .    .              .             .       .              .           .    .          return true;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Remove satisfied clauses:
            45       0    0              0             0       0             15           0    0      removeSatisfied(learnts_core); // Should clean core first.
            60       0    0              0             0       0             15           0    0      safeRemoveSatisfied(learnts_tier2, TIER2);
            60      15    5              0             0       0             15           0    0      safeRemoveSatisfied(learnts_local, LOCAL);
            30       0    0             15            14       0              0           0    0      if (remove_satisfied)        // Can be turned off.
            56      28    9              0             0       0             14           0    0          removeSatisfied(clauses);
             .       .    .              .             .       .              .           .    .      checkGarbage();
            30       1    1              0             0       0             15           0    0      rebuildOrderHeap();
             .       .    .              .             .       .              .           .    .  
            30       0    0             15            15       0             15           0    0      simpDB_assigns = nAssigns();
            45       0    0             30            15       0             15           0    0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
             .       .    .              .             .       .              .           .    .  
            15       0    0              0             0       0              0           0    0      return true;
        37,660       0    0         26,900             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // pathCs[k] is the number of variables assigned at level k,
             .       .    .              .             .       .              .           .    .  // it is initialized to 0 at the begining and reset to 0 after the function execution
        80,656       4    1              0             0       0         60,492           0    0  bool Solver::collectFirstUIP(CRef confl){
        20,164       0    0              0             0       0         10,082           0    0      involved_lits.clear();
       579,862       3    1              0             0       0              0           0    0      int max_level=1;
             .       .    .              .             .       .              .           .    .      Clause& c=ca[confl]; int minLevel=decisionLevel();
       144,066       0    0         10,082             0       0              0           0    0      for(int i=0; i<c.size(); i++) {
             .       .    .              .             .       .              .           .    .          Var v=var(c[i]);
             .       .    .              .             .       .              .           .    .          //        assert(!seen[v]);
       140,382      22    1         46,794        11,283       0              0           0    0          if (level(v)>0) {
        92,464       0    0         46,232         7,695       0         46,232      26,526    0              seen[v]=1;
       102,546       0    0         56,314        17,732       0         46,232      38,969    0              var_iLevel_tmp[v]=1;
        46,232       0    0         46,232        21,632       0              0           0    0              pathCs[level(v)]++;
             .       .    .              .             .       .              .           .    .              if (minLevel>level(v)) {
             .       .    .              .             .       .              .           .    .                  minLevel=level(v);
             .       .    .              .             .       .              .           .    .                  assert(minLevel>0);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              //    varBumpActivity(v);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
        30,246       0    0         20,164         9,271       0              0           0    0      int limit=trail_lim[minLevel-1];
    12,599,596       0    0         10,082             0       0              0           0    0      for(int i=trail.size()-1; i>=limit; i--) {
     6,279,634      63    1      6,279,634       169,266       0              0           0    0          Lit p=trail[i]; Var v=var(p);
     6,279,634       0    0      3,139,817        91,046       0              0           0    0          if (seen[v]) {
             .       .    .              .             .       .              .           .    .              int currentDecLevel=level(v);
             .       .    .              .             .       .              .           .    .              //      if (currentDecLevel==decisionLevel())
             .       .    .              .             .       .              .           .    .              //      	varBumpActivity(v);
       556,162       0    0              0             0       0        556,162           0    0              seen[v]=0;
     1,112,324       0    0        556,162             4       0              0           0    0              if (--pathCs[currentDecLevel]!=0) {
             .       .    .              .             .       .              .           .    .                  Clause& rc=ca[reason(v)];
     1,089,150       5    1        779,055            29       0              0           0    0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
       519,370       0    0              0             0       0              0           0    0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
       599,314       0    0              0             0       0              0           0    0                  if (rc.size()==2 && value(rc[0])==l_False) {
             .       .    .              .             .       .              .           .    .                      // Special case for binary clauses
             .       .    .              .             .       .              .           .    .                      // The first one has to be SAT
             .       .    .              .             .       .              .           .    .                      assert(value(rc[1]) != l_False);
             .       .    .              .             .       .              .           .    .                      Lit tmp = rc[0];
        13,407       0    0          4,469           217       0          8,938           0    0                      rc[0] =  rc[1], rc[1] = tmp;
             .       .    .              .             .       .              .           .    .                  }
     2,134,798       0    0              0             0       0              0           0    0                  for (int j = 1; j < rc.size(); j++){
             .       .    .              .             .       .              .           .    .                      Lit q = rc[j]; Var v1=var(q);
     1,695,372       0    0              0             0       0              0           0    0                      if (level(v1) > 0) {
     1,673,790       0    0              0             0       0              0           0    0                          if (minLevel>level(v1)) {
       127,780       0    0         63,890        25,138       0              0           0    0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
             .       .    .              .             .       .              .           .    .                          }
     2,510,685       0    0      1,673,790        22,925       0              0           0    0                          if (seen[v1]) {
       653,930       0    0        326,965             3       0              0           0    0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
       388,842       0    0              0             0       0        194,421           0    0                                  var_iLevel_tmp[v1]=reasonVarLevel;
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                          else {
       509,930       0    0              0             0       0        509,930     267,475    0                              var_iLevel_tmp[v1]=reasonVarLevel;
             .       .    .              .             .       .              .           .    .                              //   varBumpActivity(v1);
       509,930       0    0              0             0       0        509,930           0    0                              seen[v1] = 1;
     1,529,790       4    1      1,019,860        64,192       0              0           0    0                              pathCs[level(v1)]++;
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              involved_lits.push(p);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
        30,246     279    1         10,082             0       0         10,082           0    0      double inc=var_iLevel_inc;
             .       .    .              .             .       .              .           .    .      vec<int> level_incs; level_incs.clear();
       479,761       0    0        179,806             0       0              0           0    0      for(int i=0;i<max_level;i++){
       199,970       4    1         99,985             0       0              0           0    0          level_incs.push(inc);
       299,955       0    0        199,970             0       0         99,985           0    0          inc = inc/my_var_decay;
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
     1,152,652       0    0        566,244             0       0              0           0    0      for(int i=0;i<involved_lits.size();i++){
        10,082       0    0         10,082             0       0              0           0    0          Var v =var(involved_lits[i]);
             .       .    .              .             .       .              .           .    .          //        double old_act=activity_distance[v];
             .       .    .              .             .       .              .           .    .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
     5,166,770   3,138    2      1,708,814       250,880       0        566,244           0    0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
             .       .    .              .             .       .              .           .    .  
     1,112,324       0    0              0             0       0              0           0    0          if(activity_distance[v]>1e100){
             .       .    .              .             .       .              .           .    .              for(int vv=0;vv<nVars();vv++)
        50,410     275    1         20,164        17,848       0         20,164           0    0                  activity_distance[vv] *= 1e-100;
             .       .    .              .             .       .              .           .    .              var_iLevel_inc*=1e-100;
         9,504      27    1              0             0       0              0           0    0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          if (order_heap_distance.inHeap(v))
             .       .    .              .             .       .              .           .    .              order_heap_distance.decrease(v);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          //        var_iLevel_inc *= (1 / my_var_decay);
             .       .    .              .             .       .              .           .    .      }
        50,410      38    1         20,164             0       0         10,082           0    0      var_iLevel_inc=level_incs[level_incs.size()-1];
             .       .    .              .             .       .              .           .    .      return true;
        90,738       0    0         70,574         1,074       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  struct UIPOrderByILevel_Lt {
             .       .    .              .             .       .              .           .    .      Solver& solver;
             .       .    .              .             .       .              .           .    .      const vec<double>&  var_iLevel;
             .       .    .              .             .       .              .           .    .      bool operator () (Lit x, Lit y) const
             .       .    .              .             .       .              .           .    .      {
             .       .    .              .             .       .              .           .    .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
             .       .    .              .             .       .              .           .    .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
             .       .    .              .             .       .              .           .    .  |    Search for a model the specified number of conflicts. 
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Output:
             .       .    .              .             .       .              .           .    .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
             .       .    .              .             .       .              .           .    .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
             .       .    .              .             .       .              .           .    .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  lbool Solver::search(int& nof_conflicts)
        58,960   4,298    7              0             0       0         37,520          56    0  {
             .       .    .              .             .       .              .           .    .      assert(ok);
             .       .    .              .             .       .              .           .    .      int         backtrack_level;
             .       .    .              .             .       .              .           .    .      int         lbd;
             .       .    .              .             .       .              .           .    .      vec<Lit>    learnt_clause;
             .       .    .              .             .       .              .           .    .      bool        cached = false;
         5,360       0    0          5,360            98       0              0           0    0      starts++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // simplify
             .       .    .              .             .       .              .           .    .      //
        21,440       5    5         16,080         5,360       3              0           0    0      if (conflicts >= curSimplify * nbconfbeforesimplify){
             .       .    .              .             .       .              .           .    .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
             .       .    .              .             .       .              .           .    .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
             .       .    .              .             .       .              .           .    .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
             .       .    .              .             .       .              .           .    .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
            56      30    9             56             7       0              0           0    0          nbSimplifyAll++;
           168      56   14              0             0       0             56           0    0          if (!simplifyAll()){
             .       .    .              .             .       .              .           .    .              return l_False;
             .       .    .              .             .       .              .           .    .          }
           392       0    0            112             0       0             56           0    0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
           168       0    0             56             0       0             56           0    0          nbconfbeforesimplify += incSimplify;
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      for (;;){
             .       .    .              .             .       .              .           .    .          CRef confl = propagate();
             .       .    .              .             .       .              .           .    .  
    14,846,706       0    0              0             0       0              0           0    0          if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .    .              // CONFLICT
    10,207,008       0    0      3,402,336        71,427       0              0           0    0              if (VSIDS){
     3,097,818       0    0      1,548,894     1,473,563       1             30           0    0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
             .       .    .              .             .       .              .           .    .              }else
     6,580,470      15    0      4,046,979     1,790,219       1        340,001           0    0                  if (step_size > min_step_size) step_size -= step_size_dec;
             .       .    .              .             .       .              .           .    .  
    13,609,344     131   24      6,804,672     3,239,973       0      3,402,336           0    0              conflicts++; nof_conflicts--;
             .       .    .              .             .       .              .           .    .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
             .       .    .              .             .       .              .           .    .              ConflictData data = FindConflictLevel(confl);
     6,804,674       0    0              0             0       0              0           0    0              if (data.nHighestLevel == 0) return l_False;
             .       .    .              .             .       .              .           .    .              if (data.bOnlyOneLitFromHighest)
             .       .    .              .             .       .              .           .    .              {
             .       .    .              .             .       .              .           .    .  				cancelUntil(data.nHighestLevel - 1);
             .       .    .              .             .       .              .           .    .  				continue;
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  			
             .       .    .              .             .       .              .           .    .              learnt_clause.clear();
     6,804,670       0    0              0             0       0      3,402,335   3,049,759    0              if(conflicts>50000) DISTANCE=0;
             .       .    .              .             .       .              .           .    .              else DISTANCE=1;
     9,902,364       0    0              0             0       0              0           0    0              if(VSIDS && DISTANCE)
        40,328       4    1              0             0       0         10,082           0    0                  collectFirstUIP(confl);
             .       .    .              .             .       .              .           .    .  
    20,414,010     203    6              0             0       0      3,402,335           0    0              analyze(confl, learnt_clause, backtrack_level, lbd);
             .       .    .              .             .       .              .           .    .              // check chrono backtrack condition
    47,604,697      76    8     17,007,676        78,671       0              0           0    0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
             .       .    .              .             .       .              .           .    .              {
             .       .    .              .             .       .              .           .    .  				++chrono_backtrack;
             .       .    .              .             .       .              .           .    .  				cancelUntil(data.nHighestLevel -1);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  			else // default behavior
             .       .    .              .             .       .              .           .    .  			{
     3,402,335     225    7      3,402,335            12       0              0           0    0  				++non_chrono_backtrack;
             .       .    .              .             .       .              .           .    .  				cancelUntil(backtrack_level);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  
    10,207,005       0    0      3,402,335        10,727       0      3,402,335           0    0              lbd--;
     6,804,670       0    0      3,402,335             0       0              0           0    0              if (VSIDS){
     1,548,847      26    4              0             0       0      1,548,847           0    0                  cached = false;
     4,646,541      73    8      4,646,541     1,249,233       0              0           0    0                  conflicts_VSIDS++;
             .       .    .              .             .       .              .           .    .                  lbd_queue.push(lbd);
    12,390,776       0    0      4,646,541             0       0      1,548,847           0    0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
             .       .    .              .             .       .              .           .    .  
    10,207,005      59    9      3,402,335             0       0              0           0    0              if (learnt_clause.size() == 1){
           140       1    1             40             4       0             20           0    0                  uncheckedEnqueue(learnt_clause[0]);
             .       .    .              .             .       .              .           .    .              }else{
             .       .    .              .             .       .              .           .    .                  CRef cr = ca.alloc(learnt_clause, true);
     3,402,315       0    0      3,402,315             0       0              0           0    0                  ca[cr].set_lbd(lbd);
             .       .    .              .             .       .              .           .    .                  //duplicate learnts 
             .       .    .              .             .       .              .           .    .                  int  id = 0;
     6,804,630       0    0      3,402,315     3,341,216       0              0           0    0                  if (lbd <= max_lbd_dup){                        
             .       .    .              .             .       .              .           .    .                      std::vector<uint32_t> tmp;
   190,254,307       0    0    127,800,982             0       0      2,265,442           0    0                      for (int i = 0; i < learnt_clause.size(); i++)
   132,331,866       9    3     88,221,244             0       0     44,110,622           0    0                          tmp.push_back(learnt_clause[i].x);
     6,796,326       6    2      2,265,442             0       0      2,265,442           0    0                      id = is_duplicate(tmp);             
    11,327,210       0    0      2,265,442         2,104       0              0           0    0                      if (id == min_number_of_learnts_copies +1){
           116       0    0            116            10       0              0           0    0                          duplicates_added_conflicts++;                        
             .       .    .              .             .       .              .           .    .                      }                    
     4,530,884       0    0              0             0       0              0           0    0                      if (id == min_number_of_learnts_copies){
         1,126       0    0          1,126             0       0              0           0    0                          duplicates_added_tier2++;
             .       .    .              .             .       .              .           .    .                      }                                        
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  //duplicate learnts
             .       .    .              .             .       .              .           .    .  
    20,369,326       0    0      6,793,489     1,715,947       1              0           0    0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
            14       2    1              0             0       0              0           0    0                      learnts_core.push(cr);
             .       .    .              .             .       .              .           .    .                      ca[cr].mark(CORE);
    12,793,852     897   11              0             0       0              0           0    0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
            20       1    1              0             0       0              0           0    0                      learnts_tier2.push(cr);
             .       .    .              .             .       .              .           .    .                      ca[cr].mark(TIER2);
     1,541,396       0    0        385,349             5       0        385,349         294    0                      ca[cr].touched() = conflicts;
             .       .    .              .             .       .              .           .    .                  }else{
            23      16    1              0             0       0              0           0    0                      learnts_local.push(cr);
             .       .    .              .             .       .              .           .    .                      claBumpActivity(ca[cr]); }
    10,206,945   2,413    7              0             0       0      3,402,315           0    0                  attachClause(cr);
             .       .    .              .             .       .              .           .    .  
    20,413,890       0    0     10,206,945         2,335       0      3,402,315           0    0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .    .                  std::cout << "new " << ca[cr] << "\n";
             .       .    .              .             .       .              .           .    .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
             .       .    .              .             .       .              .           .    .  #endif                
             .       .    .              .             .       .              .           .    .              }
    10,207,005       1    1      3,402,335       164,336       0              0           0    0              if (drup_file){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .                  binDRUP('a', learnt_clause, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                  for (int i = 0; i < learnt_clause.size(); i++)
             .       .    .              .             .       .              .           .    .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
             .       .    .              .             .       .              .           .    .                  fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
    10,207,005     346   10      6,804,670     1,518,528       0              0           0    0              if (VSIDS) varDecayActivity();
             .       .    .              .             .       .              .           .    .              claDecayActivity();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              /*if (--learntsize_adjust_cnt == 0){
             .       .    .              .             .       .              .           .    .                  learntsize_adjust_confl *= learntsize_adjust_inc;
             .       .    .              .             .       .              .           .    .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
             .       .    .              .             .       .              .           .    .                  max_learnts             *= learntsize_inc;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
             .       .    .              .             .       .              .           .    .                             (int)conflicts,
             .       .    .              .             .       .              .           .    .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
             .       .    .              .             .       .              .           .    .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
             .       .    .              .             .       .              .           .    .              }*/
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          }else{
             .       .    .              .             .       .              .           .    .              // NO CONFLICT
             .       .    .              .             .       .              .           .    .              bool restart = false;
    12,063,051      55   10      4,021,017       703,015       0              0           0    0              if (!VSIDS)
             .       .    .              .             .       .              .           .    .                  restart = nof_conflicts <= 0;
     3,753,974       1    1      1,876,987     1,057,601       0              0           0    0              else if (!cached){
    13,383,642       3    0      3,758,041     1,280,726       0        778,853           0    0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
             .       .    .              .             .       .              .           .    .                  cached = true;
             .       .    .              .             .       .              .           .    .              }
     6,432,090       0    0      2,144,030     1,480,401       0              0           0    0              if (restart /*|| !withinBudget()*/){
             .       .    .              .             .       .              .           .    .                  lbd_queue.clear();
             .       .    .              .             .       .              .           .    .                  cached = false;
             .       .    .              .             .       .              .           .    .                  // Reached bound on number of conflicts:
        16,077       0    0              0             0       0         10,718           0    0                  progress_estimate = progressEstimate();
             .       .    .              .             .       .              .           .    .                  cancelUntil(0);
        10,718       0    0              0             0       0              0           0    0                  return l_Undef; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Simplify the set of problem clauses:
    12,800,159      86    7      4,015,658             0       0        737,045           0    0              if (decisionLevel() == 0 && !simplify())
             .       .    .              .             .       .              .           .    .                  return l_False;
             .       .    .              .             .       .              .           .    .  
    12,046,974      21    1      8,031,316         3,663       2              0           0    0              if (conflicts >= next_T2_reduce){
           680       0    0              0             0       0            340           0    0                  next_T2_reduce = conflicts + 10000;
         1,360       0    0            340             0       0            340           0    0                  reduceDB_Tier2(); }
     8,031,316      38    5      4,015,658             0       0              0           0    0              if (conflicts >= next_L_reduce){
           452       0    0              0             0       0            226           0    0                  next_L_reduce = conflicts + 15000;
           452       0    0              0             0       0            226           0    0                  reduceDB(); }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              Lit next = lit_Undef;
             .       .    .              .             .       .              .           .    .              /*while (decisionLevel() < assumptions.size()){
             .       .    .              .             .       .              .           .    .                  // Perform user provided assumption:
             .       .    .              .             .       .              .           .    .                  Lit p = assumptions[decisionLevel()];
             .       .    .              .             .       .              .           .    .                  if (value(p) == l_True){
             .       .    .              .             .       .              .           .    .                      // Dummy decision level:
             .       .    .              .             .       .              .           .    .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
             .       .    .              .             .       .              .           .    .                  }else{
             .       .    .              .             .       .              .           .    .                      next = p;
             .       .    .              .             .       .              .           .    .                      break;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              if (next == lit_Undef)*/{
             .       .    .              .             .       .              .           .    .                  // New variable decision:
     4,015,658       0    0      4,015,658           226       0              0           0    0                  decisions++;
    12,046,974     190   11              0             0       0      4,015,658           0    0                  next = pickBranchLit();
             .       .    .              .             .       .              .           .    .  
     8,031,316       0    0              0             0       0              0           0    0                  if (next == lit_Undef)
             .       .    .              .             .       .              .           .    .                      // Model found:
             .       .    .              .             .       .              .           .    .                      return l_True;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Increase decision level and enqueue 'next'
             .       .    .              .             .       .              .           .    .              newDecisionLevel();
    24,093,948      57   11      4,015,658             0       0      4,015,658           0    0              uncheckedEnqueue(next, decisionLevel());
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT            
             .       .    .              .             .       .              .           .    .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
             .       .    .              .             .       .              .           .    .  #endif            
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
        48,240      43    4         37,520         7,647       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  double Solver::progressEstimate() const
        32,154       6    4              0             0       0         26,795           0    0  {
        10,718       0    0              0             0       0              0           0    0      double  progress = 0;
        26,795       0    0         10,718         3,392       0          5,359           0    0      double  F = 1.0 / nVars();
             .       .    .              .             .       .              .           .    .  
       431,342       4    3              0             0       0              0           0    0      for (int i = 0; i <= decisionLevel(); i++){
       399,188       0    0        258,980             0       0              0           0    0          int beg = i == 0 ? 0 : trail_lim[i - 1];
       534,037       0    0        264,339        12,638       0              0           0    0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
       825,171      36   11        140,208             0       0              0           0    0          progress += pow(F, i) * (end - beg);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
        10,718       0    0              0             0       0              0           0    0      return progress / nVars();
        37,513       0    0         32,154             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*
             .       .    .              .             .       .              .           .    .    Finite subsequences of the Luby-sequence:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    0: 1
             .       .    .              .             .       .              .           .    .    1: 1 1 2
             .       .    .              .             .       .              .           .    .    2: 1 1 2 1 1 2 4
             .       .    .              .             .       .              .           .    .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .   */
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static double luby(double y, int x){
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Find the finite subsequence that contains index 'x', and the
             .       .    .              .             .       .              .           .    .      // size of that subsequence:
             .       .    .              .             .       .              .           .    .      int size, seq;
       194,443       0    0              0             0       0              0           0    0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
             .       .    .              .             .       .              .           .    .  
       109,571       3    3              0             0       0              0           0    0      while (size-1 != x){
        63,514       0    0              0             0       0              0           0    0          size = (size-1)>>1;
        31,757       0    0              0             0       0              0           0    0          seq--;
        95,271       0    0              0             0       0              0           0    0          x = x % size;
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      return pow(y, seq);
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static bool switch_mode = false;
             .       .    .              .             .       .              .           .    .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
             .       .    .              .             .       .              .           .    .  
            32       4    4              0             0       0             24           0    0  uint32_t Solver::reduceduplicates(){
             .       .    .              .             .       .              .           .    .      uint32_t removed_duplicates = 0;
             .       .    .              .             .       .              .           .    .      std::vector<std::vector<uint64_t>> tmp;
             .       .    .              .             .       .              .           .    .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
         3,936       0    0              8             0       0              0           0    0      for (auto & outer_mp: ht){//variables
        55,882       0    0              0             0       0              0           0    0          for (auto &inner_mp:outer_mp.second){//sizes
     4,547,270       0    0              0             0       0              0           0    0              for (auto &in_in_mp: inner_mp.second){
     6,745,875       4    4      2,248,625     2,140,898 598,047              0           0    0                  if (in_in_mp.second >= 2){
             .       .    .              .             .       .              .           .    .                  //min_number_of_learnts_copies
     1,790,830       4    4        716,332         1,269     206        716,332       1,040    0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }                    
             .       .    .              .             .       .              .           .    .           }
             .       .    .              .             .       .              .           .    .      }          
            12       0    0              4             4       0              4           0    0      removed_duplicates = dupl_db_size-tmp.size();  
             .       .    .              .             .       .              .           .    .      ht.clear();
     1,253,601       4    4        537,253            27       1              0           0    0      for (auto i=0;i<tmp.size();i++){
     1,790,830       0    0        895,415       201,541  64,708        537,249          16    1          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      return removed_duplicates;
            36       0    0             32            12       2              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // NOTE: assumptions passed in member-variable 'assumptions'.
             .       .    .              .             .       .              .           .    .  lbool Solver::solve_()
             8       0    0              0             0       0              6           0    0  {
             .       .    .              .             .       .              .           .    .      //signal(SIGALRM, SIGALRM_switch);
             .       .    .              .             .       .              .           .    .      //alarm(2500);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      model.clear();
             .       .    .              .             .       .              .           .    .      conflict.clear();
             2       1    1              1             0       0              0           0    0      if (!ok) return l_False;
             .       .    .              .             .       .              .           .    .  
             1       1    1              1             1       0              0           0    0      solves++;
             .       .    .              .             .       .              .           .    .  
             5       0    0              2             0       0              1           0    0      max_learnts               = nClauses() * learntsize_factor;
             3       0    0              1             1       0              0           0    0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
             1       0    0              0             0       0              1           1    0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
             .       .    .              .             .       .              .           .    .      lbool   status            = l_Undef;
             .       .    .              .             .       .              .           .    .  
             3       0    0              1             0       0              0           0    0      if (verbosity >= 1){
             2       0    0              0             0       0              1           0    0          printf("c ============================[ Search Statistics ]==============================\n");
             2       1    1              0             0       0              1           0    0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
             2       0    0              0             0       0              1           0    0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
             2       0    0              0             0       0              1           0    0          printf("c ===============================================================================\n");
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      add_tmp.clear();
             .       .    .              .             .       .              .           .    .  
             1       0    0              0             0       0              1           1    0      VSIDS = true;
             1       1    1              0             0       0              1           0    0      int init = 10000;
           495       0    0             99             0       0              0           0    0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
           396       3    0              0             0       0             99           0    0          status = search(init);
             1       0    0              0             0       0              1           0    0      VSIDS = false;
             .       .    .              .             .       .              .           .    .  
             3       1    1              0             0       0              2           1    0      duplicates_added_conflicts = 0;
             .       .    .              .             .       .              .           .    .      duplicates_added_minimization=0;
             .       .    .              .             .       .              .           .    .      duplicates_added_tier2 =0;    
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      dupl_db_size=0;
             1       0    0              1             1       0              0           0    0      size_t dupl_db_size_limit = dupl_db_init_size;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Search:
             1       0    0              0             0       0              0           0    0      int curr_restarts = 0;
             1       0    0              0             0       0              0           0    0      uint64_t curr_props = 0;
             .       .    .              .             .       .              .           .    .      uint32_t removed_duplicates =0;
        10,522     713    0              0             0       0              0           0    0      while (status == l_Undef /*&& withinBudget()*/){
        10,522       1    1          5,261         1,652       0              0           0    0          if (dupl_db_size >= dupl_db_size_limit){    
            16       4    4              4             0       0              4           0    0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
            16       0    0              4             3       0              4           0    0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
            16       0    0              4             0       0              4           0    0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
            16       4    4              4             0       0              4           0    0              printf("c Duptime: %i\n",duptime.count());
            16       0    0              4             0       0              4           0    0              printf("c Number of conflicts: %i\n",conflicts);
            16       0    0              4             2       0              4           0    0              printf("c Core size: %i\n",learnts_core.size());
             .       .    .              .             .       .              .           .    .              
             8       0    0              0             0       0              4           0    0              removed_duplicates = reduceduplicates();
            32       4    4              8             8       2              0           0    0              dupl_db_size_limit*=1.1;
             8       0    0              4             4       2              0           0    0              dupl_db_size -= removed_duplicates;
            20       0    0              0             0       0              4           0    0              printf("c removed duplicates %i\n",removed_duplicates);
             .       .    .              .             .       .              .           .    .          }   
        31,566     203    4         10,522         5,191       4              0           0    0          if (propagations - curr_props >  VSIDS_props_limit){
             6       0    0              0             0       0              0           0    0              curr_props = propagations;
             6       0    0              0             0       0              6           0    0              switch_mode = true;
            31       0    0              0             0       0              6           0    0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
             .       .    .              .             .       .              .           .    .          }     
        10,522       0    0          5,261             4       2              0           0    0          if (VSIDS){
         1,680       0    0              0             0       0          1,680           0    0              int weighted = INT32_MAX;
         6,720   1,680    0              0             0       0          1,680           0    0              status = search(weighted);
             .       .    .              .             .       .              .           .    .          }else{
        21,486   2,339    4          7,162             0       0          3,581           0    0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
         3,581       0    0              0             0       0              0           0    0              curr_restarts++;
        17,905   3,579    0              0             0       0          3,581           0    0              status = search(nof_conflicts);
             .       .    .              .             .       .              .           .    .          }
        10,522   3,579    1          5,261         5,261       2              0           0    0          if (switch_mode){ 
             6       0    0              0             0       0              6           0    0              switch_mode = false;
             .       .    .              .             .       .              .           .    .              VSIDS = !VSIDS;
            12       0    0              6             0       0              0           0    0              if (VSIDS){
             6       3    3              0             0       0              3           0    0                  printf("c Switched to VSIDS.\n");
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
             9       3    3              0             0       0              3           0    0                 printf("c Switched to LRB.\n");
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              //            reduceduplicates();            
            12       3    3              6             6       2              6           0    0              fflush(stdout);
             .       .    .              .             .       .              .           .    .              picked.clear();
             .       .    .              .             .       .              .           .    .              conflicted.clear();
             .       .    .              .             .       .              .           .    .              almost_conflicted.clear();
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
             .       .    .              .             .       .              .           .    .              canceled.clear();
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             3       1    1              1             0       0              0           0    0      if (verbosity >= 1)
             2       0    0              0             0       0              1           0    0          printf("c ===============================================================================\n");
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             3       0    0              1             0       0              0           0    0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .  
             2       1    1              0             0       0              0           0    0      if (status == l_True){
             .       .    .              .             .       .              .           .    .          // Extend & copy model:
             .       .    .              .             .       .              .           .    .          model.growTo(nVars());
             .       .    .              .             .       .              .           .    .          for (int i = 0; i < nVars(); i++) model[i] = value(i);
             6       1    1              1             0       0              0           0    0      }else if (status == l_False && conflict.size() == 0)
             2       0    0              0             0       0              1           0    0          ok = false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      cancelUntil(0);
             1       0    0              0             0       0              0           0    0      return status;
             8       1    1              7             1       1              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Writing CNF to DIMACS:
             .       .    .              .             .       .              .           .    .  // 
             .       .    .              .             .       .              .           .    .  // FIXME: this needs to be rewritten completely.
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static Var mapVar(Var x, vec<Var>& map, Var& max)
             .       .    .              .             .       .              .           .    .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
             .       .    .              .             .       .              .           .    .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Garbage Collection methods:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::relocAll(ClauseAllocator& to)
         2,320     124   27              0             0       0          1,856           0    0  {
             .       .    .              .             .       .              .           .    .      // All watchers:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      // for (int i = 0; i < watches.size(); i++)
           464       0    0              0             0       0            232           0    0      watches.cleanAll();
           464       0    0              0             0       0            232           0    0      watches_bin.cleanAll();
     2,646,192      13    7      1,851,592        27,017       0        264,944         231    0      for (int v = 0; v < nVars(); v++)
     1,057,920       0    0        528,960             0       0              0           0    0          for (int s = 0; s < 2; s++){
             .       .    .              .             .       .              .           .    .              Lit p = mkLit(v, s);
             .       .    .              .             .       .              .           .    .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
             .       .    .              .             .       .              .           .    .              vec<Watcher>& ws = watches[p];
    99,823,352      34   13     55,335,100       132,471     907              0           0    0              for (int j = 0; j < ws.size(); j++)
             .       .    .              .             .       .              .           .    .                  ca.reloc(ws[j].cref, to);
             .       .    .              .             .       .              .           .    .              vec<Watcher>& ws_bin = watches_bin[p];
     5,334,556       2    1      2,166,380       147,559     962              0           0    0              for (int j = 0; j < ws_bin.size(); j++)
             .       .    .              .             .       .              .           .    .                  ca.reloc(ws_bin[j].cref, to);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // All reasons:
             .       .    .              .             .       .              .           .    .      //
       150,454       0    0            696             0       0              0           0    0      for (int i = 0; i < trail.size(); i++){
             .       .    .              .             .       .              .           .    .          Var v = var(trail[i]);
             .       .    .              .             .       .              .           .    .  
       244,238       0    0         47,588        33,957       0              0           0    0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
       238,404       0    0         47,588             0       0         47,588           0    0              ca.reloc(vardata[v].reason, to);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // All learnt:
             .       .    .              .             .       .              .           .    .      //
    16,292,596     217    5      8,146,181           277       0              0           0    0      for (int i = 0; i < learnts_core.size(); i++)
             .       .    .              .             .       .              .           .    .          ca.reloc(learnts_core[i], to);
     3,600,112     692   15      1,800,055           922       0              0           0    0      for (int i = 0; i < learnts_tier2.size(); i++)
             .       .    .              .             .       .              .           .    .          ca.reloc(learnts_tier2[i], to);
     6,191,612     232    5      3,095,343           230       0              0           0    0      for (int i = 0; i < learnts_local.size(); i++)
     9,284,637       0    0              0             0       0      3,094,879           0    0          ca.reloc(learnts_local[i], to);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // All original:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      int i, j;
     1,657,284     232    5            928           230       0              0           0    0      for (i = j = 0; i < clauses.size(); i++)
     1,655,196       0    0              0             0       0              0           0    0          if (ca[clauses[i]].mark() != 1){
     2,483,258     232    5        827,598           229       0        827,598           0    0              ca.reloc(clauses[i], to);
     8,275,748     142   10      3,310,160             0       0        827,598           0    0              clauses[j++] = clauses[i]; }
           232     231    5              0             0       0              0           0    0      clauses.shrink(i - j);
         1,856     231    5          1,624           232       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::garbageCollect()
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
             .       .    .              .             .       .              .           .    .      // is not precise but should avoid some unnecessary reallocations for the new region:
             .       .    .              .             .       .              .           .    .      ClauseAllocator to(ca.size() - ca.wasted());
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      relocAll(to);
             .       .    .              .             .       .              .           .    .      if (verbosity >= 2)
             .       .    .              .             .       .              .           .    .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
             .       .    .              .             .       .              .           .    .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
             .       .    .              .             .       .              .           .    .      to.moveTo(ca);
           155      18   18             47             4       4             61           0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr        DLmr Dw          D1mw   DLmw 

-- line 77 ----------------------------------------
             .     .    .              .           .    .           .      .    .  private:
             .     .    .              .           .    .           .      .    .      template<typename T>
             .     .    .              .           .    .           .      .    .      class MyQueue {
             .     .    .              .           .    .           .      .    .          int max_sz, q_sz;
             .     .    .              .           .    .           .      .    .          int ptr;
             .     .    .              .           .    .           .      .    .          int64_t sum;
             .     .    .              .           .    .           .      .    .          vec<T> q;
             .     .    .              .           .    .           .      .    .      public:
             4     1    1              0           0    0           3      0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .     .    .              .           .    .           .      .    .          inline bool   full () const { return q_sz == max_sz; }
             .     .    .              .           .    .           .      .    .  #ifdef INT_QUEUE_AVG
     2,933,780    74    3        733,445           0    0           0      0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .     .    .              .           .    .           .      .    .  #else
             .     .    .              .           .    .           .      .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .     .    .              .           .    .           .      .    .  #endif
        10,718    26   16              0           0    0      10,718  2,788    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .     .    .              .           .    .           .      .    .          void push(T e) {
     9,470,982     0    0      4,646,541           0    0      88,950      0    0              if (q_sz < max_sz) q_sz++;
     4,379,691     6    5      1,459,897   1,447,404    0           0      0    0              else sum -= q[ptr];
     4,646,541    29    7              0           0    0   1,548,847      0    0              sum += e;
     4,646,541     0    0              0           0    0   3,097,694 88,168    5              q[ptr++] = e;
     4,676,972     0    0      3,097,694           0    0      30,431      0    0              if (ptr == max_sz) ptr = 0;
             .     .    .              .           .    .           .      .    .          }
             .     .    .              .           .    .           .      .    .      };
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  public:
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      // Constructor/Destructor:
             .     .    .              .           .    .           .      .    .      //
             .     .    .              .           .    .           .      .    .      Solver();
             .     .    .              .           .    .           .      .    .      virtual ~Solver();
            10     2    2              0           0    0           4      0    0      void print_size(std::ostream &os)
             .     .    .              .           .    .           .      .    .      {
             4     2    2              0           0    0           4      1    0          program_end_time=std::chrono::steady_clock::now();
             2     0    0              0           0    0           2      0    0          total_work_time=program_end_time-program_start_time;
             4     0    0              2           0    0           0      0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2     0    0              2           1    0           0      0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4     0    0              2           1    0           0      0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4     0    0              2           1    0           0      0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .     .    .              .           .    .           .      .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .     .    .              .           .    .           .      .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2     0    0              2           2    0           0      0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2     0    0              2           0    0           0      0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2     0    0              2           0    0           0      0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4     0    0              2           2    0           0      0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4     0    0              2           2    0           0      0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_Watchers: " << total_Watchers << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_indexs: " << total_indexs << "\n";
             .     .    .              .           .    .           .      .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .     .    .              .           .    .           .      .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6     0    0              4           0    0           0      0    0      }
             .     .    .              .           .    .           .      .    .      using ull=unsigned long long;
             .     .    .              .           .    .           .      .    .      ull total_Watchers = 0;
             .     .    .              .           .    .           .      .    .      ull total_act_watchers = 0;
             .     .    .              .           .    .           .      .    .      ull total_indexs = 0;
             .     .    .              .           .    .           .      .    .      ull time_find_conflict = 0;
             .     .    .              .           .    .           .      .    .      ull total_find_conflict_length = 0;
             .     .    .              .           .    .           .      .    .      ull total_find_conflict_allsize = 0;
             .     .    .              .           .    .           .      .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .              .           .    .           .      .    .      {
             .     .    .              .           .    .           .      .    .          const ClauseAllocator& ca;
             .     .    .              .           .    .           .      .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .     .    .              .           .    .           .      .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .     .    .              .           .    .           .      .    .      };
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      struct VarOrderLt {
             .     .    .              .           .    .           .      .    .          const vec<double>&  activity;
 1,584,596,940   312   30  1,106,636,531  99,160,735  716  57,625,372      0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .     .    .              .           .    .           .      .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .     .    .              .           .    .           .      .    .      };
             .     .    .              .           .    .           .      .    .      
             .     .    .              .           .    .           .      .    .      struct ConflictData
             .     .    .              .           .    .           .      .    .  	{
             .     .    .              .           .    .           .      .    .  		ConflictData() :
             .     .    .              .           .    .           .      .    .  			nHighestLevel(-1),
             .     .    .              .           .    .           .      .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .     .    .              .           .    .           .      .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .     .    .              .           .    .           .      .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .     .    .              .           .    .           .      .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .     .    .              .           .    .           .      .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .     .    .              .           .    .           .      .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .     .    .              .           .    .           .      .    .      std::chrono::nanoseconds total_duration;
             .     .    .              .           .    .           .      .    .      CRef     propagate(){
             .     .    .              .           .    .           .      .    .  
    14,857,716 6,342   12              0           0    0   7,428,858      1    0          auto start_time=std::chrono::steady_clock::now();
    22,286,574     0    0              0           0    0   7,428,858      0    0          auto ref= propagate_();
     7,428,858     0    0              0           0    0   7,428,858      0    0          auto end_time=std::chrono::steady_clock::now();
             .     .    .              .           .    .           .      .    .          auto duration=end_time-start_time;
             .     .    .              .           .    .           .      .    .          total_duration+=duration;
             .     .    .              .           .    .           .      .    .          return ref;
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .     .    .              .           .    .           .      .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .     .    .              .           .    .           .      .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .     .    .              .           .    .           .      .    .      
             .     .    .              .           .    .           .      .    .  public:
             .     .    .              .           .    .           .      .    .      int      level            (Var x) const;
             .     .    .              .           .    .           .      .    .  protected:
             .     .    .              .           .    .           .      .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .     .    .              .           .    .           .      .    .      bool     withinBudget     ()      const;
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      template<class V> int computeLBD(const V& c) {
   122,968,907    56   12              0           0    0           0      0    0          int lbd = 0;
             .     .    .              .           .    .           .      .    .  
    21,601,869    58   16     18,199,534   3,635,925    1           0      0    0          counter++;
   559,786,893     0    0      3,408,323           0    0           0      0    0          for (int i = 0; i < c.size(); i++){
             .     .    .              .           .    .           .      .    .              int l = level(var(c[i]));
 1,279,734,233     0    0    511,856,210  11,232,191    8           0      0    0              if (l != 0 && seen2[l] != counter){
   137,766,837     0    0              0           0    0 137,766,837      0    0                  seen2[l] = counter;
   215,347,751     0    0              0           0    0           0      0    0                  lbd++; } }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .          return lbd;
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  #ifdef BIN_DRUP
             .     .    .              .           .    .           .      .    .      static int buf_len;
             .     .    .              .           .    .           .      .    .      static unsigned char drup_buf[];
             .     .    .              .           .    .           .      .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      template<class V>
             .     .    .              .           .    .           .      .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .     .    .              .           .    .           .      .    .          assert(op == 'a' || op == 'd');
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = op; buf_len++;
             .     .    .              .           .    .           .      .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = 0; buf_len++;
       250,598    47   18              0           0    0     250,598      0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = 'a'; buf_len++;
             .     .    .              .           .    .           .      .    .          for (int i = 0; i < c.size(); i++)
             .     .    .              .           .    .           .      .    .              if (c[i] != l) byteDRUP(c[i]);
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = 0; buf_len++;
             .     .    .              .           .    .           .      .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .     .    .              .           .    .           .      .    .      double    my_var_decay;
             .     .    .              .           .    .           .      .    .      bool   DISTANCE;
             .     .    .              .           .    .           .      .    .  };
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  //=================================================================================================
             .     .    .              .           .    .           .      .    .  // Implementation of inline methods:
             .     .    .              .           .    .           .      .    .  
   291,052,317     0    0    291,052,317   3,798,620   30           0      0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
 2,006,993,961    65   11  1,720,674,370 157,990,103    1 274,829,269      0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::insertVarOrder(Var x) {
             .     .    .              .           .    .           .      .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
 2,104,526,770   141    7    652,920,210     256,405    0           0      0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    36,448,098     1    1     24,298,732   6,346,152   39           0      0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::varDecayActivity() {
     6,195,388     0    0      3,097,694       5,612    0   1,548,847      0    0      var_inc *= (1 / var_decay); }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::varBumpActivity(Var v, double mult) {
 1,030,519,163    10    9    622,734,451  43,855,031    5 154,833,029      0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .     .    .              .           .    .           .      .    .          // Rescale:
         3,742   120   11              1           0    0           0      0    0          for (int i = 0; i < nVars(); i++)
       852,720     0    0        213,180      39,896  158     213,180      0    0              activity_VSIDS[i] *= 1e-100;
           748     0    0            374           0    0         374      0    0          var_inc *= 1e-100; }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      // Update order_heap with respect to new activity:
    91,506,796     0    0              0           0    0           0      0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .     .    .              .           .    .           .      .    .  
    13,609,340   167    2      6,804,670          12    0   3,402,335      0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .     .    .              .           .    .           .      .    .  inline void Solver::claBumpActivity (Clause& c) {
    90,097,228   546    9     26,869,674   3,174,583    3   9,089,470  6,800   32      if ( (c.activity() += cla_inc) > 1e20 ) {
             .     .    .              .           .    .           .      .    .          // Rescale:
     4,505,183    71    6            219           0    0           0      0    0          for (int i = 0; i < learnts_local.size(); i++)
    10,510,731    13    0      1,501,533   1,362,037  911   1,501,533      0    0              ca[learnts_local[i]].activity() *= 1e-20;
       797,691   169    7        398,736           0    0          73     73    0          cla_inc *= 1e-20; } }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .     .    .              .           .    .           .      .    .  inline void Solver::checkGarbage(double gf){
        12,366   185    0          4,122         299    0           0      0    0      if (ca.wasted() > ca.size() * gf)
           915     1    1            462         462    4           9      1    0          garbageCollect(); }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
             .     .    .              .           .    .           .      .    .  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::locked          (const Clause& c) const {
    44,390,960   226    5     14,699,456     346,414    0           0      0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    52,650,686   352   10     11,785,129      61,550    0           0      0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .     .    .              .           .    .           .      .    .  }
     8,031,328     1    1      4,015,658           0    0           0      0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .     .    .              .           .    .           .      .    .  
       285,139     4    4        150,290           0    0     134,849      0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
   745,943,704 2,324    8    135,094,186      80,880    0           0      0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
    12,163,005     0    0     12,163,005         248    0           0      0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
27,651,894,090    60   19 27,651,894,090      17,879    0           0      0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .     .    .              .           .    .           .      .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .     .    .              .           .    .           .      .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .     .    .              .           .    .           .      .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3     0    0              2           0    0           1      1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .     .    .              .           .    .           .      .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
       441,221     1    0          4,187          12    0           1      0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6     1    1              3           2    0           0      0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .     .    .              .           .    .           .      .    .  { 
         6,840     0    0          3,420          13    0           0      0    0      if      ( b && !decision[v]) dec_vars++;
         1,407     0    0            938         155    0           0      0    0      else if (!b &&  decision[v]) dec_vars--;
             .     .    .              .           .    .           .      .    .  
         1,609     0    0              0           0    0       1,609      0    0      decision[v] = b;
             .     .    .              .           .    .           .      .    .      if (b && !order_heap_CHB.inHeap(v)){
             .     .    .              .           .    .           .      .    .          order_heap_CHB.insert(v);
             .     .    .              .           .    .           .      .    .          order_heap_VSIDS.insert(v);
             .     .    .              .           .    .           .      .    .          order_heap_distance.insert(v);}
             .     .    .              .           .    .           .      .    .  }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .     .    .              .           .    .           .      .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr       DLmr Dw          D1mw DLmw 

-- line 30 ----------------------------------------
            .    .    .           .          .    .           .    .    .  
            .    .    .           .          .    .           .    .    .  //=================================================================================================
            .    .    .           .          .    .           .    .    .  // Removing and searching for elements:
            .    .    .           .          .    .           .    .    .  //
            .    .    .           .          .    .           .    .    .  
            .    .    .           .          .    .           .    .    .  template<class V, class T>
            .    .    .           .          .    .           .    .    .  static inline void remove(V& ts, const T& t)
            .    .    .           .          .    .           .    .    .  {
       16,035  153    1           0          0    0           0    0    0      int j = 0;
  929,629,073  114   34 155,614,257 19,933,949    0           0    0    0      for (; j < ts.size() && ts[j] != t; j++);
            .    .    .           .          .    .           .    .    .      assert(j < ts.size());
1,104,964,617  122   35 315,615,122 19,444,818    0 157,527,575    0    0      for (; j < ts.size()-1; j++) ts[j] = ts[j+1];
            .    .    .           .          .    .           .    .    .      ts.pop();
            .    .    .           .          .    .           .    .    .  }
            .    .    .           .          .    .           .    .    .  
            .    .    .           .          .    .           .    .    .  
            .    .    .           .          .    .           .    .    .  template<class V, class T>
            .    .    .           .          .    .           .    .    .  static inline bool find(V& ts, const T& t)
            .    .    .           .          .    .           .    .    .  {
            .    .    .           .          .    .           .    .    .      int j = 0;
      263,062    1    1      48,121      1,668    0           0    0    0      for (; j < ts.size() && ts[j] != t; j++);
            .    .    .           .          .    .           .    .    .      return j < ts.size();
            .    .    .           .          .    .           .    .    .  }
            .    .    .           .          .    .           .    .    .  
            .    .    .           .          .    .           .    .    .  
            .    .    .           .          .    .           .    .    .  //=================================================================================================
            .    .    .           .          .    .           .    .    .  // Copying vectors with support for nested vector types:
            .    .    .           .          .    .           .    .    .  //
            .    .    .           .          .    .           .    .    .  
-- line 58 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h
--------------------------------------------------------------------------------
Ir          I1mr  ILmr Dr          D1mr       DLmr  Dw         D1mw    DLmw 

-- line 36 ----------------------------------------
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  template <class T, class LessThan>
          .     .    .           .          .     .          .       .    .  void selectionSort(T* array, int size, LessThan lt)
          .     .    .           .          .     .          .       .    .  {
          .     .    .           .          .     .          .       .    .      int     i, j, best_i;
          .     .    .           .          .     .          .       .    .      T       tmp;
          .     .    .           .          .     .          .       .    .  
 16,384,218   215    6   5,689,312          0     0    690,504   4,634    0      for (i = 0; i < size-1; i++){
          .     .    .           .          .     .          .       .    .          best_i = i;
 90,124,187   571   15   5,700,311        843     0          0       0    0          for (j = i+1; j < size; j++){
310,806,175 1,582   36  30,898,202        440     0          0       0    0              if (lt(array[j], array[best_i]))
          .     .    .           .          .     .          .       .    .                  best_i = j;
          .     .    .           .          .     .          .       .    .          }
 22,772,892     0    0      15,644          0     0 11,378,624       0    0          tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
          .     .    .           .          .     .          .       .    .      }
          .     .    .           .          .     .          .       .    .  }
          .     .    .           .          .     .          .       .    .  template <class T> static inline void selectionSort(T* array, int size) {
          .     .    .           .          .     .          .       .    .      selectionSort(array, size, LessThan_default<T>()); }
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  template <class T, class LessThan>
  7,425,386   287   10           0          0     0  5,196,230 171,370   64  void sort(T* array, int size, LessThan lt)
          .     .    .           .          .     .          .       .    .  {
  3,768,532   228    6           0          0     0          0       0    0      if (size <= 15)
          .     .    .           .          .     .          .       .    .          selectionSort(array, size, lt);
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .      else{
  3,688,460     0    0     737,692     50,647     3          0       0    0          T           pivot = array[size / 2];
          .     .    .           .          .     .          .       .    .          T           tmp;
    737,692     0    0           0          0     0          0       0    0          int         i = -1;
          .     .    .           .          .     .          .       .    .          int         j = size;
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .          for(;;){
282,333,481   198    7  80,945,880 23,457,495 8,090          0       0    0              do i++; while(lt(array[i], pivot));
432,447,480    16    0 108,111,870 23,837,894 4,454          0       0    0              do j--; while(lt(pivot, array[j]));
          .     .    .           .          .     .          .       .    .  
 25,838,766     0    0           0          0     0          0       0    0              if (i >= j) break;
          .     .    .           .          .     .          .       .    .  
103,833,878   187    5           0          0     0 24,363,382  15,812    0              tmp = array[i]; array[i] = array[j]; array[j] = tmp;
          .     .    .           .          .     .          .       .    .          }
          .     .    .           .          .     .          .       .    .  
  2,213,076     0    0           0          0     0    737,692  83,408   18          sort(array    , i     , lt);
    737,692     0    0           0          0     0          0       0    0          sort(&array[i], size-i, lt);
          .     .    .           .          .     .          .       .    .      }
  5,949,550     0    0   5,203,931     19,930     0          0       0    0  }
          .     .    .           .          .     .          .       .    .  template <class T> static inline void sort(T* array, int size) {
          .     .    .           .          .     .          .       .    .      sort(array, size, LessThan_default<T>()); }
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  //=================================================================================================
          .     .    .           .          .     .          .       .    .  // For 'vec's:
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {
     23,781   213    5      15,854        138     0      7,927       0    0      sort((T*)v, v.size(), lt); }
          .     .    .           .          .     .          .       .    .  template <class T> void sort(vec<T>& v) {
          .     .    .           .          .     .          .       .    .      sort(v, LessThan_default<T>()); }
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  //=================================================================================================
          .     .    .           .          .     .          .       .    .  }
          .     .    .           .          .     .          .       .    .  
          .     .    .           .          .     .          .       .    .  #endif
-- line 98 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr             D1mr          DLmr Dw             D1mw          DLmw    

-- line 40 ----------------------------------------
             .       .    .              .             .    .              .             .       .      int sz;
             .       .    .              .             .    .              .             .       .      int cap;
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Don't allow copying (error prone):
             .       .    .              .             .    .              .             .       .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
             .       .    .              .             .    .              .             .       .               vec        (vec<T>& other) { assert(0); }
             .       .    .              .             .    .              .             .       .               
             .       .    .              .             .    .              .             .       .      // Helpers for calculating next capacity:
     2,071,011      11    8              0             0    0              0             0       0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
             .       .    .              .             .    .              .             .       .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .              .             .    .              .             .       .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  public:
             .       .    .              .             .    .              .             .       .      // Constructors:
       633,452      30   28              2             0    0        627,748        17,860   1,381      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
            42       0    0              0             0    0             42             0       0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
             .       .    .              .             .    .              .             .       .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
             .       .    .              .             .    .              .             .       .     ~vec()                                                          { clear(true); }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Pointer to first element:
             .       .    .              .             .    .              .             .       .      operator T*       (void)           { return data; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Size operations:
             .       .    .              .             .    .              .             .       .      int      size     (void) const     { return sz; }
   846,491,494   1,294    3     61,378,939     1,879,203    0     37,060,992             9       0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
             .       .    .              .             .    .              .             .       .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
             .       .    .              .             .    .              .             .       .      int      capacity (void) const     { return cap; }
             .       .    .              .             .    .              .             .       .      void     capacity (int min_cap);
             .       .    .              .             .    .              .             .       .      void     growTo   (int size);
             .       .    .              .             .    .              .             .       .      void     growTo   (int size, const T& pad);
             .       .    .              .             .    .              .             .       .      void     clear    (bool dealloc = false);
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Stack interface:
    13,651,480     247    6      6,818,825         1,626    0      3,413,070           169       0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
70,315,027,321 220,465  175 25,336,351,710 1,500,876,177  294 19,386,903,832 2,607,217,536 526,846      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
 1,452,755,115       0    0    369,305,215             0    0    713,768,974    24,900,931      97      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
   394,489,108       6    1     12,150,724             0    0    191,313,148            15       0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
             .       .    .              .             .    .              .             .       .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
             .       .    .              .             .    .              .             .       .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
             .       .    .              .             .    .              .             .       .      // happen given the way capacities are calculated (below). Essentially, all capacities are
             .       .    .              .             .    .              .             .       .      // even, but INT_MAX is odd.
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      const T& last  (void) const        { return data[sz-1]; }
   178,594,365       0    0              0             0    0              0             0       0      T&       last  (void)              { return data[sz-1]; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Vector interface:
47,343,160,874     501   44    153,446,888             0    0     12,192,200             0       0      const T& operator [] (int index) const { return data[index]; }
28,171,626,919     924   86  8,043,458,047    13,689,895  303    431,959,710            80       0      T&       operator [] (int index)       { return data[index]; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Duplicatation (preferred instead):
   854,795,471      29   11    287,200,047        27,947    0    138,496,521             0       0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
        16,364       0    0         16,304             0    0             40             0       0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
             .       .    .              .             .    .              .             .       .  };
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
       517,648       0    0              0             0    0        258,824             0       0  void vec<T>::capacity(int min_cap) {
    11,034,345      56   12      3,678,115             3    0              0             0       0      if (cap >= min_cap) return;
     1,812,183      16    9              0             0    0             20             0       0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     3,368,036      91   26        258,930            11    0        776,638           768       0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
             .       .    .              .             .    .              .             .       .          throw OutOfMemoryException();
     3,932,379       4    4      3,932,379             1    0              0             0       0   }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
             .       .    .              .             .    .              .             .       .  void vec<T>::growTo(int size, const T& pad) {
    36,472,038       9    9     12,156,206            53    0              0             0       0      if (sz >= size) return;
        22,800       4    4          2,280             0    0         10,260             0       0      capacity(size);
       128,822       7    7         20,521             0    0         10,261           143       0      for (int i = sz; i < size; i++) data[i] = pad;
    15,046,092       6    6            744             0    0         10,260             0       0      sz = size; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
        22,800       1    1              0             0    0          9,120             0       0  void vec<T>::growTo(int size) {
     6,832,075       1    1          7,982            21    0          4,560             0       0      if (sz >= size) return;
    13,611,686   2,301    6              0             0    0      6,805,833             0       0      capacity(size);
    47,724,142      49   12     13,620,786             0    0      6,804,693             0       0      for (int i = sz; i < size; i++) new (&data[i]) T();
    10,231,029       0    0      3,416,075             5    0      3,408,058             0       0      sz = size; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
             .       .    .              .             .    .              .             .       .  void vec<T>::clear(bool dealloc) {
   388,650,870 922,008   52    114,828,157     3,614,791    0          1,076             0       0      if (data != NULL){
         2,286       0    0              1             0    0              0             0       0          for (int i = 0; i < sz; i++) data[i].~T();
   728,850,762      11    8     20,668,116             0    0    140,152,772             3       0          sz = 0;
       140,928       5    5          5,494             0    0        134,743             1       0          if (dealloc) free(data), data = NULL, cap = 0; } }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  //=================================================================================================
             .       .    .              .             .    .              .             .       .  }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir            I1mr   ILmr Dr            D1mr        DLmr Dw            D1mw       DLmw 

-- line 31 ----------------------------------------
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  template<class Comp>
            .      .    .             .           .    .             .          .    .  class Heap {
            .      .    .             .           .    .             .          .    .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
            .      .    .             .           .    .             .          .    .      vec<int> heap;     // Heap of integers
            .      .    .             .           .    .             .          .    .      vec<int> indices;  // Each integers position (index) in the Heap
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .      // Index "traversal" functions
  355,055,541     15    6             0           0    0             0          0    0      static inline int left  (int i) { return i*2+1; }
1,234,154,112     25   10   493,629,344 151,364,449  608             0          0    0      static inline int right (int i) { return (i+1)*2; }
  737,022,873      7    5    93,561,442           0    0             0          0    0      static inline int parent(int i) { return (i-1) >> 1; }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
  187,122,884     23    9             0           0    0   187,122,884         37    0      void percolateUp(int i)
            .      .    .             .           .    .             .          .    .      {
  527,596,195      0    0   316,659,090  18,449,730    5   117,375,663          0    0          int x  = heap[i];
            .      .    .             .           .    .             .          .    .          int p  = parent(i);
            .      .    .             .           .    .             .          .    .          
2,263,060,262     18   13   759,403,427  63,082,579    5    17,208,681          0    0          while (i != 0 && lt(x, heap[p])){
  157,322,495     49   14             0           0    0   157,322,495          0    0              heap[i]          = heap[p];
  157,322,495      0    0             0           0    0   157,322,495 20,495,529    6              indices[heap[p]] = i;
            .      .    .             .           .    .             .          .    .              i                = p;
  166,666,894      0    0             0           0    0             0          0    0              p                = parent(p);
            .      .    .             .           .    .             .          .    .          }
  223,097,648     11    6    58,691,140           0    0   164,406,508          0    0          heap   [i] = x;
  235,836,633      2    2    58,697,501           0    0   164,412,997          0    0          indices[x] = i;
  367,357,098      0    0   280,684,326           0    0             0          0    0      }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
1,421,343,168      0    0   203,049,024           0    0 1,218,294,144        310    0      void percolateDown(int i)
            .      .    .             .           .    .             .          .    .      {
  642,273,413  1,152   24   421,211,363  68,834,852    8   221,048,472          0    0          int x = heap[i];
1,368,651,160 21,631   32   345,846,909           0    0             0          0    0          while (left(i) < heap.size()){
1,757,644,666     24    9   244,256,147   8,789,907   15             0          0    0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
  643,337,514     31    9             0           0    0             0          0    0              if (!lt(heap[child], x)) break;
  136,894,625      0    0             0           0    0   136,894,625          0    0              heap[i]          = heap[child];
  136,908,857      0    0        14,232           0    0   136,894,625 37,202,741  149              indices[heap[i]] = i;
  105,686,597      0    0             0           0    0             0          0    0              i                = child;
            .      .    .             .           .    .             .          .    .          }
  436,278,244     36   14   218,139,186           0    0   218,139,058          0    0          heap   [i] = x;
  248,264,809      1    1    15,072,576           0    0   218,139,058          0    0          indices[x] = i;
1,435,035,034      1    0 1,421,343,168           0    0             0          0    0      }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .    public:
            .      .    .             .           .    .             .          .    .      Heap(const Comp& c) : lt(c) { }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .      int  size      ()          const { return heap.size(); }
   12,150,724      1    1    12,150,724   1,840,195    2             0          0    0      bool empty     ()          const { return heap.size() == 0; }
5,276,575,277  1,139   37 2,714,840,662 134,815,743   29             0          0    0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
   25,283,794      7    6    15,890,584   1,373,131    3             0          0    0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
  469,861,856      0    0   328,492,370           0    0    93,561,442          0    0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
1,068,071,468      6    6   661,973,420           0    0   203,049,024          0    0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .      // Safe variant of insert/decrease/increase:
            .      .    .             .           .    .             .          .    .      void update(int n)
            .      .    .             .           .    .             .          .    .      {
            .      .    .             .           .    .             .          .    .          if (!inHeap(n))
            .      .    .             .           .    .             .          .    .              insert(n);
            .      .    .             .           .    .             .          .    .          else {
            .      .    .             .           .    .             .          .    .              percolateUp(indices[n]);
       13,234      0    0         6,617           0    0             0          0    0              percolateDown(indices[n]); }
            .      .    .             .           .    .             .          .    .      }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .      void insert(int n)
            .      .    .             .           .    .             .          .    .      {
   12,153,926      2    2             0           0    0             0          0    0          indices.growTo(n+1, -1);
            .      .    .             .           .    .             .          .    .          assert(!inHeap(n));
            .      .    .             .           .    .             .          .    .  
   24,307,852      1    1    12,153,926           0    0    12,153,926          0    0          indices[n] = heap.size();
       11,148      1    1             0           0    0         7,392          0    0          heap.push(n);
   24,307,852      0    0    12,153,926           0    0             0          0    0          percolateUp(indices[n]); 
            .      .    .             .           .    .             .          .    .      }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .      int  removeMin()
            .      .    .             .           .    .             .          .    .      {
   36,452,172      1    1    24,301,448   1,094,793    1    12,150,724        338    0          int x            = heap[0];
   24,301,448      0    0    12,150,724   2,506,609    5    12,150,724          0    0          heap[0]          = heap.last();
   24,301,448     33    9    12,150,724           0    0    12,150,724  6,386,366   31          indices[heap[0]] = 0;
   12,150,724      1    1             0           0    0    12,150,724  2,291,356    2          indices[x]       = -1;
            .      .    .             .           .    .             .          .    .          heap.pop();
   24,301,448      0    0             0           0    0             0          0    0          if (heap.size() > 1) percolateDown(0);
            .      .    .             .           .    .             .          .    .          return x; 
            .      .    .             .           .    .             .          .    .      }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .      // Rebuild the heap from scratch, using the elements in 'ns':
            .      .    .             .           .    .             .          .    .      void build(const vec<int>& ns) {
       58,282     25   11        29,141          32    1             0          0    0          for (int i = 0; i < heap.size(); i++)
       29,189     15    5            48           0    0        29,045      2,514  349              indices[heap[i]] = -1;
           48      0    0             0           0    0             0          0    0          heap.clear();
            .      .    .             .           .    .             .          .    .  
       54,618     14    5        27,237           0    0             0          0    0          for (int i = 0; i < ns.size(); i++){
       54,378      0    0        27,189           0    0        27,189          1    1              indices[ns[i]] = i;
            .      .    .             .           .    .             .          .    .              heap.push(ns[i]); }
            .      .    .             .           .    .             .          .    .  
       95,542     46   15        13,626           0    0            48          0    0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
            .      .    .             .           .    .             .          .    .              percolateDown(i);
            .      .    .             .           .    .             .          .    .      }
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .      void clear(bool dealloc = false) 
            .      .    .             .           .    .             .          .    .      { 
            4      0    0             2           1    0             0          0    0          for (int i = 0; i < heap.size(); i++)
            .      .    .             .           .    .             .          .    .              indices[heap[i]] = -1;
            .      .    .             .           .    .             .          .    .          heap.clear(dealloc); 
            .      .    .             .           .    .             .          .    .      }
            .      .    .             .           .    .             .          .    .  };
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  
            .      .    .             .           .    .             .          .    .  //=================================================================================================
            .      .    .             .           .    .             .          .    .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
Ir                I1mr      ILmr  Dr              D1mr           DLmr      Dw              D1mw          DLmw      
--------------------------------------------------------------------------------
1,137,079,649,613 1,728,691 3,194 370,687,538,017 16,492,525,287 1,142,509 130,619,507,010 3,344,572,649 1,699,713  events annotated

