--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         17825792 B, 64 B, 17-way associative
Command:          ./glucose_release ./cnfs/Trivium_no_init_out350_known_last142_1.cnf
Data file:        Trivium_no_init_out350_known_last142_1.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir              I1mr      ILmr   Dr              D1mr           DLmr      Dw              D1mw          DLmw      
--------------------------------------------------------------------------------
945,982,022,692 2,015,059 13,055 313,182,188,090 13,645,295,123 3,712,102 110,966,797,849 2,703,312,614 3,370,089  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr              D1mr          DLmr      Dw             D1mw          DLmw     file:function
--------------------------------------------------------------------------------
473,686,596,835   1,751   72 184,509,526,146 8,311,379,344    69,679 53,262,153,354     2,211,669       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
189,581,938,251      10    5  28,187,654,783 1,147,334,313    21,009 27,361,372,423             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
 86,776,451,369  60,388   46  18,031,356,962 1,063,736,966       489 10,915,947,310 1,619,061,993 570,049  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
 23,845,245,718       2    2  23,551,863,820   102,503,318         0    293,380,666             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
 16,953,688,239     294  162   4,224,999,883   664,711,653    47,148  1,725,553,513     5,143,900      96  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
 14,184,823,565  13,105  229   5,153,896,492   211,109,402        88    919,329,973     3,304,044      10  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 11,396,562,249      71   43   3,083,327,011   127,139,249    14,627              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
 10,053,618,739   5,664   79   3,924,234,069   331,819,423        42  1,189,069,322    77,910,141       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
  9,930,875,876       0    0   4,965,437,938         4,886         0              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
  9,674,137,384      10    6   4,125,993,496   166,276,730       176  2,941,698,447   619,105,561   1,951  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  8,594,121,673      41   21   2,174,021,525    69,481,746       403  1,625,462,876   155,537,559  72,175  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
  7,861,254,433   3,354  121   1,833,957,520     1,300,649         0    799,945,177    16,790,064   3,163  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  6,660,166,630   6,502   55   2,286,159,206    34,668,890        27    848,458,819     1,602,871       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  6,491,357,380  10,554   20   2,516,518,101   210,236,808       129  1,604,001,289    11,557,893       2  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  6,123,341,319 427,569  430   1,323,262,315    31,735,323       120    597,218,750     6,887,162       0  ???:__ieee754_pow_fma
  5,635,336,088     132   14   2,684,040,818    84,512,656       338    315,529,294     2,421,159      26  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  5,630,332,302     634   73   1,504,989,970   119,055,427       387     50,826,290        61,536       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  4,612,647,143     703   93   2,201,129,076    85,557,731       831    382,412,195            56       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  4,352,901,110 351,577   47     983,381,758             1         0    752,522,429     4,918,151      68  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  3,121,597,122     806   46   1,425,214,662    99,383,499       408    437,547,916     7,859,563      24  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  2,992,347,855      15   11     994,771,396    30,581,762        17    567,289,364     9,900,320      10  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
  2,589,959,476     206   23   1,059,411,367     6,734,351        48              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  2,255,986,477     172   24     675,680,454   137,020,734       160              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  2,238,076,638      81   43     442,677,631    47,207,524       943    238,019,175    28,737,122     704  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
  2,151,975,716       5    5     735,280,088     1,969,366         0    681,415,540    20,550,860     169  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  2,044,245,260       0    0   1,362,829,830    10,268,546         0    340,707,200    43,661,856      80  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  1,848,370,975   3,014  206     443,441,474    30,459,402     1,196     49,326,737        43,373       0  ???:__exp1_fma
  1,793,206,394     485   14     546,001,147       125,994         0     36,796,880     1,137,595      12  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  1,362,831,080       0    0     340,707,770             0         0    340,707,770         4,581       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  1,148,840,674       0    0     574,420,337         5,202         0              0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::simplePropagate()
  1,142,540,064   1,180  209     284,183,734    30,511,774    99,853    164,969,001     7,510,994 321,636  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
  1,057,538,510   2,222  354     193,786,333    37,580,630    22,474     32,084,501       222,660     310  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h:void Minisat::sort<unsigned int, reduceDB_lt>(unsigned int*, int, reduceDB_lt)
    994,535,680   3,488   25     275,965,528         7,571         8    165,531,864            14       0  ???:pow

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr             D1mr          DLmr Dw             D1mw          DLmw    

-- line 40 ----------------------------------------
             .       .    .              .             .    .              .             .       .      int sz;
             .       .    .              .             .    .              .             .       .      int cap;
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Don't allow copying (error prone):
             .       .    .              .             .    .              .             .       .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
             .       .    .              .             .    .              .             .       .               vec        (vec<T>& other) { assert(0); }
             .       .    .              .             .    .              .             .       .               
             .       .    .              .             .    .              .             .       .      // Helpers for calculating next capacity:
     1,265,874      14    9              0             0    0              0             0       0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
             .       .    .              .             .    .              .             .       .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .              .             .    .              .             .       .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  public:
             .       .    .              .             .    .              .             .       .      // Constructors:
       273,056      23   23              2             0    0        262,117         3,571   2,137      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
            50       0    0              0             0    0             50             0       0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
             .       .    .              .             .    .              .             .       .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
             .       .    .              .             .    .              .             .       .     ~vec()                                                          { clear(true); }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Pointer to first element:
             .       .    .              .             .    .              .             .       .      operator T*       (void)           { return data; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Size operations:
             .       .    .              .             .    .              .             .       .      int      size     (void) const     { return sz; }
   746,439,711     676   21     11,856,786     1,411,927    0     27,982,043             1       0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
             .       .    .              .             .    .              .             .       .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
             .       .    .              .             .    .              .             .       .      int      capacity (void) const     { return cap; }
             .       .    .              .             .    .              .             .       .      void     capacity (int min_cap);
             .       .    .              .             .    .              .             .       .      void     growTo   (int size);
             .       .    .              .             .    .              .             .       .      void     growTo   (int size, const T& pad);
             .       .    .              .             .    .              .             .       .      void     clear    (bool dealloc = false);
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Stack interface:
    10,476,767     626    5      5,234,102         5,260    0      2,618,080             0       0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
48,577,153,800  63,301  285 17,747,726,374 1,135,736,657  892 13,293,803,956 1,807,550,189 658,909      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
 1,383,442,369       0    0    346,807,907            12    0    690,114,024    21,113,653     197      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
   316,783,447       3    0      8,781,700             0    0    154,049,592             3       0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
             .       .    .              .             .    .              .             .       .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
             .       .    .              .             .    .              .             .       .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
             .       .    .              .             .    .              .             .       .      // happen given the way capacities are calculated (below). Essentially, all capacities are
             .       .    .              .             .    .              .             .       .      // even, but INT_MAX is odd.
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      const T& last  (void) const        { return data[sz-1]; }
   145,097,057       0    0              0             0    0              0             0       0      T&       last  (void)              { return data[sz-1]; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Vector interface:
39,016,339,619     536   44    113,009,450             0    0      8,877,200             0       0      const T& operator [] (int index) const { return data[index]; }
21,365,242,784     734  168  5,823,823,840     4,686,272    0    461,006,153            65       0      T&       operator [] (int index)       { return data[index]; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .      // Duplicatation (preferred instead):
   743,329,945       7    7    249,516,289        44,700    0    120,843,953             0       0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
        39,038       0    0         38,966             4    0             48             0       0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
             .       .    .              .             .    .              .             .       .  };
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
       316,358       0    0              0             0    0        158,179             0       0  void vec<T>::capacity(int min_cap) {
     8,400,855      61   16      2,800,285             0    0              0             0       0      if (cap >= min_cap) return;
     1,107,693       6    4              0             0    0             24             0       0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     2,060,257      96   33        158,295             4    0        474,712           399       0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
             .       .    .              .             .    .              .             .       .          throw OutOfMemoryException();
     2,949,716       2    2      2,949,716            13    0              0             0       0   }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
             .       .    .              .             .    .              .             .       .  void vec<T>::growTo(int size, const T& pad) {
    26,383,623       6    6      8,792,354            24    0              0             0       0      if (sz >= size) return;
        43,740       4    4          4,374             0    0         19,683             0       0      capacity(size);
       247,133       7    7         39,367             0    0         19,684           188       0      for (int i = sz; i < size; i++) data[i] = pad;
    10,133,311       6    5          2,687             0    0         19,683             0       0      sz = size; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
        43,740       1    1              0             0    0         17,496             0       0  void vec<T>::growTo(int size) {
     5,271,465       1    1         15,312            36    0          8,748             0       0      if (sz >= size) return;
    10,442,298     646   27              0             0    0      5,221,137             0       0      capacity(size);
    36,707,766      35   18     10,459,770             0    0      5,218,949             0       0      for (int i = sz; i < size; i++) new (&data[i]) T();
     7,874,413       0    0      2,635,778            12    0      2,620,424             4       0      sz = size; }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  template<class T>
             .       .    .              .             .    .              .             .       .  void vec<T>::clear(bool dealloc) {
   322,010,287 352,057  132     97,290,066     2,551,363    0          1,617             0       0      if (data != NULL){
         4,380       0    0              1             0    0              0             0       0          for (int i = 0; i < sz; i++) data[i].~T();
   599,664,779       3    3     13,742,658             0    0    114,914,552       168,029       0          sz = 0;
        50,066       5    5          7,777             0    0         41,007           803       0          if (dealloc) free(data), data = NULL, cap = 0; } }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  //=================================================================================================
             .       .    .              .             .    .              .             .       .  }
             .       .    .              .             .    .              .             .       .  
             .       .    .              .             .    .              .             .       .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr             D1mr          DLmr    Dw             D1mw        DLmw 

-- line 51 ----------------------------------------
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Options:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static const char* _cat = "CORE";
             .       .    .              .             .       .              .           .    .  
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
             4       1    1              0             0       0              1           0    0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
             4       0    0              0             0       0              1           0    0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
             4       0    0              0             0       0              1           0    0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
             4       0    0              0             0       0              1           0    0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
             4       1    1              0             0       0              1           0    0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
             4       0    0              0             0       0              1           0    0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
             4       1    1              0             0       0              1           0    0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
             4       1    1              0             0       0              1           0    0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
             4       1    1              0             0       0              1           0    0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
             4       1    1              0             0       0              1           0    0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
             .       .    .              .             .       .              .           .    .  
             4       1    1              0             0       0              1           0    0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
             1       1    1              0             0       0              1           0    0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
             4       0    0              0             0       0              1           0    0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
             .       .    .              .             .       .              .           .    .  
             4       1    1              0             0       0              1           0    0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //VSIDS_props_limit
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Constructor/Destructor:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             4       1    1              0             0       0              2           0    0  Solver::Solver() :
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Parameters (user settable):
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      drup_file        (NULL)
             .       .    .              .             .       .              .           .    .    , verbosity        (0)
             .       .    .              .             .       .              .           .    .    , step_size        (opt_step_size)
             .       .    .              .             .       .              .           .    .    , step_size_dec    (opt_step_size_dec)
             .       .    .              .             .       .              .           .    .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
             .       .    .              .             .       .              .           .    .    , garbage_frac     (opt_garbage_frac)
             .       .    .              .             .       .              .           .    .    , restart_first    (opt_restart_first)
             .       .    .              .             .       .              .           .    .    , restart_inc      (opt_restart_inc)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    , min_number_of_learnts_copies(opt_min_dupl_app)  
             .       .    .              .             .       .              .           .    .    , max_lbd_dup(opt_max_lbd_dup)
             .       .    .              .             .       .              .           .    .    , dupl_db_init_size(opt_dupl_db_init_size)
             3       1    1              1             0       0              1           0    0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    // Parameters (the rest):
             .       .    .              .             .       .              .           .    .    //
             .       .    .              .             .       .              .           .    .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    // Parameters (experimental):
             .       .    .              .             .       .              .           .    .    //
             .       .    .              .             .       .              .           .    .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
             .       .    .              .             .       .              .           .    .    //
             .       .    .              .             .       .              .           .    .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
             .       .    .              .             .       .              .           .    .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
             .       .    .              .             .       .              .           .    .    , chrono_backtrack(0), non_chrono_backtrack(0)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    , ok                 (true)
             .       .    .              .             .       .              .           .    .    , cla_inc            (1)
             .       .    .              .             .       .              .           .    .    , var_inc            (1)
             1       0    0              0             0       0              0           0    0    , watches_bin        (WatcherDeleted(ca))
             .       .    .              .             .       .              .           .    .    , watches            (WatcherDeleted(ca))
             .       .    .              .             .       .              .           .    .    , qhead              (0)
             .       .    .              .             .       .              .           .    .    , simpDB_assigns     (-1)
             .       .    .              .             .       .              .           .    .    , simpDB_props       (0)
             .       .    .              .             .       .              .           .    .    , order_heap_CHB     (VarOrderLt(activity_CHB))
             .       .    .              .             .       .              .           .    .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
             .       .    .              .             .       .              .           .    .    , progress_estimate  (0)
             .       .    .              .             .       .              .           .    .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
             .       .    .              .             .       .              .           .    .    // simplifyAll adjust occasion
             .       .    .              .             .       .              .           .    .    , curSimplify(1)
             .       .    .              .             .       .              .           .    .    , nbconfbeforesimplify(1000)
             .       .    .              .             .       .              .           .    .    , incSimplify(1000)
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    , my_var_decay       (0.6)
             .       .    .              .             .       .              .           .    .    , DISTANCE           (true)
             .       .    .              .             .       .              .           .    .    , var_iLevel_inc     (1)
            94       8    8             25             2       2             63           1    0    , order_heap_distance(VarOrderLt(activity_distance))
             .       .    .              .             .       .              .           .    .  
             4       0    0              3             0       0              0           0    0  {}
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  Solver::~Solver()
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // simplify All
             .       .    .              .             .       .              .           .    .  //
             .       .    .              .             .       .              .           .    .  CRef Solver::simplePropagate()
     9,087,608       5    4              0             0       0      6,815,706       4,156    0  {
     1,135,951       0    0              0             0       0      1,135,951           0    0      CRef    confl = CRef_Undef;
     1,135,951       0    0              0             0       0      1,135,951           0    0      int     num_props = 0;
     2,271,902       0    0              0             0       0      1,135,951       3,288    0      watches.cleanAll();
     3,407,853      36   19      1,135,951             0       0      1,135,951           0    0      watches_bin.cleanAll();
    10,683,576       0    0      5,341,788            19       0              0           0    0      while (qhead < trail.size())
             .       .    .              .             .       .              .           .    .      {
    21,041,400       1    1      8,416,560       323,084       0      8,416,560           0    0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .       .    .              .             .       .              .           .    .          vec<Watcher>&  ws = watches[p];
             .       .    .              .             .       .              .           .    .          Watcher        *i, *j, *end;
     4,205,837       0    0      4,205,837             0       0              0           0    0          num_props++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // First, Propagate binary clauses
             .       .    .              .             .       .              .           .    .          vec<Watcher>&  wbin = watches_bin[p];
             .       .    .              .             .       .              .           .    .  
    28,734,311       0    0      4,208,280     4,170,285     399              0           0    0          for (int k = 0; k<wbin.size(); k++)
             .       .    .              .             .       .              .           .    .          {
             .       .    .              .             .       .              .           .    .  
     7,222,496       0    0      6,254,586     2,659,228      56              0           0    0              Lit imp = wbin[k].blocker;
             .       .    .              .             .       .              .           .    .  
     7,222,496       0    0              0             0       0              0           0    0              if (value(imp) == l_False)
             .       .    .              .             .       .              .           .    .              {
         4,886       0    0          2,443             0       0          2,443           0    0                  return wbin[k].cref;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
     7,217,610       6    5              0             0       0              0           0    0              if (value(imp) == l_Undef)
             .       .    .              .             .       .              .           .    .              {
     1,749,865       0    0      1,749,865             0       0              0           0    0                  simpleUncheckEnqueue(imp, wbin[k].cref);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
 1,355,490,556      22   11    665,313,016     2,399,441      77      8,168,401           0    0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
             .       .    .              .             .       .              .           .    .          {
             .       .    .              .             .       .              .           .    .              // Try to avoid inspecting the clause:
   656,901,342      32   18    656,901,342    82,284,959   8,471              0           0    0              Lit blocker = i->blocker;
 1,313,802,684       0    0    656,901,342     4,431,826      17              0           0    0              if (value(blocker) == l_True)
             .       .    .              .             .       .              .           .    .              {
             .       .    .              .             .       .              .           .    .                  *j++ = *i++; continue;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Make sure the false literal is data[1]:
 1,148,840,674       0    0    574,420,337             0       0              0           0    0              CRef     cr = i->cref;
             .       .    .              .             .       .              .           .    .              Clause&  c = ca[cr];
             .       .    .              .             .       .              .           .    .              Lit      false_lit = ~p;
 1,723,261,011       0    0    574,420,337   552,717,824  37,142              0           0    0              if (c[0] == false_lit)
   686,860,356       0    0    228,953,452    13,836,631     959    457,906,904           0    0                  c[0] = c[1], c[1] = false_lit;
             .       .    .              .             .       .              .           .    .              assert(c[1] == false_lit);
             .       .    .              .             .       .              .           .    .              //  i++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // If 0th watch is true, then clause is already satisfied.
             .       .    .              .             .       .              .           .    .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
             .       .    .              .             .       .              .           .    .              // why not simply do i->blocker=first in this case?
             .       .    .              .             .       .              .           .    .              Lit     first = c[0];
             .       .    .              .             .       .              .           .    .              //  Watcher w     = Watcher(cr, first);
 1,472,571,446       0    0    161,865,386       429,275       1              0           0    0              if (first != blocker && value(first) == l_True)
             .       .    .              .             .       .              .           .    .              {
    34,648,835       0    0              0             0       0     34,648,835           0    0                  i->blocker = first;
   468,519,360       0    0    117,129,840             0       0    117,129,840   2,118,449    0                  *j++ = *i++; continue;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Look for new watch:
             .       .    .              .             .       .              .           .    .              //if (incremental)
             .       .    .              .             .       .              .           .    .              //{ // ----------------- INCREMENTAL MODE
             .       .    .              .             .       .              .           .    .              //	int choosenPos = -1;
             .       .    .              .             .       .              .           .    .              //	for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .    .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
             .       .    .              .             .       .              .           .    .              //		Watcher w = Watcher(cr, first); i++;
             .       .    .              .             .       .              .           .    .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
             .       .    .              .             .       .              .           .    .              //		watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .    .              //		goto NextClause;
             .       .    .              .             .       .              .           .    .              //	}
             .       .    .              .             .       .              .           .    .              //}
             .       .    .              .             .       .              .           .    .              else
             .       .    .              .             .       .              .           .    .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
 1,597,027,161      36   21              0             0       0              0           0    0                  for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .    .                  {
             .       .    .              .             .       .              .           .    .  
 3,228,704,179       0    0              0             0       0              0           0    0                      if (value(c[k]) != l_False)
             .       .    .              .             .       .              .           .    .                      {
             .       .    .              .             .       .              .           .    .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
             .       .    .              .             .       .              .           .    .                          // the blocker is first in the watcher. However,
             .       .    .              .             .       .              .           .    .                          // the blocker in the corresponding watcher in ~first is not c[1]
             .       .    .              .             .       .              .           .    .                          Watcher w = Watcher(cr, first); i++;
 2,153,109,408       0    0    538,277,352             0       0  1,076,554,704           0    0                          c[1] = c[k]; c[k] = false_lit;
             .       .    .              .             .       .              .           .    .                          watches[~c[1]].push(w);
   538,277,352       0    0              0             0       0              0           0    0                          goto NextClause;
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Did not find watch -- clause is unit under assignment:
     1,494,150       0    0              0             0       0      1,494,150           0    0              i->blocker = first;
     5,976,600       2    2      1,494,150             0       0      1,494,150      18,205    0              *j++ = *i++;
     2,988,300      36   19              0             0       0              0           0    0              if (value(first) == l_False)
             .       .    .              .             .       .              .           .    .              {
       201,943      10    4              0             0       0         31,754          19    0                  confl = cr;
        63,508      27   14         31,754             0       0         31,754       1,377    0                  qhead = trail.size();
             .       .    .              .             .       .              .           .    .                  // Copy the remaining watches:
     3,962,362       3    1         59,441         2,276       0              0           0    0                  while (i < end)
     1,889,986       0    0      1,889,986       233,370      26      1,889,986      13,463    0                      *j++ = *i++;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else
             .       .    .              .             .       .              .           .    .              {
             .       .    .              .             .       .              .           .    .                  simpleUncheckEnqueue(first, cr);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  NextClause:;
             .       .    .              .             .       .              .           .    .          }
     7,925,128      36   20              0             0       0              0           0    0          ws.shrink(i - j);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
     2,267,016       0    0      2,267,016       558,341       0              0           0    0      s_propagations += num_props;
             .       .    .              .             .       .              .           .    .  
     1,133,508       0    0      1,133,508             0       0              0           0    0      return confl;
   431,550,453      42   23      7,951,657       541,277       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
             .       .    .              .             .       .              .           .    .      assert(value(p) == l_Undef);
     3,212,261       0    0              0             0       0      3,212,261           0    0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
     8,696,424      36   18      4,348,212       128,100       0      4,348,212   4,012,290  138      vardata[var(p)].reason = from;
     2,598,347       0    0      2,598,347             0       0              0           0    0      trail.push_(p);
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::cancelUntilTrailRecord()
             .       .    .              .             .       .              .           .    .  {
     9,181,649       0    0        194,090         1,498       0              0           0    0      for (int c = trail.size() - 1; c >= trailRecord; c--)
             .       .    .              .             .       .              .           .    .      {
        97,045      36   18         97,045             0       0              0           0    0          Var x = var(trail[c]);
     4,639,347       0    0         97,045             0       0      4,348,212      36,722    0          assigns[x] = l_Undef;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      }
        97,045       0    0              0             0       0         97,045           0    0      qhead = trailRecord;
       194,090       0    0              0             0       0              0           0    0      trail.shrink(trail.size() - trailRecord);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::litsEnqueue(int cutP, Clause& c)
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .      for (int i = cutP; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .      {
             .       .    .              .             .       .              .           .    .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::removed(CRef cr) {
             .       .    .              .             .       .              .           .    .      return ca[cr].mark() == 1;
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
     1,050,929      33   16              0             0       0        573,234           0    0  {
        95,539       0    0              0             0       0              0           0    0      int pathC = 0;
        95,539       0    0              0             0       0              0           0    0      Lit p = lit_Undef;
       286,617       0    0         95,539             0       0              0           0    0      int index = trail.size() - 1;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      do{
     3,784,224      36   18              0             0       0              0           0    0          if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .    .              reason_clause.push(confl);
             .       .    .              .             .       .              .           .    .              Clause& c = ca[confl];
             .       .    .              .             .       .              .           .    .              // Special case for binary clauses
             .       .    .              .             .       .              .           .    .              // The first one has to be SAT
     3,452,240      36   18              0             0       0              0           0    0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .    .                  Lit tmp = c[0];
       175,623       0    0         58,541         3,571       2        117,082           0    0                  c[0] = c[1], c[1] = tmp;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              // if True_confl==true, then choose p begin with the 1th index of c;
     8,718,662       0    0      2,071,140        93,947       0              0           0    0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
             .       .    .              .             .       .              .           .    .                  Lit q = c[j];
     5,018,842       0    0      2,509,421       573,787      16              0           0    0                  if (!seen[var(q)]){
     1,796,573       0    0              0             0       0      1,796,573           0    0                      seen[var(q)] = 1;
     5,389,719       0    0      1,796,573             0       0              0           0    0                      pathC++;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else if (confl == CRef_Undef){
             .       .    .              .             .       .              .           .    .              out_learnt.push(~p);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
     6,297,824      36   18      1,796,573             0       0              0           0    0          if (pathC == 0) break;
             .       .    .              .             .       .              .           .    .          // Select next clause to look at:
    31,117,365       0    0     10,372,455       744,659       4              0           0    0          while (!seen[var(trail[index--])]);
             .       .    .              .             .       .              .           .    .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
             .       .    .              .             .       .              .           .    .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
     3,593,146       0    0      1,796,573        93,443       0              0           0    0          if (trailRecord > index + 1) break;
             .       .    .              .             .       .              .           .    .          p = trail[index + 1];
             .       .    .              .             .       .              .           .    .          confl = reason(var(p));
     1,796,573       0    0              0             0       0      1,796,573           0    0          seen[var(p)] = 0;
     1,796,573       0    0              0             0       0              0           0    0          pathC--;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      } while (pathC >= 0);
       955,390      36   17        668,773            16       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::simplifyLearnt(Clause& c)
       873,405      72   37              0             0       0        582,270       2,974    0  {
             .       .    .              .             .       .              .           .    .      ////
        97,045       0    0         97,045         5,318       0              0           0    0      original_length_record += c.size();
             .       .    .              .             .       .              .           .    .  
       194,090       0    0         97,045         3,202       0         97,045      11,338    0      trailRecord = trail.size();// record the start pointer
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      vec<Lit> falseLit;
             .       .    .              .             .       .              .           .    .      falseLit.clear();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
             .       .    .              .             .       .              .           .    .  
        68,394      34   19              0             0       0              0           0    0      bool True_confl = false;
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      beforeSize = c.size();
             .       .    .              .             .       .              .           .    .      int i, j;
             .       .    .              .             .       .              .           .    .      CRef confl;
             .       .    .              .             .       .              .           .    .  
     3,965,358      36   18              0             0       0              0           0    0      for (i = 0, j = 0; i < c.size(); i++){
     2,446,470       0    0              0             0       0              0           0    0          if (value(c[i]) == l_Undef){
             .       .    .              .             .       .              .           .    .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
             .       .    .              .             .       .              .           .    .              simpleUncheckEnqueue(~c[i]);
     4,509,607       0    0      1,135,951             0       0      1,135,951       2,019    0              c[j++] = c[i];
     3,407,853       0    0              0             0       0      1,135,951         191    0              confl = simplePropagate();
     3,407,853      36   19      1,135,951       543,533       0              0           0    0              if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .    .                  break;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{
       174,568       0    0              0             0       0              0           0    0              if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .    .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
       245,368      32   15         61,342             0       0         61,342         345    0                  c[j++] = c[i];
        61,342      19    6              0             0       0              0           0    0                  True_confl = true;
             .       .    .              .             .       .              .           .    .                  confl = reason(var(c[i]));
             .       .    .              .             .       .              .           .    .                  break;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
             .       .    .              .             .       .              .           .    .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
             .       .    .              .             .       .              .           .    .                  falseLit.push(c[i]);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      c.shrink(c.size() - j);
             .       .    .              .             .       .              .           .    .      afterSize = c.size();
             .       .    .              .             .       .              .           .    .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      if (confl != CRef_Undef || True_confl == true){
        95,539       0    0              0             0       0              0           0    0          simp_learnt_clause.clear();
        95,539       0    0              0             0       0              0           0    0          simp_reason_clause.clear();
       191,078       0    0              0             0       0              0           0    0          if (True_confl == true){
             .       .    .              .             .       .              .           .    .              simp_learnt_clause.push(c.last());
             .       .    .              .             .       .              .           .    .          }
       668,773      17   12              0             0       0         95,539           0    0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
             .       .    .              .             .       .              .           .    .  
       286,617       0    0         95,539             0       0              0           0    0          if (simp_learnt_clause.size() < c.size()){
       467,724      36   18        201,958             0       0              0           0    0              for (i = 0; i < simp_learnt_clause.size(); i++){
       744,024       0    0        186,006             0       0        186,006       2,177    0                  c[i] = simp_learnt_clause[i];
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              c.shrink(c.size() - i);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      cancelUntilTrailRecord();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
        97,045       0    0         97,045             0       0              0           0    0      simplified_length_record += c.size();
             .       .    .              .             .       .              .           .    .  
       776,360       0    0        679,315        94,573       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      int learnts_x_size_before = learnts_x.size();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .    .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .    .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      return true;
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyLearnt_core()
           396       0    0              0             0       0            216           0    0  {
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      int learnts_core_size_before = learnts_core.size();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .    .      bool sat, false_lit;
             .       .    .              .             .       .              .           .    .      unsigned int nblevels;
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      //printf("learnts_x size : %d\n", learnts_x.size());
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      int nbSimplified = 0;
             .       .    .              .             .       .              .           .    .      int nbSimplifing = 0;
             .       .    .              .             .       .              .           .    .  
       710,013      36   22             36             0       0              0           0    0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     1,064,817      36   19        709,878        22,206     789              0           0    0          CRef cr = learnts_core[ci];
             .       .    .              .             .       .              .           .    .          Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .  
       709,878       0    0              0             0       0              0           0    0          if (removed(cr)) continue;
       709,878       0    0        354,939        40,777     612              0           0    0          else if (c.simplified()){
       683,516       0    0              0             0       0        341,758           0    0              learnts_core[cj++] = learnts_core[ci];
             .       .    .              .             .       .              .           .    .              ////
     1,025,274       0    0        341,758             0       0              0           0    0              nbSimplified++;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{
             .       .    .              .             .       .              .           .    .              int saved_size=c.size();
             .       .    .              .             .       .              .           .    .              //         if (drup_file){
             .       .    .              .             .       .              .           .    .              //                 add_oc.clear();
             .       .    .              .             .       .              .           .    .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .       .    .              .             .       .              .           .    .              ////
             .       .    .              .             .       .              .           .    .              nbSimplifing++;
        13,181       0    0              0             0       0              0           0    0              sat = false_lit = false;
       263,858       0    0              0             0       0              0           0    0              for (int i = 0; i < c.size(); i++){
       263,858       0    0              0             0       0              0           0    0                  if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .    .                      sat = true;
             .       .    .              .             .       .              .           .    .                      break;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else if (value(c[i]) == l_False){
       290,220      36   19              0             0       0         13,181           0    0                      false_lit = true;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              if (sat){
             .       .    .              .             .       .              .           .    .                  removeClause(cr);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
        79,086       0    0              0             0       0         39,543           0    0                  detachClause(cr, true);
             .       .    .              .             .       .              .           .    .  
        52,724      36   18         26,362             0       0              0           0    0                  if (false_lit){
             .       .    .              .             .       .              .           .    .                      for (li = lj = 0; li < c.size(); li++){
             .       .    .              .             .       .              .           .    .                          if (value(c[li]) != l_False){
             .       .    .              .             .       .              .           .    .                              c[lj++] = c[li];
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      c.shrink(li - lj);
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  beforeSize = c.size();
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 1);
             .       .    .              .             .       .              .           .    .                  // simplify a learnt clause c
        52,724       0    0              0             0       0         26,362           0    0                  simplifyLearnt(c);
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 0);
             .       .    .              .             .       .              .           .    .                  afterSize = c.size();
             .       .    .              .             .       .              .           .    .                  
        60,356       0    0         39,543        12,750       1              0           0    0                  if(drup_file && saved_size !=c.size()){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .                      binDRUP('a', c , drup_file);
             .       .    .              .             .       .              .           .    .                      //                    binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                      for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .                      fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
             .       .    .              .             .       .              .           .    .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .    .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .    .                      //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .       .    .              .             .       .              .           .    .  
        26,362       0    0              0             0       0              0           0    0                  if (c.size() == 1){
             .       .    .              .             .       .              .           .    .                      // when unit clause occur, enqueue and propagate
             .       .    .              .             .       .              .           .    .                      uncheckedEnqueue(c[0]);
             .       .    .              .             .       .              .           .    .                      if (propagate() != CRef_Undef){
             .       .    .              .             .       .              .           .    .                          ok = false;
             .       .    .              .             .       .              .           .    .                          return false;
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      // delete the clause memory in logic
             .       .    .              .             .       .              .           .    .                      c.mark(1);
-- line 671 ----------------------------------------
-- line 675 ----------------------------------------
             .       .    .              .             .       .              .           .    .  //#else
             .       .    .              .             .       .              .           .    .  //                    fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .    .  //                    for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .  //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  //#endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else{
        39,543       0    0              0             0       0         13,181           0    0                      attachClause(cr);
        79,086      36   20         39,543        25,384       0         13,181           0    0                      learnts_core[cj++] = learnts_core[ci];
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                      nblevels = computeLBD(c);
        26,362      33   20              0             0       0              0           0    0                      if (nblevels < c.lbd()){
             .       .    .              .             .       .              .           .    .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .       .    .              .             .       .              .           .    .                          c.set_lbd(nblevels);
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                      c.setSimplified(true);
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
            36       0    0              0             0       0              0           0    0      learnts_core.shrink(ci - cj);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .    .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .    .  
            36      28   15              0             0       0              0           0    0      return true;
             .       .    .              .             .       .              .           .    .  
           288       0    0            252            36       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    12,396,465       2    2              0             0       0      8,264,310           0    0  int Solver::is_duplicate(std::vector<uint32_t>&c){
     2,754,770       0    0              0             0       0      2,754,770       4,406    0     auto time_point_0 = std::chrono::high_resolution_clock::now();
     1,377,385       0    0      1,377,385       906,878       0              0           0    0      dupl_db_size++;
     3,270,164     166    4        619,860             0       0              0           0    0      int res = 0;    
             .       .    .              .             .       .              .           .    .      
     2,754,770       0    0      2,754,770             0       0              0           0    0      int sz = c.size();
             .       .    .              .             .       .              .           .    .      std::vector<uint32_t> tmp(c);    
             .       .    .              .             .       .              .           .    .      sort(tmp.begin(),tmp.end());
             .       .    .              .             .       .              .           .    .      
     1,377,385 152,164    2              0             0       0      1,377,385           0    0      uint64_t hash = 0;    
             .       .    .              .             .       .              .           .    .      
    69,502,208   4,155   10              0             0       0      1,377,385           0    0      for (int i =0; i<sz; i++) {
   292,415,640       0    0     29,241,564             0       0              0           0    0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
             .       .    .              .             .       .              .           .    .      }    
             .       .    .              .             .       .              .           .    .      
     1,377,385       0    0              0             0       0      1,377,385           0    0      int32_t head = tmp[0];
             .       .    .              .             .       .              .           .    .      auto it0 = ht.find(head);
     6,883,728       0    0      1,377,381             0       0              0           0    0      if (it0 != ht.end()){
             .       .    .              .             .       .              .           .    .          auto it1=ht[head].find(sz);
     2,752,644       0    0              0             0       0              0           0    0          if (it1 != ht[head].end()){
     1,361,127       0    0              0             0       0      1,361,127           0    0              auto it2 = ht[head][sz].find(hash);
     4,083,381       0    0              0             0       0      1,361,127           0    0              if (it2 != ht[head][sz].end()){
       156,699       0    0         52,233        11,926   2,443         52,233           0    0                  it2->second++;
        52,233       0    0              0             0       0              0           0    0                  res = it2->second;            
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
     1,308,894       0    0              0             0       0      1,308,894           0    0                  ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{            
        30,390      15    1              0             0       0         15,195           0    0              ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }else{        
     1,326,215     860   15              0             0       0      1,326,215         160    0          ht[head][sz][hash]=1;
             .       .    .              .             .       .              .           .    .      } 
     1,377,385      86    1              0             0       0      1,377,385           0    0      auto time_point_1 = std::chrono::high_resolution_clock::now();
             .       .    .              .             .       .              .           .    .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
             .       .    .              .             .       .              .           .    .      return res;
    12,396,465       0    0      9,641,695         1,887       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyLearnt_tier2()
           396      36   19              0             0       0            216           0    0  {
             .       .    .              .             .       .              .           .    .      int beforeSize, afterSize;
             .       .    .              .             .       .              .           .    .      int learnts_tier2_size_before = learnts_tier2.size();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      int ci, cj, li, lj;
             .       .    .              .             .       .              .           .    .      bool sat, false_lit;
             .       .    .              .             .       .              .           .    .      unsigned int nblevels;
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      //printf("learnts_x size : %d\n", learnts_x.size());
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      int nbSimplified = 0;
             .       .    .              .             .       .              .           .    .      int nbSimplifing = 0;
             .       .    .              .             .       .              .           .    .  
       266,140      29    5             36             0       0              0           0    0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
       399,048       0    0        266,032        10,741     623              0           0    0          CRef cr = learnts_tier2[ci];
             .       .    .              .             .       .              .           .    .          Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .  
       266,032       0    0              0             0       0              0           0    0          if (removed(cr)) continue;
       266,032       0    0        133,016        16,012       9              0           0    0          else if (c.simplified()){
        98,304       0    0              0             0       0         49,152         115    0              learnts_tier2[cj++] = learnts_tier2[ci];
             .       .    .              .             .       .              .           .    .              ////
       315,184       0    0         49,152             0       0              0           0    0              nbSimplified++;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          else{
             .       .    .              .             .       .              .           .    .              int saved_size=c.size();
             .       .    .              .             .       .              .           .    .              //            if (drup_file){
             .       .    .              .             .       .              .           .    .              //                    add_oc.clear();
             .       .    .              .             .       .              .           .    .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .       .    .              .             .       .              .           .    .              ////
             .       .    .              .             .       .              .           .    .              nbSimplifing++;
        83,864       0    0              0             0       0              0           0    0              sat = false_lit = false;
     2,488,418       0    0              0             0       0              0           0    0              for (int i = 0; i < c.size(); i++){
     2,488,418       0    0              0             0       0              0           0    0                  if (value(c[i]) == l_True){
             .       .    .              .             .       .              .           .    .                      sat = true;
             .       .    .              .             .       .              .           .    .                      break;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else if (value(c[i]) == l_False){
     2,656,146       9    5              0             0       0         83,864           0    0                      false_lit = true;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              if (sat){
             .       .    .              .             .       .              .           .    .                  removeClause(cr);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
       503,184      29   15              0             0       0        251,592          32    0                  detachClause(cr, true);
             .       .    .              .             .       .              .           .    .  
       335,456       0    0        167,728         2,888       0              0           0    0                  if (false_lit){
             .       .    .              .             .       .              .           .    .                      for (li = lj = 0; li < c.size(); li++){
             .       .    .              .             .       .              .           .    .                          if (value(c[li]) != l_False){
             .       .    .              .             .       .              .           .    .                              c[lj++] = c[li];
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      c.shrink(li - lj);
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  beforeSize = c.size();
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 1);
             .       .    .              .             .       .              .           .    .                  // simplify a learnt clause c
       419,320       0    0              0             0       0        251,592           0    0                  simplifyLearnt(c);
             .       .    .              .             .       .              .           .    .                  assert(c.size() > 0);
             .       .    .              .             .       .              .           .    .                  afterSize = c.size();
             .       .    .              .             .       .              .           .    .                  
       335,456      36   20        167,728        82,510       0              0           0    0                  if(drup_file && saved_size!=c.size()){
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .                      binDRUP('a', c , drup_file);
             .       .    .              .             .       .              .           .    .                      //                    binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                      for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
             .       .    .              .             .       .              .           .    .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .    .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .    .                      //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .       .    .              .             .       .              .           .    .  
       167,728       0    0              0             0       0              0           0    0                  if (c.size() == 1){
             .       .    .              .             .       .              .           .    .                      // when unit clause occur, enqueue and propagate
             .       .    .              .             .       .              .           .    .                      uncheckedEnqueue(c[0]);
             .       .    .              .             .       .              .           .    .                      if (propagate() != CRef_Undef){
             .       .    .              .             .       .              .           .    .                          ok = false;
             .       .    .              .             .       .              .           .    .                          return false;
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                      // delete the clause memory in logic
             .       .    .              .             .       .              .           .    .                      c.mark(1);
-- line 838 ----------------------------------------
-- line 845 ----------------------------------------
             .       .    .              .             .       .              .           .    .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .  //                    fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  //#endif
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  else{
             .       .    .              .             .       .              .           .    .                      
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                      nblevels = computeLBD(c);
       167,728       0    0              0             0       0              0           0    0                      if (nblevels < c.lbd()){
             .       .    .              .             .       .              .           .    .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .       .    .              .             .       .              .           .    .                          c.set_lbd(nblevels);
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                       //duplicate learnts 
             .       .    .              .             .       .              .           .    .                      int id = 0;                    
             .       .    .              .             .       .              .           .    .                      
             .       .    .              .             .       .              .           .    .                      std::vector<uint32_t> tmp;
     4,013,441       0    0      2,958,518             0       0              0           0    0                      for (int i = 0; i < c.size(); i++)                           
     2,084,164       0    0      1,042,082             0       0      1,042,082           0    0                          tmp.push_back(c[i].x);
       335,456       0    0              0             0       0         83,864           0    0                      id = is_duplicate(tmp);
             .       .    .              .             .       .              .           .    .                       
             .       .    .              .             .       .              .           .    .                                          
             .       .    .              .             .       .              .           .    .                      //duplicate learnts 
             .       .    .              .             .       .              .           .    .  
       335,456       4    4         83,864             0       0              0           0    0                      if (id < min_number_of_learnts_copies+2){
       243,933       6    5              0             0       0         81,311           0    0                          attachClause(cr);
       404,756       0    0        243,933       159,733       0         81,311      63,218    0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
       325,244      36   20         81,311             0       0              0           0    0                          if (id == min_number_of_learnts_copies+1){                            
         1,039       2    2          1,039             0       0              0           0    0                              duplicates_added_minimization++;                                  
             .       .    .              .             .       .              .           .    .                          }
       160,544       0    0         80,272        78,987       1              0           0    0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
             .       .    .              .             .       .              .           .    .                          //if (id == min_number_of_learnts_copies+1){
             .       .    .              .             .       .              .           .    .                              cj--;
             3       3    1              0             0       0              0           0    0                              learnts_core.push(cr);
             .       .    .              .             .       .              .           .    .                              c.mark(CORE);
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                          c.setSimplified(true);
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
            36      33   20              0             0       0              0           0    0      learnts_tier2.shrink(ci - cj);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .       .    .              .             .       .              .           .    .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
             .       .    .              .             .       .              .           .    .  
            36       0    0              0             0       0              0           0    0      return true;
             .       .    .              .             .       .              .           .    .  
           288       0    0            252            36       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::simplifyAll()
           180       6    5              0             0       0            108           0    0  {
             .       .    .              .             .       .              .           .    .      ////
            72       0    0              0             0       0             36           0    0      simplified_length_record = original_length_record = 0;
             .       .    .              .             .       .              .           .    .  
           144       0    0             36            35       1              0           0    0      if (!ok || propagate() != CRef_Undef)
             .       .    .              .             .       .              .           .    .          return ok = false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      //// cleanLearnts(also can delete these code), here just for analyzing
             .       .    .              .             .       .              .           .    .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .       .    .              .             .       .              .           .    .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
             .       .    .              .             .       .              .           .    .      //local_learnts_dirty = tier2_learnts_dirty = false;
             .       .    .              .             .       .              .           .    .  
           144       0    0              0             0       0             36           0    0      if (!simplifyLearnt_core()) return ok = false;
           144      36   21              0             0       0             36           0    0      if (!simplifyLearnt_tier2()) return ok = false;
             .       .    .              .             .       .              .           .    .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      checkGarbage();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      ////
             .       .    .              .             .       .              .           .    .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
             .       .    .              .             .       .              .           .    .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      return true;
           180       0    0            144            36       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Minor methods:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
             .       .    .              .             .       .              .           .    .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
             .       .    .              .             .       .              .           .    .  //
             .       .    .              .             .       .              .           .    .  Var Solver::newVar(bool sign, bool dvar)
        21,870       1    1              0             0       0         17,496           0    0  {
             .       .    .              .             .       .              .           .    .      int v = nVars();
             .       .    .              .             .       .              .           .    .      watches_bin.init(mkLit(v, false));
             .       .    .              .             .       .              .           .    .      watches_bin.init(mkLit(v, true ));
             .       .    .              .             .       .              .           .    .      watches  .init(mkLit(v, false));
             .       .    .              .             .       .              .           .    .      watches  .init(mkLit(v, true ));
            17       1    1              0             0       0              0           0    0      assigns  .push(l_Undef);
            17       1    1              0             0       0              0           0    0      vardata  .push(mkVarData(CRef_Undef, 0));
            17       0    0              0             0       0              0           0    0      activity_CHB  .push(0);
         6,595       0    0          2,187            18       0             17           0    0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
             .       .    .              .             .       .              .           .    .  
            17       1    1              0             0       0              0           0    0      picked.push(0);
            17       0    0              0             0       0              0           0    0      conflicted.push(0);
            17       0    0              0             0       0              0           0    0      almost_conflicted.push(0);
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
            17       0    0              0             0       0              0           0    0      canceled.push(0);
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .  
            17       0    0              0             0       0              0           0    0      seen     .push(0);
            17       0    0              0             0       0              0           0    0      seen2    .push(0);
            17       0    0              0             0       0              0           0    0      polarity .push(sign);
            17       0    0              0             0       0              0           0    0      decision .push();
        10,935       1    1              0             0       0          4,374          46    0      trail    .capacity(v+1);
             .       .    .              .             .       .              .           .    .      setDecisionVar(v, dvar);
             .       .    .              .             .       .              .           .    .  
            17       0    0              0             0       0              0           0    0      activity_distance.push(0);
            17       1    1              0             0       0              0           0    0      var_iLevel.push(0);
            17       0    0              0             0       0              0           0    0      var_iLevel_tmp.push(0);
            17       0    0              0             0       0              0           0    0      pathCs.push(0);
             .       .    .              .             .       .              .           .    .      return v;
        19,683       0    0         15,309            14       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::addClause_(vec<Lit>& ps)
       212,464       2    1              0             0       0        182,112           0    0  {
             .       .    .              .             .       .              .           .    .      assert(decisionLevel() == 0);
        91,056       1    1         30,352             0       0              0           0    0      if (!ok) return false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Check if clause is satisfied and remove false/duplicate literals:
             .       .    .              .             .       .              .           .    .      sort(ps);
             .       .    .              .             .       .              .           .    .      Lit p; int i, j;
             .       .    .              .             .       .              .           .    .  
        60,704       0    0         30,352            20       0              0           0    0      if (drup_file){
             .       .    .              .             .       .              .           .    .          add_oc.clear();
        30,352       2    1         30,352             0       0              0           0    0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
             .       .    .              .             .       .              .           .    .  
       435,623       0    0              0             0       0              0           0    0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
       758,273       0    0        130,913             0       0              0           0    0          if (value(ps[i]) == l_True || ps[i] == ~p)
             .       .    .              .             .       .              .           .    .              return true;
       487,948       4    2              0             0       0              0           0    0          else if (value(ps[i]) != l_False && ps[i] != p)
       357,003       0    0        119,001             0       0        119,001           0    0              ps[j++] = p = ps[i];
       195,296       0    0         24,412             0       0              0           0    0      ps.shrink(i - j);
             .       .    .              .             .       .              .           .    .  
        48,824       2    1              0             0       0              0           0    0      if (drup_file && i != j){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .          binDRUP('a', ps, drup_file);
        24,412       0    0         24,412             0       0              0           0    0          binDRUP('d', add_oc, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .          for (int i = 0; i < ps.size(); i++)
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
             .       .    .              .             .       .              .           .    .          fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .    .          for (int i = 0; i < add_oc.size(); i++)
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .       .    .              .             .       .              .           .    .          fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      
        48,824       0    0              0             0       0              0           0    0      if (ps.size() == 0)
             .       .    .              .             .       .              .           .    .          return ok = false;
        48,824       2    1              0             0       0              0           0    0      else if (ps.size() == 1){
         3,420       1    1          1,140             0       0            570           0    0          uncheckedEnqueue(ps[0]);
         2,280       0    0              0             0       0            570           0    0          return ok = (propagate() == CRef_Undef);
             .       .    .              .             .       .              .           .    .      }else{
        23,842       0    0              0             0       0         23,842           0    0          CRef cr = ca.alloc(ps, false);
             .       .    .              .             .       .              .           .    .          //auto ca_size=ca.size();
             .       .    .              .             .       .              .           .    .          //printf("ca size:%d\n",ca_size);
        71,526       0    0              0             0       0         23,842           0    0          clauses.push(cr);
        71,526       1    0         23,842             0       0         23,842           0    0          attachClause(cr);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
        23,842       0    0              0             0       0              0           0    0      return true;
       333,872       0    0        212,464             5       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    27,279,900       5    2              0             0       0     16,367,940           0    0  void Solver::attachClause(CRef cr) {
             .       .    .              .             .       .              .           .    .      const Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .      assert(c.size() > 1);
    10,910,751       0    0      2,727,990            28       0              0           0    0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .    .      ws[~c[0]].push(Watcher(cr, c[1]));
             .       .    .              .             .       .              .           .    .      ws[~c[1]].push(Watcher(cr, c[0]));
     8,159,933       0    0      5,431,943       473,274       0              0           0    0      if (c.learnt()) learnts_literals += c.size();
    21,847,957       1    0     19,119,967            17       0              0           0    0      else            clauses_literals += c.size(); }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    15,916,308     210   24              0             0       0     10,610,872          32    0  void Solver::detachClause(CRef cr, bool strict) {
             .       .    .              .             .       .              .           .    .      const Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .      assert(c.size() > 1);
    10,610,872       0    0              0             0       0              0           0    0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .    .      
    10,610,872       0    0              0             0       0              0           0    0      if (strict){
             .       .    .              .             .       .              .           .    .          remove(ws[~c[0]], Watcher(cr, c[1]));
             .       .    .              .             .       .              .           .    .          remove(ws[~c[1]], Watcher(cr, c[0]));
             .       .    .              .             .       .              .           .    .      }else{
             .       .    .              .             .       .              .           .    .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
             .       .    .              .             .       .              .           .    .          ws.smudge(~c[0]);
             .       .    .              .             .       .              .           .    .          ws.smudge(~c[1]);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
     7,954,431       9    2      5,301,713         8,056       1              0           0    0      if (c.learnt()) learnts_literals -= c.size();
    15,920,031       0    0     13,267,313         3,248       0              0           0    0      else            clauses_literals -= c.size(); }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
    20,443,824     348   24              0             0       0     10,221,912           0    0  void Solver::removeClause(CRef cr) {
             .       .    .              .             .       .              .           .    .      Clause& c = ca[cr];
             .       .    .              .             .       .              .           .    .  
     7,666,434       0    0      2,555,478           175       0              0           0    0      if (drup_file){
             .       .    .              .             .       .              .           .    .          if (c.mark() != 1){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .              binDRUP('d', c, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "d ");
             .       .    .              .             .       .              .           .    .              for (int i = 0; i < c.size(); i++)
             .       .    .              .             .       .              .           .    .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .       .    .              .             .       .              .           .    .              fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .          }else
             .       .    .              .             .       .              .           .    .              printf("c Bug. I don't expect this to happen.\n");
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
    10,221,912     157   25              0             0       0      2,555,478           0    0      detachClause(cr);
             .       .    .              .             .       .              .           .    .      // Don't leave pointers to free'd memory!
             .       .    .              .             .       .              .           .    .      if (locked(c)){
             .       .    .              .             .       .              .           .    .          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
             .       .    .              .             .       .              .           .    .          vardata[var(implied)].reason = CRef_Undef; }
             .       .    .              .             .       .              .           .    .      c.mark(1);
             .       .    .              .             .       .              .           .    .      ca.free(cr);
    15,332,868       0    0     12,777,390             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  bool Solver::satisfied(const Clause& c) const {
       247,292       0    0              0             0       0              0           0    0      for (int i = 0; i < c.size(); i++)
       290,192       0    0        102,380            66       0              0           0    0          if (value(c[i]) == l_True)
            92       1    1              0             0       0              0           0    0              return true;
        42,624       0    0         21,358             0       0              0           0    0      return false; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
             .       .    .              .             .       .              .           .    .  //
    23,523,894   1,742   21              0             0       0     15,682,596           0    0  void Solver::cancelUntil(int bLevel) {
             .       .    .              .             .       .              .           .    .  	
    10,463,670       4    2          4,305             0       0      2,613,766           0    0      if (decisionLevel() > bLevel){
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .    .  		std::cout << "bt " << bLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif				
     5,227,532       0    0              0             0       0      2,613,766           0    0  		add_tmp.clear();
 1,740,133,874   3,668    7    353,777,060     3,259,285       5              0           0    0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
             .       .    .              .             .       .              .           .    .          {
             .       .    .              .             .       .              .           .    .              Var      x  = var(trail[c]);
             .       .    .              .             .       .              .           .    .  
   681,416,460       0    0    340,708,230   105,877,748       0              0           0    0  			if (level(x) <= bLevel)
             .       .    .              .             .       .              .           .    .  			{
             .       .    .              .             .       .              .           .    .  				add_tmp.push(trail[c]);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  			else
             .       .    .              .             .       .              .           .    .  			{
   681,414,400       0    0    340,707,200           441       0              0           0    0  				 if (!VSIDS){
   502,877,799       0    0    335,251,866         1,731       0              0           0    0  					uint32_t age = conflicts - picked[x];
   335,251,866       0    0    167,625,933    62,260,512       0              0           0    0  					if (age > 0){
 1,675,560,430      90   13    670,224,172    99,606,627       0              0           0    0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
   167,556,043       0    0    167,556,043    59,283,171      36              0           0    0  						double old_activity = activity_CHB[x];
 1,172,892,301      20    7    335,112,086       631,823       1    167,556,043           0    0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
             .       .    .              .             .       .              .           .    .  						if (order_heap_CHB.inHeap(x)){
   984,540,036      41    8              0             0       0    492,270,018           0    0  							if (activity_CHB[x] > old_activity)
             .       .    .              .             .       .              .           .    .  								order_heap_CHB.decrease(x);
             .       .    .              .             .       .              .           .    .  							else
             .       .    .              .             .       .              .           .    .  								order_heap_CHB.increase(x);
             .       .    .              .             .       .              .           .    .  						}
             .       .    .              .             .       .              .           .    .  					}
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
   335,251,866       0    0    167,625,933             0       0    167,625,933  63,322,811    0  					canceled[x] = conflicts;
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .  				}
             .       .    .              .             .       .              .           .    .  				
   681,414,400     102   22    340,707,200             0       0    340,707,200  14,587,330    0  				assigns [x] = l_Undef;
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .    .  				std::cout << "undo " << x << "\n";
             .       .    .              .             .       .              .           .    .  #endif				
   681,414,400       0    0    340,707,200             0       0              0           0    0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
   340,707,200       0    0    340,707,200             0       0              0           0    0  					polarity[x] = sign(trail[c]);
             .       .    .              .             .       .              .           .    .  				insertVarOrder(x);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .          }
     2,613,766       0    0              0             0       0      2,613,766           0    0          qhead = trail_lim[bLevel];
     5,227,532       0    0              0             0       0              0           0    0          trail.shrink(trail.size() - trail_lim[bLevel]);
     7,841,298       0    0      2,613,766             0       0              0           0    0          trail_lim.shrink(trail_lim.size() - bLevel);
     7,843,358       1    1      2,613,766             0       0              0           0    0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
             .       .    .              .             .       .              .           .    .  		{
           156       0    0             52             0       0              0           0    0  			trail.push_(add_tmp[nLitId]);
             .       .    .              .             .       .              .           .    .  		}
             .       .    .              .             .       .              .           .    .  		
             .       .    .              .             .       .              .           .    .  		add_tmp.clear();
    20,910,128       0    0     18,296,362       898,085       0              0           0    0      } }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Major methods:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  Lit Solver::pickBranchLit()
    24,932,952      44    4              0             0       0     18,699,714         259    0  {
             .       .    .              .             .       .              .           .    .      Var next = var_Undef;
             .       .    .              .             .       .              .           .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
    20,801,193     636   35      5,911,027     2,219,083       2              0           0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Random decision:
             .       .    .              .             .       .              .           .    .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
             .       .    .              .             .       .              .           .    .          next = order_heap[irand(random_seed,order_heap.size())];
             .       .    .              .             .       .              .           .    .          if (value(next) == l_Undef && decision[next])
             .       .    .              .             .       .              .           .    .              rnd_decisions++; }*/
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Activity based decision:
    60,050,999     423    1     26,908,880     2,901,156      45              0           0    0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    17,559,028       0    0              0             0       0              0           0    0          if (order_heap.empty())
             1       0    0              0             0       0              0           0    0              return lit_Undef;
             .       .    .              .             .       .              .           .    .          else{
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
    17,559,026       0    0      8,779,513             6       0              0           0    0              if (!VSIDS){
             .       .    .              .             .       .              .           .    .                  Var v = order_heap_CHB[0];
     7,435,190       0    0      7,435,190        83,393       0              0           0    0                  uint32_t age = conflicts - canceled[v];
    10,775,512       0    0      4,825,326     2,922,154     278        562,430           0    0                  while (age > 0){
             .       .    .              .             .       .              .           .    .                      double decay = pow(0.95, age);
     2,215,462       0    0      1,107,731        40,167       3      1,107,731           0    0                      activity_CHB[v] *= decay;
             .       .    .              .             .       .              .           .    .                      if (order_heap_CHB.inHeap(v))
             .       .    .              .             .       .              .           .    .                          order_heap_CHB.increase(v);
     3,323,193       0    0      2,215,462             0       0      1,107,731           0    0                      canceled[v] = conflicts;
             .       .    .              .             .       .              .           .    .                      v = order_heap_CHB[0];
             .       .    .              .             .       .              .           .    .                      age = conflicts - canceled[v];
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .              next = order_heap.removeMin();
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  
    12,466,472       0    0      6,233,236     2,719,605      22              0           0    0      return mkLit(next, polarity[next]);
    28,049,570       0    0     21,816,333            36       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .  	ConflictData data;
             .       .    .              .             .       .              .           .    .  	Clause& conflCls = ca[cind];
             .       .    .              .             .       .              .           .    .  	data.nHighestLevel = level(var(conflCls[0]));
    10,437,840       0    0      5,218,920        25,891       0              0           0    0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
             .       .    .              .             .       .              .           .    .  	{
             .       .    .              .             .       .              .           .    .  		return data;
             .       .    .              .             .       .              .           .    .  	}
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  	int highestId = 0;
             .       .    .              .             .       .              .           .    .      data.bOnlyOneLitFromHighest = true;
             .       .    .              .             .       .              .           .    .  	// find the largest decision level in the clause
           150       1    1              0             0       0              0           0    0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
             .       .    .              .             .       .              .           .    .  	{
             .       .    .              .             .       .              .           .    .  		int nLevel = level(var(conflCls[nLitId]));
            71       0    0              0             0       0              0           0    0  		if (nLevel > data.nHighestLevel)
             .       .    .              .             .       .              .           .    .  		{
             .       .    .              .             .       .              .           .    .  			highestId = nLitId;
             .       .    .              .             .       .              .           .    .  			data.nHighestLevel = nLevel;
             3       0    0              0             0       0              0           0    0  			data.bOnlyOneLitFromHighest = true;
             .       .    .              .             .       .              .           .    .  		}
             .       .    .              .             .       .              .           .    .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
             .       .    .              .             .       .              .           .    .  		{
            56       0    0              0             0       0              0           0    0  			data.bOnlyOneLitFromHighest = false;
             .       .    .              .             .       .              .           .    .  		}
             .       .    .              .             .       .              .           .    .  	}
             .       .    .              .             .       .              .           .    .  
            22       5    1              0             0       0              0           0    0  	if (highestId != 0)
             .       .    .              .             .       .              .           .    .  	{
             .       .    .              .             .       .              .           .    .  		std::swap(conflCls[0], conflCls[highestId]);
             6       0    0              0             0       0              0           0    0  		if (highestId > 1)
             .       .    .              .             .       .              .           .    .  		{
             8       0    0              0             0       0              0           0    0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
             .       .    .              .             .       .              .           .    .  			//ws.smudge(~conflCls[highestId]);
             .       .    .              .             .       .              .           .    .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
             .       .    .              .             .       .              .           .    .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
             .       .    .              .             .       .              .           .    .  		}
             .       .    .              .             .       .              .           .    .  	}
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  	return data;
             .       .    .              .             .       .              .           .    .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |    Post-conditions:
             .       .    .              .             .       .              .           .    .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
             .       .    .              .             .       .              .           .    .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
             .       .    .              .             .       .              .           .    .  |        rest of literals. There may be others from the same level though.
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
    33,922,993      62   20              0             0       0     23,485,149           0    0  {
     2,609,461       0    0              0             0       0      2,609,461           0    0      int pathC = 0;
     2,609,461       0    0              0             0       0              0           0    0      Lit p     = lit_Undef;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Generate conflict clause:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      out_learnt.push();      // (leave room for the asserting literal)
     5,218,922       0    0      2,609,461           532       0              0           0    0      int index   = trail.size() - 1;
     2,609,461       0    0      2,609,461             0       0              0           0    0      int nDecisionLevel = level(var(ca[confl][0]));
             .       .    .              .             .       .              .           .    .      assert(nDecisionLevel == level(var(ca[confl][0])));
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      do{
             .       .    .              .             .       .              .           .    .          assert(confl != CRef_Undef); // (otherwise should be UIP)
             .       .    .              .             .       .              .           .    .          Clause& c = ca[confl];
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
   426,782,956       0    0              0             0       0              0           0    0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
             .       .    .              .             .       .              .           .    .              assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .    .              Lit tmp = c[0];
     4,164,669       0    0      1,388,223        87,157       0      2,776,446           0    0              c[0] = c[1], c[1] = tmp; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // Update LBD if improved.
   322,197,992       0    0     21,376,618             0       0              0           0    0          if (c.learnt() && c.mark() != CORE){
             .       .    .              .             .       .              .           .    .              int lbd = computeLBD(c);
    17,400,862       0    0              0             0       0              0           0    0              if (lbd < c.lbd()){
       797,656       0    0              0             0       0              0           0    0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
             .       .    .              .             .       .              .           .    .                  c.set_lbd(lbd);
       797,656       0    0        398,828       307,750       0              0           0    0                  if (lbd <= core_lbd_cut){
            22       7    0              0             0       0             11           0    0                      learnts_core.push(confl);
             .       .    .              .             .       .              .           .    .                      c.mark(CORE);
     1,173,638       0    0        158,455             0       0              0           0    0                  }else if (lbd <= 6 && c.mark() == LOCAL){
             .       .    .              .             .       .              .           .    .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
             .       .    .              .             .       .              .           .    .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
    18,520,743       3    3              0             0       0      5,346,180   2,536,437    0                      learnts_tier2.push(confl);
             .       .    .              .             .       .              .           .    .                      c.mark(TIER2); }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
    17,237,850       0    0      8,618,925             0       0              0           0    0              if (c.mark() == TIER2)
    17,807,720      28   10      4,451,930         6,125       0      4,451,930     547,686   10                  c.touched() = conflicts;
     8,461,248       0    0      4,230,624             0       0              0           0    0              else if (c.mark() == LOCAL)
             .       .    .              .             .       .              .           .    .                  claBumpActivity(c);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  
 1,895,106,768       4    2    525,752,932            19       0    101,382,557          56    0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
   424,370,375       0    0    424,370,375    25,945,789      16              0           0    0              Lit q = c[j];
             .       .    .              .             .       .              .           .    .  
 1,507,591,897       2    2    643,987,424    93,784,697       8              0           0    0              if (!seen[var(q)] && level(var(q)) > 0){
   439,234,098       0    0    219,617,049         4,549       0              0           0    0                  if (VSIDS){
             .       .    .              .             .       .              .           .    .                      varBumpActivity(var(q), .5);
            22       1    1              0             0       0             11           0    0                      add_tmp.push(q);
             .       .    .              .             .       .              .           .    .                  }else
   107,072,742       0    0    107,072,742    31,927,370       0              0           0    0                      conflicted[var(q)]++;
   219,617,049       0    0              0             0       0    219,617,049           1    0                  seen[var(q)] = 1;
   439,234,098       0    0    219,617,049             0       0              0           0    0                  if (level(var(q)) >= nDecisionLevel){
   202,765,114       0    0    202,765,114             0       0              0           0    0                      pathC++;
             .       .    .              .             .       .              .           .    .                  }else
             .       .    .              .             .       .              .           .    .                      out_learnt.push(q);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          
             .       .    .              .             .       .              .           .    .          // Select next clause to look at:
             .       .    .              .             .       .              .           .    .  		do {
 1,876,073,579       0    0    770,705,943    41,554,124      63              0           0    0  			while (!seen[var(trail[index--])]);
             .       .    .              .             .       .              .           .    .  			p  = trail[index+1];
   202,765,276       0    0    101,382,638       122,514       0              0           0    0  		} while (level(var(p)) < nDecisionLevel);
             .       .    .              .             .       .              .           .    .  		
   202,765,114       0    0    101,382,557             0       0    101,382,557          40    0          confl = reason(var(p));
   101,382,557       0    0              0             0       0    101,382,557           0    0          seen[var(p)] = 0;
   202,765,114       0    0    202,765,114             0       0              0           0    0          pathC--;
             .       .    .              .             .       .              .           .    .  
   597,857,498       0    0    197,546,192           426       0              0           0    0      }while (pathC > 0);
     2,609,461       0    0      2,609,461             9       0              0           0    0      out_learnt[0] = ~p;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Simplify conflict clause:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      int i, j;
     5,218,922       0    0              0             0       0      2,609,461           0    0      out_learnt.copyTo(analyze_toclear);
     7,828,383       0    0      2,609,461             4       0              0           0    0      if (ccmin_mode == 2){
     2,609,461     239   18              0             0       0              0           0    0          uint32_t abstract_level = 0;
   241,687,906     333   19              0             0       0              0           0    0          for (i = 1; i < out_learnt.size(); i++)
   123,453,414       0    0      2,609,461             0       0              0           0    0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
             .       .    .              .             .       .              .           .    .  
   853,736,054      39    7    352,094,015             0       0      2,609,461           0    0          for (i = j = 1; i < out_learnt.size(); i++)
   747,633,049      30   19    151,036,757        10,549       0     89,111,907           0    0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
   185,774,550       7    1     61,924,850             0       0     61,924,850           7    0                  out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .    .          
             .       .    .              .             .       .              .           .    .      }else if (ccmin_mode == 1){
             .       .    .              .             .       .              .           .    .          for (i = j = 1; i < out_learnt.size(); i++){
             .       .    .              .             .       .              .           .    .              Var x = var(out_learnt[i]);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              if (reason(x) == CRef_Undef)
             .       .    .              .             .       .              .           .    .                  out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .    .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
             .       .    .              .             .       .              .           .    .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
             .       .    .              .             .       .              .           .    .                          out_learnt[j++] = out_learnt[i];
             .       .    .              .             .       .              .           .    .                          break; }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }else
             .       .    .              .             .       .              .           .    .          i = j = out_learnt.size();
             .       .    .              .             .       .              .           .    .  
     5,218,922       0    0      2,609,461     2,573,979       1              0           0    0      max_literals += out_learnt.size();
    76,553,301       2    2     18,485,960             0       0              0           0    0      out_learnt.shrink(i - j);
     2,609,461      43    3      2,609,461             0       0              0           0    0      tot_literals += out_learnt.size();
             .       .    .              .             .       .              .           .    .  
     5,218,922       0    0      2,609,461         3,198       0      2,609,461           0    0      out_lbd = computeLBD(out_learnt);
    28,895,060   3,888   53     13,109,910             0       0              0           0    0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
       438,235   3,474   16         62,605             0       0        125,210           0    0          if (binResMinimize(out_learnt))
            93       0    0             31             0       0             31           0    0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Find correct backtrack level:
             .       .    .              .             .       .              .           .    .      //
     5,215,748       0    0              0             0       0              0           0    0      if (out_learnt.size() == 1)
             .       .    .              .             .       .              .           .    .          out_btlevel = 0;
             .       .    .              .             .       .              .           .    .      else{
     5,218,856       0    0              0             0       0              0           0    0          int max_i = 1;
             .       .    .              .             .       .              .           .    .          // Find the first literal assigned at the next-highest level:
   242,914,027       0    0              0             0       0              0           0    0          for (int i = 2; i < out_learnt.size(); i++)
   197,086,806       0    0     59,315,358             0       0              0           0    0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
             .       .    .              .             .       .              .           .    .                  max_i = i;
             .       .    .              .             .       .              .           .    .          // Swap-in this literal at index 1:
             .       .    .              .             .       .              .           .    .          Lit p             = out_learnt[max_i];
     5,218,922       1    0      2,609,461             0       0      2,609,461           0    0          out_learnt[max_i] = out_learnt[1];
     2,609,461       0    0              0             0       0      2,609,461           0    0          out_learnt[1]     = p;
     5,218,922       0    0      2,609,461             0       0      2,609,461           0    0          out_btlevel       = level(var(p));
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
     5,218,922     433   19      2,609,461         8,999       0              0           0    0      if (VSIDS){
   396,821,405   3,209   33    116,687,949       199,843       0              0           0    0          for (int i = 0; i < add_tmp.size(); i++){
             .       .    .              .             .       .              .           .    .              Var v = var(add_tmp[i]);
   337,632,921       0    0    112,544,307     2,271,084       0              0           0    0              if (level(v) >= out_btlevel - 1)
             .       .    .              .             .       .              .           .    .                  varBumpActivity(v, 1);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          add_tmp.clear();
             .       .    .              .             .       .              .           .    .      }else{
     2,456,494       0    0      1,228,247             0       0      1,228,247         103    0          seen[var(p)] = true;
   107,894,287       0    0      1,228,247             0       0              0           0    0          for(int i = out_learnt.size() - 1; i >= 0; i--){
             .       .    .              .             .       .              .           .    .              Var v = var(out_learnt[i]);
             .       .    .              .             .       .              .           .    .              CRef rea = reason(v);
    62,922,380       0    0              0             0       0              0           0    0              if (rea != CRef_Undef){
             .       .    .              .             .       .              .           .    .                  const Clause& reaC = ca[rea];
   266,052,086       0    0              0             0       0              0           0    0                  for (int i = 0; i < reaC.size(); i++){
             .       .    .              .             .       .              .           .    .                      Lit l = reaC[i];
   205,262,522       0    0    102,631,261       209,731       0              0           0    0                      if (!seen[var(l)]){
    21,319,604       0    0              0             0       0     21,319,604           0    0                          seen[var(l)] = true;
    21,319,604       0    0     21,319,604    11,776,470       0              0           0    0                          almost_conflicted[var(l)]++;
             .       .    .              .             .       .              .           .    .                          analyze_toclear.push(l); } } } } }
             .       .    .              .             .       .              .           .    .  
   683,165,105   1,300    1    337,668,361             0       0    167,529,450     219,714    0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
    20,875,688       0    0     18,266,227       314,484       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Try further learnt clause minimization by means of binary clause resolution.
             .       .    .              .             .       .              .           .    .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
       150,110       0    0              0             0       0        120,088          23    0  {
             .       .    .              .             .       .              .           .    .      // Preparation: remember which false variables we have in 'out_learnt'.
       187,815       9    6         62,605             0       0         62,605           0    0      counter++;
     1,998,522       0    0        125,210             0       0              0           0    0      for (int i = 1; i < out_learnt.size(); i++)
       811,512       0    0         62,605             0       0        748,907     615,934  978          seen2[var(out_learnt[i])] = counter;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Get the list of binary clauses containing 'out_learnt[0]'.
             .       .    .              .             .       .              .           .    .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
             .       .    .              .             .       .              .           .    .  
        30,022       0    0              0             0       0              0           0    0      int to_remove = 0;
       315,910       2    2         62,605        46,418       0             31           0    0      for (int i = 0; i < ws.size(); i++){
        77,743       0    0         77,743        23,388       0              0           0    0          Lit the_other = ws[i].blocker;
             .       .    .              .             .       .              .           .    .          // Does 'the_other' appear negatively in 'out_learnt'?
       311,034      10    5        125,526        38,542      82              0           0    0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
            31       0    0              0             0       0              0           0    0              to_remove++;
            93       0    0              0             0       0             31           0    0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Shrink.
        90,066      23    6              0             0       0              0           0    0      if (to_remove > 0){
            31       0    0              0             0       0              0           0    0          int last = out_learnt.size() - 1;
         3,187      17   13             31             0       0              0           0    0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
           884       0    0            442             0       0              0           0    0              if (seen2[var(out_learnt[i])] != counter)
           155       0    0             62             0       0             31           0    0                  out_learnt[i--] = out_learnt[last--];
             .       .    .              .             .       .              .           .    .          out_learnt.shrink(to_remove);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      return to_remove != 0;
       182,693       3    2        182,693             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
             .       .    .              .             .       .              .           .    .  // visiting literals at levels that cannot be removed later.
             .       .    .              .             .       .              .           .    .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
   891,119,070   5,519    3              0             0       0    534,671,442   1,602,871    0  {
   178,223,814       0    0              0             0       0     89,111,907           0    0      analyze_stack.clear(); analyze_stack.push(p);
   267,335,721       0    0    178,223,814             0       0     89,111,907           0    0      int top = analyze_toclear.size();
   402,765,714       0    0              0             0       0              0           0    0      while (analyze_stack.size() > 0){
             .       .    .              .             .       .              .           .    .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
             .       .    .              .             .       .              .           .    .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          // Special handling for binary clauses like in 'analyze()'.
   377,617,750      41   19              0             0       0              0           0    0          if (c.size() == 2 && value(c[0]) == l_False){
             .       .    .              .             .       .              .           .    .              assert(value(c[1]) == l_True);
             .       .    .              .             .       .              .           .    .              Lit tmp = c[0];
     1,415,763       0    0        471,921        29,250       1        943,842           0    0              c[0] = c[1], c[1] = tmp; }
             .       .    .              .             .       .              .           .    .  
   925,981,702       0    0              0             0       0              0           0    0          for (int i = 1; i < c.size(); i++){
   394,455,561      91    8    394,455,561    33,736,585      24              0           0    0              Lit p  = c[i];
 1,408,956,827       0    0    788,911,122       903,055       2              0           0    0              if (!seen[var(p)] && level(var(p)) > 0){
   389,859,132       0    0    112,795,072             0       0              0           0    0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
    79,992,807       0    0              0             0       0     79,992,807           0    0                      seen[var(p)] = 1;
             .       .    .              .             .       .              .           .    .                      analyze_stack.push(p);
             3       0    0              0             0       0              0           0    0                      analyze_toclear.push(p);
             .       .    .              .             .       .              .           .    .                  }else{
   329,409,859     811   22    120,231,444             0       0              0           0    0                      for (int j = top; j < analyze_toclear.size(); j++)
    89,111,572       0    0     34,484,658             0       0     54,626,914           0    0                          seen[var(analyze_toclear[j])] = 0;
    65,604,530      29    3     32,802,265             0       0              0           0    0                      analyze_toclear.shrink(analyze_toclear.size() - top);
    32,802,265       0    0              0             0       0              0           0    0                      return false;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
   112,619,284       0    0              0             0       0              0           0    0      return true;
   712,895,256      11    0    623,783,349             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  analyzeFinal : (p : Lit)  ->  [void]
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      seen[var(p)] = 0;
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 3,407,077,700       4    2              0             0       0  1,703,538,850           0    0  {
             .       .    .              .             .       .              .           .    .      assert(value(p) == l_Undef);
             .       .    .              .             .       .              .           .    .      Var x = var(p);
   681,415,540       0    0    340,707,770     2,410,467       0              0           0    0      if (!VSIDS){
   502,879,509       0    0    335,253,006     1,331,573       0    167,626,503 119,825,215  455          picked[x] = conflicts;
   335,253,006       0    0    167,626,503             0       0    167,626,503 119,223,234  423          conflicted[x] = 0;
   335,253,006       1    1    167,626,503             0       0    167,626,503 119,483,752  439          almost_conflicted[x] = 0;
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
   167,626,503       0    0    167,626,503             0       0              0           0    0          uint32_t age = conflicts - canceled[var(p)];
   335,253,006       0    0    167,626,503   118,409,560     171              0           0    0          if (age > 0){
             .       .    .              .             .       .              .           .    .              double decay = pow(0.95, age);
   107,729,096       0    0     53,864,548    44,123,962       5     53,864,548           0    0              activity_CHB[var(p)] *= decay;
             .       .    .              .             .       .              .           .    .              if (order_heap_CHB.inHeap(var(p)))
    53,864,548       0    0              0             0       0              0           0    0                  order_heap_CHB.increase(var(p));
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
   340,707,770       2    1    340,707,770         1,168       0              0           0    0      assigns[x] = lbool(!sign(p));
   681,415,540       0    0              0             0       0    681,415,540 260,573,360  634      vardata[x] = mkVarData(from, level);
   340,707,770       3    2    340,707,770             0       0              0           0    0      trail.push_(p);
 2,384,954,390       0    0  2,044,246,620             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  unsigned number_watch_changed_total=0;
             .       .    .              .             .       .              .           .    .  unsigned number_clause_read_total=0;
             .       .    .              .             .       .              .           .    .  unsigned times_only_access_watch=0;
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  propagate : [void]  ->  [Clause*]
             .       .    .              .             .       .              .           .    .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
             .       .    .              .             .       .              .           .    .  |    otherwise CRef_Undef.
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |    Post-conditions:
             .       .    .              .             .       .              .           .    .  |      * the propagation queue is empty, even if there was a conflict.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  CRef Solver::propagate_()
    45,882,336       5    3              0             0       0     34,411,752           0    0  {
             .       .    .              .             .       .              .           .    .      //auto start_time=std::chrono::steady_clock::now();
     5,735,292       0    0              0             0       0      5,735,292           0    0      CRef    confl     = CRef_Undef;
     5,735,292       0    0              0             0       0      5,735,292           1    0      int     num_props = 0;
    11,470,584       0    0              0             0       0      5,735,292       2,764    0      watches.cleanAll();
    11,470,584       4    2              0             0       0      5,735,292           0    0      watches_bin.cleanAll();
             .       .    .              .             .       .              .           .    .      
 1,131,451,394       1    1    830,283,193       947,967       4              0           0    0      while (qhead < trail.size()){
 1,466,903,330       0    0    586,761,332     2,268,771       0    293,380,666           0    0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .       .    .              .             .       .              .           .    .          int currLevel = level(var(p));
             .       .    .              .             .       .              .           .    .          vec<Watcher>&  ws  = watches[p];
             .       .    .              .             .       .              .           .    .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          Watcher        *i, *j, *end;
   525,598,673       0    0    525,598,673     1,471,788       0              0           0    0          num_props++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
             .       .    .              .             .       .              .           .    .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
 1,410,968,374       2    1    293,380,666   286,968,602     742              0           0    0          for (int k = 0; k < ws_bin.size(); k++){
   249,031,630       0    0    249,031,630   108,539,899      80              0           0    0              Lit the_other = ws_bin[k].blocker;
19,964,976,741       0    0 19,144,124,755             0       0              0           0    0              if (value(the_other) == l_False){
       333,460       1    0        166,730             0       0        166,730           0    0                  confl = ws_bin[k].cref;
             .       .    .              .             .       .              .           .    .                  //auto end_time=std::chrono::steady_clock::now();
             .       .    .              .             .       .              .           .    .                  //auto duration=end_time-start_time;
             .       .    .              .             .       .              .           .    .  #ifdef LOOSE_PROP_STAT
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  return confl;
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                  goto ExitProp;
             .       .    .              .             .       .              .           .    .  #endif
   282,128,206       4    2              0             0       0              0           0    0              }else if(value(the_other) == l_Undef)
             .       .    .              .             .       .              .           .    .              {
   286,776,185       3    2    172,065,711             0       0     57,355,237           0    0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
             .       .    .              .             .       .              .           .    .  #ifdef  PRINT_OUT                
             .       .    .              .             .       .              .           .    .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif                
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .          }
   586,427,872       0    0    586,427,872   230,202,967     396              0           0    0          total_Watchers+=ws.size();
   293,213,936       0    0    293,213,936             0       0              0           0    0          total_indexs++;//number of rounds
             .       .    .              .             .       .              .           .    .          //int count=0;
   287,648,820       0    0              0             0       0              0           0    0          bool no_clause_access=true;
   287,648,820       0    0              0             0       0    287,648,820           0    0          bool no_implication_added=true;
   287,648,820       0    0              0             0       0    287,648,820           0    0          bool no_change_other_watch=true;
47,683,918,038       6    5 23,258,313,705             0       0    293,213,936           0    0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             .       .    .              .             .       .              .           .    .              // Try to avoid inspecting the clause:
             .       .    .              .             .       .              .           .    .              //count++;
22,965,099,769       1    1 22,965,099,769 3,091,897,975  17,327              0           0    0              Lit blocker = i->blocker;
45,930,199,538       0    0 22,965,099,769     1,446,200       2              0           0    0              total_access_watches++;
45,930,199,538       0    0 22,965,099,769    56,858,296      26              0           0    0              if (value(blocker) == l_True){
             .       .    .              .             .       .              .           .    .                  
71,998,647,324       0    0 17,999,661,831             0       0 17,999,661,831   1,516,428    0                  *j++ = *i++; continue; }//no clause accessed
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Make sure the false literal is data[1]:
 4,979,019,193       0    0      2,227,704            18       0              0           0    0              no_clause_access=false;
14,896,313,814       2    2  9,930,875,876     1,405,436       2  4,965,437,938           0    0              total_clause_access_times++;
 9,930,875,876       0    0  4,965,437,938             0       0              0           0    0              CRef     cr        = i->cref;
             .       .    .              .             .       .              .           .    .              //std::cout<<"cr: "<<cr<<"\n";
             .       .    .              .             .       .              .           .    .              Clause&  c         = ca[cr];
             .       .    .              .             .       .              .           .    .              Lit      false_lit = ~p;
 4,965,437,938       0    0  4,965,437,938             0       0              0           0    0              total_clause_access_size+=2;
14,896,313,814       0    0  9,930,875,876 4,372,329,547  49,315              0           0    0              if (c[0] == false_lit)
 9,871,328,360       0    0  4,935,664,180   134,593,951   1,734  4,935,664,180           0    0                  c[0] = c[1], c[1] = false_lit;
             .       .    .              .             .       .              .           .    .              assert(c[1] == false_lit);
             .       .    .              .             .       .              .           .    .              i++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // If 0th watch is true, then clause is already satisfied.
             .       .    .              .             .       .              .           .    .              Lit     first = c[0];
             .       .    .              .             .       .              .           .    .              Watcher w     = Watcher(cr, first);
12,701,828,698       0    0  1,385,476,411     3,137,785       0              0           0    0              if (first != blocker && value(first) == l_True){
 3,433,388,772       0    0              0             0       0  2,288,925,848     612,121    0                  *j++ = w; continue; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Look for new watch:
26,974,022,103       1    1              0             0       0              0           0    0              for (int k = 2; k < c.size(); k++)
             .       .    .              .             .       .              .           .    .              {
48,778,015,102       0    0              0             0       0  9,984,930,420           0    0                  total_clause_access_size++;
30,190,882,879       0    0  2,579,072,011             0       0              0           0    0                  if (value(c[k]) != l_False){
14,163,625,580     981    1  7,081,812,790             0       0  7,081,812,790           0    0                      c[1] = c[k]; c[k] = false_lit;
 3,540,906,395       0    0  3,540,906,395             0       0              0           0    0                      total_change_other_watch++;
 3,540,906,395       0    0              0             0       0  3,540,906,395         248    0                      no_change_other_watch=false;
             .       .    .              .             .       .              .           .    .                      watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .    .                      goto NextClause; }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Did not find watch -- clause is unit under assignment:
   842,648,592       0    0              0             0       0    560,137,238      58,121    0              *j++ = w;
   560,137,238       0    0              0             0       0              0           0    0              if (value(first) == l_False){
     2,442,735       0    0      2,442,735        11,684       0              0           0    0                  time_find_conflict++;
    14,656,410      13    4      9,770,940         6,643       0              0           0    0                  total_find_conflict_length+=i-(Watcher*)ws;
     4,885,470       0    0      4,885,470             0       0              0           0    0                  total_find_conflict_allsize+=ws.size();
             .       .    .              .             .       .              .           .    .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
     2,442,735       0    0              0             0       0      2,442,735           0    0                  confl = cr;
     4,885,470       0    0      2,442,735             0       0      2,442,735       2,035    0                  qhead = trail.size();
             .       .    .              .             .       .              .           .    .                  // Copy the remaining watches:
             .       .    .              .             .       .              .           .    .  
   147,328,115       2    2      4,670,439            18       0              0           0    0                  while (i < end)
    67,772,251       0    0     67,772,251     8,391,023      49     67,772,251      19,951    0                      *j++ = *i++;
             .       .    .              .             .       .              .           .    .              }else
             .       .    .              .             .       .              .           .    .              {//new implecate
   277,625,884       0    0              0             0       0    277,625,884           0    0                  no_implication_added=false;
   277,625,884       0    0    277,625,884     2,455,721       0              0           0    0                  total_push_new_implication++;
   832,877,652       0    0    555,251,768       300,786       0              0           0    0  				if (currLevel == decisionLevel())
             .       .    .              .             .       .              .           .    .  				{
   555,251,768       0    0              0             0       0              0           0    0  					uncheckedEnqueue(first, currLevel, cr);
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT					
             .       .    .              .             .       .              .           .    .  					std::cout << "i " << first << " l " << currLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif					
             .       .    .              .             .       .              .           .    .  				}
             .       .    .              .             .       .              .           .    .  				else
             .       .    .              .             .       .              .           .    .  				{
             .       .    .              .             .       .              .           .    .  					int nMaxLevel = currLevel;
         1,232       0    0              0             0       0              0           0    0  					int nMaxInd = 1;
             .       .    .              .             .       .              .           .    .  					// pass over all the literals in the clause and find the one with the biggest level
         5,438       0    0            616             0       0              0           0    0  					for (int nInd = 2; nInd < c.size(); ++nInd)
             .       .    .              .             .       .              .           .    .  					{
             .       .    .              .             .       .              .           .    .  						int nLevel = level(var(c[nInd]));
         3,216       0    0              0             0       0              0           0    0  						if (nLevel > nMaxLevel)
             .       .    .              .             .       .              .           .    .  						{
             .       .    .              .             .       .              .           .    .  							nMaxLevel = nLevel;
             .       .    .              .             .       .              .           .    .  							nMaxInd = nInd;
             .       .    .              .             .       .              .           .    .  						}
             .       .    .              .             .       .              .           .    .  					}
             .       .    .              .             .       .              .           .    .  
         1,232       2    1              0             0       0              0           0    0  					if (nMaxInd != 1)
             .       .    .              .             .       .              .           .    .  					{
             .       .    .              .             .       .              .           .    .  						std::swap(c[1], c[nMaxInd]);
             .       .    .              .             .       .              .           .    .  						*j--; // undo last watch
            96       0    0             96             0       0              0           0    0                          total_change_other_watch++;
            96       0    0              0             0       0             96           0    0                          no_change_other_watch=false;
             .       .    .              .             .       .              .           .    .  						watches[~c[1]].push(w);
             .       .    .              .             .       .              .           .    .  					}
             .       .    .              .             .       .              .           .    .  					
 1,388,130,036       0    0    277,625,884             0       0    277,625,884           0    0  					uncheckedEnqueue(first, nMaxLevel, cr);
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT					
             .       .    .              .             .       .              .           .    .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
             .       .    .              .             .       .              .           .    .  #endif	
             .       .    .              .             .       .              .           .    .  				}
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  
     2,227,704      69   10              0             0       0              0           0    0  NextClause:;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
 1,438,244,100       0    0    287,648,820             0       0              0           0    0          if(no_clause_access==true){
    28,800,670     266   12     28,800,670        17,065       1              0           0    0              total_no_clause_access++;
             .       .    .              .             .       .              .           .    .          }
   598,533,194      39   13    287,648,820             0       0              0           0    0          if(no_implication_added==true){
   145,488,363       2    1    139,923,247     1,229,486       1              0           0    0              total_no_implication_added++;
             .       .    .              .             .       .              .           .    .          }
   611,712,993       0    0    287,648,820             0       0              0           0    0          if(no_change_other_watch==true){
    60,829,199      40    3     60,829,199             0       0              0           0    0              total_no_change_other_watch++;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          ws.shrink(i - j);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  ExitProp:;
    11,137,124       3    1     11,137,124     2,457,516       0              0           0    0      propagations += num_props;
     5,568,562       0    0      5,568,562             0       0              0           0    0      simpDB_props -= num_props;
             .       .    .              .             .       .              .           .    .  
     5,568,562       0    0      5,568,562             0       0              0           0    0      return confl;
 1,287,785,339     304    4     40,147,044     4,440,200       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  reduceDB : ()  ->  [void]
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
             .       .    .              .             .       .              .           .    .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  struct reduceDB_lt { 
             .       .    .              .             .       .              .           .    .      ClauseAllocator& ca;
             .       .    .              .             .       .              .           .    .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
   130,985,444     346   26    128,318,399    42,102,331   6,673              0           0    0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
             .       .    .              .             .       .              .           .    .  };
             .       .    .              .             .       .              .           .    .  void Solver::reduceDB()
         1,038     111   17              0             0       0            692           0    0  {
             .       .    .              .             .       .              .           .    .      int     i, j;
             .       .    .              .             .       .              .           .    .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .       .    .              .             .       .              .           .    .      //local_learnts_dirty = false;
             .       .    .              .             .       .              .           .    .  
           173       0    0              0             0       0              0           0    0      sort(learnts_local, reduceDB_lt(ca));
             .       .    .              .             .       .              .           .    .  
           865       0    0            173           173       0              0           0    0      int limit = learnts_local.size() / 2;
    10,268,165     173   49              0             0       0              0           0    0      for (i = j = 0; i < learnts_local.size(); i++){
    15,400,950     173   29     10,267,300       321,015       0              0           0    0          Clause& c = ca[learnts_local[i]];
    10,267,300       0    0      5,133,650     5,085,459      29              0           0    0          if (c.mark() == LOCAL)
    19,774,786       0    0      5,068,155             0       0              0           0    0              if (c.removable() && !locked(c) && i < limit)
    12,759,750       0    0      2,551,950             0       0      2,551,950           0    0                  removeClause(learnts_local[i]);
             .       .    .              .             .       .              .           .    .              else{
       247,743       0    0              0             0       0              0           0    0                  if (!c.removable()) limit++;
             .       .    .              .             .       .              .           .    .                  c.removable(true);
    12,712,015       0    0      2,516,205             0       0      2,516,205     157,532    0                  learnts_local[j++] = learnts_local[i]; }
             .       .    .              .             .       .              .           .    .      }
           173       0    0              0             0       0              0           0    0      learnts_local.shrink(i - j);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      checkGarbage();
           865       0    0            692           173       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  void Solver::reduceDB_Tier2()
         1,560     217   16              0             0       0          1,300           0    0  {
             .       .    .              .             .       .              .           .    .      int i, j;
     2,794,682      89    7            260           259       0              0           0    0      for (i = j = 0; i < learnts_tier2.size(); i++){
     3,653,451     186   17      2,435,634        76,363     224              0           0    0          Clause& c = ca[learnts_tier2[i]];
     2,435,634       0    0              0             0       0              0           0    0          if (c.mark() == TIER2)
     6,006,410     254    9      2,402,564       977,933   1,583              0           0    0              if (!locked(c) && c.touched() + 30000 < conflicts){
             .       .    .              .             .       .              .           .    .                  learnts_local.push(learnts_tier2[i]);
             .       .    .              .             .       .              .           .    .                  c.mark(LOCAL);
             .       .    .              .             .       .              .           .    .                  //c.removable(true);
             .       .    .              .             .       .              .           .    .                  c.activity() = 0;
             .       .    .              .             .       .              .           .    .                  claBumpActivity(c);
             .       .    .              .             .       .              .           .    .              }else
     5,195,365       0    0      1,039,073             0       0      1,039,073      36,117    0                  learnts_tier2[j++] = learnts_tier2[i];
             .       .    .              .             .       .              .           .    .      }
           260       0    0              0             0       0              0           0    0      learnts_tier2.shrink(i - j);
         1,560       0    0          1,560           260       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::removeSatisfied(vec<CRef>& cs)
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .      int i, j;
             3       1    1              1             1       0              0           0    0      for (i = j = 0; i < cs.size(); i++){
             .       .    .              .             .       .              .           .    .          Clause& c = ca[cs[i]];
             .       .    .              .             .       .              .           .    .          if (satisfied(c))
             1       1    1              1             0       0              0           0    0              removeClause(cs[i]);
             .       .    .              .             .       .              .           .    .          else
             .       .    .              .             .       .              .           .    .              cs[j++] = cs[i];
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      cs.shrink(i - j);
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
            12       0    0              0             0       0             10           0    0  {
             .       .    .              .             .       .              .           .    .      int i, j;
             6       0    0              2             1       0              0           0    0      for (i = j = 0; i < cs.size(); i++){
             .       .    .              .             .       .              .           .    .          Clause& c = ca[cs[i]];
             .       .    .              .             .       .              .           .    .          if (c.mark() == valid_mark)
             .       .    .              .             .       .              .           .    .              if (satisfied(c))
             .       .    .              .             .       .              .           .    .                  removeClause(cs[i]);
             .       .    .              .             .       .              .           .    .              else
             .       .    .              .             .       .              .           .    .                  cs[j++] = cs[i];
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      cs.shrink(i - j);
            12       2    2             12             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::rebuildOrderHeap()
            18       1    1              0             0       0             12           0    0  {
             .       .    .              .             .       .              .           .    .      vec<Var> vs;
         8,756       0    0              2             0       0              2           0    0      for (Var v = 0; v < nVars(); v++)
        25,500       0    0         12,750           147       0              0           0    0          if (decision[v] && value(v) == l_Undef)
             .       .    .              .             .       .              .           .    .              vs.push(v);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      order_heap_CHB  .build(vs);
             .       .    .              .             .       .              .           .    .      order_heap_VSIDS.build(vs);
             .       .    .              .             .       .              .           .    .      order_heap_distance.build(vs);
            16       2    1             14             2       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*_________________________________________________________________________________________________
             .       .    .              .             .       .              .           .    .  |
             .       .    .              .             .       .              .           .    .  |  simplify : [void]  ->  [bool]
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Description:
             .       .    .              .             .       .              .           .    .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
             .       .    .              .             .       .              .           .    .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  bool Solver::simplify()
        25,812     668    3              0             0       0         17,208           0    0  {
             .       .    .              .             .       .              .           .    .      assert(decisionLevel() == 0);
             .       .    .              .             .       .              .           .    .  
        21,510       0    0          4,302         4,258       1              0           0    0      if (!ok || propagate() != CRef_Undef)
             .       .    .              .             .       .              .           .    .          return ok = false;
             .       .    .              .             .       .              .           .    .  
        12,908     236   24          8,605             0       0              0           0    0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
             .       .    .              .             .       .              .           .    .          return true;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Remove satisfied clauses:
             3       0    0              0             0       0              1           0    0      removeSatisfied(learnts_core); // Should clean core first.
             4       0    0              0             0       0              1           0    0      safeRemoveSatisfied(learnts_tier2, TIER2);
             4       1    1              0             0       0              1           0    0      safeRemoveSatisfied(learnts_local, LOCAL);
             2       0    0              1             1       0              0           0    0      if (remove_satisfied)        // Can be turned off.
             .       .    .              .             .       .              .           .    .          removeSatisfied(clauses);
             .       .    .              .             .       .              .           .    .      checkGarbage();
             2       1    1              0             0       0              1           0    0      rebuildOrderHeap();
             .       .    .              .             .       .              .           .    .  
             2       0    0              1             1       0              1           1    0      simpDB_assigns = nAssigns();
             3       0    0              2             2       0              1           0    0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
             .       .    .              .             .       .              .           .    .  
             1       0    0              0             0       0              0           0    0      return true;
        30,114       0    0         21,510             1       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // pathCs[k] is the number of variables assigned at level k,
             .       .    .              .             .       .              .           .    .  // it is initialized to 0 at the begining and reset to 0 after the function execution
        80,128       3    1              0             0       0         60,096           0    0  bool Solver::collectFirstUIP(CRef confl){
        20,032       0    0              0             0       0         10,016           0    0      involved_lits.clear();
       959,246       3    1              0             0       0              0           0    0      int max_level=1;
             .       .    .              .             .       .              .           .    .      Clause& c=ca[confl]; int minLevel=decisionLevel();
       142,470       0    0         10,016             0       0              0           0    0      for(int i=0; i<c.size(); i++) {
             .       .    .              .             .       .              .           .    .          Var v=var(c[i]);
             .       .    .              .             .       .              .           .    .          //        assert(!seen[v]);
       138,585      23    1         46,195        15,932       0              0           0    0          if (level(v)>0) {
        92,390       0    0         46,195         9,069       0         46,195      30,508    0              seen[v]=1;
       102,406       0    0         56,211        18,399       0         46,195      41,531    0              var_iLevel_tmp[v]=1;
        46,195       0    0         46,195        25,058       0              0           0    0              pathCs[level(v)]++;
             .       .    .              .             .       .              .           .    .              if (minLevel>level(v)) {
             .       .    .              .             .       .              .           .    .                  minLevel=level(v);
             .       .    .              .             .       .              .           .    .                  assert(minLevel>0);
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              //    varBumpActivity(v);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
        30,048       0    0         20,032         9,473       0              0           0    0      int limit=trail_lim[minLevel-1];
    20,778,552       0    0         10,016             0       0              0           0    0      for(int i=trail.size()-1; i>=limit; i--) {
    10,369,244      41    1     10,369,244       298,443       0              0           0    0          Lit p=trail[i]; Var v=var(p);
    10,369,244       0    0      5,184,622       197,077       0              0           0    0          if (seen[v]) {
             .       .    .              .             .       .              .           .    .              int currentDecLevel=level(v);
             .       .    .              .             .       .              .           .    .              //      if (currentDecLevel==decisionLevel())
             .       .    .              .             .       .              .           .    .              //      	varBumpActivity(v);
     1,088,245       0    0              0             0       0      1,088,245           0    0              seen[v]=0;
     2,176,490       0    0      1,088,245           610       0              0           0    0              if (--pathCs[currentDecLevel]!=0) {
             .       .    .              .             .       .              .           .    .                  Clause& rc=ca[reason(v)];
     1,848,380       5    1      1,348,725         1,271       0              0           0    0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
       899,150       0    0              0             0       0              0           0    0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
     1,092,256       0    0              0             0       0              0           0    0                  if (rc.size()==2 && value(rc[0])==l_False) {
             .       .    .              .             .       .              .           .    .                      // Special case for binary clauses
             .       .    .              .             .       .              .           .    .                      // The first one has to be SAT
             .       .    .              .             .       .              .           .    .                      assert(value(rc[1]) != l_False);
             .       .    .              .             .       .              .           .    .                      Lit tmp = rc[0];
        30,756       0    0         10,252           781       0         20,504           0    0                      rc[0] =  rc[1], rc[1] = tmp;
             .       .    .              .             .       .              .           .    .                  }
     4,405,086       0    0              0             0       0              0           0    0                  for (int j = 1; j < rc.size(); j++){
             .       .    .              .             .       .              .           .    .                      Lit q = rc[j]; Var v1=var(q);
     3,699,042       0    0              0             0       0              0           0    0                      if (level(v1) > 0) {
     3,699,042       0    0              0             0       0              0           0    0                          if (minLevel>level(v1)) {
       151,492       0    0         75,746        29,975       0              0           0    0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
             .       .    .              .             .       .              .           .    .                          }
     5,548,563       0    0      3,699,042        43,586       0              0           0    0                          if (seen[v1]) {
     1,614,942       0    0        807,471         3,076       0              0           0    0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
     1,218,222       0    0              0             0       0        609,111           0    0                                  var_iLevel_tmp[v1]=reasonVarLevel;
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                          else {
     1,042,050       0    0              0             0       0      1,042,050     594,563    0                              var_iLevel_tmp[v1]=reasonVarLevel;
             .       .    .              .             .       .              .           .    .                              //   varBumpActivity(v1);
     1,042,050       0    0              0             0       0      1,042,050           0    0                              seen[v1] = 1;
     3,126,150       3    1      2,084,100       130,237       0              0           0    0                              pathCs[level(v1)]++;
             .       .    .              .             .       .              .           .    .                          }
             .       .    .              .             .       .              .           .    .                      }
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              involved_lits.push(p);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
        30,048     271    1         10,016             0       0         10,016           0    0      double inc=var_iLevel_inc;
             .       .    .              .             .       .              .           .    .      vec<int> level_incs; level_incs.clear();
       822,913       0    0        317,146             0       0              0           0    0      for(int i=0;i<max_level;i++){
       337,178       2    1        168,589             0       0              0           0    0          level_incs.push(inc);
       505,767       0    0        337,178             0       0        168,589           0    0          inc = inc/my_var_decay;
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
     2,216,554       0    0      1,098,261             0       0              0           0    0      for(int i=0;i<involved_lits.size();i++){
        10,016       0    0         10,016             1       0              0           0    0          Var v =var(involved_lits[i]);
             .       .    .              .             .       .              .           .    .          //        double old_act=activity_distance[v];
             .       .    .              .             .       .              .           .    .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
     9,954,461   2,327    2      3,304,799       737,328       0      1,098,261           0    0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
             .       .    .              .             .       .              .           .    .  
     2,176,490       0    0              0             0       0              0           0    0          if(activity_distance[v]>1e100){
             .       .    .              .             .       .              .           .    .              for(int vv=0;vv<nVars();vv++)
        50,080     198    1         20,032        18,648       0         20,032           0    0                  activity_distance[vv] *= 1e-100;
             .       .    .              .             .       .              .           .    .              var_iLevel_inc*=1e-100;
        20,427       8    1              0             0       0              0           0    0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .          if (order_heap_distance.inHeap(v))
             .       .    .              .             .       .              .           .    .              order_heap_distance.decrease(v);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          //        var_iLevel_inc *= (1 / my_var_decay);
             .       .    .              .             .       .              .           .    .      }
        50,080      65    1         20,032             0       0         10,016         408    0      var_iLevel_inc=level_incs[level_incs.size()-1];
             .       .    .              .             .       .              .           .    .      return true;
        90,144       0    0         70,112         5,355       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  struct UIPOrderByILevel_Lt {
             .       .    .              .             .       .              .           .    .      Solver& solver;
             .       .    .              .             .       .              .           .    .      const vec<double>&  var_iLevel;
             .       .    .              .             .       .              .           .    .      bool operator () (Lit x, Lit y) const
             .       .    .              .             .       .              .           .    .      {
             .       .    .              .             .       .              .           .    .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
             .       .    .              .             .       .              .           .    .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
             .       .    .              .             .       .              .           .    .  |    Search for a model the specified number of conflicts. 
             .       .    .              .             .       .              .           .    .  |  
             .       .    .              .             .       .              .           .    .  |  Output:
             .       .    .              .             .       .              .           .    .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
             .       .    .              .             .       .              .           .    .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
             .       .    .              .             .       .              .           .    .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
             .       .    .              .             .       .              .           .    .  |________________________________________________________________________________________________@*/
             .       .    .              .             .       .              .           .    .  lbool Solver::search(int& nof_conflicts)
        47,311   3,022   10              0             0       0         30,107           0    0  {
             .       .    .              .             .       .              .           .    .      assert(ok);
             .       .    .              .             .       .              .           .    .      int         backtrack_level;
             .       .    .              .             .       .              .           .    .      int         lbd;
             .       .    .              .             .       .              .           .    .      vec<Lit>    learnt_clause;
             .       .    .              .             .       .              .           .    .      bool        cached = false;
         4,301       0    0          4,301           109       0              0           0    0      starts++;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // simplify
             .       .    .              .             .       .              .           .    .      //
        17,204       3    3         12,903         4,301       6              0           0    0      if (conflicts >= curSimplify * nbconfbeforesimplify){
             .       .    .              .             .       .              .           .    .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
             .       .    .              .             .       .              .           .    .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
             .       .    .              .             .       .              .           .    .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
             .       .    .              .             .       .              .           .    .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
            36      16   14             36            36      15              0           0    0          nbSimplifyAll++;
           108      36   23              0             0       0             36           0    0          if (!simplifyAll()){
             .       .    .              .             .       .              .           .    .              return l_False;
             .       .    .              .             .       .              .           .    .          }
           252       0    0             72            72       0             36           0    0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
           108       0    0             36             0       0             36           0    0          nbconfbeforesimplify += incSimplify;
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      for (;;){
             .       .    .              .             .       .              .           .    .          CRef confl = propagate();
             .       .    .              .             .       .              .           .    .  
    11,460,768       0    0              0             0       0              0           0    0          if (confl != CRef_Undef){
             .       .    .              .             .       .              .           .    .              // CONFLICT
     7,828,395       0    0      2,609,465         9,295       0              0           0    0              if (VSIDS){
     2,762,556       0    0      1,381,263     1,345,007       0             30           0    0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
             .       .    .              .             .       .              .           .    .              }else
     4,704,750      16    3      2,796,499     1,203,259       1        340,001           0    0                  if (step_size > min_step_size) step_size -= step_size_dec;
             .       .    .              .             .       .              .           .    .  
    10,437,860     161   37      5,218,930     2,628,637       0      2,609,465           0    0              conflicts++; nof_conflicts--;
             .       .    .              .             .       .              .           .    .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
             .       .    .              .             .       .              .           .    .              ConflictData data = FindConflictLevel(confl);
     5,218,930       3    1              0             0       0              0           0    0              if (data.nHighestLevel == 0) return l_False;
            36       0    0             14             0       0              0           0    0              if (data.bOnlyOneLitFromHighest)
             .       .    .              .             .       .              .           .    .              {
             4       2    0              0             0       0              0           0    0  				cancelUntil(data.nHighestLevel - 1);
             .       .    .              .             .       .              .           .    .  				continue;
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  			
             .       .    .              .             .       .              .           .    .              learnt_clause.clear();
     5,218,922       0    0              0             0       0      2,609,461   2,494,524    0              if(conflicts>50000) DISTANCE=0;
             .       .    .              .             .       .              .           .    .              else DISTANCE=1;
     7,981,350       0    0              0             0       0              0           0    0              if(VSIDS && DISTANCE)
        40,064       4    1              0             0       0         10,016           0    0                  collectFirstUIP(confl);
             .       .    .              .             .       .              .           .    .  
    15,656,766     109   39              0             0       0      2,609,461           0    0              analyze(confl, learnt_clause, backtrack_level, lbd);
             .       .    .              .             .       .              .           .    .              // check chrono backtrack condition
    36,504,461      42   23     13,043,306        94,224       0              0           0    0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
             .       .    .              .             .       .              .           .    .              {
            14       0    0             14             0       0              0           0    0  				++chrono_backtrack;
            14       0    0              0             0       0              0           0    0  				cancelUntil(data.nHighestLevel -1);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  			else // default behavior
             .       .    .              .             .       .              .           .    .  			{
     2,609,447     254   24      2,609,447           444       0              0           0    0  				++non_chrono_backtrack;
             .       .    .              .             .       .              .           .    .  				cancelUntil(backtrack_level);
             .       .    .              .             .       .              .           .    .  			}
             .       .    .              .             .       .              .           .    .  
     7,828,383       0    0      2,609,461       740,832       0      2,609,461           0    0              lbd--;
     5,218,922       0    0      2,609,461             0       0              0           0    0              if (VSIDS){
     1,381,214      30   12              0             0       0      1,381,214           0    0                  cached = false;
     4,143,642     265   14      4,143,642     1,303,160       0              0           0    0                  conflicts_VSIDS++;
             .       .    .              .             .       .              .           .    .                  lbd_queue.push(lbd);
    11,049,712       0    0      4,143,642             0       0      1,381,214           0    0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
             .       .    .              .             .       .              .           .    .  
     7,828,383      39   21      2,609,461             0       0              0           0    0              if (learnt_clause.size() == 1){
             .       .    .              .             .       .              .           .    .                  uncheckedEnqueue(learnt_clause[0]);
             .       .    .              .             .       .              .           .    .              }else{
             .       .    .              .             .       .              .           .    .                  CRef cr = ca.alloc(learnt_clause, true);
     2,609,461       0    0      2,609,461             0       0              0           0    0                  ca[cr].set_lbd(lbd);
             .       .    .              .             .       .              .           .    .                  //duplicate learnts 
             .       .    .              .             .       .              .           .    .                  int  id = 0;
     5,218,922       0    0      2,609,461     2,587,371       0              0           0    0                  if (lbd <= max_lbd_dup){                        
             .       .    .              .             .       .              .           .    .                      std::vector<uint32_t> tmp;
   120,652,469       0    0     82,011,404             0       0      1,293,521           0    0                      for (int i = 0; i < learnt_clause.size(); i++)
    84,598,446      10    2     56,398,964             0       0     28,199,482           0    0                          tmp.push_back(learnt_clause[i].x);
     3,880,563       9    3      1,293,521             0       0      1,293,521           0    0                      id = is_duplicate(tmp);             
     6,467,605       0    0      1,293,521             0       0              0           0    0                      if (id == min_number_of_learnts_copies +1){
           328       0    0            328            16       0              0           0    0                          duplicates_added_conflicts++;                        
             .       .    .              .             .       .              .           .    .                      }                    
     2,587,042       0    0              0             0       0              0           0    0                      if (id == min_number_of_learnts_copies){
         1,815       0    0          1,815            77       0              0           0    0                          duplicates_added_tier2++;
             .       .    .              .             .       .              .           .    .                      }                                        
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .                  //duplicate learnts
             .       .    .              .             .       .              .           .    .  
    15,647,010       0    0      5,216,483     1,209,645       0              0           0    0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
             8       2    1              0             0       0              0           0    0                      learnts_core.push(cr);
             .       .    .              .             .       .              .           .    .                      ca[cr].mark(CORE);
    10,181,476     961   21              0             0       0              0           0    0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
            18       2    1              0             0       0              0           0    0                      learnts_tier2.push(cr);
             .       .    .              .             .       .              .           .    .                      ca[cr].mark(TIER2);
       493,576       0    0        123,394            87       0        123,394          66    0                      ca[cr].touched() = conflicts;
             .       .    .              .             .       .              .           .    .                  }else{
            23      19    1              0             0       0              0           0    0                      learnts_local.push(cr);
             .       .    .              .             .       .              .           .    .                      claBumpActivity(ca[cr]); }
     7,828,383   1,328   14              0             0       0      2,609,461           0    0                  attachClause(cr);
             .       .    .              .             .       .              .           .    .  
    15,656,766       0    0      7,828,383         1,148       0      2,609,461           0    0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT
             .       .    .              .             .       .              .           .    .                  std::cout << "new " << ca[cr] << "\n";
             .       .    .              .             .       .              .           .    .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
             .       .    .              .             .       .              .           .    .  #endif                
             .       .    .              .             .       .              .           .    .              }
     7,828,383       0    0      2,609,461       572,192       0              0           0    0              if (drup_file){
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             .       .    .              .             .       .              .           .    .                  binDRUP('a', learnt_clause, drup_file);
             .       .    .              .             .       .              .           .    .  #else
             .       .    .              .             .       .              .           .    .                  for (int i = 0; i < learnt_clause.size(); i++)
             .       .    .              .             .       .              .           .    .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
             .       .    .              .             .       .              .           .    .                  fprintf(drup_file, "0\n");
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
     7,828,383     437   21      5,218,922     1,369,903       1              0           0    0              if (VSIDS) varDecayActivity();
             .       .    .              .             .       .              .           .    .              claDecayActivity();
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              /*if (--learntsize_adjust_cnt == 0){
             .       .    .              .             .       .              .           .    .                  learntsize_adjust_confl *= learntsize_adjust_inc;
             .       .    .              .             .       .              .           .    .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
             .       .    .              .             .       .              .           .    .                  max_learnts             *= learntsize_inc;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
             .       .    .              .             .       .              .           .    .                             (int)conflicts,
             .       .    .              .             .       .              .           .    .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
             .       .    .              .             .       .              .           .    .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
             .       .    .              .             .       .              .           .    .              }*/
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .          }else{
             .       .    .              .             .       .              .           .    .              // NO CONFLICT
             .       .    .              .             .       .              .           .    .              bool restart = false;
     9,362,757      33   17      3,120,919       252,204       0              0           0    0              if (!VSIDS)
             .       .    .              .             .       .              .           .    .                  restart = nof_conflicts <= 0;
     3,302,492       1    1      1,651,246             0       0              0           0    0              else if (!cached){
    11,847,886       2    0      3,336,603     1,257,113       0        698,049           0    0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
             .       .    .              .             .       .              .           .    .                  cached = true;
             .       .    .              .             .       .              .           .    .              }
     4,409,019       0    0      1,469,673     1,015,789       0              0           0    0              if (restart /*|| !withinBudget()*/){
             .       .    .              .             .       .              .           .    .                  lbd_queue.clear();
             .       .    .              .             .       .              .           .    .                  cached = false;
             .       .    .              .             .       .              .           .    .                  // Reached bound on number of conflicts:
        12,900       0    0              0             0       0          8,600       3,929    2                  progress_estimate = progressEstimate();
             .       .    .              .             .       .              .           .    .                  cancelUntil(0);
         8,600       0    0              0             0       0              0           0    0                  return l_Undef; }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Simplify the set of problem clauses:
    10,011,897     106   11      3,116,619             0       0        649,137           0    0              if (decisionLevel() == 0 && !simplify())
             .       .    .              .             .       .              .           .    .                  return l_False;
             .       .    .              .             .       .              .           .    .  
     9,349,857      18    3      6,233,238     1,508,640       1              0           0    0              if (conflicts >= next_T2_reduce){
           520       0    0              0             0       0            260           0    0                  next_T2_reduce = conflicts + 10000;
         1,040       0    0            260             0       0            260           0    0                  reduceDB_Tier2(); }
     6,233,238      20    5      3,116,619         1,684       0              0           0    0              if (conflicts >= next_L_reduce){
           346       0    0              0             0       0            173           0    0                  next_L_reduce = conflicts + 15000;
           346       0    0              0             0       0            173           0    0                  reduceDB(); }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              Lit next = lit_Undef;
             .       .    .              .             .       .              .           .    .              /*while (decisionLevel() < assumptions.size()){
             .       .    .              .             .       .              .           .    .                  // Perform user provided assumption:
             .       .    .              .             .       .              .           .    .                  Lit p = assumptions[decisionLevel()];
             .       .    .              .             .       .              .           .    .                  if (value(p) == l_True){
             .       .    .              .             .       .              .           .    .                      // Dummy decision level:
             .       .    .              .             .       .              .           .    .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
             .       .    .              .             .       .              .           .    .                  }else{
             .       .    .              .             .       .              .           .    .                      next = p;
             .       .    .              .             .       .              .           .    .                      break;
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              if (next == lit_Undef)*/{
             .       .    .              .             .       .              .           .    .                  // New variable decision:
     3,116,619       0    0      3,116,619           173       0              0           0    0                  decisions++;
     9,349,857     258   13              0             0       0      3,116,619           0    0                  next = pickBranchLit();
             .       .    .              .             .       .              .           .    .  
     6,233,238       0    0              0             0       0              0           0    0                  if (next == lit_Undef)
             .       .    .              .             .       .              .           .    .                      // Model found:
             2       0    0              0             0       0              0           0    0                      return l_True;
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .              // Increase decision level and enqueue 'next'
             .       .    .              .             .       .              .           .    .              newDecisionLevel();
    18,699,708      33   18      3,116,618             0       0      3,116,618           0    0              uncheckedEnqueue(next, decisionLevel());
             .       .    .              .             .       .              .           .    .  #ifdef PRINT_OUT            
             .       .    .              .             .       .              .           .    .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
             .       .    .              .             .       .              .           .    .  #endif            
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
        38,709      46   16         30,107         4,301       9              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  double Solver::progressEstimate() const
        25,800       4    3              0             0       0         21,500           0    0  {
         8,600       0    0              0             0       0              0           0    0      double  progress = 0;
        21,500       0    0          8,600         2,946       0          4,300           0    0      double  F = 1.0 / nVars();
             .       .    .              .             .       .              .           .    .  
       629,621       3    3              0             0       0              0           0    0      for (int i = 0; i <= decisionLevel(); i++){
       603,821       0    0        396,814             0       0              0           0    0          int beg = i == 0 ? 0 : trail_lim[i - 1];
       806,528       0    0        401,114        16,783       4              0           0    0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
     1,229,142      13    8        207,007             0       0              0           0    0          progress += pow(F, i) * (end - beg);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
         8,600       0    0              0             0       0              0           0    0      return progress / nVars();
        30,100       0    0         25,800             0       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  /*
             .       .    .              .             .       .              .           .    .    Finite subsequences of the Luby-sequence:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .    0: 1
             .       .    .              .             .       .              .           .    .    1: 1 1 2
             .       .    .              .             .       .              .           .    .    2: 1 1 2 1 1 2 4
             .       .    .              .             .       .              .           .    .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .   */
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static double luby(double y, int x){
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Find the finite subsequence that contains index 'x', and the
             .       .    .              .             .       .              .           .    .      // size of that subsequence:
             .       .    .              .             .       .              .           .    .      int size, seq;
       117,703       0    0              0             0       0              0           0    0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
             .       .    .              .             .       .              .           .    .  
        66,052       3    3              0             0       0              0           0    0      while (size-1 != x){
        37,912       0    0              0             0       0              0           0    0          size = (size-1)>>1;
        18,956       0    0              0             0       0              0           0    0          seq--;
        56,868       0    0              0             0       0              0           0    0          x = x % size;
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      return pow(y, seq);
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static bool switch_mode = false;
             .       .    .              .             .       .              .           .    .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
             .       .    .              .             .       .              .           .    .  
            16       2    2              0             0       0             12           0    0  uint32_t Solver::reduceduplicates(){
             .       .    .              .             .       .              .           .    .      uint32_t removed_duplicates = 0;
             .       .    .              .             .       .              .           .    .      std::vector<std::vector<uint64_t>> tmp;
             .       .    .              .             .       .              .           .    .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
         3,734       0    0              4             0       0              0           0    0      for (auto & outer_mp: ht){//variables
        39,748       0    0              0             0       0              0           0    0          for (auto &inner_mp:outer_mp.second){//sizes
     2,097,570       0    0              0             0       0              0           0    0              for (auto &in_in_mp: inner_mp.second){
     3,095,103       2    2      1,031,701     1,004,665 449,071              0           0    0                  if (in_in_mp.second >= 2){
             .       .    .              .             .       .              .           .    .                  //min_number_of_learnts_copies
       501,160       2    2        200,464           721     301        200,464         131    0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
             .       .    .              .             .       .              .           .    .                  }
             .       .    .              .             .       .              .           .    .              }                    
             .       .    .              .             .       .              .           .    .           }
             .       .    .              .             .       .              .           .    .      }          
             6       0    0              2             2       2              2           0    0      removed_duplicates = dupl_db_size-tmp.size();  
             .       .    .              .             .       .              .           .    .      ht.clear();
       350,822       2    2        150,350            21       3              0           0    0      for (auto i=0;i<tmp.size();i++){
       501,160       0    0        250,580        56,420  56,276        150,348          13    2          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .      return removed_duplicates;
            18       0    0             16             4       2              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  // NOTE: assumptions passed in member-variable 'assumptions'.
             .       .    .              .             .       .              .           .    .  lbool Solver::solve_()
             8       0    0              0             0       0              6           0    0  {
             .       .    .              .             .       .              .           .    .      //signal(SIGALRM, SIGALRM_switch);
             .       .    .              .             .       .              .           .    .      //alarm(2500);
             .       .    .              .             .       .              .           .    .  
             1       1    1              0             0       0              0           0    0      model.clear();
             .       .    .              .             .       .              .           .    .      conflict.clear();
             2       1    1              1             0       0              0           0    0      if (!ok) return l_False;
             .       .    .              .             .       .              .           .    .  
             1       1    1              1             0       0              0           0    0      solves++;
             .       .    .              .             .       .              .           .    .  
             5       0    0              2             1       0              1           0    0      max_learnts               = nClauses() * learntsize_factor;
             3       0    0              1             1       0              0           0    0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
             1       0    0              0             0       0              1           1    0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
             .       .    .              .             .       .              .           .    .      lbool   status            = l_Undef;
             .       .    .              .             .       .              .           .    .  
             3       0    0              1             0       0              0           0    0      if (verbosity >= 1){
             2       0    0              0             0       0              1           0    0          printf("c ============================[ Search Statistics ]==============================\n");
             2       1    1              0             0       0              1           0    0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
             2       0    0              0             0       0              1           0    0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
             2       0    0              0             0       0              1           0    0          printf("c ===============================================================================\n");
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      add_tmp.clear();
             .       .    .              .             .       .              .           .    .  
             1       0    0              0             0       0              1           0    0      VSIDS = true;
             1       1    1              0             0       0              1           0    0      int init = 10000;
           545       0    0            109           109       0              0           0    0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
           436       3    0              0             0       0            109           0    0          status = search(init);
             1       0    0              0             0       0              1           0    0      VSIDS = false;
             .       .    .              .             .       .              .           .    .  
             3       1    1              0             0       0              2           2    0      duplicates_added_conflicts = 0;
             .       .    .              .             .       .              .           .    .      duplicates_added_minimization=0;
             .       .    .              .             .       .              .           .    .      duplicates_added_tier2 =0;    
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      dupl_db_size=0;
             1       0    0              1             1       0              0           0    0      size_t dupl_db_size_limit = dupl_db_init_size;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // Search:
             1       0    0              0             0       0              0           0    0      int curr_restarts = 0;
             1       0    0              0             0       0              0           0    0      uint64_t curr_props = 0;
             .       .    .              .             .       .              .           .    .      uint32_t removed_duplicates =0;
         8,384   1,598   11              0             0       0              0           0    0      while (status == l_Undef /*&& withinBudget()*/){
         8,384       1    1          4,192         1,887       0              0           0    0          if (dupl_db_size >= dupl_db_size_limit){    
             8       2    2              2             2       0              2           0    0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             8       0    0              2             0       0              2           0    0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             8       0    0              2             0       0              2           0    0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             8       2    2              2             2       0              2           0    0              printf("c Duptime: %i\n",duptime.count());
             8       0    0              2             0       0              2           0    0              printf("c Number of conflicts: %i\n",conflicts);
             8       0    0              2             2       0              2           0    0              printf("c Core size: %i\n",learnts_core.size());
             .       .    .              .             .       .              .           .    .              
             4       0    0              0             0       0              2           0    0              removed_duplicates = reduceduplicates();
            16       2    2              4             4       4              0           0    0              dupl_db_size_limit*=1.1;
             4       0    0              2             2       2              0           0    0              dupl_db_size -= removed_duplicates;
            10       0    0              0             0       0              2           0    0              printf("c removed duplicates %i\n",removed_duplicates);
             .       .    .              .             .       .              .           .    .          }   
        25,152     106   19          8,384         4,709       4              0           0    0          if (propagations - curr_props >  VSIDS_props_limit){
             6       0    0              0             0       0              0           0    0              curr_props = propagations;
             6       0    0              0             0       0              6           1    1              switch_mode = true;
            31       0    0              0             0       0              6           0    0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
             .       .    .              .             .       .              .           .    .          }     
         8,384       0    0          4,192             2       2              0           0    0          if (VSIDS){
         1,890       0    0              0             0       0          1,890       1,881    1              int weighted = INT32_MAX;
         7,560   1,890    6              0             0       0          1,890           0    0              status = search(weighted);
             .       .    .              .             .       .              .           .    .          }else{
        13,812   1,183   10          4,604             0       0          2,302         446    1              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
         2,302       0    0              0             0       0              0           0    0              curr_restarts++;
        11,510   2,270    6              0             0       0          2,302           0    0              status = search(nof_conflicts);
             .       .    .              .             .       .              .           .    .          }
         8,384   2,268    3          4,192         4,192       6              0           0    0          if (switch_mode){ 
             6       0    0              0             0       0              6           0    0              switch_mode = false;
             .       .    .              .             .       .              .           .    .              VSIDS = !VSIDS;
            12       0    0              6             0       0              0           0    0              if (VSIDS){
             6       3    3              0             0       0              3           0    0                  printf("c Switched to VSIDS.\n");
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              else{
             9       3    3              0             0       0              3           0    0                 printf("c Switched to LRB.\n");
             .       .    .              .             .       .              .           .    .              }
             .       .    .              .             .       .              .           .    .              //            reduceduplicates();            
            12       3    3              6             6       5              6           0    0              fflush(stdout);
             .       .    .              .             .       .              .           .    .              picked.clear();
             .       .    .              .             .       .              .           .    .              conflicted.clear();
             .       .    .              .             .       .              .           .    .              almost_conflicted.clear();
             .       .    .              .             .       .              .           .    .  #ifdef ANTI_EXPLORATION
             .       .    .              .             .       .              .           .    .              canceled.clear();
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             3       1    1              1             1       0              0           0    0      if (verbosity >= 1)
             2       0    0              0             0       0              1           0    0          printf("c ===============================================================================\n");
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  #ifdef BIN_DRUP
             3       0    0              1             0       0              0           0    0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
             .       .    .              .             .       .              .           .    .  #endif
             .       .    .              .             .       .              .           .    .  
             2       1    1              0             0       0              0           0    0      if (status == l_True){
             .       .    .              .             .       .              .           .    .          // Extend & copy model:
             .       .    .              .             .       .              .           .    .          model.growTo(nVars());
           319       1    1            137            14       6            147           0    0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
             .       .    .              .             .       .              .           .    .      }else if (status == l_False && conflict.size() == 0)
             .       .    .              .             .       .              .           .    .          ok = false;
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      cancelUntil(0);
             1       0    0              0             0       0              0           0    0      return status;
             8       1    1              7             2       1              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Writing CNF to DIMACS:
             .       .    .              .             .       .              .           .    .  // 
             .       .    .              .             .       .              .           .    .  // FIXME: this needs to be rewritten completely.
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  static Var mapVar(Var x, vec<Var>& map, Var& max)
             .       .    .              .             .       .              .           .    .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
             .       .    .              .             .       .              .           .    .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
             .       .    .              .             .       .              .           .    .  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  //=================================================================================================
             .       .    .              .             .       .              .           .    .  // Garbage Collection methods:
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::relocAll(ClauseAllocator& to)
         1,740      74   31              0             0       0          1,392           0    0  {
             .       .    .              .             .       .              .           .    .      // All watchers:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      // for (int i = 0; i < watches.size(); i++)
           348       0    0              0             0       0            174           0    0      watches.cleanAll();
           348       0    0              0             0       0            174           0    0      watches_bin.cleanAll();
     3,806,424      10    6      2,663,940        13,464       0        380,886         174    0      for (int v = 0; v < nVars(); v++)
     1,522,152       0    0        761,076             0       0              0           0    0          for (int s = 0; s < 2; s++){
             .       .    .              .             .       .              .           .    .              Lit p = mkLit(v, s);
             .       .    .              .             .       .              .           .    .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
             .       .    .              .             .       .              .           .    .              vec<Watcher>& ws = watches[p];
    72,184,760      37   18     37,402,388       190,513  10,961              0           0    0              for (int j = 0; j < ws.size(); j++)
             .       .    .              .             .       .              .           .    .                  ca.reloc(ws[j].cref, to);
             .       .    .              .             .       .              .           .    .              vec<Watcher>& ws_bin = watches_bin[p];
     6,450,510       4    3      2,467,956       200,290  11,865              0           0    0              for (int j = 0; j < ws_bin.size(); j++)
             .       .    .              .             .       .              .           .    .                  ca.reloc(ws_bin[j].cref, to);
             .       .    .              .             .       .              .           .    .          }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // All reasons:
             .       .    .              .             .       .              .           .    .      //
       250,358       0    0            522           174       0              0           0    0      for (int i = 0; i < trail.size(); i++){
             .       .    .              .             .       .              .           .    .          Var v = var(trail[i]);
             .       .    .              .             .       .              .           .    .  
       293,352       0    0         22,019        21,334       0              0           0    0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
       110,443       0    0         22,019             0       0         22,019         172    0              ca.reloc(vardata[v].reason, to);
             .       .    .              .             .       .              .           .    .      }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // All learnt:
             .       .    .              .             .       .              .           .    .      //
     4,765,499     120   20      2,382,662           188       0              0           0    0      for (int i = 0; i < learnts_core.size(); i++)
             .       .    .              .             .       .              .           .    .          ca.reloc(learnts_core[i], to);
     1,565,155     522   71        782,577           346       0              0           0    0      for (int i = 0; i < learnts_tier2.size(); i++)
             .       .    .              .             .       .              .           .    .          ca.reloc(learnts_tier2[i], to);
     5,033,801     174   23      2,516,553           174       0              0           0    0      for (int i = 0; i < learnts_local.size(); i++)
     7,548,615       0    0              0             0       0      2,516,205         173    0          ca.reloc(learnts_local[i], to);
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      // All original:
             .       .    .              .             .       .              .           .    .      //
             .       .    .              .             .       .              .           .    .      int i, j;
     7,070,838     174   23            696           347       0              0           0    0      for (i = j = 0; i < clauses.size(); i++)
     7,069,272       0    0              0             0       0              0           0    0          if (ca[clauses[i]].mark() != 1){
    10,604,256     174   16      3,534,636             0       0      3,534,636           0    0              ca.reloc(clauses[i], to);
    35,346,186     121    9     14,138,370             0       0      3,534,636           0    0              clauses[j++] = clauses[i]; }
           174     174   20              0             0       0              0           0    0      clauses.shrink(i - j);
         1,392     174   25          1,218           174       0              0           0    0  }
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .  void Solver::garbageCollect()
             .       .    .              .             .       .              .           .    .  {
             .       .    .              .             .       .              .           .    .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
             .       .    .              .             .       .              .           .    .      // is not precise but should avoid some unnecessary reallocations for the new region:
             .       .    .              .             .       .              .           .    .      ClauseAllocator to(ca.size() - ca.wasted());
             .       .    .              .             .       .              .           .    .  
             .       .    .              .             .       .              .           .    .      relocAll(to);
             .       .    .              .             .       .              .           .    .      if (verbosity >= 2)
             .       .    .              .             .       .              .           .    .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
             .       .    .              .             .       .              .           .    .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
             .       .    .              .             .       .              .           .    .      to.moveTo(ca);
           155      18   18             47             4       4             61           0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr            D1mr      DLmr   Dw         D1mw DLmw 

-- line 40 ----------------------------------------
             .     .    .             .         .      .          .    .    .      void capacity(uint32_t min_cap);
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .   public:
             .     .    .             .         .      .          .    .    .      // TODO: make this a class for better type-checking?
             .     .    .             .         .      .          .    .    .      typedef uint32_t Ref;
             .     .    .             .         .      .          .    .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .             .         .      .          .    .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .             .         .      .          .    .    .  
           876     1    1             0         0      0        700  173    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .             .         .      .          .    .    .      ~RegionAllocator()
             .     .    .             .         .      .          .    .    .      {
             .     .    .             .         .      .          .    .    .          if (memory != NULL)
             .     .    .             .         .      .          .    .    .              ::free(memory);
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      uint32_t size      () const      { return sz; }
             .     .    .             .         .      .          .    .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      Ref      alloc     (int size); 
     7,666,434     0    0     2,555,478         0      0  2,555,478    0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
11,920,531,795   480   91 5,909,228,808 3,382,417 99,829    133,016    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    16,948,496     0    0    16,948,496 2,212,082 21,752          0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .             .         .      .          .    .    .  
    38,128,909 2,908   20     2,633,304         0      0          0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     4,599,060     0    0             0         0      0          0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .             .         .      .          .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .             .         .      .          .    .    .          return  (Ref)(t - &memory[0]); }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      void     moveTo(RegionAllocator& to) {
           696     0    0           174         0      0        174    0    0          if (to.memory != NULL) ::free(to.memory);
           348     0    0           174         0      0        174    0    0          to.memory = memory;
           348     0    0           174         0      0        174    0    0          to.sz = sz;
             .     .    .             .         .      .          .    .    .          to.cap = cap;
           348     0    0           174         0      0        174    0    0          to.wasted_ = wasted_;
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .          memory = NULL;
             .     .    .             .         .      .          .    .    .          sz = cap = wasted_ = 0;
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  };
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  template<class T>
         2,130    82   46             0         0      0        710    0    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .             .         .      .          .    .    .  {
    35,519,973     2    0    11,839,991         0      0          0    0    0      if (cap >= min_cap) return;
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      uint32_t prev_cap = cap;
        10,155     0    0             0         0      0        355    0    0      while (cap < min_cap){
             .     .    .             .         .      .          .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .             .         .      .          .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .             .         .      .          .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .             .         .      .          .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        29,400     0    0             0         0      0          0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         4,900     0    0             0         0      0          0    0    0          cap += delta;
             .     .    .             .         .      .          .    .    .  
         9,800     0    0             0         0      0          0    0    0          if (cap <= prev_cap)
             .     .    .             .         .      .          .    .    .              throw OutOfMemoryException();
             .     .    .             .         .      .          .    .    .      }
             .     .    .             .         .      .          .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      assert(cap > 0);
           710     2    1             0         0      0        355  175    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
         1,420     0    0         1,065         0      0          0    0    0  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  template<class T>
             .     .    .             .         .      .          .    .    .  typename RegionAllocator<T>::Ref
        95,368     2    1             0         0      0     71,526    0    0  RegionAllocator<T>::alloc(int size)
             .     .    .             .         .      .          .    .    .  { 
             .     .    .             .         .      .          .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .             .         .      .          .    .    .      assert(size > 0);
    63,115,143     0    0    11,839,816   948,624      0 30,228,996  212    0      capacity(sz + size);
             .     .    .             .         .      .          .    .    .  
    38,057,381     0    0    21,022,484         0      0          0    0    0      uint32_t prev_sz = sz;
    11,839,816     2    1             0         0      0 11,839,816    0    0      sz += size;
             .     .    .             .         .      .          .    .    .      
             .     .    .             .         .      .          .    .    .      // Handle overflow:
    51,299,167   127   33     9,206,512         0      0          0    0    0      if (sz < prev_sz)
             2     1    1             1         1      0          0    0    0          throw OutOfMemoryException();
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .      return prev_sz;
        95,368     0    0        95,368         0      0          0    0    0  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  //=================================================================================================
             .     .    .             .         .      .          .    .    .  }
             .     .    .             .         .      .          .    .    .  
             .     .    .             .         .      .          .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr            D1mr        DLmr Dw            D1mw       DLmw 

-- line 31 ----------------------------------------
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  template<class Comp>
            .     .    .             .           .    .             .          .    .  class Heap {
            .     .    .             .           .    .             .          .    .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
            .     .    .             .           .    .             .          .    .      vec<int> heap;     // Heap of integers
            .     .    .             .           .    .             .          .    .      vec<int> indices;  // Each integers position (index) in the Heap
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .      // Index "traversal" functions
  293,725,518     4    2             0           0    0             0          0    0      static inline int left  (int i) { return i*2+1; }
1,149,438,784    10    6   459,713,817 176,246,207  965             0          0    0      static inline int right (int i) { return (i+1)*2; }
  805,422,480     5    5   108,294,852           0    0             0          0    0      static inline int parent(int i) { return (i-1) >> 1; }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
  216,589,704    10    7             0           0    0   216,589,704          0    0      void percolateUp(int i)
            .     .    .             .           .    .             .          .    .      {
  641,330,535     0    0   379,211,198  20,670,489  287   153,824,485          0    0          int x  = heap[i];
            .     .    .             .           .    .             .          .    .          int p  = parent(i);
            .     .    .             .           .    .             .          .    .          
2,529,928,577    27   12   853,258,700  72,952,170  120    19,139,891          0    0          while (i != 0 && lt(x, heap[p])){
  154,564,193    30   13             0           0    0   154,564,193          0    0              heap[i]          = heap[p];
  154,564,193     0    0             0           0    0   154,564,193 20,191,123   60              indices[heap[p]] = i;
            .     .    .             .           .    .             .          .    .              i                = p;
  164,209,360     0    0             0           0    0             0          0    0              p                = parent(p);
            .     .    .             .           .    .             .          .    .          }
  270,916,346     7    5    76,916,757           0    0   193,999,589          0    0          heap   [i] = x;
  280,829,985     2    2    76,925,396           0    0   194,008,423          0    0          indices[x] = i;
  411,295,226     0    0   324,884,556           0    0             0          0    0      }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
1,208,788,161     0    0   172,684,023           0    0 1,036,104,138          0    0      void percolateDown(int i)
            .     .    .             .           .    .             .          .    .      {
  539,309,647 1,429   15   355,494,642  63,266,546   33   183,810,715          0    0          int x = heap[i];
1,150,269,280 9,130   14   286,046,696           1    0             0          0    0          while (left(i) < heap.size()){
1,572,271,368     6    5   227,708,681  10,616,946   47             0          0    0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
  606,823,472     6    1             0           0    0             0          0    0              if (!lt(heap[child], x)) break;
  111,009,128     0    0             0           0    0   111,009,128          0    0              heap[i]          = heap[child];
  111,009,128     0    0             0           0    0   111,009,128 33,009,311  444              indices[heap[i]] = i;
   86,065,833     0    0             0           0    0             0          0    0              i                = child;
            .     .    .             .           .    .             .          .    .          }
  365,397,583    20   10   182,698,889           0    0   182,698,694          0    0          heap   [i] = x;
  202,492,972     2    2     9,895,822           0    0   182,698,694         47    0          indices[x] = i;
1,217,581,529     0    0 1,208,788,161           0    0             0          0    0      }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .    public:
            .     .    .             .           .    .             .          .    .      Heap(const Comp& c) : lt(c) { }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .      int  size      ()          const { return heap.size(); }
    8,781,701     2    1     8,781,701   1,718,362    2             0          0    0      bool empty     ()          const { return heap.size() == 0; }
5,296,719,158 1,203   50 2,702,769,678 167,596,098  461             0          0    0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
   13,368,247     6    4     8,542,921   1,030,405    4             0          0    0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
  523,720,470     0    0   370,155,087           0    0   108,294,852         64    0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
  928,375,043     4    4   583,006,996           0    0   172,684,023        364    0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .      // Safe variant of insert/decrease/increase:
            .     .    .             .           .    .             .          .    .      void update(int n)
            .     .    .             .           .    .             .          .    .      {
            .     .    .             .           .    .             .          .    .          if (!inHeap(n))
            .     .    .             .           .    .             .          .    .              insert(n);
            .     .    .             .           .    .             .          .    .          else {
            .     .    .             .           .    .             .          .    .              percolateUp(indices[n]);
       18,058     0    0         9,029           0    0             0          0    0              percolateDown(indices[n]); }
            .     .    .             .           .    .             .          .    .      }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .      void insert(int n)
            .     .    .             .           .    .             .          .    .      {
    8,787,980     2    2             0           0    0             0          0    0          indices.growTo(n+1, -1);
            .     .    .             .           .    .             .          .    .          assert(!inHeap(n));
            .     .    .             .           .    .             .          .    .  
   17,575,960     1    1     8,787,980       2,512    0     8,787,980          0    0          indices[n] = heap.size();
       10,652     1    1             0           0    0         7,056          0    0          heap.push(n);
   17,575,960     0    0     8,787,980           0    0             0          0    0          percolateUp(indices[n]); 
            .     .    .             .           .    .             .          .    .      }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .      int  removeMin()
            .     .    .             .           .    .             .          .    .      {
   26,345,100     1    1    17,563,400   1,215,826    4     8,781,700          0    0          int x            = heap[0];
   17,563,400     0    0     8,781,700   2,118,101   13     8,781,700          0    0          heap[0]          = heap.last();
   17,563,400    18   11     8,781,700   1,203,682    1     8,781,700  5,232,590  257          indices[heap[0]] = 0;
    8,781,700     1    1             0           0    0     8,781,700  2,057,617    5          indices[x]       = -1;
            .     .    .             .           .    .             .          .    .          heap.pop();
   17,563,400     0    0             0           0    0             0          0    0          if (heap.size() > 1) percolateDown(0);
            .     .    .             .           .    .             .          .    .          return x; 
            .     .    .             .           .    .             .          .    .      }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .      // Rebuild the heap from scratch, using the elements in 'ns':
            .     .    .             .           .    .             .          .    .      void build(const vec<int>& ns) {
       22,848     6    3        11,424           2    0             0          0    0          for (int i = 0; i < heap.size(); i++)
       11,430     2    1             6           2    0        11,412        740    0              indices[heap[i]] = -1;
            6     0    0             0           0    0             0          0    0          heap.clear();
            .     .    .             .           .    .             .          .    .  
       17,202     2    1         8,592           0    0             0          0    0          for (int i = 0; i < ns.size(); i++){
       17,172     0    0         8,586           0    0         8,586          0    0              indices[ns[i]] = i;
            .     .    .             .           .    .             .          .    .              heap.push(ns[i]); }
            .     .    .             .           .    .             .          .    .  
       30,092     5    3         4,296           0    0             6          0    0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
            .     .    .             .           .    .             .          .    .              percolateDown(i);
            .     .    .             .           .    .             .          .    .      }
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .      void clear(bool dealloc = false) 
            .     .    .             .           .    .             .          .    .      { 
            4     0    0             2           0    0             0          0    0          for (int i = 0; i < heap.size(); i++)
            .     .    .             .           .    .             .          .    .              indices[heap[i]] = -1;
            .     .    .             .           .    .             .          .    .          heap.clear(dealloc); 
            .     .    .             .           .    .             .          .    .      }
            .     .    .             .           .    .             .          .    .  };
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  
            .     .    .             .           .    .             .          .    .  //=================================================================================================
            .     .    .             .           .    .             .          .    .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h
--------------------------------------------------------------------------------
Ir          I1mr  ILmr Dr         D1mr       DLmr   Dw         D1mw    DLmw 

-- line 36 ----------------------------------------
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  template <class T, class LessThan>
          .     .    .          .          .      .          .       .    .  void selectionSort(T* array, int size, LessThan lt)
          .     .    .          .          .      .          .       .    .  {
          .     .    .          .          .      .          .       .    .      int     i, j, best_i;
          .     .    .          .          .      .          .       .    .      T       tmp;
          .     .    .          .          .      .          .       .    .  
 13,645,232   121   14  4,664,986          0      0    547,592   3,916    0      for (i = 0; i < size-1; i++){
          .     .    .          .          .      .          .       .    .          best_i = i;
 73,672,174   361   61  4,839,383        903      0          0       0    0          for (j = i+1; j < size; j++){
251,286,603 1,213  194 24,836,052        341      0          0       0    0              if (lt(array[j], array[best_i]))
          .     .    .          .          .      .          .       .    .                  best_i = j;
          .     .    .          .          .      .          .       .    .          }
 18,774,901     0    0    114,957          0      0  9,329,972       0    0          tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
          .     .    .          .          .      .          .       .    .      }
          .     .    .          .          .      .          .       .    .  }
          .     .    .          .          .      .          .       .    .  template <class T> static inline void selectionSort(T* array, int size) {
          .     .    .          .          .      .          .       .    .      selectionSort(array, size, LessThan_default<T>()); }
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  template <class T, class LessThan>
  6,018,322   145   28          0          0      0  4,206,755 134,912  246  void sort(T* array, int size, LessThan lt)
          .     .    .          .          .      .          .       .    .  {
  3,080,602   175   31          0          0      0          0       0    0      if (size <= 15)
          .     .    .          .          .      .          .       .    .          selectionSort(array, size, lt);
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .      else{
  2,917,240     0    0    583,448     40,665      5          0       0    0          T           pivot = array[size / 2];
          .     .    .          .          .      .          .       .    .          T           tmp;
    583,448     0    0          0          0      0          0       0    0          int         i = -1;
          .     .    .          .          .      .          .       .    .          int         j = size;
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .          for(;;){
218,110,796   111   14 63,041,640 17,864,112 15,906          0       0    0              do i++; while(lt(array[i], pivot));
368,559,152    12    0 92,139,788 19,660,092  6,563          0       0    0              do j--; while(lt(pivot, array[j]));
          .     .    .          .          .      .          .       .    .  
 18,934,952     0    0          0          0      0          0       0    0              if (i >= j) break;
          .     .    .          .          .      .          .       .    .  
 79,642,800    99   19          0          0      0 17,768,056  16,215    0              tmp = array[i]; array[i] = array[j]; array[j] = tmp;
          .     .    .          .          .      .          .       .    .          }
          .     .    .          .          .      .          .       .    .  
  1,750,344     0    0          0          0      0    583,448  67,617   64          sort(array    , i     , lt);
    583,448     0    0          0          0      0          0       0    0          sort(&array[i], size-i, lt);
          .     .    .          .          .      .          .       .    .      }
  4,851,080     0    0  4,237,107     14,517      0          0       0    0  }
          .     .    .          .          .      .          .       .    .  template <class T> static inline void sort(T* array, int size) {
          .     .    .          .          .      .          .       .    .      sort(array, size, LessThan_default<T>()); }
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  //=================================================================================================
          .     .    .          .          .      .          .       .    .  // For 'vec's:
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {
     91,575   119   17     61,050        130      0     30,525       6    0      sort((T*)v, v.size(), lt); }
          .     .    .          .          .      .          .       .    .  template <class T> void sort(vec<T>& v) {
          .     .    .          .          .      .          .       .    .      sort(v, LessThan_default<T>()); }
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  //=================================================================================================
          .     .    .          .          .      .          .       .    .  }
          .     .    .          .          .      .          .       .    .  
          .     .    .          .          .      .          .       .    .  #endif
-- line 98 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr        DLmr   Dw             D1mw       DLmw    

-- line 54 ----------------------------------------
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  struct Lit {
              .     .    .              .           .      .              .          .       .      int     x;
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      // Use this as a constructor:
              .     .    .              .           .      .              .          .       .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      bool operator == (Lit p) const { return x == p.x; }
    406,344,568     0    0    203,579,454 100,917,630    330              0          0       0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .           .      .              .          .       .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .           .      .              .          .       .  };
              .     .    .              .           .      .              .          .       .  
         98,946     0    0              0           0      0            372          4       0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 10,770,940,947    38   22  4,656,319,879     153,432    411    577,907,101     61,536       0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .           .      .              .          .       .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 64,062,040,980    10    7  1,363,965,321           0      0    682,550,921 43,666,437      80  inline  bool sign      (Lit p)              { return p.x & 1; }
103,095,996,290 3,435  104  1,708,335,863  21,428,916    467 22,965,111,829          0       0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .           .      .              .          .       .  inline  int  toInt     (Var v)              { return v; } 
          1,277     0    0              8           0      0              8          0       0  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .           .      .              .          .       .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .           .      .              .          .       .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .           .      .              .          .       .  const Lit lit_Error = { -1 };  // }
              .     .    .              .           .      .              .          .       .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .     .    .              .           .      .              .          .       .  #define l_Undef (lbool((uint8_t)2))
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  class lbool {
              .     .    .              .           .      .              .          .       .      uint8_t value;
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  public:
              .     .    .              .           .      .              .          .       .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .           .      .              .          .       .  
            566     1    1              0           0      0            147         33      33      lbool()       : value(0) { }
              .     .    .              .           .      .              .          .       .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .           .      .              .          .       .  
    998,983,504     1    1              0           0      0              0          0       0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
          6,561     0    0          4,374          35      0              0          0       0      bool  operator != (lbool b) const { return !(*this == b); }
 11,929,375,753    36   18 11,380,495,926  16,827,868     12              0          0       0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      lbool operator && (lbool b) const {
              .     .    .              .           .      .              .          .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .           .      .              .          .       .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .           .      .              .          .       .          return lbool(v); }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      lbool operator || (lbool b) const {
              .     .    .              .           .      .              .          .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .           .      .              .          .       .          unsigned simplified : 1;}                            header;
              .     .    .              .           .      .              .          .       .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      friend class ClauseAllocator;
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .           .      .              .          .       .      template<class V>
              .     .    .              .           .      .              .          .       .      Clause(const V& ps, bool use_extra, bool learnt) {
     39,530,882     0    0      9,230,355           0      0     11,839,816    110,400       0          header.mark      = 0;
     27,619,536     0    0      9,206,512     576,106 25,085              0          0       0          header.learnt    = learnt;
     55,405,973     2    2      9,254,198           0      0      9,230,355          0       0          header.has_extra = learnt | use_extra;
              .     .    .              .           .      .              .          .       .          header.reloced   = 0;
     14,473,118     0    0      2,633,303         175      0     11,839,815  2,052,435  32,295          header.size      = ps.size();
              .     .    .              .           .      .              .          .       .          header.lbd       = 0;
              .     .    .              .           .      .              .          .       .          header.removable = 1;
              .     .    .              .           .      .              .          .       .          //simplify
              .     .    .              .           .      .              .          .       .          //
     11,839,816     8    6     11,839,816   1,315,872 65,709              0          0       0          header.simplified = 0;
              .     .    .              .           .      .              .          .       .  
    423,784,983   210   29      2,745,228           0      0              0          0       0          for (int i = 0; i < ps.size(); i++)
    256,377,371   227   33     87,841,680   8,172,698 19,440    103,889,486 10,839,473 731,481              data[i].lit = ps[i];
              .     .    .              .           .      .              .          .       .  
     35,519,447    38   17     11,839,815           0      0              0          0       0          if (header.has_extra){
     16,610,358     4    3              0           0      0              0          0       0              if (header.learnt){
     16,562,674     1    1      5,671,874           0      0      8,281,337    518,196  28,220                  data[header.size].act = 0;
     16,562,676     0    0              0           0      0      8,281,337    518,533  27,964                  data[header.size+1].touched = 0;
              .     .    .              .           .      .              .          .       .              }else
              .     .    .              .           .      .              .          .       .                  calcAbstraction(); }
              .     .    .              .           .      .              .          .       .      }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  public:
              .     .    .              .           .      .              .          .       .      void calcAbstraction() {
              .     .    .              .           .      .              .          .       .          assert(header.has_extra);
         25,177     0    0              0           0      0              0          0       0          uint32_t abstraction = 0;
        324,726     2    1            146           0      0              0          0       0          for (int i = 0; i < size(); i++)
        524,223     2    1              0           0      0              1          0       0              abstraction |= 1 << (var(data[i].lit) & 31);
         48,449     0    0              0           0      0         24,607      1,817   1,817          data[header.size].abs = abstraction;  }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
  9,699,984,343   142   76  4,732,562,782 605,251,113  8,640  3,830,207,886         32       0      int          size        ()      const   { return header.size; }
        905,525    20   13        226,384      35,174      1        226,384      1,925       0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .           .      .              .          .       .      void         pop         ()              { shrink(1); }
    109,115,234     3    3      2,555,478           0      0              0          0       0      bool         learnt      ()      const   { return header.learnt; }
          7,056     0    0              0           0      0              0          0       0      bool         has_extra   ()      const   { return header.has_extra; }
    158,672,761   181   24     22,356,401  20,198,915 15,252     47,754,372          0       0      uint32_t     mark        ()      const   { return header.mark; }
     48,577,977   210   18     12,412,127       1,640      0     12,032,173          0       0      void         mark        (uint32_t m)    { header.mark = m; }
        122,684     0    0              0           0      0         61,342      7,132       0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .           .      .              .          .       .  
     27,649,901     0    0     27,649,901  19,074,687  1,966              0          0       0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .           .      .              .          .       .      CRef         relocation  ()      const   { return data[0].rel; }
     36,826,048    30   13      9,206,512           0      0     18,413,024          0       0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .           .      .              .          .       .  
     26,394,833     0    0      8,793,884           0      0              0          0       0      int          lbd         ()      const   { return header.lbd; }
     58,156,112   150   29     14,361,620           0      0      8,689,958          0       0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .           .      .              .          .       .      bool         removable   ()      const   { return header.removable; }
     36,930,061     4    4     14,242,557           0      0      5,671,876          0       0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .           .      .              .          .       .      //       subsumption operations to behave correctly.
 10,987,823,452   103   38 10,758,075,302 795,101,364 28,354              0          0       0      Lit&         operator [] (int i)         { return data[i].lit; }
    152,943,266   318   50    132,862,046   4,263,514  4,353              0          0       0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .           .      .              .          .       .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .           .      .              .          .       .  
      5,795,270     0    0      5,795,270           5      0              0          0       0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     12,075,293     0    0      3,762,632     867,097     43              0          0       0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .           .      .              .          .       .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .           .      .              .          .       .      void         strengthen  (Lit p);
              .     .    .              .           .      .              .          .       .      // simplify
              .     .    .              .           .      .              .          .       .      //
     39,918,478     0    0     11,451,425           0      0      5,671,876          0       0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .           .      .              .          .       .      bool simplified() { return header.simplified; }
              .     .    .              .           .      .              .          .       .  };
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  //=================================================================================================
              .     .    .              .           .      .              .          .       .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .           .      .              .          .       .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .           .      .              .          .       .  {
              .     .    .              .           .      .              .          .       .      static int clauseWord32Size(int size, int extras){
     23,601,807     0    0     11,761,990     515,993  1,376              0          0       0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .           .      .              .          .       .  public:
              .     .    .              .           .      .              .          .       .      bool extra_clause_field;
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0           0      0              1          0       0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      void moveTo(ClauseAllocator& to){
            348    22    6            174         174      0            174          0       0          to.extra_clause_field = extra_clause_field;
              .     .    .              .           .      .              .          .       .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      template<class Lits>
              .     .    .              .           .      .              .          .       .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .           .      .              .          .       .      {
              .     .    .              .           .      .              .          .       .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .           .      .              .          .       .          assert(sizeof(float)    == sizeof(uint32_t));
     21,971,502   129   32      3,558,478         248      0              0          0       0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .           .      .              .          .       .  
      2,657,145     0    0              0           0      0         23,842          0       0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .           .      .              .          .       .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .          return cid;
              .     .    .              .           .      .              .          .       .      }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
     86,051,584   173   17     76,333,885      54,511      0         13,676          0       0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
          5,384     1    1          2,692          80      0              0          0       0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
      9,206,512     0    0      9,206,512           0      0              0          0       0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .           .      .              .          .       .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .           .      .              .          .       .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      void free(CRef cid)
              .     .    .              .           .      .              .          .       .      {
              .     .    .              .           .      .              .          .       .          Clause& c = operator[](cid);
      7,673,490     1    1              0           0      0              0          0       0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .           .      .              .          .       .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .           .      .              .          .       .      }
              .     .    .              .           .      .              .          .       .  
     42,510,020   174   22              0           0      0     36,437,160          1       0      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .           .      .              .          .       .      {
              .     .    .              .           .      .              .          .       .          Clause& c = operator[](cr);
              .     .    .              .           .      .              .          .       .          
     95,350,601     0    0     18,443,389   2,835,433      0     18,443,389          0       0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .           .      .              .          .       .          
      9,206,512     0    0              0           0      0      9,206,512          0       0          cr = to.alloc(c, c.learnt());
              .     .    .              .           .      .              .          .       .          c.relocate(cr);
              .     .    .              .           .      .              .          .       .          
              .     .    .              .           .      .              .          .       .          // Copy extra data-fields:
              .     .    .              .           .      .              .          .       .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .           .      .              .          .       .          to[cr].mark(c.mark());
     18,413,024     1    1              0           0      0              0          0       0          if (to[cr].learnt()){
     22,687,504     0    0      5,671,876     327,071     66      5,671,876          0       0              to[cr].touched() = c.touched();
     22,687,502     0    0     11,343,752     327,826     63      5,671,876          0       0              to[cr].activity() = c.activity();
              .     .    .              .           .      .              .          .       .              to[cr].set_lbd(c.lbd());
              .     .    .              .           .      .              .          .       .              to[cr].removable(c.removable());
              .     .    .              .           .      .              .          .       .              // simplify
              .     .    .              .           .      .              .          .       .              //
              .     .    .              .           .      .              .          .       .              to[cr].setSimplified(c.simplified());
              .     .    .              .           .      .              .          .       .          }
      7,069,272   331   59              0           0      0              0          0       0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     48,582,880     0    0     42,510,020           0      0              0          0       0      }
              .     .    .              .           .      .              .          .       .  };
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .           .      .              .          .       .  {
              .     .    .              .           .      .              .          .       .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .           .      .              .          .       .      {
              .     .    .              .           .      .              .          .       .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .           .      .              .          .       .  class OccLists
              .     .    .              .           .      .              .          .       .  {
              .     .    .              .           .      .              .          .       .      vec<Vec>  occs;
              .     .    .              .           .      .              .          .       .      vec<char> dirty;
              .     .    .              .           .      .              .          .       .      vec<Idx>  dirties;
              .     .    .              .           .      .              .          .       .      Deleted   deleted;
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  public:
              3     0    0              0           0      0              3          0       0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .           .      .              .          .       .      unsigned int size(){
              .     .    .              .           .      .              .          .       .          auto m_size=0;
             40     2    2              4           3      0              0          0       0          for(int i=0;i<occs.size();i++){
         48,188    14   14         17,500       4,376     41              0          0       0              m_size+=occs[i].size();
              .     .    .              .           .      .              .          .       .          }
              .     .    .              .           .      .              .          .       .          
              .     .    .              .           .      .              .          .       .          return m_size;
              .     .    .              .           .      .              .          .       .      }
         24,057     1    1              0           0      0          4,374          0       0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .           .      .              .          .       .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
    300,414,922    25    6    300,414,922   1,954,953      0              0          0       0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
        102,347     1    1         51,707       3,901      0          1,617          1       0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      void  cleanAll  ();
              .     .    .              .           .      .              .          .       .      void  clean     (const Idx& idx);
              .     .    .              .           .      .              .          .       .      void  smudge    (const Idx& idx){
     15,356,988     0    0     10,233,972      45,423  1,187              0          0       0          if (dirty[toInt(idx)] == 0){
        117,308   175   25              0           0      0        117,308          0       0              dirty[toInt(idx)] = 1;
             48     1    1              0           0      0              0          0       0              dirties.push(idx);
              .     .    .              .           .      .              .          .       .          }
              .     .    .              .           .      .              .          .       .      }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .      void  clear(bool free = true){
              .     .    .              .           .      .              .          .       .          occs   .clear(free);
              .     .    .              .           .      .              .          .       .          dirty  .clear(free);
              .     .    .              .           .      .              .          .       .          dirties.clear(free);
              .     .    .              .           .      .              .          .       .      }
              .     .    .              .           .      .              .          .       .  };
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  template<class Idx, class Vec, class Deleted>
            704     0    0              0           0      0            528          0       0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .           .      .              .          .       .  {
     55,202,692   170    2     27,485,668   1,371,014      4              0          0       0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .           .      .              .          .       .          // Dirties may contain duplicates so check here if a variable is already cleaned:
        346,770     0    0        231,180      82,014      0              0          0       0          if (dirty[toInt(dirties[i])])
              .     .    .              .           .      .              .          .       .              clean(dirties[i]);
              .     .    .              .           .      .              .          .       .      dirties.clear();
            704     0    0            704         176      0              0          0       0  }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  template<class Idx, class Vec, class Deleted>
              .     .    .              .           .      .              .          .       .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .           .      .              .          .       .  {
              .     .    .              .           .      .              .          .       .      Vec& vec = occs[toInt(idx)];
              .     .    .              .           .      .              .          .       .      int  i, j;
     57,335,927     2    2        460,810     119,424    196              0          0       0      for (i = j = 0; i < vec.size(); i++)
     34,386,800     0    0        176,407       6,687      0              0          0       0          if (!deleted(vec[i]))
     83,356,349     3    2     23,772,657          93      0     11,934,145    144,960       0              vec[j++] = vec[i];
        116,188   175   31              0           0      0              0          0       0      vec.shrink(i - j);
        469,350     0    0        233,976       7,739      0        117,682      7,826       0      dirty[toInt(idx)] = 0;
              .     .    .              .           .      .              .          .       .  }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  //=================================================================================================
              .     .    .              .           .      .              .          .       .  // CMap -- a class for mapping clauses to values:
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .           .      .              .          .       .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .           .      .              .          .       .  |________________________________________________________________________________________________@*/
              .     .    .              .           .      .              .          .       .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .           .      .              .          .       .  {
              .     .    .              .           .      .              .          .       .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .           .      .              .          .       .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .           .      .              .          .       .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .           .      .              .          .       .      assert(header.has_extra); assert(other.header.has_extra);
     17,662,392     0    0      5,887,464     138,135      0              0          0       0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .           .      .              .          .       .          return lit_Error;
              .     .    .              .           .      .              .          .       .  
        466,964     0    0              0           0      0              0          0       0      Lit        ret = lit_Undef;
              .     .    .              .           .      .              .          .       .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .           .      .              .          .       .      const Lit* d   = (const Lit*)other;
              .     .    .              .           .      .              .          .       .  
      5,699,226     1    1      1,191,527           0      0              0          0       0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .           .      .              .          .       .          // search for c[i] or ~c[i]
     15,051,193     2    2        466,964           0      0        466,964          0       0          for (unsigned j = 0; j < other.header.size; j++)
     22,108,356     0    0      5,067,639           0      0              0          0       0              if (c[i] == d[j])
              .     .    .              .           .      .              .          .       .                  goto ok;
      2,752,821     0    0              0           0      0              0          0       0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .           .      .              .          .       .                  ret = c[i];
              .     .    .              .           .      .              .          .       .                  goto ok;
              .     .    .              .           .      .              .          .       .              }
              .     .    .              .           .      .              .          .       .  
              .     .    .              .           .      .              .          .       .          // did not find it
              .     .    .              .           .      .              .          .       .          return lit_Error;
              .     .    .              .           .      .              .          .       .  ok:;
              .     .    .              .           .      .              .          .       .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr        DLmr Dw          D1mw   DLmw 

-- line 77 ----------------------------------------
             .     .    .              .           .    .           .      .    .  private:
             .     .    .              .           .    .           .      .    .      template<typename T>
             .     .    .              .           .    .           .      .    .      class MyQueue {
             .     .    .              .           .    .           .      .    .          int max_sz, q_sz;
             .     .    .              .           .    .           .      .    .          int ptr;
             .     .    .              .           .    .           .      .    .          int64_t sum;
             .     .    .              .           .    .           .      .    .          vec<T> q;
             .     .    .              .           .    .           .      .    .      public:
             4     1    1              0           0    0           3      0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .     .    .              .           .    .           .      .    .          inline bool   full () const { return q_sz == max_sz; }
             .     .    .              .           .    .           .      .    .  #ifdef INT_QUEUE_AVG
     2,587,340    81    5        646,835           0    0           0      0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .     .    .              .           .    .           .      .    .  #else
             .     .    .              .           .    .           .      .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .     .    .              .           .    .           .      .    .  #endif
         8,600    18   13              0           0    0       8,600  1,970    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .     .    .              .           .    .           .      .    .          void push(T e) {
     8,487,184     0    0      4,143,642           0    0      99,950      0    0              if (q_sz < max_sz) q_sz++;
     3,843,792     5    5      1,281,264   1,269,646    0           0      0    0              else sum -= q[ptr];
     4,143,642    17   12              0           0    0   1,381,214      0    0              sum += e;
     4,143,642     0    0              0           0    0   2,762,428 96,744   12              q[ptr++] = e;
     4,170,962     0    0      2,762,428           0    0      27,320      0    0              if (ptr == max_sz) ptr = 0;
             .     .    .              .           .    .           .      .    .          }
             .     .    .              .           .    .           .      .    .      };
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  public:
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      // Constructor/Destructor:
             .     .    .              .           .    .           .      .    .      //
             .     .    .              .           .    .           .      .    .      Solver();
             .     .    .              .           .    .           .      .    .      virtual ~Solver();
            10     2    2              0           0    0           4      0    0      void print_size(std::ostream &os)
             .     .    .              .           .    .           .      .    .      {
             4     2    2              0           0    0           4      1    0          program_end_time=std::chrono::steady_clock::now();
             2     0    0              0           0    0           2      0    0          total_work_time=program_end_time-program_start_time;
             4     0    0              2           1    0           0      0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2     0    0              2           2    0           0      0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4     0    0              2           1    0           0      0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4     0    0              2           2    0           0      0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .     .    .              .           .    .           .      .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .     .    .              .           .    .           .      .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2     0    0              2           2    0           0      0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2     0    0              2           0    0           0      0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2     0    0              2           0    0           0      0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4     0    0              2           2    0           0      0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4     0    0              2           0    0           0      0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_Watchers: " << total_Watchers << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_indexs: " << total_indexs << "\n";
             .     .    .              .           .    .           .      .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .     .    .              .           .    .           .      .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .     .    .              .           .    .           .      .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .     .    .              .           .    .           .      .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6     0    0              4           0    0           0      0    0      }
             .     .    .              .           .    .           .      .    .      using ull=unsigned long long;
             .     .    .              .           .    .           .      .    .      ull total_Watchers = 0;
             .     .    .              .           .    .           .      .    .      ull total_act_watchers = 0;
             .     .    .              .           .    .           .      .    .      ull total_indexs = 0;
             .     .    .              .           .    .           .      .    .      ull time_find_conflict = 0;
             .     .    .              .           .    .           .      .    .      ull total_find_conflict_length = 0;
             .     .    .              .           .    .           .      .    .      ull total_find_conflict_allsize = 0;
             .     .    .              .           .    .           .      .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .              .           .    .           .      .    .      {
             .     .    .              .           .    .           .      .    .          const ClauseAllocator& ca;
             .     .    .              .           .    .           .      .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .     .    .              .           .    .           .      .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .     .    .              .           .    .           .      .    .      };
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      struct VarOrderLt {
             .     .    .              .           .    .           .      .    .          const vec<double>&  activity;
 1,673,860,418   341   30  1,191,662,906 110,451,750  922  75,598,103      0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .     .    .              .           .    .           .      .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .     .    .              .           .    .           .      .    .      };
             .     .    .              .           .    .           .      .    .      
             .     .    .              .           .    .           .      .    .      struct ConflictData
             .     .    .              .           .    .           .      .    .  	{
             .     .    .              .           .    .           .      .    .  		ConflictData() :
             .     .    .              .           .    .           .      .    .  			nHighestLevel(-1),
             .     .    .              .           .    .           .      .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .     .    .              .           .    .           .      .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .     .    .              .           .    .           .      .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .     .    .              .           .    .           .      .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .     .    .              .           .    .           .      .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .     .    .              .           .    .           .      .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .     .    .              .           .    .           .      .    .      std::chrono::nanoseconds total_duration;
             .     .    .              .           .    .           .      .    .      CRef     propagate(){
             .     .    .              .           .    .           .      .    .  
    11,470,584 4,660   24              0           0    0   5,735,292      1    0          auto start_time=std::chrono::steady_clock::now();
    17,205,876     0    0              0           0    0   5,735,292      0    0          auto ref= propagate_();
     5,735,292     0    0              0           0    0   5,735,292      0    0          auto end_time=std::chrono::steady_clock::now();
             .     .    .              .           .    .           .      .    .          auto duration=end_time-start_time;
             .     .    .              .           .    .           .      .    .          total_duration+=duration;
             .     .    .              .           .    .           .      .    .          return ref;
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .     .    .              .           .    .           .      .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .     .    .              .           .    .           .      .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .     .    .              .           .    .           .      .    .      
             .     .    .              .           .    .           .      .    .  public:
             .     .    .              .           .    .           .      .    .      int      level            (Var x) const;
             .     .    .              .           .    .           .      .    .  protected:
             .     .    .              .           .    .           .      .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .     .    .              .           .    .           .      .    .      bool     withinBudget     ()      const;
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      template<class V> int computeLBD(const V& c) {
    99,091,051    36   22              0           0    0           0      0    0          int lbd = 0;
             .     .    .              .           .    .           .      .    .  
    16,625,890    39   24     14,016,429   1,245,371    2           0      0    0          counter++;
   439,133,846     0    0      2,609,523           0    0           0      0    0          for (int i = 0; i < c.size(); i++){
             .     .    .              .           .    .           .      .    .              int l = level(var(c[i]));
 1,005,725,595     0    0    402,290,238   9,298,749   13           0      0    0              if (l != 0 && seen2[l] != counter){
   114,935,011     0    0              0           0    0 114,935,011      0    0                  seen2[l] = counter;
   179,469,764     0    0              0           0    0           0      0    0                  lbd++; } }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .          return lbd;
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  #ifdef BIN_DRUP
             .     .    .              .           .    .           .      .    .      static int buf_len;
             .     .    .              .           .    .           .      .    .      static unsigned char drup_buf[];
             .     .    .              .           .    .           .      .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      template<class V>
             .     .    .              .           .    .           .      .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .     .    .              .           .    .           .      .    .          assert(op == 'a' || op == 'd');
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = op; buf_len++;
             .     .    .              .           .    .           .      .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = 0; buf_len++;
        83,864    33   21              0           0    0      83,864      0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .     .    .              .           .    .           .      .    .      }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = 'a'; buf_len++;
             .     .    .              .           .    .           .      .    .          for (int i = 0; i < c.size(); i++)
             .     .    .              .           .    .           .      .    .              if (c[i] != l) byteDRUP(c[i]);
             .     .    .              .           .    .           .      .    .          *buf_ptr++ = 0; buf_len++;
             .     .    .              .           .    .           .      .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .     .    .              .           .    .           .      .    .      double    my_var_decay;
             .     .    .              .           .    .           .      .    .      bool   DISTANCE;
             .     .    .              .           .    .           .      .    .  };
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  //=================================================================================================
             .     .    .              .           .    .           .      .    .  // Implementation of inline methods:
             .     .    .              .           .    .           .      .    .  
   226,950,332     0    0    226,950,332   1,512,281  773           0      0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
 1,967,431,431    43   22  1,665,159,605 146,133,288    2 293,380,666      0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::insertVarOrder(Var x) {
             .     .    .              .           .    .           .      .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
 2,196,575,857   205   22    674,806,980     668,157    0           0      0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    26,337,696     1    1     17,558,464   5,482,262   48           0      0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::varDecayActivity() {
     5,524,856     0    0      2,762,428      42,958    0   1,381,214      0    0      var_inc *= (1 / var_decay); }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::varBumpActivity(Var v, double mult) {
 1,234,913,014     7    7    749,115,625  49,794,342   96 186,626,541      0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .     .    .              .           .    .           .      .    .          // Rescale:
         3,362    71   33              1           0    0           0      0    0          for (int i = 0; i < nVars(); i++)
     1,470,336     0    0        367,920      75,965  629     367,584      0    0              activity_VSIDS[i] *= 1e-100;
           672     0    0            336           0    0         336      0    0          var_inc *= 1e-100; }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .      // Update order_heap with respect to new activity:
   126,048,642     0    0              0           0    0           0      0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .     .    .              .           .    .           .      .    .  
    10,437,844   166    2      5,218,922          91    0   2,609,461      0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .     .    .              .           .    .           .      .    .  inline void Solver::claBumpActivity (Clause& c) {
    68,443,832   823   37     20,467,920   2,364,656   12   6,876,998  3,358    2      if ( (c.activity() += cla_inc) > 1e20 ) {
             .     .    .              .           .    .           .      .    .          // Rescale:
     3,838,444    41   27            168           0    0           0      0    0          for (int i = 0; i < learnts_local.size(); i++)
     8,955,324     8    0      1,279,332   1,167,856   81   1,279,332      0    0              ca[learnts_local[i]].activity() *= 1e-20;
       326,316   172   11        163,074           0    0          56     56    0          cla_inc *= 1e-20; } }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .     .    .              .           .    .           .      .    .  inline void Solver::checkGarbage(double gf){
        16,452   151    0          5,484         212    0           0      0    0      if (ca.wasted() > ca.size() * gf)
           692     0    0            346         346   84           0      0    0          garbageCollect(); }
             .     .    .              .           .    .           .      .    .  
             .     .    .              .           .    .           .      .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
             .     .    .              .           .    .           .      .    .  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .     .    .              .           .    .           .      .    .  inline bool     Solver::locked          (const Clause& c) const {
    33,113,637   173   43     12,196,302     294,210    0           0      0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    42,374,837   174   28      8,578,037      66,917   12           0      0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .     .    .              .           .    .           .      .    .  }
     6,233,248     1    1      3,116,618           0    0           0      0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .     .    .              .           .    .           .      .    .  
       419,730     2    2        217,023           0    0     202,707      0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
   615,912,754   660   19    118,234,492     302,074    0           0      0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
     8,787,347     2    2      8,787,331         192    0           0      0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
23,626,047,700    39   23 23,626,047,700         385    0           0      0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .     .    .              .           .    .           .      .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .     .    .              .           .    .           .      .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .     .    .              .           .    .           .      .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3     0    0              2           0    0           1      1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .     .    .              .           .    .           .      .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
       740,626     1    1          2,862           2    0           0      0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6     1    1              3           3    0           0      0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .     .    .              .           .    .           .      .    .  { 
        13,122     0    0          6,561          21    0           0      0    0      if      ( b && !decision[v]) dec_vars++;
         1,116     0    0            744         138    0           0      0    0      else if (!b &&  decision[v]) dec_vars--;
             .     .    .              .           .    .           .      .    .  
         2,559     0    0              0           0    0       2,559      0    0      decision[v] = b;
             .     .    .              .           .    .           .      .    .      if (b && !order_heap_CHB.inHeap(v)){
             .     .    .              .           .    .           .      .    .          order_heap_CHB.insert(v);
             .     .    .              .           .    .           .      .    .          order_heap_VSIDS.insert(v);
             .     .    .              .           .    .           .      .    .          order_heap_distance.insert(v);}
             .     .    .              .           .    .           .      .    .  }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .     .    .              .           .    .           .      .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .     .    .              .           .    .           .      .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr              D1mr           DLmr    Dw              D1mw          DLmw      
--------------------------------------------------------------------------------
929,368,348,290 662,925 5,117 308,564,501,531 13,443,097,695 981,712 108,353,155,648 2,661,992,557 1,487,307  events annotated

