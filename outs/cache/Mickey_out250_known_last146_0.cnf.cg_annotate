--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/Mickey_out250_known_last146_0.cnf
Data file:        Mickey_out250_known_last146_0.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir              I1mr      ILmr   Dr             D1mr          DLmr       Dw             D1mw        DLmw       
--------------------------------------------------------------------------------
159,438,973,153 1,636,236 15,895 49,890,513,419 3,329,499,146 30,798,665 17,867,110,973 843,294,737 12,743,835  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr             D1mr          DLmr      Dw            D1mw        DLmw       file:function
--------------------------------------------------------------------------------
45,561,001,089  11,564  128 16,458,310,524 1,043,671,732 3,576,767 5,477,858,067     271,829         2  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
17,430,980,432      16   14  3,241,831,982   179,073,004   608,519 2,320,836,160           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
 8,825,530,716  61,230   66  1,875,127,534   142,744,602   198,283 1,165,453,399 185,727,861 1,468,716  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
 7,128,860,400     198   69  1,338,996,186    90,953,958    30,598   687,445,184  75,535,255    29,841  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
 6,382,177,891  30,226  100  2,103,126,361    49,014,899     7,707   517,180,421   1,857,357         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 5,453,917,696 172,128  690  1,168,756,345     6,304,984       430   511,713,305   1,351,476        32  ???:__ieee754_pow_fma
 5,340,413,114 110,025   57  1,599,282,940         1,591         0   916,141,639   2,731,102     1,490  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 4,161,393,353     180  144  1,103,289,370   147,863,059   203,153   461,201,381   6,546,501     3,889  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
 4,065,228,907  44,940  299  1,466,705,734   152,699,236    16,490   288,370,713   2,958,570       144  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 3,688,755,989  14,166  126  1,431,718,977   308,961,285    28,929   447,149,079 101,456,266     7,020  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
 3,326,000,978      13   13  1,440,250,114    86,563,848    36,402 1,011,967,283 274,757,227   139,913  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 3,321,259,364  34,976   58  1,216,496,973   165,608,328    42,861   769,443,950  16,011,347     2,305  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
 2,706,748,514     247   17  1,110,531,378   100,458,320    28,428   232,482,853  14,561,167     7,516  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
 2,633,863,864      49   25    781,673,185    93,006,494    20,724             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 2,603,271,398      36   31    665,378,778    25,605,866    30,780             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
 2,410,818,370   3,482  146    667,436,364       898,427         6   201,582,563   4,596,394    11,366  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 1,988,528,328       6    6  1,881,524,934    25,231,435       108   104,727,392           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
 1,932,428,018   2,654  117    542,632,992    44,773,795    21,449     4,476,624      83,494         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 1,864,914,777      34   27    461,896,575    31,441,293    17,877   340,507,053  45,711,819   143,582  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
 1,767,500,448   9,992  249    422,551,734     7,187,387     5,217    47,517,815      65,732         3  ???:__exp1_fma
 1,139,357,128      41   14    218,896,564     5,293,003   151,203     9,893,365           1         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::SimpSolver::backwardSubsumptionCheck(bool)
 1,132,911,112       0    0    566,455,556        67,803         0             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
 1,111,379,575   2,536   66    482,035,452    62,338,572    60,548    63,490,040          14         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   906,880,326      28   21    257,182,670    39,912,339     5,591   169,205,064  16,399,028     5,054  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
   888,276,997      13   13    162,083,287       417,237    19,984    10,638,613           6         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc:Minisat::SimpSolver::eliminateVar(int)
   888,019,262     199  199    217,130,463    22,836,270 8,693,667   114,785,044   3,261,388 3,113,412  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
   886,743,828   4,654   55    247,356,681       147,411         0    52,458,478   1,442,091     2,779  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   866,842,540   8,661   23    399,745,570    21,778,016    10,290             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   725,354,348       3    3    252,173,535       242,506         8   221,007,278   6,701,195    13,872  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   720,184,083  15,093   57    196,918,672        10,344        50   117,646,269      15,995         0  ???:pow
   711,319,791      10   10    202,695,778    16,051,324    30,936     3,022,903           6         1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc:Minisat::SimpSolver::backwardSubsumptionCheck(bool)
   710,944,999     330   24    370,841,587    70,585,324    30,532             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::pickBranchLit()
   707,008,713     692   25    326,897,720    79,454,453     2,162             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   678,482,760       0    0     23,435,436         4,640         0    32,659,098           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::pickBranchLit()
   663,533,908       0    0    442,266,042     6,452,986     1,958   110,499,088  48,637,547     9,793  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   471,780,030   7,378   38    204,894,941    34,016,742    17,484    61,696,985         695         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::pickBranchLit()
   458,637,541   3,074   45    175,870,887    22,933,978    15,874    67,952,416   4,793,986     6,094  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   442,014,556       0    0    110,503,639             0         0   110,503,639      61,513         8  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   437,203,339   9,561   23    162,411,405    19,217,648     5,681     1,879,829     354,694    12,661  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::collectFirstUIP(unsigned int)
   411,065,313   3,068  222    118,414,259     1,374,902   208,326    62,609,237      44,847     2,787  ???:_int_free
   400,837,449       0    0    267,224,966       213,711         0             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   386,136,934 170,049  979     62,980,311     5,385,655   171,206    68,348,119   3,158,869   516,945  ???:_int_malloc
   377,308,297       0    0    244,307,681    58,690,211    14,242             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
   373,995,084       0    0    218,163,799    27,874,158    13,269    31,166,257           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   354,035,914       9    9     54,992,488       238,200    15,460    26,932,773           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../utils/ParseUtils.h:int Minisat::parseInt<Minisat::StreamBuffer>(Minisat::StreamBuffer&)
   341,389,050       6    6     29,958,612     5,573,682   641,443     3,094,624       3,049        32  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::SimpSolver::eliminateVar(int)
   314,489,954       0    0              0             0         0             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
   313,863,279  25,817  436    106,244,670     3,787,526       169    27,044,835     373,197        15  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::search(int&)
   302,395,218       7    6     88,939,770     1,298,091        27    53,363,862          18         0  ???:clock_gettime
   295,962,503  38,166  241    103,177,043    11,643,311   461,955             0           0         0  /usr/include/c++/8/bits/stl_tree.h:Minisat::Solver::is_duplicate(std::vector<unsigned int, std::allocator<unsigned int> >&)
   260,388,172     190  190     97,109,398     1,115,204   990,734    17,699,812          42        15  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
   250,233,960      60   23    100,093,584       642,992         5    33,364,528           1         1  ???:std::chrono::_V2::steady_clock::now()
   244,191,626       0    0    122,095,813            27         0             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::simplePropagate()
   239,854,285      44   44     71,371,305     3,923,058 3,681,515    34,468,876          16         1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
   238,948,549      44   31     63,836,062     5,221,549     1,789    28,227,117      55,930         1  ???:malloc
   218,163,799       0    0     31,166,257       326,291         6    93,498,771     330,447         0  /usr/include/c++/8/cmath:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   210,237,959     993   76     69,112,501     8,984,553   624,703     8,177,442       2,720         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::OccLists<Minisat::Lit, Minisat::vec<Minisat::Solver::Watcher>, Minisat::Solver::WatcherDeleted>::cleanAll()
   189,299,966     601  340     33,159,464     6,305,443    78,631     6,811,683      36,661       286  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h:void Minisat::sort<unsigned int, reduceDB_lt>(unsigned int*, int, reduceDB_lt)
   176,567,160      14   14     84,079,600     1,384,614   526,541    58,855,720           1         1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::ClauseAllocator::reloc(unsigned int&, Minisat::ClauseAllocator&)
   173,994,421     123   89     48,720,496     3,530,798       913     8,995,512           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simpleAnalyze(unsigned int, Minisat::vec<Minisat::Lit>&, Minisat::vec<unsigned int>&, bool)
   168,274,423      33    6     55,255,776        40,162         1     1,219,000      62,348       173  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::collectFirstUIP(unsigned int)
   167,858,285       0    0    167,858,285            21         0             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::simplePropagate()
   167,336,630       0    0              0             0         0             0           0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
   163,784,201      70   27     29,087,995     1,426,374    37,322    26,774,565   2,047,732 1,623,093  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::search(int&)
   159,755,830  39,921  164     29,379,674     1,308,184    93,743    16,618,263      87,282         1  ???:realloc

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr            D1mr        DLmr      Dw            D1mw       DLmw      

-- line 54 ----------------------------------------
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  struct Lit {
             .     .    .             .           .         .             .          .         .      int     x;
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      // Use this as a constructor:
             .     .    .             .           .         .             .          .         .      friend Lit mkLit(Var var, bool sign );
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      bool operator == (Lit p) const { return x == p.x; }
    98,922,640     0    0    50,493,832  23,345,255    10,250             0          0         0      bool operator != (Lit p) const { return x != p.x; }
             .     .    .             .           .         .             .          .         .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
             .     .    .             .           .         .             .          .         .  };
             .     .    .             .           .         .             .          .         .  
    10,875,924     0    0             0           0         0        23,179         11         0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 1,741,227,186    18   18   581,676,330      28,947     2,378   202,022,057     83,494         0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
             .     .    .             .           .         .             .          .         .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 6,249,948,741     7    6   444,017,369       4,843         0   223,019,193 48,699,060     9,801  inline  bool sign      (Lit p)              { return p.x & 1; }
13,039,780,023 6,582  125 1,092,548,533  15,000,700     8,947 1,668,718,759          0         0  inline  int  var       (Lit p)              { return p.x >> 1; }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  // Mapping Literals to and from compact integers suitable for array indexing:
             .     .    .             .           .         .             .          .         .  inline  int  toInt     (Var v)              { return v; } 
       113,650     0    0           884           0         0           884         31        31  inline  int  toInt     (Lit p)              { return p.x; } 
             .     .    .             .           .         .             .          .         .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
             .     .    .             .           .         .             .          .         .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
             .     .    .             .           .         .             .          .         .  const Lit lit_Error = { -1 };  // }
             .     .    .             .           .         .             .          .         .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
             .     .    .             .           .         .             .          .         .  #define l_Undef (lbool((uint8_t)2))
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  class lbool {
             .     .    .             .           .         .             .          .         .      uint8_t value;
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  public:
             .     .    .             .           .         .             .          .         .      explicit lbool(uint8_t v) : value(v) { }
             .     .    .             .           .         .             .          .         .  
        18,041     1    1             0           0         0         4,518      1,126     1,125      lbool()       : value(0) { }
             .     .    .             .           .         .             .          .         .      explicit lbool(bool x) : value(!x) { }
             .     .    .             .           .         .             .          .         .  
   267,933,310     1    1             0           0         0             0          0         0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
       216,234     0    0       144,156       1,127         0             0          0         0      bool  operator != (lbool b) const { return !(*this == b); }
 1,556,435,828    23   17 1,420,933,924  62,249,588     5,474             0          0         0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      lbool operator && (lbool b) const {
             .     .    .             .           .         .             .          .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
             .     .    .             .           .         .             .          .         .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
             .     .    .             .           .         .             .          .         .          return lbool(v); }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      lbool operator || (lbool b) const {
             .     .    .             .           .         .             .          .         .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
             .     .    .             .           .         .             .          .         .          unsigned simplified : 1;}                            header;
             .     .    .             .           .         .             .          .         .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      friend class ClauseAllocator;
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
             .     .    .             .           .         .             .          .         .      template<class V>
             .     .    .             .           .         .             .          .         .      Clause(const V& ps, bool use_extra, bool learnt) {
    40,609,367     0    0    10,003,610           0         0    10,598,536     27,068         0          header.mark      = 0;
    27,493,815     1    1     9,164,605     567,098   536,731             0          0         0          header.learnt    = learnt;
    60,860,665     1    1    10,842,615           5         0    10,003,610          0         0          header.has_extra = learnt | use_extra;
             .     .    .             .           .         .             .          .         .          header.reloced   = 0;
    12,032,465     0    0     1,433,930           8         8    10,598,535    576,893   179,119          header.size      = ps.size();
             .     .    .             .           .         .             .          .         .          header.lbd       = 0;
             .     .    .             .           .         .             .          .         .          header.removable = 1;
             .     .    .             .           .         .             .          .         .          //simplify
             .     .    .             .           .         .             .          .         .          //
    10,598,536     8    8    10,598,536   1,230,394 1,171,426             0          0         0          header.simplified = 0;
             .     .    .             .           .         .             .          .         .  
   318,892,024    45   45     4,968,514           0         0             0          0         0          for (int i = 0; i < ps.size(); i++)
   119,222,095    52   30    34,630,493   3,405,683 1,563,883    57,467,128  4,993,773 4,849,058              data[i].lit = ps[i];
             .     .    .             .           .         .             .          .         .  
    31,795,607    27   27    10,598,535           0         0             0          0         0          if (header.has_extra){
     5,870,836     0    0             0           0         0             0          0         0              if (header.learnt){
     3,098,056     0    0       954,102           0         0     1,549,028     96,868    95,190                  data[header.size].act = 0;
     3,098,056     0    0             0           0         0     1,549,028     97,071    95,488                  data[header.size+1].touched = 0;
             .     .    .             .           .         .             .          .         .              }else
             .     .    .             .           .         .             .          .         .                  calcAbstraction(); }
             .     .    .             .           .         .             .          .         .      }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  public:
             .     .    .             .           .         .             .          .         .      void calcAbstraction() {
             .     .    .             .           .         .             .          .         .          assert(header.has_extra);
     1,414,327     0    0             0           0         0             0          0         0          uint32_t abstraction = 0;
    25,557,595     4    4       565,483           0         0             0          0         0          for (int i = 0; i < size(); i++)
    40,165,913     3    3             0           0         0             1          0         0              abstraction |= 1 << (var(data[i].lit) & 31);
     4,438,325     0    0       547,385           0         0     1,957,166    102,726   102,726          data[header.size].abs = abstraction;  }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
 2,080,479,926   133   89   812,465,394 158,987,404 1,067,099   463,208,534         20         0      int          size        ()      const   { return header.size; }
     2,225,545    23   18       556,984      42,496        24       556,984      1,576         0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
             .     .    .             .           .         .             .          .         .      void         pop         ()              { shrink(1); }
    43,386,346     4    4     1,311,120         447         0             0          0         0      bool         learnt      ()      const   { return header.learnt; }
       583,324     0    0             0           0         0             0          0         0      bool         has_extra   ()      const   { return header.has_extra; }
    75,495,657    61   37    24,562,539  18,020,600 3,437,030     3,718,021          0         0      uint32_t     mark        ()      const   { return header.mark; }
    48,325,088    60   44    11,585,221       4,850         0    12,227,070          0         0      void         mark        (uint32_t m)    { header.mark = m; }
       211,478     0    0             0           0         0       105,739     13,004         0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
             .     .    .             .           .         .             .          .         .  
    30,020,444     0    0    30,020,444  12,183,280 2,002,538             0          0         0      bool         reloced     ()      const   { return header.reloced; }
             .     .    .             .           .         .             .          .         .      CRef         relocation  ()      const   { return data[0].rel; }
    36,658,420    18   18     9,164,605           0         0    18,329,210          0         0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
             .     .    .             .           .         .             .          .         .  
     5,290,171     0    0     1,747,422       2,701         0             0          0         0      int          lbd         ()      const   { return header.lbd; }
    12,135,181    47   24     2,725,294           0         0     1,774,037          0         0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
             .     .    .             .           .         .             .          .         .      bool         removable   ()      const   { return header.removable; }
     6,325,571     2    2     2,509,163           0         0       954,102          0         0      void         removable   (bool b)        { header.removable = b; }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
             .     .    .             .           .         .             .          .         .      //       subsumption operations to behave correctly.
 1,340,694,633    72   44 1,280,767,163  92,049,684   472,176             0          0         0      Lit&         operator [] (int i)         { return data[i].lit; }
   183,892,728   796   78   169,471,929   9,343,194 1,711,177             0          0         0      Lit          operator [] (int i) const   { return data[i].lit; }
             .     .    .             .           .         .             .          .         .      operator const Lit* (void) const         { return (Lit*)data; }
             .     .    .             .           .         .             .          .         .  
     1,164,146     0    0     1,164,146           0         0             0          0         0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     2,011,187     0    0       580,770     162,341    10,125             0          0         0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
             .     .    .             .           .         .             .          .         .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      Lit          subsumes    (const Clause& other) const;
             .     .    .             .           .         .             .          .         .      void         strengthen  (Lit p);
             .     .    .             .           .         .             .          .         .      // simplify
             .     .    .             .           .         .             .          .         .      //
     7,220,590     0    0     2,179,142           0         0       954,102          0         0      void setSimplified(bool b) { header.simplified = b; }
             .     .    .             .           .         .             .          .         .      bool simplified() { return header.simplified; }
             .     .    .             .           .         .             .          .         .  };
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  //=================================================================================================
             .     .    .             .           .         .             .          .         .  // ClauseAllocator -- a simple class for allocating memory for clauses:
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
             .     .    .             .           .         .             .          .         .  class ClauseAllocator : public RegionAllocator<uint32_t>
             .     .    .             .           .         .             .          .         .  {
             .     .    .             .           .         .             .          .         .      static int clauseWord32Size(int size, int extras){
    20,526,876     2    2     9,928,341     535,573   403,601             0          0         0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
             .     .    .             .           .         .             .          .         .  public:
             .     .    .             .           .         .             .          .         .      bool extra_clause_field;
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
             1     0    0             0           0         0             1          0         0      ClauseAllocator() : extra_clause_field(false){}
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      void moveTo(ClauseAllocator& to){
            30    14   14            15          15        14            15          0         0          to.extra_clause_field = extra_clause_field;
             .     .    .             .           .         .             .          .         .          RegionAllocator<uint32_t>::moveTo(to); }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      template<class Lits>
             .     .    .             .           .         .             .          .         .      CRef alloc(const Lits& ps, bool learnt = false)
             .     .    .             .           .         .             .          .         .      {
             .     .    .             .           .         .             .          .         .          assert(sizeof(Lit)      == sizeof(uint32_t));
             .     .    .             .           .         .             .          .         .          assert(sizeof(float)    == sizeof(uint32_t));
    27,378,717    28   28     9,049,507         498         0             0          0         0          int extras = learnt ? 2 : (int)extra_clause_field;
             .     .    .             .           .         .             .          .         .  
     2,272,934     0    0             0           0         0       839,004          0         0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
             .     .    .             .           .         .             .          .         .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .          return cid;
             .     .    .             .           .         .             .          .         .      }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    58,344,611    39   22    53,831,131      18,718        14     1,083,148          0         0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
       260,180     2    2       130,090       1,121         0             0          0         0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     9,164,605     0    0     9,164,605           0         0             0          0         0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
             .     .    .             .           .         .             .          .         .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
             .     .    .             .           .         .             .          .         .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      void free(CRef cid)
             .     .    .             .           .         .             .          .         .      {
             .     .    .             .           .         .             .          .         .          Clause& c = operator[](cid);
     2,874,529     5    5             0           0         0             0          0         0          int extras = c.learnt() ? 2 : (int)c.has_extra();
             .     .    .             .           .         .             .          .         .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
             .     .    .             .           .         .             .          .         .      }
             .     .    .             .           .         .             .          .         .  
    58,855,720    14   14             0           0         0    50,447,760          1         1      void reloc(CRef& cr, ClauseAllocator& to)
             .     .    .             .           .         .             .          .         .      {
             .     .    .             .           .         .             .          .         .          Clause& c = operator[](cr);
             .     .    .             .           .         .             .          .         .          
   102,543,964     0    0    20,855,839   3,114,932   578,718    20,855,839          0         0          if (c.reloced()) { cr = c.relocation(); return; }
             .     .    .             .           .         .             .          .         .          
     9,164,606     0    0             1           0         0     9,164,605          0         0          cr = to.alloc(c, c.learnt());
             .     .    .             .           .         .             .          .         .          c.relocate(cr);
             .     .    .             .           .         .             .          .         .          
             .     .    .             .           .         .             .          .         .          // Copy extra data-fields:
             .     .    .             .           .         .             .          .         .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
             .     .    .             .           .         .             .          .         .          to[cr].mark(c.mark());
    18,329,210     0    0             0           0         0             0          0         0          if (to[cr].learnt()){
     3,816,408     0    0       954,102      52,388    30,250       954,102          0         0              to[cr].touched() = c.touched();
     3,816,408     0    0     1,908,204      52,796    30,664       954,102          0         0              to[cr].activity() = c.activity();
             .     .    .             .           .         .             .          .         .              to[cr].set_lbd(c.lbd());
             .     .    .             .           .         .             .          .         .              to[cr].removable(c.removable());
             .     .    .             .           .         .             .          .         .              // simplify
             .     .    .             .           .         .             .          .         .              //
             .     .    .             .           .         .             .          .         .              to[cr].setSimplified(c.simplified());
             .     .    .             .           .         .             .          .         .          }
    16,421,006    30   30             0           0         0             0          0         0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
    67,263,680     0    0    58,855,720           0         0             0          0         0      }
             .     .    .             .           .         .             .          .         .  };
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
             .     .    .             .           .         .             .          .         .  {
             .     .    .             .           .         .             .          .         .      for (int i = 0; i < cls.size(); ++i)
             .     .    .             .           .         .             .          .         .      {
             .     .    .             .           .         .             .          .         .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .             .           .         .             .          .         .  class OccLists
             .     .    .             .           .         .             .          .         .  {
             .     .    .             .           .         .             .          .         .      vec<Vec>  occs;
             .     .    .             .           .         .             .          .         .      vec<char> dirty;
             .     .    .             .           .         .             .          .         .      vec<Idx>  dirties;
             .     .    .             .           .         .             .          .         .      Deleted   deleted;
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  public:
             3     0    0             0           0         0             3          0         0      OccLists(const Deleted& d) : deleted(d) {}
             .     .    .             .           .         .             .          .         .      unsigned int size(){
             .     .    .             .           .         .             .          .         .          auto m_size=0;
            64     2    2             4           3         0             0          0         0          for(int i=0;i<occs.size();i++){
     1,585,784    14   14       576,628     144,160    54,346             0          0         0              m_size+=occs[i].size();
             .     .    .             .           .         .             .          .         .          }
             .     .    .             .           .         .             .          .         .          
             .     .    .             .           .         .             .          .         .          return m_size;
             .     .    .             .           .         .             .          .         .      }
       792,858     1    1             0           0         0       144,156          0         0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
             .     .    .             .           .         .             .          .         .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
   116,351,115    25   16   116,351,115     389,970        12             0          0         0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
     3,459,551     1    1     1,711,479     433,934    33,151       133,293          3         1      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      void  cleanAll  ();
             .     .    .             .           .         .             .          .         .      void  clean     (const Idx& idx);
             .     .    .             .           .         .             .          .         .      void  smudge    (const Idx& idx){
     6,630,142     0    0     4,078,805     490,843    28,820             0          0         0          if (dirty[toInt(idx)] == 0){
       459,848    72   28             0           0         0       459,848          0         0              dirty[toInt(idx)] = 1;
            75     1    1             0           0         0             0          0         0              dirties.push(idx);
             .     .    .             .           .         .             .          .         .          }
             .     .    .             .           .         .             .          .         .      }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .      void  clear(bool free = true){
             .     .    .             .           .         .             .          .         .          occs   .clear(free);
             .     .    .             .           .         .             .          .         .          dirty  .clear(free);
             .     .    .             .           .         .             .          .         .          dirties.clear(free);
             .     .    .             .           .         .             .          .         .      }
             .     .    .             .           .         .             .          .         .  };
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  template<class Idx, class Vec, class Deleted>
           312     0    0             0           0         0           234         13         0  void OccLists<Idx,Vec,Deleted>::cleanAll()
             .     .    .             .           .         .             .          .         .  {
    83,846,107   899   22    41,430,446     485,238        15             0          0         0      for (int i = 0; i < dirties.size(); i++)
             .     .    .             .           .         .             .          .         .          // Dirties may contain duplicates so check here if a variable is already cleaned:
     1,379,544     0    0       919,696     264,949     7,586             0          0         0          if (dirty[toInt(dirties[i])])
             .     .    .             .           .         .             .          .         .              clean(dirties[i]);
             .     .    .             .           .         .             .          .         .      dirties.clear();
           312     0    0           312          52         1             0          0         0  }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  template<class Idx, class Vec, class Deleted>
             .     .    .             .           .         .             .          .         .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
             .     .    .             .           .         .             .          .         .  {
             .     .    .             .           .         .             .          .         .      Vec& vec = occs[toInt(idx)];
             .     .    .             .           .         .             .          .         .      int  i, j;
    40,339,996     5    4     1,391,836     387,873    97,016             0          0         0      for (i = j = 0; i < vec.size(); i++)
    35,222,919     0    0     5,594,002     220,276   192,927             0          0         0          if (!deleted(vec[i]))
    76,159,736    29    3    18,550,424         136         0    10,744,840      3,061         0              vec[j++] = vec[i];
       390,256    45   26             0           0         0             0          0         0      vec.shrink(i - j);
     1,904,830     2    2       919,696       3,612         0       481,641      2,761         0      dirty[toInt(idx)] = 0;
             .     .    .             .           .         .             .          .         .  }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  //=================================================================================================
             .     .    .             .           .         .             .          .         .  // CMap -- a class for mapping clauses to values:
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
             .     .    .             .           .         .             .          .         .  |       p          - The literal p can be deleted from 'other'
             .     .    .             .           .         .             .          .         .  |________________________________________________________________________________________________@*/
             .     .    .             .           .         .             .          .         .  inline Lit Clause::subsumes(const Clause& other) const
             .     .    .             .           .         .             .          .         .  {
             .     .    .             .           .         .             .          .         .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
             .     .    .             .           .         .             .          .         .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
             .     .    .             .           .         .             .          .         .      assert(!header.learnt);   assert(!other.header.learnt);
             .     .    .             .           .         .             .          .         .      assert(header.has_extra); assert(other.header.has_extra);
   251,950,167     0    0    83,983,389   4,049,749    29,658             0          0         0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
             .     .    .             .           .         .             .          .         .          return lit_Error;
             .     .    .             .           .         .             .          .         .  
     9,185,992     0    0             0           0         0             0          0         0      Lit        ret = lit_Undef;
             .     .    .             .           .         .             .          .         .      const Lit* c   = (const Lit*)(*this);
             .     .    .             .           .         .             .          .         .      const Lit* d   = (const Lit*)other;
             .     .    .             .           .         .             .          .         .  
   103,107,246     1    1    21,193,546           0         0             0          0         0      for (unsigned i = 0; i < header.size; i++) {
             .     .    .             .           .         .             .          .         .          // search for c[i] or ~c[i]
   267,943,686     2    2     9,185,992           0         0     9,185,992          0         0          for (unsigned j = 0; j < other.header.size; j++)
   397,819,173     0    0    90,512,232           0         0             0          0         0              if (c[i] == d[j])
             .     .    .             .           .         .             .          .         .                  goto ok;
    50,530,659     0    0             0           0         0             0          0         0              else if (ret == lit_Undef && c[i] == ~d[j]){
             .     .    .             .           .         .             .          .         .                  ret = c[i];
             .     .    .             .           .         .             .          .         .                  goto ok;
             .     .    .             .           .         .             .          .         .              }
             .     .    .             .           .         .             .          .         .  
             .     .    .             .           .         .             .          .         .          // did not find it
             .     .    .             .           .         .             .          .         .          return lit_Error;
             .     .    .             .           .         .             .          .         .  ok:;
             .     .    .             .           .         .             .          .         .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir            I1mr    ILmr Dr            D1mr        DLmr    Dw            D1mw        DLmw      

-- line 40 ----------------------------------------
            .       .    .             .           .       .             .           .         .      int sz;
            .       .    .             .           .       .             .           .         .      int cap;
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .      // Don't allow copying (error prone):
            .       .    .             .           .       .             .           .         .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
            .       .    .             .           .       .             .           .         .               vec        (vec<T>& other) { assert(0); }
            .       .    .             .           .       .             .           .         .               
            .       .    .             .           .       .             .           .         .      // Helpers for calculating next capacity:
   17,713,122       9    9             0           0       0             0           0         0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
            .       .    .             .           .       .             .           .         .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
            .       .    .             .           .       .             .           .         .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  public:
            .       .    .             .           .       .             .           .         .      // Constructors:
    2,446,176      28   28             2           0       0     2,085,782     102,609    79,327      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
           66       0    0             0           0       0            66           0         0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
            .       .    .             .           .       .             .           .         .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
            .       .    .             .           .       .             .           .         .     ~vec()                                                          { clear(true); }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .      // Pointer to first element:
            .       .    .             .           .       .             .           .         .      operator T*       (void)           { return data; }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .      // Size operations:
            .       .    .             .           .       .             .           .         .      int      size     (void) const     { return sz; }
  324,356,779     384   19    23,529,420     115,169       0    15,695,661          38         0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
            .       .    .             .           .       .             .           .         .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
            .       .    .             .           .       .             .           .         .      int      capacity (void) const     { return cap; }
            .       .    .             .           .       .             .           .         .      void     capacity (int min_cap);
            .       .    .             .           .       .             .           .         .      void     growTo   (int size);
            .       .    .             .           .       .             .           .         .      void     growTo   (int size, const T& pad);
            .       .    .             .           .       .             .           .         .      void     clear    (bool dealloc = false);
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .      // Stack interface:
    2,686,867   1,300    5     1,411,471       8,905       0       600,308           0         0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
8,899,380,106  71,547  381 3,613,285,020 178,000,432 331,061 2,382,639,658 245,933,649 1,927,006      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
  492,457,350       0    0   122,723,681      16,135       0   241,883,106   7,244,417    13,910      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
  317,373,404      16    3    16,467,390           0       0   150,583,928           0         0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
            .       .    .             .           .       .             .           .         .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
            .       .    .             .           .       .             .           .         .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
            .       .    .             .           .       .             .           .         .      // happen given the way capacities are calculated (below). Essentially, all capacities are
            .       .    .             .           .       .             .           .         .      // even, but INT_MAX is odd.
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .      const T& last  (void) const        { return data[sz-1]; }
  134,451,487       0    0             0           0       0             0           0         0      T&       last  (void)              { return data[sz-1]; }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .      // Vector interface:
4,728,772,643   1,691   76   203,323,062           5       0    22,054,225           0         0      const T& operator [] (int index) const { return data[index]; }
6,472,101,376     861  192 1,305,017,063     920,827  76,106   151,836,349      23,734         0      T&       operator [] (int index)       { return data[index]; }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .      // Duplicatation (preferred instead):
  171,907,805      14   12    57,699,221     560,758       0    27,957,217           0         0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
    1,718,222       0    0     1,718,126          12       0            64           0         0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
            .       .    .             .           .       .             .           .         .  };
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  template<class T>
    4,428,120       0    0             0           0       0     2,214,060           0         0  void vec<T>::capacity(int min_cap) {
   11,669,778      59   33     3,889,926           0       0             0           0         0      if (cap >= min_cap) return;
   15,499,066      16   15             0           0       0            32           0         0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
   29,006,775     121   44     2,214,215           9       0     6,642,433       2,978         1      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
            .       .    .             .           .       .             .           .         .          throw OutOfMemoryException();
    5,815,674       1    1     5,815,674         150       0             0           0         0   }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  template<class T>
            .       .    .             .           .       .             .           .         .  void vec<T>::growTo(int size, const T& pad) {
   50,692,218       7    7    16,825,328       1,253       0             0           0         0      if (sz >= size) return;
    1,441,560       4    4       144,156           0       0       648,702           0         0      capacity(size);
    8,144,816       7    7     1,297,405           0       0       648,703       9,936         0      for (int i = sz; i < size; i++) data[i] = pad;
   25,563,427       6    6       151,809           0       0       648,702           0         0      sz = size; }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  template<class T>
    1,441,560       1    1             0           0       0       576,624       1,427         0  void vec<T>::growTo(int size) {
    2,919,801       1    1       504,549       2,918       0       288,312           0         0      if (sz >= size) return;
    2,523,976     556   26             0           0       0     1,261,972           0         0      capacity(size);
   14,095,698      31   11     3,100,568           0       0     1,189,893           0         0      for (int i = sz; i < size; i++) new (&data[i]) T();
    3,298,560       0    0     1,459,962          24       0       955,355          13         0      sz = size; }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  template<class T>
            .       .    .             .           .       .             .           .         .  void vec<T>::clear(bool dealloc) {
  117,699,951 119,010  122    25,667,870     561,565  70,521       133,293           0         0      if (data != NULL){
      144,162       0    0             1           0       0             0           0         0          for (int i = 0; i < sz; i++) data[i].~T();
  378,744,188       9    9    20,715,145           1       0    46,656,698      80,838         8          sz = 0;
    1,280,333       6    6       532,213           2       0       699,621       1,251         0          if (dealloc) free(data), data = NULL, cap = 0; } }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  //=================================================================================================
            .       .    .             .           .       .             .           .         .  }
            .       .    .             .           .       .             .           .         .  
            .       .    .             .           .       .             .           .         .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../utils/ParseUtils.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr    DLmr   Dw         D1mw DLmw 

-- line 36 ----------------------------------------
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  class StreamBuffer {
          .    .    .          .       .      .          .    .    .      gzFile        in;
          .    .    .          .       .      .          .    .    .      unsigned char buf[buffer_size];
          .    .    .          .       .      .          .    .    .      int           pos;
          .    .    .          .       .      .          .    .    .      int           size;
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .      void assureLookahead() {
 31,677,136    1    1          0       0      0          0    0    0          if (pos >= size) {
         16    0    0          0       0      0         16    0    0              pos  = 0;
 21,661,827    4    4 11,727,941       0      0         34    0    0              size = gzread(in, buf, sizeof(buf)); } }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  public:
          2    0    0          0       0      0          2    1    1      explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0) { assureLookahead(); }
          .    .    .          .       .      .          .    .    .  
101,835,369    4    4 21,075,259 229,230 14,805          0    0    0      int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }
 31,089,706    2    2          0       0      0 15,251,614    0    0      void operator ++ ()       { pos++; assureLookahead(); }
          .    .    .          .       .      .          .    .    .      int  position    () const { return pos; }
          .    .    .          .       .      .          .    .    .  };
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  //-------------------------------------------------------------------------------------------------
          .    .    .          .       .      .          .    .    .  // End-of-file detection functions for StreamBuffer and char*:
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  
-- line 60 ----------------------------------------
-- line 62 ----------------------------------------
          .    .    .          .       .      .          .    .    .  static inline bool isEof(const char*   in) { return *in == '\0'; }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  //-------------------------------------------------------------------------------------------------
          .    .    .          .       .      .          .    .    .  // Generic parse functions parametrized over the input-stream type.
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  template<class B>
          .    .    .          .       .      .          .    .    .  static void skipWhitespace(B& in) {
 31,548,761    0    0          0       0      0          0    0    0      while ((*in >= 9 && *in <= 13) || *in == 32)
          .    .    .          .       .      .          .    .    .          ++in; }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  template<class B>
          .    .    .          .       .      .          .    .    .  static void skipLine(B& in) {
          .    .    .          .       .      .          .    .    .      for (;;){
          .    .    .          .       .      .          .    .    .          if (isEof(in)) return;
        726    0    0        244       0      0          0    0    0          if (*in == '\n') { ++in; return; }
          .    .    .          .       .      .          .    .    .          ++in; } }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  template<class B>
 26,282,539    2    2  5,840,565       6      0 11,681,128    0    0  static int parseInt(B& in) {
  2,920,282    0    0          0       0      0          0    0    0      int     val = 0;
  1,730,407    0    0          0       0      0          0    0    0      bool    neg = false;
          .    .    .          .       .      .          .    .    .      skipWhitespace(in);
  8,220,313    1    1          0       0      0          0    0    0      if      (*in == '-') neg = true, ++in;
  3,460,814    0    0          0       0      0          0    0    0      else if (*in == '+') ++in;
 11,681,128    1    1  2,920,282  18,377  1,388          0    0    0      if (*in < '0' || *in > '9') fprintf(stderr, "PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
 43,944,615    0    0          0       0      0          0    0    0      while (*in >= '0' && *in <= '9')
 23,455,846    0    0          0       0      0          0    0    0          val = val*10 + (*in - '0'),
          .    .    .          .       .      .          .    .    .          ++in;
 32,123,102    1    1 14,601,410       0      0          0    0    0      return neg ? -val : val; }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  // String matching: in case of a match the input iterator will be advanced the corresponding
          .    .    .          .       .      .          .    .    .  // number of characters.
          .    .    .          .       .      .          .    .    .  template<class B>
          .    .    .          .       .      .          .    .    .  static bool match(B& in, const char* str) {
          .    .    .          .       .      .          .    .    .      int i;
          .    .    .          .       .      .          .    .    .      for (i = 0; str[i] != '\0'; i++)
         72    6    6         35       1      0          0    0    0          if (in[i] != str[i])
          .    .    .          .       .      .          .    .    .              return false;
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .      in += i;
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .      return true; 
          .    .    .          .       .      .          .    .    .  }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  // String matching: consumes characters eagerly, but does not require random access iterator.
          .    .    .          .       .      .          .    .    .  template<class B>
          .    .    .          .       .      .          .    .    .  static bool eagerMatch(B& in, const char* str) {
         25    1    1          9       1      1          0    0    0      for (; *str != '\0'; ++str, ++in)
         10    0    0          0       0      0          0    0    0          if (*str != *in)
          .    .    .          .       .      .          .    .    .              return false;
          .    .    .          .       .      .          .    .    .      return true; }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  //=================================================================================================
          .    .    .          .       .      .          .    .    .  }
          .    .    .          .       .      .          .    .    .  
          .    .    .          .       .      .          .    .    .  #endif
-- line 122 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr            D1mr      DLmr      Dw         D1mw DLmw 

-- line 40 ----------------------------------------
            .     .    .             .         .         .          .    .    .      void capacity(uint32_t min_cap);
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .   public:
            .     .    .             .         .         .          .    .    .      // TODO: make this a class for better type-checking?
            .     .    .             .         .         .          .    .    .      typedef uint32_t Ref;
            .     .    .             .         .         .          .    .    .      enum { Ref_Undef = UINT32_MAX };
            .     .    .             .         .         .          .    .    .      enum { Unit_Size = sizeof(uint32_t) };
            .     .    .             .         .         .          .    .    .  
           81     1    1             0         0         0         64   14    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
            .     .    .             .         .         .          .    .    .      ~RegionAllocator()
            .     .    .             .         .         .          .    .    .      {
            .     .    .             .         .         .          .    .    .          if (memory != NULL)
            .     .    .             .         .         .          .    .    .              ::free(memory);
            .     .    .             .         .         .          .    .    .      }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .      uint32_t size      () const      { return sz; }
            .     .    .             .         .         .          .    .    .      uint32_t wasted    () const      { return wasted_; }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .      Ref      alloc     (int size); 
    2,291,206     0    0       763,735         0         0    763,735    0    0      void     free      (int size)    { wasted_ += size; }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
2,154,171,930   159   86 1,122,096,867 4,981,577 4,162,662    700,783    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    9,236,824     0    0     9,236,824 1,419,135   402,267          0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
            .     .    .             .         .         .          .    .    .  
   32,390,534 4,659   19     1,433,931         0         0          0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
      623,154     0    0             0         0         0          0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
            .     .    .             .         .         .          .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
            .     .    .             .         .         .          .    .    .          return  (Ref)(t - &memory[0]); }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .      void     moveTo(RegionAllocator& to) {
           60     0    0            15         0         0         15    0    0          if (to.memory != NULL) ::free(to.memory);
           30     0    0            15         0         0         15    0    0          to.memory = memory;
           30     0    0            15         0         0         15    0    0          to.sz = sz;
            .     .    .             .         .         .          .    .    .          to.cap = cap;
           30     0    0            15         0         0         15    0    0          to.wasted_ = wasted_;
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .          memory = NULL;
            .     .    .             .         .         .          .    .    .          sz = cap = wasted_ = 0;
            .     .    .             .         .         .          .    .    .      }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  };
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  template<class T>
          144    17   17             0         0         0         48    0    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
            .     .    .             .         .         .          .    .    .  {
   31,795,668     4    4    10,598,552         0         0          0    0    0      if (cap >= min_cap) return;
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .      uint32_t prev_cap = cap;
        1,030     0    0             0         0         0         28    0    0      while (cap < min_cap){
            .     .    .             .         .         .          .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
            .     .    .             .         .         .          .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
            .     .    .             .         .         .          .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
            .     .    .             .         .         .          .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        3,006     0    0             0         0         0          0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
          501     0    0             0         0         0          0    0    0          cap += delta;
            .     .    .             .         .         .          .    .    .  
        1,002     0    0             0         0         0          0    0    0          if (cap <= prev_cap)
            .     .    .             .         .         .          .    .    .              throw OutOfMemoryException();
            .     .    .             .         .         .          .    .    .      }
            .     .    .             .         .         .          .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .      assert(cap > 0);
           60     2    2             0         0         0         28    9    8      memory = (T*)xrealloc(memory, sizeof(T)*cap);
           96     0    0            72         0         0          0    0    0  }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  template<class T>
            .     .    .             .         .         .          .    .    .  typename RegionAllocator<T>::Ref
    3,356,016     3    3             0         0         0  2,517,012    0    0  RegionAllocator<T>::alloc(int size)
            .     .    .             .         .         .          .    .    .  { 
            .     .    .             .         .         .          .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
            .     .    .             .         .         .          .    .    .      assert(size > 0);
   58,450,419     0    0    10,598,536   262,413         0 28,088,741   16    1      capacity(sz + size);
            .     .    .             .         .         .          .    .    .  
   29,873,524     0    0    18,924,137         0         0          0    0    0      uint32_t prev_sz = sz;
   10,598,536     3    3             0         0         0 10,598,536    0    0      sz += size;
            .     .    .             .         .         .          .    .    .      
            .     .    .             .         .         .          .    .    .      // Handle overflow:
   48,690,883    28   28     9,164,604         0         0          0    0    0      if (sz < prev_sz)
            2     1    1             1         1         1          0    0    0          throw OutOfMemoryException();
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .      return prev_sz;
    3,356,016     0    0     3,356,016         0         0          0    0    0  }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  //=================================================================================================
            .     .    .             .         .         .          .    .    .  }
            .     .    .             .         .         .          .    .    .  
            .     .    .             .         .         .          .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/8/bits/stl_tree.h
--------------------------------------------------------------------------------
Ir          I1mr   ILmr Dr         D1mr      DLmr    Dw      D1mw   DLmw  

-- line 167 ----------------------------------------
          .      .    .          .         .       .       .      .     .    // Helper type to manage default initialization of node count and header.
          .      .    .          .         .       .       .      .     .    struct _Rb_tree_header
          .      .    .          .         .       .       .      .     .    {
          .      .    .          .         .       .       .      .     .      _Rb_tree_node_base	_M_header;
          .      .    .          .         .       .       .      .     .      size_t		_M_node_count; // Keeps track of size of tree.
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .      _Rb_tree_header() _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .      {
     40,991      0    0          0         0       0  40,991 14,071 1,545        _M_header._M_color = _S_red;
          .      .    .          .         .       .       .      .     .        _M_reset();
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .  #if __cplusplus >= 201103L
          .      .    .          .         .       .       .      .     .      _Rb_tree_header(_Rb_tree_header&& __x) noexcept
          .      .    .          .         .       .       .      .     .      {
          .      .    .          .         .       .       .      .     .        if (__x._M_header._M_parent != nullptr)
          .      .    .          .         .       .       .      .     .  	_M_move_data(__x);
-- line 183 ----------------------------------------
-- line 200 ----------------------------------------
          .      .    .          .         .       .       .      .     .        _M_node_count = __from._M_node_count;
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        __from._M_reset();
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .      void
          .      .    .          .         .       .       .      .     .      _M_reset()
          .      .    .          .         .       .       .      .     .      {
     40,992      1    1          0         0       0  40,992      1     1        _M_header._M_parent = 0;
     81,983      1    1          0         0       0  40,992  6,041     9        _M_header._M_left = &_M_header;
     40,992      1    1          0         0       0  40,992      1     1        _M_header._M_right = &_M_header;
     40,992      1    1          0         0       0  40,992  5,979     4        _M_node_count = 0;
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .    };
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Val>
          .      .    .          .         .       .       .      .     .      struct _Rb_tree_node : public _Rb_tree_node_base
          .      .    .          .         .       .       .      .     .      {
          .      .    .          .         .       .       .      .     .        typedef _Rb_tree_node<_Val>* _Link_type;
          .      .    .          .         .       .       .      .     .  
-- line 219 ----------------------------------------
-- line 279 ----------------------------------------
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        pointer
          .      .    .          .         .       .       .      .     .        operator->() const _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        { return static_cast<_Link_type> (_M_node)->_M_valptr(); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Self&
          .      .    .          .         .       .       .      .     .        operator++() _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        {
    495,165      2    2          0         0       0 165,055      0     0  	_M_node = _Rb_tree_increment(_M_node);
          .      .    .          .         .       .       .      .     .  	return *this;
          .      .    .          .         .       .       .      .     .        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Self
          .      .    .          .         .       .       .      .     .        operator++(int) _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        {
          .      .    .          .         .       .       .      .     .  	_Self __tmp = *this;
          .      .    .          .         .       .       .      .     .  	_M_node = _Rb_tree_increment(_M_node);
          .      .    .          .         .       .       .      .     .  	return __tmp;
          .      .    .          .         .       .       .      .     .        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Self&
          .      .    .          .         .       .       .      .     .        operator--() _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        {
    286,536      0    0          0         0       0  95,512      0     0  	_M_node = _Rb_tree_decrement(_M_node);
          .      .    .          .         .       .       .      .     .  	return *this;
          .      .    .          .         .       .       .      .     .        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Self
          .      .    .          .         .       .       .      .     .        operator--(int) _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        {
          .      .    .          .         .       .       .      .     .  	_Self __tmp = *this;
          .      .    .          .         .       .       .      .     .  	_M_node = _Rb_tree_decrement(_M_node);
-- line 310 ----------------------------------------
-- line 756 ----------------------------------------
          .      .    .          .         .       .       .      .     .        _M_begin() const _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        {
          .      .    .          .         .       .       .      .     .  	return static_cast<_Const_Link_type>
          .      .    .          .         .       .       .      .     .  	  (this->_M_impl._M_header._M_parent);
          .      .    .          .         .       .       .      .     .        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Base_ptr
          .      .    .          .         .       .       .      .     .        _M_end() _GLIBCXX_NOEXCEPT
  6,674,877    358    7          0         0       0       0      0     0        { return &this->_M_impl._M_header; }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Const_Base_ptr
          .      .    .          .         .       .       .      .     .        _M_end() const _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        { return &this->_M_impl._M_header; }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        static const_reference
          .      .    .          .         .       .       .      .     .        _S_value(_Const_Link_type __x)
          .      .    .          .         .       .       .      .     .        { return *__x->_M_valptr(); }
-- line 772 ----------------------------------------
-- line 957 ----------------------------------------
          .      .    .          .         .       .       .      .     .        _Rb_tree(_Rb_tree&& __x, const allocator_type& __a)
          .      .    .          .         .       .       .      .     .        : _Rb_tree(std::move(__x), _Node_allocator(__a))
          .      .    .          .         .       .       .      .     .        { }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Rb_tree(_Rb_tree&& __x, _Node_allocator&& __a);
          .      .    .          .         .       .       .      .     .  #endif
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        ~_Rb_tree() _GLIBCXX_NOEXCEPT
     23,155      0    0     23,155    12,234   5,962       0      0     0        { _M_erase(_M_begin()); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        _Rb_tree&
          .      .    .          .         .       .       .      .     .        operator=(const _Rb_tree& __x);
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        // Accessors.
          .      .    .          .         .       .       .      .     .        _Compare
          .      .    .          .         .       .       .      .     .        key_comp() const
          .      .    .          .         .       .       .      .     .        { return _M_impl._M_key_compare; }
-- line 973 ----------------------------------------
-- line 977 ----------------------------------------
          .      .    .          .         .       .       .      .     .        { return iterator(this->_M_impl._M_header._M_left); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        const_iterator
          .      .    .          .         .       .       .      .     .        begin() const _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        { return const_iterator(this->_M_impl._M_header._M_left); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        iterator
          .      .    .          .         .       .       .      .     .        end() _GLIBCXX_NOEXCEPT
    657,407      0    0          0         0       0       0      0     0        { return iterator(&this->_M_impl._M_header); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        const_iterator
          .      .    .          .         .       .       .      .     .        end() const _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        { return const_iterator(&this->_M_impl._M_header); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        reverse_iterator
          .      .    .          .         .       .       .      .     .        rbegin() _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        { return reverse_iterator(end()); }
-- line 993 ----------------------------------------
-- line 1179 ----------------------------------------
          .      .    .          .         .       .       .      .     .        { _M_erase_aux(__first, __last); }
          .      .    .          .         .       .       .      .     .  #endif
          .      .    .          .         .       .       .      .     .        void
          .      .    .          .         .       .       .      .     .        erase(const key_type* __first, const key_type* __last);
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        void
          .      .    .          .         .       .       .      .     .        clear() _GLIBCXX_NOEXCEPT
          .      .    .          .         .       .       .      .     .        {
          3      1    1          1         1       1       1      0     0  	_M_erase(_M_begin());
          .      .    .          .         .       .       .      .     .  	_M_impl._M_reset();
          .      .    .          .         .       .       .      .     .        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        // Set operations.
          .      .    .          .         .       .       .      .     .        iterator
          .      .    .          .         .       .       .      .     .        find(const key_type& __k);
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        const_iterator
          .      .    .          .         .       .       .      .     .        find(const key_type& __k) const;
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        size_type
          .      .    .          .         .       .       .      .     .        count(const key_type& __k) const;
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        iterator
          .      .    .          .         .       .       .      .     .        lower_bound(const key_type& __k)
  2,099,025  6,043   98  2,010,529         2       0       0      0     0        { return _M_lower_bound(_M_begin(), _M_end(), __k); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        const_iterator
          .      .    .          .         .       .       .      .     .        lower_bound(const key_type& __k) const
          .      .    .          .         .       .       .      .     .        { return _M_lower_bound(_M_begin(), _M_end(), __k); }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        iterator
          .      .    .          .         .       .       .      .     .        upper_bound(const key_type& __k)
          .      .    .          .         .       .       .      .     .        { return _M_upper_bound(_M_begin(), _M_end(), __k); }
-- line 1211 ----------------------------------------
-- line 1858 ----------------------------------------
          .      .    .          .         .       .       .      .     .  	    __throw_exception_again;
          .      .    .          .         .       .       .      .     .  	  }
          .      .    .          .         .       .       .      .     .  	return __top;
          .      .    .          .         .       .       .      .     .        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      void
    716,808      1    1          0         0       0 397,348  1,247    14      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      _M_erase(_Link_type __x)
          .      .    .          .         .       .       .      .     .      {
          .      .    .          .         .       .       .      .     .        // Erase without rebalancing.
    718,155      1    1          0         0       0       0      0     0        while (__x != 0)
          .      .    .          .         .       .       .      .     .  	{
    495,165      2    2    188,210   164,204  70,576 165,055    410     3  	  _M_erase(_S_right(__x));
    165,055      0    0    165,055       731       0       0      0     0  	  _Link_type __y = _S_left(__x);
          .      .    .          .         .       .       .      .     .  	  _M_drop_node(__x);
          .      .    .          .         .       .       .      .     .  	  __x = __y;
          .      .    .          .         .       .       .      .     .  	}
    621,218      1    1    539,248     1,577       2       0      0     0      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  		      _Compare, _Alloc>::iterator
          .      .    .          .         .       .       .      .     .      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      _M_lower_bound(_Link_type __x, _Base_ptr __y,
          .      .    .          .         .       .       .      .     .  		   const _Key& __k)
          .      .    .          .         .       .       .      .     .      {
111,325,623  2,131   39          0         0       0       0      0     0        while (__x != 0)
109,404,773 29,147   84 53,864,931 9,199,582 362,857       0      0     0  	if (!_M_impl._M_key_compare(_S_key(__x), __k))
 44,824,118      0    0 22,412,059   983,528  45,618       0      0     0  	  __y = __x, __x = _S_left(__x);
          .      .    .          .         .       .       .      .     .  	else
 31,793,422      0    0 28,954,528 1,338,206  41,426       0      0     0  	  __x = _S_right(__x);
          .      .    .          .         .       .       .      .     .        return iterator(__y);
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  		      _Compare, _Alloc>::const_iterator
          .      .    .          .         .       .       .      .     .      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
-- line 1899 ----------------------------------------
-- line 2040 ----------------------------------------
          .      .    .          .         .       .       .      .     .      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  			   _Compare, _Alloc>::_Base_ptr,
          .      .    .          .         .       .       .      .     .  	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  			   _Compare, _Alloc>::_Base_ptr>
          .      .    .          .         .       .       .      .     .      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      _M_get_insert_unique_pos(const key_type& __k)
          .      .    .          .         .       .       .      .     .      {
          .      .    .          .         .       .       .      .     .        typedef pair<_Base_ptr, _Base_ptr> _Res;
     40,992      2    2     40,992         3       0       0      0     0        _Link_type __x = _M_begin();
          .      .    .          .         .       .       .      .     .        _Base_ptr __y = _M_end();
          .      .    .          .         .       .       .      .     .        bool __comp = true;
    122,976 10,471   14          0         0       0       0      0     0        while (__x != 0)
          .      .    .          .         .       .       .      .     .  	{
          .      .    .          .         .       .       .      .     .  	  __y = __x;
          .      .    .          .         .       .       .      .     .  	  __comp = _M_impl._M_key_compare(__k, _S_key(__x));
          .      .    .          .         .       .       .      .     .  	  __x = __comp ? _S_left(__x) : _S_right(__x);
          .      .    .          .         .       .       .      .     .  	}
          .      .    .          .         .       .       .      .     .        iterator __j = iterator(__y);
          .      .    .          .         .       .       .      .     .        if (__comp)
          .      .    .          .         .       .       .      .     .  	{
    122,976 20,040   26     40,992         0       0       0      0     0  	  if (__j == begin())
     81,984      0    0          0         0       0       0      0     0  	    return _Res(__x, __y);
          .      .    .          .         .       .       .      .     .  	  else
          .      .    .          .         .       .       .      .     .  	    --__j;
          .      .    .          .         .       .       .      .     .  	}
          .      .    .          .         .       .       .      .     .        if (_M_impl._M_key_compare(_S_key(__j._M_node), __k))
          .      .    .          .         .       .       .      .     .  	return _Res(__x, __y);
          .      .    .          .         .       .       .      .     .        return _Res(__j._M_node, 0);
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .  
-- line 2069 ----------------------------------------
-- line 2138 ----------------------------------------
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  			   _Compare, _Alloc>::_Base_ptr,
          .      .    .          .         .       .       .      .     .  	 typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  			   _Compare, _Alloc>::_Base_ptr>
  1,982,408     21   10          0         0       0 991,204      0     0      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      _M_get_insert_hint_unique_pos(const_iterator __position,
          .      .    .          .         .       .       .      .     .  				  const key_type& __k)
          .      .    .          .         .       .       .      .     .      {
          .      .    .          .         .       .       .      .     .        iterator __pos = __position._M_const_cast();
          .      .    .          .         .       .       .      .     .        typedef pair<_Base_ptr, _Base_ptr> _Res;
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .        // end()
    495,602      0    0          0         0       0       0      0     0        if (__pos._M_node == _M_end())
          .      .    .          .         .       .       .      .     .  	{
          .      .    .          .         .       .       .      .     .  	  if (size() > 0
    614,112     14   13    395,744    15,478   3,465       0      0     0  	      && _M_impl._M_key_compare(_S_key(_M_rightmost()), __k))
          .      .    .          .         .       .       .      .     .  	    return _Res(0, _M_rightmost());
          .      .    .          .         .       .       .      .     .  	  else
          .      .    .          .         .       .       .      .     .  	    return _M_get_insert_unique_pos(__k);
          .      .    .          .         .       .       .      .     .  	}
    354,363      0    0    236,242         0       0       0      0     0        else if (_M_impl._M_key_compare(__k, _S_key(__pos._M_node)))
          .      .    .          .         .       .       .      .     .  	{
          .      .    .          .         .       .       .      .     .  	  // First, try before...
          .      .    .          .         .       .       .      .     .  	  iterator __before = __pos;
    354,363     98   22    118,121    19,986   3,757       0      0     0  	  if (__pos._M_node == _M_leftmost()) // begin()
    118,121      0    0          0         0       0       0      0     0  	    return _Res(_M_leftmost(), _M_leftmost());
    191,024      0    0     95,512         0       0       0      0     0  	  else if (_M_impl._M_key_compare(_S_key((--__before)._M_node), __k))
          .      .    .          .         .       .       .      .     .  	    {
          .      .    .          .         .       .       .      .     .  	      if (_S_right(__before._M_node) == 0)
    477,560      0    0     95,512         0       0       0      0     0  		return _Res(0, __before._M_node);
          .      .    .          .         .       .       .      .     .  	      else
          .      .    .          .         .       .       .      .     .  		return _Res(__pos._M_node, __pos._M_node);
          .      .    .          .         .       .       .      .     .  	    }
          .      .    .          .         .       .       .      .     .  	  else
          .      .    .          .         .       .       .      .     .  	    return _M_get_insert_unique_pos(__k);
          .      .    .          .         .       .       .      .     .  	}
          .      .    .          .         .       .       .      .     .        else if (_M_impl._M_key_compare(_S_key(__pos._M_node), __k))
          .      .    .          .         .       .       .      .     .  	{
          .      .    .          .         .       .       .      .     .  	  // ... then try after.
          .      .    .          .         .       .       .      .     .  	  iterator __after = __pos;
          .      .    .          .         .       .       .      .     .  	  if (__pos._M_node == _M_rightmost())
    177,376      0    0          0         0       0       0      0     0  	    return _Res(0, _M_rightmost());
          .      .    .          .         .       .       .      .     .  	  else if (_M_impl._M_key_compare(__k, _S_key((++__after)._M_node)))
          .      .    .          .         .       .       .      .     .  	    {
          .      .    .          .         .       .       .      .     .  	      if (_S_right(__pos._M_node) == 0)
          .      .    .          .         .       .       .      .     .  		return _Res(0, __pos._M_node);
          .      .    .          .         .       .       .      .     .  	      else
          .      .    .          .         .       .       .      .     .  		return _Res(__after._M_node, __after._M_node);
          .      .    .          .         .       .       .      .     .  	    }
          .      .    .          .         .       .       .      .     .  	  else
          .      .    .          .         .       .       .      .     .  	    return _M_get_insert_unique_pos(__k);
          .      .    .          .         .       .       .      .     .  	}
          .      .    .          .         .       .       .      .     .        else
          .      .    .          .         .       .       .      .     .  	// Equivalent keys.
          .      .    .          .         .       .       .      .     .  	return _Res(__pos._M_node, 0);
  1,568,790 17,111   45  1,239,005         0       0       0      0     0      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .  #if __cplusplus >= 201103L
          .      .    .          .         .       .       .      .     .      template<typename _Arg, typename _NodeGen>
          .      .    .          .         .       .       .      .     .  #else
          .      .    .          .         .       .       .      .     .      template<typename _NodeGen>
          .      .    .          .         .       .       .      .     .  #endif
-- line 2205 ----------------------------------------
-- line 2308 ----------------------------------------
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .  #if __cplusplus >= 201103L
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
          .      .    .          .         .       .       .      .     .      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      _M_insert_node(_Base_ptr __x, _Base_ptr __p, _Link_type __z)
          .      .    .          .         .       .       .      .     .      {
    379,647  5,365   17          0         0       0       0      0     0        bool __insert_left = (__x != 0 || __p == _M_end()
  1,351,963      1    1    263,764         0       0       0      0     0  			    || _M_impl._M_key_compare(_S_key(__z),
          .      .    .          .         .       .       .      .     .  						      _S_key(__p)));
          .      .    .          .         .       .       .      .     .  
    512,552  2,110   12          0         0       0 247,801      0     0        _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,
          .      .    .          .         .       .       .      .     .  				    this->_M_impl._M_header);
    247,801      6    6    247,801    22,938   3,537       0      0     0        ++_M_impl._M_node_count;
          .      .    .          .         .       .       .      .     .        return iterator(__z);
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
          .      .    .          .         .       .       .      .     .      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      _M_insert_lower_node(_Base_ptr __p, _Link_type __z)
-- line 2330 ----------------------------------------
-- line 2403 ----------------------------------------
          .      .    .          .         .       .       .      .     .  	    __throw_exception_again;
          .      .    .          .         .       .       .      .     .  	  }
          .      .    .          .         .       .       .      .     .        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      template<typename... _Args>
          .      .    .          .         .       .       .      .     .        typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
  1,894,888 15,488   29          0         0       0 971,484      0     0        _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .        _M_emplace_hint_unique(const_iterator __pos, _Args&&... __args)
          .      .    .          .         .       .       .      .     .        {
          .      .    .          .         .       .       .      .     .  	_Link_type __z = _M_create_node(std::forward<_Args>(__args)...);
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .  	__try
          .      .    .          .         .       .       .      .     .  	  {
    991,204      0    0     16,950         0       0 264,751      0     0  	    auto __res = _M_get_insert_hint_unique_pos(__pos, _S_key(__z));
          .      .    .          .         .       .       .      .     .  
    726,453      1    1          0         0       0       0      0     0  	    if (__res.second)
          .      .    .          .         .       .       .      .     .  	      return _M_insert_node(__res.first, __res.second, __z);
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .  	    _M_drop_node(__z);
          .      .    .          .         .       .       .      .     .  	    return iterator(__res.first);
          .      .    .          .         .       .       .      .     .  	  }
          .      .    .          .         .       .       .      .     .  	__catch(...)
          .      .    .          .         .       .       .      .     .  	  {
          .      .    .          .         .       .       .      .     .  	    _M_drop_node(__z);
          .      .    .          .         .       .       .      .     .  	    __throw_exception_again;
          .      .    .          .         .       .       .      .     .  	  }
  1,664,037      0    0  1,202,335        31       0       0      0     0        }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      template<typename... _Args>
          .      .    .          .         .       .       .      .     .        typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator
          .      .    .          .         .       .       .      .     .        _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .        _M_emplace_hint_equal(const_iterator __pos, _Args&&... __args)
          .      .    .          .         .       .       .      .     .        {
-- line 2439 ----------------------------------------
-- line 2531 ----------------------------------------
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  		      _Compare, _Alloc>::iterator
          .      .    .          .         .       .       .      .     .      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      find(const _Key& __k)
          .      .    .          .         .       .       .      .     .      {
  1,081,650     27    5  1,081,650   123,338  12,065       0      0     0        iterator __j = _M_lower_bound(_M_begin(), _M_end(), __k);
          .      .    .          .         .       .       .      .     .        return (__j == end()
    982,684    463   11    491,342         0       0       0      0     0  	      || _M_impl._M_key_compare(__k,
  2,163,298      0    0          0         0       0       0      0     0  					_S_key(__j._M_node))) ? end() : __j;
          .      .    .          .         .       .       .      .     .      }
          .      .    .          .         .       .       .      .     .  
          .      .    .          .         .       .       .      .     .    template<typename _Key, typename _Val, typename _KeyOfValue,
          .      .    .          .         .       .       .      .     .  	   typename _Compare, typename _Alloc>
          .      .    .          .         .       .       .      .     .      typename _Rb_tree<_Key, _Val, _KeyOfValue,
          .      .    .          .         .       .       .      .     .  		      _Compare, _Alloc>::const_iterator
          .      .    .          .         .       .       .      .     .      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::
          .      .    .          .         .       .       .      .     .      find(const _Key& __k) const
-- line 2550 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr            D1mr        DLmr    Dw          D1mw   DLmw 

-- line 77 ----------------------------------------
            .     .    .             .           .       .           .      .    .  private:
            .     .    .             .           .       .           .      .    .      template<typename T>
            .     .    .             .           .       .           .      .    .      class MyQueue {
            .     .    .             .           .       .           .      .    .          int max_sz, q_sz;
            .     .    .             .           .       .           .      .    .          int ptr;
            .     .    .             .           .       .           .      .    .          int64_t sum;
            .     .    .             .           .       .           .      .    .          vec<T> q;
            .     .    .             .           .       .           .      .    .      public:
            4     1    1             0           0       0           3      0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
            .     .    .             .           .       .           .      .    .          inline bool   full () const { return q_sz == max_sz; }
            .     .    .             .           .       .           .      .    .  #ifdef INT_QUEUE_AVG
      419,256   127   12       104,814           0       0           0      0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
            .     .    .             .           .       .           .      .    .  #else
            .     .    .             .           .       .           .      .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
            .     .    .             .           .       .           .      .    .  #endif
        5,352    26   19             0           0       0       5,352    283    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
            .     .    .             .           .       .           .      .    .          void push(T e) {
    1,934,614     0    0       870,807           0       0      96,500      0    0              if (q_sz < max_sz) q_sz++;
      581,307     7    6       193,769     169,937      13           0      0    0              else sum -= q[ptr];
      870,807    14    6             0           0       0     290,269      0    0              sum += e;
      870,807     0    0             0           0       0     580,538 83,844   18              q[ptr++] = e;
      875,932     0    0       580,538           0       0       5,125      0    0              if (ptr == max_sz) ptr = 0;
            .     .    .             .           .       .           .      .    .          }
            .     .    .             .           .       .           .      .    .      };
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  public:
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .      // Constructor/Destructor:
            .     .    .             .           .       .           .      .    .      //
            .     .    .             .           .       .           .      .    .      Solver();
            .     .    .             .           .       .           .      .    .      virtual ~Solver();
           10     2    2             0           0       0           4      0    0      void print_size(std::ostream &os)
            .     .    .             .           .       .           .      .    .      {
            4     2    2             0           0       0           4      1    1          program_end_time=std::chrono::steady_clock::now();
            2     0    0             0           0       0           2      0    0          total_work_time=program_end_time-program_start_time;
            4     0    0             2           1       0           0      0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
            2     0    0             2           2       0           0      0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
            4     0    0             2           0       0           0      0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
            4     0    0             2           1       1           0      0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
            4     0    0             2           0       0           0      0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
            4     0    0             2           2       1           0      0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
            .     .    .             .           .       .           .      .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
            .     .    .             .           .       .           .      .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
            2     0    0             2           2       0           0      0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
            2     0    0             2           0       0           0      0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
            2     0    0             2           0       0           0      0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
            4     0    0             2           0       0           0      0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
            4     0    0             2           2       0           0      0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
            4     0    0             2           0       0           0      0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
            4     0    0             2           0       0           0      0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
            .     .    .             .           .       .           .      .    .          os << "total_Watchers: " << total_Watchers << "\n";
            .     .    .             .           .       .           .      .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
            .     .    .             .           .       .           .      .    .          os << "total_indexs: " << total_indexs << "\n";
            .     .    .             .           .       .           .      .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
            .     .    .             .           .       .           .      .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
            .     .    .             .           .       .           .      .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
            .     .    .             .           .       .           .      .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
            .     .    .             .           .       .           .      .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
            .     .    .             .           .       .           .      .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
            .     .    .             .           .       .           .      .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
            .     .    .             .           .       .           .      .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
            .     .    .             .           .       .           .      .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
            .     .    .             .           .       .           .      .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
            .     .    .             .           .       .           .      .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
            .     .    .             .           .       .           .      .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
            .     .    .             .           .       .           .      .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
            6     0    0             4           0       0           0      0    0      }
            .     .    .             .           .       .           .      .    .      using ull=unsigned long long;
            .     .    .             .           .       .           .      .    .      ull total_Watchers = 0;
            .     .    .             .           .       .           .      .    .      ull total_act_watchers = 0;
            .     .    .             .           .       .           .      .    .      ull total_indexs = 0;
            .     .    .             .           .       .           .      .    .      ull time_find_conflict = 0;
            .     .    .             .           .       .           .      .    .      ull total_find_conflict_length = 0;
            .     .    .             .           .       .           .      .    .      ull total_find_conflict_allsize = 0;
            .     .    .             .           .       .           .      .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
            .     .    .             .           .       .           .      .    .      {
            .     .    .             .           .       .           .      .    .          const ClauseAllocator& ca;
            .     .    .             .           .       .           .      .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
            .     .    .             .           .       .           .      .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
            .     .    .             .           .       .           .      .    .      };
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .      struct VarOrderLt {
            .     .    .             .           .       .           .      .    .          const vec<double>&  activity;
1,224,602,303   643   37   742,454,373 139,862,860 139,702   8,042,994      2    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
            .     .    .             .           .       .           .      .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
            .     .    .             .           .       .           .      .    .      };
            .     .    .             .           .       .           .      .    .      
            .     .    .             .           .       .           .      .    .      struct ConflictData
            .     .    .             .           .       .           .      .    .  	{
            .     .    .             .           .       .           .      .    .  		ConflictData() :
            .     .    .             .           .       .           .      .    .  			nHighestLevel(-1),
            .     .    .             .           .       .           .      .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
            .     .    .             .           .       .           .      .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
            .     .    .             .           .       .           .      .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
            .     .    .             .           .       .           .      .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
            .     .    .             .           .       .           .      .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
            .     .    .             .           .       .           .      .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
            .     .    .             .           .       .           .      .    .      std::chrono::nanoseconds total_duration;
            .     .    .             .           .       .           .      .    .      CRef     propagate(){
            .     .    .             .           .       .           .      .    .  
   16,682,260 8,110   54             0           0       0   8,341,130      2    0          auto start_time=std::chrono::steady_clock::now();
   25,023,390     0    0             0           0       0   8,341,130      0    0          auto ref= propagate_();
    8,341,130     1    1             0           0       0   8,341,130      0    0          auto end_time=std::chrono::steady_clock::now();
            .     .    .             .           .       .           .      .    .          auto duration=end_time-start_time;
            .     .    .             .           .       .           .      .    .          total_duration+=duration;
            .     .    .             .           .       .           .      .    .          return ref;
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .      }
            .     .    .             .           .       .           .      .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
            .     .    .             .           .       .           .      .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
            .     .    .             .           .       .           .      .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
            .     .    .             .           .       .           .      .    .      
            .     .    .             .           .       .           .      .    .  public:
            .     .    .             .           .       .           .      .    .      int      level            (Var x) const;
            .     .    .             .           .       .           .      .    .  protected:
            .     .    .             .           .       .           .      .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
            .     .    .             .           .       .           .      .    .      bool     withinBudget     ()      const;
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .      template<class V> int computeLBD(const V& c) {
   31,328,743    23   16             0           0       0           0      0    0          int lbd = 0;
            .     .    .             .           .       .           .      .    .  
    3,533,716    24   18     2,938,787     373,809      12           0      0    0          counter++;
  151,976,670     0    0       596,057           0       0           0      0    0          for (int i = 0; i < c.size(); i++){
            .     .    .             .           .       .           .      .    .              int l = level(var(c[i]));
  360,752,412     0    0   144,300,852   7,542,848   3,734           0      0    0              if (l != 0 && seen2[l] != counter){
   31,248,019     0    0             0           0       0  31,248,019      0    0                  seen2[l] = counter;
   54,844,436     0    0             0           0       0           0      0    0                  lbd++; } }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .          return lbd;
            .     .    .             .           .       .           .      .    .      }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  #ifdef BIN_DRUP
            .     .    .             .           .       .           .      .    .      static int buf_len;
            .     .    .             .           .       .           .      .    .      static unsigned char drup_buf[];
            .     .    .             .           .       .           .      .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
            .     .    .             .           .       .           .      .    .      }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .      template<class V>
            .     .    .             .           .       .           .      .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
            .     .    .             .           .       .           .      .    .          assert(op == 'a' || op == 'd');
            .     .    .             .           .       .           .      .    .          *buf_ptr++ = op; buf_len++;
            .     .    .             .           .       .           .      .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
            .     .    .             .           .       .           .      .    .          *buf_ptr++ = 0; buf_len++;
      175,470    22   16             0           0       0     175,470      0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
            .     .    .             .           .       .           .      .    .      }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
            .     .    .             .           .       .           .      .    .          *buf_ptr++ = 'a'; buf_len++;
            .     .    .             .           .       .           .      .    .          for (int i = 0; i < c.size(); i++)
            .     .    .             .           .       .           .      .    .              if (c[i] != l) byteDRUP(c[i]);
            .     .    .             .           .       .           .      .    .          *buf_ptr++ = 0; buf_len++;
            .     .    .             .           .       .           .      .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
            .     .    .             .           .       .           .      .    .      double    my_var_decay;
            .     .    .             .           .       .           .      .    .      bool   DISTANCE;
            .     .    .             .           .       .           .      .    .  };
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  //=================================================================================================
            .     .    .             .           .       .           .      .    .  // Implementation of inline methods:
            .     .    .             .           .       .           .      .    .  
  179,335,930     0    0   179,335,930   7,990,604  30,349           0      0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
  795,224,112    33   23   686,380,001 133,666,617   3,212 104,727,392      0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  inline void Solver::insertVarOrder(Var x) {
            .     .    .             .           .       .           .      .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
  658,111,177 8,660   22   207,341,305     191,944       0           0      0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
   48,981,294     1    1    32,654,196  11,185,763   5,761           0      0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  inline void Solver::varDecayActivity() {
    1,161,076     0    0       580,538      68,094       0     290,269      0    0      var_inc *= (1 / var_decay); }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  inline void Solver::varBumpActivity(Var v, double mult) {
  138,452,607     4    4    84,035,293  12,330,176   2,673  20,860,091      0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
            .     .    .             .           .       .           .      .    .          // Rescale:
          932    35   16             1           0       0           0      0    0          for (int i = 0; i < nVars(); i++)
   13,406,508     0    0     3,351,627     837,930  39,191   3,351,627      0    0              activity_VSIDS[i] *= 1e-100;
          186     0    0            93          93       0          93      0    0          var_inc *= 1e-100; }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .      // Update order_heap with respect to new activity:
   13,421,516     0    0             0           0       0           0      0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
            .     .    .             .           .       .           .      .    .  
    2,379,716   899   20     1,189,858         120       0     594,929      0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
            .     .    .             .           .       .           .      .    .  inline void Solver::claBumpActivity (Clause& c) {
   12,131,180 2,530   49     3,577,304     598,106      81   1,244,143  1,273  353      if ( (c.activity() += cla_inc) > 1e20 ) {
            .     .    .             .           .       .           .      .    .          // Rescale:
      672,804    12   11            36           0       0           0      0    0          for (int i = 0; i < learnts_local.size(); i++)
    1,569,652     1    0       224,236     190,019  14,287     224,236      0    0              ca[learnts_local[i]].activity() *= 1e-20;
      310,286    56   22       155,125           0       0          12     12    0          cla_inc *= 1e-20; } }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
            .     .    .             .           .       .           .      .    .  inline void Solver::checkGarbage(double gf){
    1,200,267    38    1       400,089          78       2           0      0    0      if (ca.wasted() > ca.size() * gf)
           55     1    1            28          28      15           1      1    0          garbageCollect(); }
            .     .    .             .           .       .           .      .    .  
            .     .    .             .           .       .           .      .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
           27     0    0             0           0       0           5      0    0  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
            .     .    .             .           .       .           .      .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
            .     .    .             .           .       .           .      .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
            .     .    .             .           .       .           .      .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
            .     .    .             .           .       .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
            .     .    .             .           .       .           .      .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
            .     .    .             .           .       .           .      .    .  inline bool     Solver::locked          (const Clause& c) const {
    8,903,842    39   22     2,513,158      54,060       0           0      0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    7,792,065    45   26     2,385,328     383,609   4,657           0      0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
            .     .    .             .           .       .           .      .    .  }
   15,475,487     1    1     7,737,734           0       0           0      0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
            .     .    .             .           .       .           .      .    .  
    1,897,349     3    3       954,816           2       1     942,533      0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
  463,982,635   692   25    27,362,288   7,414,053       0           0      0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
   16,966,473     2    2    16,966,457      37,434       1           0      0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
1,842,105,409    19   19 1,842,105,409         867       0           0      0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
            .     .    .             .           .       .           .      .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
            .     .    .             .           .       .           .      .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
            .     .    .             .           .       .           .      .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
            5     0    0             3           0       0           1      1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
            .     .    .             .           .       .           .      .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
    7,104,481     4    2       216,431         102       1           1      0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
           18     2    2             9           8       2           0      0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
            .     .    .             .           .       .           .      .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
            .     .    .             .           .       .           .      .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
            .     .    .             .           .       .           .      .    .  { 
      432,468     0    0       216,234       1,394       0           0      0    0      if      ( b && !decision[v]) dec_vars++;
       69,537     0    0        46,358      21,939   2,599           0      0    0      else if (!b &&  decision[v]) dec_vars--;
            .     .    .             .           .       .           .      .    .  
       95,257     0    0             0           0       0      95,257      0    0      decision[v] = b;
            .     .    .             .           .       .           .      .    .      if (b && !order_heap_CHB.inHeap(v)){
            .     .    .             .           .       .           .      .    .          order_heap_CHB.insert(v);
            .     .    .             .           .       .           .      .    .          order_heap_VSIDS.insert(v);
            .     .    .             .           .       .           .      .    .          order_heap_distance.insert(v);}
            .     .    .             .           .       .           .      .    .  }
            .     .    .             .           .       .           .      .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
            .     .    .             .           .       .           .      .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
            .     .    .             .           .       .           .      .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr       DLmr    Dw        D1mw    DLmw  

-- line 33 ----------------------------------------
          .    .    .           .          .       .         .       .     .  using namespace Minisat;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  //=================================================================================================
          .    .    .           .          .       .         .       .     .  // Options:
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  static const char* _cat = "SIMP";
          .    .    .           .          .       .         .       .     .  
          4    1    1           0          0       0         1       0     0  static BoolOption   opt_use_asymm        (_cat, "asymm",        "Shrink clauses by asymmetric branching.", false);
          4    0    0           0          0       0         1       0     0  static BoolOption   opt_use_rcheck       (_cat, "rcheck",       "Check if a clause is already implied. (costly)", false);
          4    0    0           0          0       0         1       0     0  static BoolOption   opt_use_elim         (_cat, "elim",         "Perform variable elimination.", true);
          4    1    1           0          0       0         1       0     0  static IntOption    opt_grow             (_cat, "grow",         "Allow a variable elimination step to grow by a number of clauses.", 0);
          4    0    0           0          0       0         1       0     0  static IntOption    opt_clause_lim       (_cat, "cl-lim",       "Variables are not eliminated if it produces a resolvent with a length above this limit. -1 means no limit", 20,   IntRange(-1, INT32_MAX));
          4    0    0           0          0       0         1       0     0  static IntOption    opt_subsumption_lim  (_cat, "sub-lim",      "Do not check if subsumption against a clause larger than this. -1 means no limit.", 1000, IntRange(-1, INT32_MAX));
          4    0    0           0          0       0         1       0     0  static DoubleOption opt_simp_garbage_frac(_cat, "simp-gc-frac", "The fraction of wasted memory allowed before a garbage collection is triggered during simplification.",  0.5, DoubleRange(0, false, HUGE_VAL, false));
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  //=================================================================================================
          .    .    .           .          .       .         .       .     .  // Constructor/Destructor:
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          4    1    1           0          0       0         3       0     0  SimpSolver::SimpSolver() :
          .    .    .           .          .       .         .       .     .      parsing            (false)
          .    .    .           .          .       .         .       .     .    , grow               (opt_grow)
          .    .    .           .          .       .         .       .     .    , clause_lim         (opt_clause_lim)
          .    .    .           .          .       .         .       .     .    , subsumption_lim    (opt_subsumption_lim)
          .    .    .           .          .       .         .       .     .    , simp_garbage_frac  (opt_simp_garbage_frac)
          .    .    .           .          .       .         .       .     .    , use_asymm          (opt_use_asymm)
          .    .    .           .          .       .         .       .     .    , use_rcheck         (opt_use_rcheck)
          .    .    .           .          .       .         .       .     .    , use_elim           (opt_use_elim)
          .    .    .           .          .       .         .       .     .    , merges             (0)
          .    .    .           .          .       .         .       .     .    , asymm_lits         (0)
          .    .    .           .          .       .         .       .     .    , eliminated_vars    (0)
          .    .    .           .          .       .         .       .     .    , elimorder          (1)
          .    .    .           .          .       .         .       .     .    , use_simplification (true)
          1    0    0           0          0       0         0       0     0    , occurs             (ClauseDeleted(ca))
          .    .    .           .          .       .         .       .     .    , elim_heap          (ElimLt(n_occ))
          .    .    .           .          .       .         .       .     .    , bwdsub_assigns     (0)
         22    2    2           8          1       1        13       0     0    , n_touched          (0)
          .    .    .           .          .       .         .       .     .  {
          .    .    .           .          .       .         .       .     .      vec<Lit> dummy(1,lit_Undef);
          1    0    0           0          0       0         1       0     0      ca.extra_clause_field = true; // NOTE: must happen before allocating the dummy clause below.
          1    1    1           0          0       0         1       0     0      bwdsub_tmpunit        = ca.alloc(dummy);
          1    0    0           0          0       0         1       0     0      remove_satisfied      = false;
          3    0    0           3          0       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  SimpSolver::~SimpSolver()
          .    .    .           .          .       .         .       .     .  {
          .    .    .           .          .       .         .       .     .  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
    432,468    2    2           0          0       0   360,390       0     0  Var SimpSolver::newVar(bool sign, bool dvar) {
    288,312    0    0           0          0       0    72,078       0     0      Var v = Solver::newVar(sign, dvar);
          .    .    .           .          .       .         .       .     .  
         25    0    0           0          0       0         0       0     0      frozen    .push((char)false);
         25    0    0           0          0       0         0       0     0      eliminated.push((char)false);
          .    .    .           .          .       .         .       .     .  
    144,156    0    0      72,078      1,370       0         0       0     0      if (use_simplification){
    144,156    1    1           0          0       0         0       0     0          n_occ     .push(0);
          .    .    .           .          .       .         .       .     .          n_occ     .push(0);
          .    .    .           .          .       .         .       .     .          occurs    .init(v);
         25    0    0           0          0       0         0       0     0          touched   .push(0);
          .    .    .           .          .       .         .       .     .          elim_heap .insert(v);
          .    .    .           .          .       .         .       .     .      }
    504,546    0    0     432,468      1,447       0         0       0     0      return v; }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)
          8    1    1           0          0       0         6       0     0  {
          .    .    .           .          .       .         .       .     .      vec<Var> extra_frozen;
          .    .    .           .          .       .         .       .     .      lbool    result = l_True;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      do_simp &= use_simplification;
          .    .    .           .          .       .         .       .     .  
          4    0    0           1          1       1         1       0     0      if (do_simp){
          .    .    .           .          .       .         .       .     .          // Assumptions must be temporarily frozen to run variable elimination:
          .    .    .           .          .       .         .       .     .          for (int i = 0; i < assumptions.size(); i++){
          .    .    .           .          .       .         .       .     .              Var v = var(assumptions[i]);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .              // If an assumption has been eliminated, remember it.
          .    .    .           .          .       .         .       .     .              assert(!isEliminated(v));
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .              if (!frozen[v]){
-- line 117 ----------------------------------------
-- line 119 ----------------------------------------
          .    .    .           .          .       .         .       .     .                  setFrozen(v, true);
          .    .    .           .          .       .         .       .     .                  extra_frozen.push(v);
          .    .    .           .          .       .         .       .     .              } }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          result = lbool(eliminate(turn_off_simp));
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      if (result == l_True)
          3    2    2           0          0       0         2       0     0          result = Solver::solve_();
          .    .    .           .          .       .         .       .     .      else if (verbosity >= 1)
          .    .    .           .          .       .         .       .     .          printf("c ===============================================================================\n");
          .    .    .           .          .       .         .       .     .  
          2    0    0           0          0       0         0       0     0      if (result == l_True)
          2    0    0           0          0       0         1       0     0          extendModel();
          .    .    .           .          .       .         .       .     .  
          2    0    0           1          1       1         0       0     0      if (do_simp)
          .    .    .           .          .       .         .       .     .          // Unfreeze the assumptions that were frozen:
          .    .    .           .          .       .         .       .     .          for (int i = 0; i < extra_frozen.size(); i++)
          .    .    .           .          .       .         .       .     .              setFrozen(extra_frozen[i], false);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      return result;
          9    0    0           8          1       1         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  bool SimpSolver::addClause_(vec<Lit>& ps)
  8,185,833    5    5           0          0       0 5,457,222       0     0  {
          .    .    .           .          .       .         .       .     .  #ifndef NDEBUG
          .    .    .           .          .       .         .       .     .      for (int i = 0; i < ps.size(); i++)
          .    .    .           .          .       .         .       .     .          assert(!isEliminated(var(ps[i])));
          .    .    .           .          .       .         .       .     .  #endif
          .    .    .           .          .       .         .       .     .  
    909,537    0    0     909,537        926       2         0       0     0      int nclauses = clauses.size();
          .    .    .           .          .       .         .       .     .  
  1,819,074    0    0     909,537         21       0         0       0     0      if (use_rcheck && implied(ps))
    909,537    0    0           0          0       0         0       0     0          return true;
          .    .    .           .          .       .         .       .     .  
  4,547,685    0    0           0          0       0   909,537       0     0      if (!Solver::addClause_(ps))
          .    .    .           .          .       .         .       .     .          return false;
          .    .    .           .          .       .         .       .     .  
  2,788,257    3    3   1,232,598        247       0         0       0     0      if (!parsing && drup_file) {
          .    .    .           .          .       .         .       .     .  #ifdef BIN_DRUP
          .    .    .           .          .       .         .       .     .          binDRUP('a', ps, drup_file);
          .    .    .           .          .       .         .       .     .  #else
          .    .    .           .          .       .         .       .     .          for (int i = 0; i < ps.size(); i++)
          .    .    .           .          .       .         .       .     .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
          .    .    .           .          .       .         .       .     .          fprintf(drup_file, "0\n");
          .    .    .           .          .       .         .       .     .  #endif
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
  4,547,685    3    3   1,819,074        168       0         0       0     0      if (use_simplification && clauses.size() == nclauses + 1){
  3,356,016    2    2   1,678,008        140       0   839,004     134     0          CRef          cr = clauses.last();
          .    .    .           .          .       .         .       .     .          const Clause& c  = ca[cr];
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          // NOTE: the clause is added to the queue immediately and then
          .    .    .           .          .       .         .       .     .          // again during 'gatherTouchedClauses()'. If nothing happens
          .    .    .           .          .       .         .       .     .          // in between, it will only be checked once. Otherwise, it may
          .    .    .           .          .       .         .       .     .          // be checked twice unnecessarily. This is an unfortunate
          .    .    .           .          .       .         .       .     .          // consequence of how backward subsumption is used to mimic
          .    .    .           .          .       .         .       .     .          // forward subsumption.
          .    .    .           .          .       .         .       .     .          subsumption_queue.insert(cr);
 12,103,190    1    1   4,373,587         56       0         0       0     0          for (int i = 0; i < c.size(); i++){
          .    .    .           .          .       .         .       .     .              occurs[var(c[i])].push(cr);
  3,534,583    0    0   3,534,583  1,180,068     365         0       0     0              n_occ[toInt(c[i])]++;
  7,069,166    0    0   3,534,583        160       0 3,534,583 282,211 2,457              touched[var(c[i])] = 1;
  3,534,583    2    2   3,534,583        548       0         0       0     0              n_touched++;
          .    .    .           .          .       .         .       .     .              if (elim_heap.inHeap(var(c[i])))
          .    .    .           .          .       .         .       .     .                  elim_heap.increase(var(c[i]));
          .    .    .           .          .       .         .       .     .          }
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      return true;
  7,276,296    0    0   6,366,759        400       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  void SimpSolver::removeClause(CRef cr)
  2,624,571    1    1           0          0       0 2,041,333      61     0  {
          .    .    .           .          .       .         .       .     .      const Clause& c = ca[cr];
          .    .    .           .          .       .         .       .     .  
    583,238    0    0     291,619         78       0         0       0     0      if (use_simplification)
  5,261,952    0    0   2,339,357      3,320       0         0       0     0          for (int i = 0; i < c.size(); i++){
  1,023,869    0    0   1,023,869     92,463     288         0       0     0              n_occ[toInt(c[i])]--;
          .    .    .           .          .       .         .       .     .              updateElimHeap(var(c[i]));
          .    .    .           .          .       .         .       .     .              occurs.smudge(var(c[i]));
          .    .    .           .          .       .         .       .     .          }
          .    .    .           .          .       .         .       .     .  
    874,857    0    0     291,619          0       0         0       0     0      Solver::removeClause(cr);
  2,041,333    0    0   1,749,714          7       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  bool SimpSolver::strengthenClause(CRef cr, Lit l)
    188,430    2    2           0          0       0   113,058     208     1  {
          .    .    .           .          .       .         .       .     .      Clause& c = ca[cr];
          .    .    .           .          .       .         .       .     .      assert(decisionLevel() == 0);
          .    .    .           .          .       .         .       .     .      assert(use_simplification);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // FIX: this is too inefficient but would be nice to have (properly implemented)
          .    .    .           .          .       .         .       .     .      // if (!find(subsumption_queue, &c))
          .    .    .           .          .       .         .       .     .      subsumption_queue.insert(cr);
          .    .    .           .          .       .         .       .     .  
     56,529    0    0      18,843          3       0         0       0     0      if (drup_file){
          .    .    .           .          .       .         .       .     .  #ifdef BIN_DRUP
          .    .    .           .          .       .         .       .     .          binDRUP_strengthen(c, l, drup_file);
          .    .    .           .          .       .         .       .     .  #else
          .    .    .           .          .       .         .       .     .          for (int i = 0; i < c.size(); i++)
          .    .    .           .          .       .         .       .     .              if (c[i] != l) fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
          .    .    .           .          .       .         .       .     .          fprintf(drup_file, "0\n");
          .    .    .           .          .       .         .       .     .  #endif
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
     37,686    1    1      18,843          0       0         0       0     0      if (c.size() == 2){
         18    0    0           0          0       0         6       0     0          removeClause(cr);
          .    .    .           .          .       .         .       .     .          c.strengthen(l);
          .    .    .           .          .       .         .       .     .      }else{
          .    .    .           .          .       .         .       .     .          if (drup_file){
          .    .    .           .          .       .         .       .     .  #ifdef BIN_DRUP
          .    .    .           .          .       .         .       .     .              binDRUP('d', c, drup_file);
          .    .    .           .          .       .         .       .     .  #else
          .    .    .           .          .       .         .       .     .              fprintf(drup_file, "d ");
          .    .    .           .          .       .         .       .     .              for (int i = 0; i < c.size(); i++)
          .    .    .           .          .       .         .       .     .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
          .    .    .           .          .       .         .       .     .              fprintf(drup_file, "0\n");
          .    .    .           .          .       .         .       .     .  #endif
          .    .    .           .          .       .         .       .     .          }
          .    .    .           .          .       .         .       .     .  
     75,348    4    4           0          0       0    18,837     213     1          detachClause(cr, true);
          .    .    .           .          .       .         .       .     .          c.strengthen(l);
     56,511    4    3           0          0       0    18,837       0     0          attachClause(cr);
          .    .    .           .          .       .         .       .     .          remove(occurs[var(l)], cr);
     18,837    0    0      18,837        954     488         0       0     0          n_occ[toInt(l)]--;
          .    .    .           .          .       .         .       .     .          updateElimHeap(var(l));
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
     56,549    3    3           0          0       0         0       0     0      return c.size() == 1 ? enqueue(c[0]) && propagate() == CRef_Undef : true;
    150,744    0    0     131,901          2       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  // Returns FALSE if clause is always satisfied ('out_clause' should not be used).
          .    .    .           .          .       .         .       .     .  bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
  7,397,698    2    2           0          0       0 4,035,108       0     0  {
    672,518    1    1     672,518        208       0         0       0     0      merges++;
          .    .    .           .          .       .         .       .     .      out_clause.clear();
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      bool  ps_smallest = _ps.size() < _qs.size();
  5,998,069    0    0           0          0       0         0       0     0      const Clause& ps  =  ps_smallest ? _qs : _ps;
          .    .    .           .          .       .         .       .     .      const Clause& qs  =  ps_smallest ? _ps : _qs;
          .    .    .           .          .       .         .       .     .  
  4,535,086    0    0           0          0       0         0       0     0      for (int i = 0; i < qs.size(); i++){
  3,216,446    0    0           0          0       0         0       0     0          if (var(qs[i]) != v){
  8,315,148    1    1           0          0       0         0       0     0              for (int j = 0; j < ps.size(); j++)
 10,730,162    0    0           0          0       0         0       0     0                  if (var(ps[j]) == var(qs[i]))
  1,089,174    0    0           0          0       0         0       0     0                      if (ps[j] == ~qs[i])
    349,457    0    0           0          0       0         0       0     0                          return false;
          .    .    .           .          .       .         .       .     .                      else
          .    .    .           .          .       .         .       .     .                          goto next;
          .    .    .           .          .       .         .       .     .              out_clause.push(qs[i]);
          .    .    .           .          .       .         .       .     .          }
          .    .    .           .          .       .         .       .     .          next:;
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
  3,731,866    2    2           0          0       0         0       0     0      for (int i = 0; i < ps.size(); i++)
  2,439,622    0    0           0          0       0         0       0     0          if (var(ps[i]) != v)
          .    .    .           .          .       .         .       .     .              out_clause.push(ps[i]);
          .    .    .           .          .       .         .       .     .  
    323,061    0    0           0          0       0         0       0     0      return true;
  5,380,144    0    0   4,707,626          0       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  // Returns FALSE if clause is always satisfied.
          .    .    .           .          .       .         .       .     .  bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)
          .    .    .           .          .       .         .       .     .  {
 22,853,349    0    0   7,617,783          0       0 7,617,783       0     0      merges++;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      bool  ps_smallest = _ps.size() < _qs.size();
 45,217,614    1    1           0          0       0         0       0     0      const Clause& ps  =  ps_smallest ? _qs : _ps;
          .    .    .           .          .       .         .       .     .      const Clause& qs  =  ps_smallest ? _ps : _qs;
          .    .    .           .          .       .         .       .     .      const Lit*  __ps  = (const Lit*)ps;
          .    .    .           .          .       .         .       .     .      const Lit*  __qs  = (const Lit*)qs;
          .    .    .           .          .       .         .       .     .  
  7,617,783    0    0           0          0       0         0       0     0      size = ps.size()-1;
          .    .    .           .          .       .         .       .     .  
112,266,887    0    0           0          0       0         0       0     0      for (int i = 0; i < qs.size(); i++){
 73,222,068    1    1  24,407,356     69,742     172         0       0     0          if (var(__qs[i]) != v){
180,736,256    0    0           0          0       0         0       0     0              for (int j = 0; j < ps.size(); j++)
262,296,770    0    0  76,220,696    233,511   2,022         0       0     0                  if (var(__ps[j]) == var(__qs[i]))
 11,276,754    0    0           0          0       0         0       0     0                      if (__ps[j] == ~__qs[i])
          .    .    .           .          .       .         .       .     .                          return false;
          .    .    .           .          .       .         .       .     .                      else
          .    .    .           .          .       .         .       .     .                          goto next;
 28,294,864    0    0           0          0       0         0       0     0              size++;
          .    .    .           .          .       .         .       .     .          }
          .    .    .           .          .       .         .       .     .          next:;
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      return true;
          .    .    .           .          .       .         .       .     .  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
         48    1    1           0          0       0        36       0     0  void SimpSolver::gatherTouchedClauses()
          .    .    .           .          .       .         .       .     .  {
          2    0    0           0          0       0         0       0     0      if (n_touched == 0) return;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      int i,j;
  1,031,898    1    1           0          0       0         0       0     0      for (i = j = 0; i < subsumption_queue.size(); i++)
  1,031,886    0    0           0          0       0         0       0     0          if (ca[subsumption_queue[i]].mark() == 0)
          .    .    .           .          .       .         .       .     .              ca[subsumption_queue[i]].mark(2);
          .    .    .           .          .       .         .       .     .  
    864,992    1    1          20          7       1         0       0     0      for (i = 0; i < touched.size(); i++)
  1,297,404    0    0     864,936      6,762   2,602         0       0     0          if (touched[i]){
          .    .    .           .          .       .         .       .     .              const vec<CRef>& cs = occurs.lookup(i);
 11,052,740    0    0     186,358      1,199       0         0       0     0              for (j = 0; j < cs.size(); j++)
 18,425,780    0    0   7,370,312  2,719,593 200,753         0       0     0                  if (ca[cs[j]].mark() == 0){
          .    .    .           .          .       .         .       .     .                      subsumption_queue.insert(cs[j]);
          .    .    .           .          .       .         .       .     .                      ca[cs[j]].mark(2);
          .    .    .           .          .       .         .       .     .                  }
    386,800    2    2     193,400      1,143       0    96,700   1,423     0              touched[i] = 0;
          .    .    .           .          .       .         .       .     .          }
          .    .    .           .          .       .         .       .     .  
  3,072,821    3    3           0          0       0         0       0     0      for (i = 0; i < subsumption_queue.size(); i++)
  2,169,574    0    0           0          0       0         0       0     0          if (ca[subsumption_queue[i]].mark() == 2)
          .    .    .           .          .       .         .       .     .              ca[subsumption_queue[i]].mark(0);
          .    .    .           .          .       .         .       .     .  
          6    1    1           0          0       0         6       6     0      n_touched = 0;
         48    0    0          42         12       2         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  bool SimpSolver::implied(const vec<Lit>& c)
          .    .    .           .          .       .         .       .     .  {
          .    .    .           .          .       .         .       .     .      assert(decisionLevel() == 0);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      trail_lim.push(trail.size());
          .    .    .           .          .       .         .       .     .      for (int i = 0; i < c.size(); i++)
-- line 350 ----------------------------------------
-- line 359 ----------------------------------------
          .    .    .           .          .       .         .       .     .      bool result = propagate() != CRef_Undef;
          .    .    .           .          .       .         .       .     .      cancelUntil(0);
          .    .    .           .          .       .         .       .     .      return result;
          .    .    .           .          .       .         .       .     .  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  // Backward subsumption + backward subsumption resolution
          .    .    .           .          .       .         .       .     .  bool SimpSolver::backwardSubsumptionCheck(bool verbose)
    208,665    1    1           0          0       0   162,295       0     0  {
  1,454,341    0    0   1,407,971          2       0    23,185       0     0      int cnt = 0;
     23,185    1    1           0          0       0    23,185       0     0      int subsumed = 0;
     23,185    0    0           0          0       0    23,185       0     0      int deleted_literals = 0;
          .    .    .           .          .       .         .       .     .      assert(decisionLevel() == 0);
          .    .    .           .          .       .         .       .     .  
  2,992,042    1    1      55,464        459       1         0       0     0      while (subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()){
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          // Empty subsumption queue and return immediately on user-interrupt:
 11,427,169    1    1   5,715,858      5,690       1         0       0     0          if (asynch_interrupt){
          .    .    .           .          .       .         .       .     .              subsumption_queue.clear();
          .    .    .           .          .       .         .       .     .              bwdsub_assigns = trail.size();
          .    .    .           .          .       .         .       .     .              break; }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          // Check top-level assignments by creating a dummy clause and placing it in the queue:
     13,641    0    0       4,547          0       0         0       0     0          if (subsumption_queue.size() == 0 && bwdsub_assigns < trail.size()){
     18,188    1    1       9,094        479     284     4,547       0     0              Lit l = trail[bwdsub_assigns++];
     13,641    0    0       4,547          0       0     4,547       0     0              ca[bwdsub_tmpunit][0] = l;
          .    .    .           .          .       .         .       .     .              ca[bwdsub_tmpunit].calcAbstraction();
          .    .    .           .          .       .         .       .     .              subsumption_queue.insert(bwdsub_tmpunit); }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          CRef    cr = subsumption_queue.peek(); subsumption_queue.pop();
          .    .    .           .          .       .         .       .     .          Clause& c  = ca[cr];
          .    .    .           .          .       .         .       .     .  
 14,476,943    2    2   1,431,238    207,218       1         0       0     0          if (c.mark()) continue;
          .    .    .           .          .       .         .       .     .  
  4,892,072    0    0   2,446,036          6       1         0       0     0          if (verbose && verbosity >= 2 && cnt++ % 1000 == 0)
          .    .    .           .          .       .         .       .     .              printf("c subsumption left: %10d (%10d subsumed, %10d deleted literals)\r", subsumption_queue.size(), subsumed, deleted_literals);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          assert(c.size() > 1 || value(c[0]) == l_True);    // Unit-clauses should have been propagated before this point.
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          // Find best variable to scan:
          .    .    .           .          .       .         .       .     .          Var best = var(c[0]);
 17,400,268    0    0           0          0       0         0       0     0          for (int i = 1; i < c.size(); i++)
 16,514,618    0    0   4,554,870  1,273,251   2,379         0       0     0              if (occurs[var(c[i])].size() < occurs[best].size())
          .    .    .           .          .       .         .       .     .                  best = var(c[i]);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          // Search all candidates:
          .    .    .           .          .       .         .       .     .          vec<CRef>& _cs = occurs.lookup(best);
  1,384,786    0    0   1,384,786          0       0         0       0     0          CRef*       cs = (CRef*)_cs;
          .    .    .           .          .       .         .       .     .  
 82,216,861    1    1           0          0       0 1,381,249       6     1          for (int j = 0; j < _cs.size(); j++)
 76,684,791    0    0  37,651,771          0       0 1,381,249       0     0              if (c.mark())
          .    .    .           .          .       .         .       .     .                  break;
481,191,581    1    1 147,846,604 14,564,208  28,269         0       0     0              else if (!ca[cs[j]].mark() &&  cs[j] != cr && (subsumption_lim == -1 || ca[cs[j]].size() < subsumption_lim)){
          .    .    .           .          .       .         .       .     .                  Lit l = c.subsumes(ca[cs[j]]);
          .    .    .           .          .       .         .       .     .  
     38,922    0    0           0          0       0         0       0     0                  if (l == lit_Undef)
      4,326    0    0       1,854          1       0       618       0     0                      subsumed++, removeClause(cs[j]);
     37,686    0    0           0          0       0         0       0     0                  else if (l != lit_Error){
     18,843    0    0      18,843          0       0         0       0     0                      deleted_literals++;
          .    .    .           .          .       .         .       .     .  
     75,372    0    0           0          0       0    18,843       0     0                      if (!strengthenClause(cs[j], ~l))
          .    .    .           .          .       .         .       .     .                          return false;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .                      // Did current candidate get deleted from cs? Then check candidate at index j again:
          .    .    .           .          .       .         .       .     .                      if (var(l) == best)
          .    .    .           .          .       .         .       .     .                          j--;
          .    .    .           .          .       .         .       .     .                  }
          .    .    .           .          .       .         .       .     .              }
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
     23,185    0    0           0          0       0         0       0     0      return true;
    185,480    1    1     162,295         10       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  bool SimpSolver::asymm(Var v, CRef cr)
          .    .    .           .          .       .         .       .     .  {
          .    .    .           .          .       .         .       .     .      Clause& c = ca[cr];
          .    .    .           .          .       .         .       .     .      assert(decisionLevel() == 0);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      if (c.mark() || satisfied(c)) return true;
-- line 438 ----------------------------------------
-- line 478 ----------------------------------------
          .    .    .           .          .       .         .       .     .  static void mkElimClause(vec<uint32_t>& elimclauses, Lit x)
          .    .    .           .          .       .         .       .     .  {
          .    .    .           .          .       .         .       .     .      elimclauses.push(toInt(x));
          .    .    .           .          .       .         .       .     .      elimclauses.push(1);
          .    .    .           .          .       .         .       .     .  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  static void mkElimClause(vec<uint32_t>& elimclauses, Var v, Clause& c)
    891,968   24    2           0          0       0   668,976       0     0  {
    111,496    0    0     111,496          0       0         0       0     0      int first = elimclauses.size();
    640,251    0    0     417,259          0       0         0       0     0      int v_pos = -1;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Copy clause to elimclauses-vector. Remember position where the
          .    .    .           .          .       .         .       .     .      // variable 'v' occurs:
  1,809,305    0    0     305,779          0       0         0       0     0      for (int i = 0; i < c.size(); i++){
    834,550   10    2     417,275          3       0         0       0     0          elimclauses.push(toInt(c[i]));
          .    .    .           .          .       .         .       .     .          if (var(c[i]) == v)
          .    .    .           .          .       .         .       .     .              v_pos = i + first;
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .      assert(v_pos != -1);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Swap the first literal with the 'v' literal, so that the literal
          .    .    .           .          .       .         .       .     .      // containing 'v' will occur first in the clause:
    111,496    0    0     111,496          0       0         0       0     0      uint32_t tmp = elimclauses[v_pos];
    222,992    0    0     111,496          0       0   111,496       0     0      elimclauses[v_pos] = elimclauses[first];
    111,496    0    0           0          0       0   111,496       0     0      elimclauses[first] = tmp;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Store the length of the clause last:
          .    .    .           .          .       .         .       .     .      elimclauses.push(c.size());
    891,968    0    0     780,472         11       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  bool SimpSolver::eliminateVar(Var v)
  1,332,930    1    1           0          0       0   799,758       1     0  {
          .    .    .           .          .       .         .       .     .      assert(!frozen[v]);
          .    .    .           .          .       .         .       .     .      assert(!isEliminated(v));
          .    .    .           .          .       .         .       .     .      assert(value(v) == l_Undef);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Split the occurrences into positive and negative:
          .    .    .           .          .       .         .       .     .      //
          .    .    .           .          .       .         .       .     .      const vec<CRef>& cls = occurs.lookup(v);
          .    .    .           .          .       .         .       .     .      vec<CRef>        pos, neg;
 14,088,534    1    1   9,303,494    104,804  17,789         0       0     0      for (int i = 0; i < cls.size(); i++)
  4,518,454    1    1           0          0       0         0       0     0          (find(ca[cls[i]], mkLit(v)) ? pos : neg).push(cls[i]);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Check wether the increase in number of clauses stays within the allowed ('grow'). Moreover, no
          .    .    .           .          .       .         .       .     .      // clause must exceed the limit on the maximal clause size (if it is set):
          .    .    .           .          .       .         .       .     .      //
    133,293    0    0           0          0       0   133,293       0     0      int cnt         = 0;
          .    .    .           .          .       .         .       .     .      int clause_size = 0;
          .    .    .           .          .       .         .       .     .  
  1,396,092    1    1     698,046          0       0         0       0     0      for (int i = 0; i < pos.size(); i++)
 32,449,627    0    0   9,045,456          0       0   266,586       0     0          for (int j = 0; j < neg.size(); j++)
 20,921,853    1    1  10,260,987          0       0   399,879       0     0              if (merge(ca[pos[i]], ca[neg[j]], v, clause_size) && 
 54,821,405    1    1  20,145,274          0       0         0       0     0                  (++cnt > cls.size() + grow || (clause_lim != -1 && clause_size > clause_lim)))
          .    .    .           .          .       .         .       .     .                  return true;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Delete and store old clauses:
     69,537    0    0      46,358          0       0    23,179       0     0      eliminated[v] = true;
          .    .    .           .          .       .         .       .     .      setDecisionVar(v, false);
     23,179    0    0      23,179          0       0         0       0     0      eliminated_vars++;
          .    .    .           .          .       .         .       .     .  
    115,895    1    1      46,358          0       0         0       0     0      if (pos.size() > neg.size()){
     25,733    0    0       1,056          1       0         0       0     0          for (int i = 0; i < neg.size(); i++)
      5,280    0    0       1,056          0       0     1,056       0     0              mkElimClause(elimclauses, v, ca[neg[i]]);
          .    .    .           .          .       .         .       .     .          mkElimClause(elimclauses, mkLit(v));
          .    .    .           .          .       .         .       .     .      }else{
    266,796    1    1     110,440         10       0         0       0     0          for (int i = 0; i < pos.size(); i++)
    552,200    0    0     110,440          0       0   110,440       0     0              mkElimClause(elimclauses, v, ca[pos[i]]);
          .    .    .           .          .       .         .       .     .          mkElimClause(elimclauses, ~mkLit(v));
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Produce clauses in cross product:
     23,179    1    1           0          0       0         0       0     0      vec<Lit>& resolvent = add_tmp;
    451,055    0    0      46,358          0       0         0       0     0      for (int i = 0; i < pos.size(); i++)
  3,025,232    0    0     672,518        378       0         0       0     0          for (int j = 0; j < neg.size(); j++)
  7,041,807    1    1   1,368,215          4       0 1,018,758       5     0              if (merge(ca[pos[i]], ca[neg[j]], v, resolvent) && !addClause_(resolvent))
          .    .    .           .          .       .         .       .     .                  return false;
          .    .    .           .          .       .         .       .     .  
    605,299    0    0     291,060      2,215       0         0       0     0      for (int i = 0; i < cls.size(); i++)
  1,468,212    1    1     734,106      2,509       0   244,702       0     0          removeClause(cls[i]); 
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Free occurs list for this variable:
          .    .    .           .          .       .         .       .     .      occurs[v].clear(true);
          .    .    .           .          .       .         .       .     .      
          .    .    .           .          .       .         .       .     .      // Free watchers lists for this variable, if possible:
          .    .    .           .          .       .         .       .     .      watches_bin[ mkLit(v)].clear(true);
          .    .    .           .          .       .         .       .     .      watches_bin[~mkLit(v)].clear(true);
          .    .    .           .          .       .         .       .     .      watches[ mkLit(v)].clear(true);
          .    .    .           .          .       .         .       .     .      watches[~mkLit(v)].clear(true);
          .    .    .           .          .       .         .       .     .  
     92,716    0    0           0          0       0    23,179       0     0      return backwardSubsumptionCheck();
  1,066,344    0    0     933,051      4,063       1         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  bool SimpSolver::substitute(Var v, Lit x)
          .    .    .           .          .       .         .       .     .  {
          .    .    .           .          .       .         .       .     .      assert(!frozen[v]);
          .    .    .           .          .       .         .       .     .      assert(!isEliminated(v));
          .    .    .           .          .       .         .       .     .      assert(value(v) == l_Undef);
          .    .    .           .          .       .         .       .     .  
-- line 579 ----------------------------------------
-- line 603 ----------------------------------------
          .    .    .           .          .       .         .       .     .  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  void SimpSolver::extendModel()
          .    .    .           .          .       .         .       .     .  {
          .    .    .           .          .       .         .       .     .      int i, j;
          .    .    .           .          .       .         .       .     .      Lit x;
          .    .    .           .          .       .         .       .     .  
    538,704    1    1           1          1       1         0       0     0      for (i = elimclauses.size()-1; i > 0; i -= j){
  2,137,601    1    1     269,352     28,977  28,976         0       0     0          for (j = elimclauses[i--]; j > 1; j--, i--)
    629,965    0    0      87,872      6,970   6,970         0       0     0              if (modelValue(toLit(elimclauses[i])) != l_False)
          .    .    .           .          .       .         .       .     .                  goto next;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          x = toLit(elimclauses[i]);
     34,839    0    0           0          0       0    34,839   1,298     0          model[var(x)] = lbool(!sign(x));
          .    .    .           .          .       .         .       .     .      next:;
          .    .    .           .          .       .         .       .     .      }
          1    0    0           1          1       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  // Almost duplicate of Solver::removeSatisfied. Didn't want to make the base method 'virtual'.
          .    .    .           .          .       .         .       .     .  void SimpSolver::removeSatisfied()
    118,890    1    1           0          0       0         8       0     0  {
          .    .    .           .          .       .         .       .     .      int i, j;
  1,988,516    1    1           2          1       0         0       0     0      for (i = j = 0; i < clauses.size(); i++){
  1,988,510    0    0     994,255          0       0         0       0     0          const Clause& c = ca[clauses[i]];
  1,988,510    0    0     994,255    139,459  56,030         0       0     0          if (c.mark() == 0)
  3,924,448    0    0           0          0       0   981,112       2     0              if (satisfied(c))
  1,212,577    2    2   1,073,698          6       0    46,293       0     0                  removeClause(clauses[i]);
          .    .    .           .          .       .         .       .     .              else
  5,608,914    0    0   1,869,638          0       0   934,819  58,835     0                  clauses[j++] = clauses[i];
          .    .    .           .          .       .         .       .     .      }
          2    0    0           0          0       0         0       0     0      clauses.shrink(i - j);
         12    1    1          10          2       0         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  // The technique and code are by the courtesy of the GlueMiniSat team. Thank you!
          .    .    .           .          .       .         .       .     .  // It helps solving certain types of huge problems tremendously.
          .    .    .           .          .       .         .       .     .  bool SimpSolver::eliminate(bool turn_off_elim)
          9    1    1           0          0       0         7       1     1  {
          1    0    0           0          0       0         0       0     0      bool res = true;
          .    .    .           .          .       .         .       .     .      int iter = 0;
          .    .    .           .          .       .         .       .     .      int n_cls, n_cls_init, n_vars;
          .    .    .           .          .       .         .       .     .  
          3    0    0           1          0       0         0       0     0      if (nVars() == 0) goto cleanup; // User disabling preprocessing.
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Get an initial number of clauses (more accurately).
          5    2    2           1          0       0         1       0     0      if (trail.size() != 0) removeSatisfied();
          .    .    .           .          .       .         .       .     .      n_cls_init = nClauses();
          .    .    .           .          .       .         .       .     .  
          3    0    0           0          0       0         1       0     0      res = eliminate_(); // The first, usual variable elimination of MiniSat.
          2    0    0           0          0       0         0       0     0      if (!res) goto cleanup;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      n_cls  = nClauses();
          .    .    .           .          .       .         .       .     .      n_vars = nFreeVars();
          .    .    .           .          .       .         .       .     .  
          6    0    0           1          1       0         1       0     0      printf("c Reduced to %d vars, %d cls (grow=%d)\n", n_vars, n_cls, grow);
          .    .    .           .          .       .         .       .     .  
          9    1    1           1          0       0         0       0     0      if ((double)n_cls / n_vars >= 10 || n_vars < 10000){
          .    .    .           .          .       .         .       .     .          printf("c No iterative elimination performed. (vars=%d, c/v ratio=%.1f)\n", n_vars, (double)n_cls / n_vars);
          .    .    .           .          .       .         .       .     .          goto cleanup; }
          .    .    .           .          .       .         .       .     .  
          4    0    0           1          0       0         1       0     0      grow = grow ? grow * 2 : 8;
          .    .    .           .          .       .         .       .     .      for (; grow < 10000; grow *= 2){
          .    .    .           .          .       .         .       .     .          // Rebuild elimination variable heap.
    930,346    0    0           1          0       0         2       0     0          for (int i = 0; i < clauses.size(); i++){
    465,169    0    0     465,169          0       0         0       0     0              const Clause& c = ca[clauses[i]];
  6,793,767    0    0   3,164,299          0       0         0       0     0              for (int j = 0; j < c.size(); j++)
          .    .    .           .          .       .         .       .     .                  if (!elim_heap.inHeap(var(c[j])))
          .    .    .           .          .       .         .       .     .                      elim_heap.insert(var(c[j]));
          .    .    .           .          .       .         .       .     .                  else
          .    .    .           .          .       .         .       .     .                      elim_heap.update(var(c[j])); }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          int n_cls_last = nClauses();
          .    .    .           .          .       .         .       .     .          int n_vars_last = nFreeVars();
          .    .    .           .          .       .         .       .     .  
          3    1    1           0          0       0         1       0     0          res = eliminate_();
          4    1    1           0          0       0         0       0     0          if (!res || n_vars_last == nFreeVars()) break;
          .    .    .           .          .       .         .       .     .          iter++;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          int n_cls_now  = nClauses();
          .    .    .           .          .       .         .       .     .          int n_vars_now = nFreeVars();
          .    .    .           .          .       .         .       .     .  
          7    1    1           1          1       1         1       0     0          double cl_inc_rate  = (double)n_cls_now   / n_cls_last;
          6    0    0           0          0       0         1       0     0          double var_dec_rate = (double)n_vars_last / n_vars_now;
          .    .    .           .          .       .         .       .     .  
          6    0    0           1          1       1         2       0     0          printf("c Reduced to %d vars, %d cls (grow=%d)\n", n_vars_now, n_cls_now, grow);
          5    1    1           2          0       0         1       0     0          printf("c cl_inc_rate=%.3f, var_dec_rate=%.3f\n", cl_inc_rate, var_dec_rate);
          .    .    .           .          .       .         .       .     .  
          2    0    0           1          0       0         0       0     0          if (n_cls_now > n_cls_init || cl_inc_rate > var_dec_rate) break;
          .    .    .           .          .       .         .       .     .      }
          4    1    1           1          0       0         1       0     0      printf("c No. effective iterative eliminations: %d\n", iter);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  cleanup:
          .    .    .           .          .       .         .       .     .      touched  .clear(true);
          .    .    .           .          .       .         .       .     .      occurs   .clear(true);
          .    .    .           .          .       .         .       .     .      n_occ    .clear(true);
          .    .    .           .          .       .         .       .     .      elim_heap.clear(true);
          1    0    0           0          0       0         0       0     0      subsumption_queue.clear(true);
          .    .    .           .          .       .         .       .     .  
          1    0    0           0          0       0         1       1     0      use_simplification    = false;
          1    0    0           0          0       0         1       1     1      remove_satisfied      = true;
          1    0    0           0          0       0         1       1     1      ca.extra_clause_field = false;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Force full cleanup (this is safe and desirable since it only happens once):
          2    0    0           0          0       0         1       0     0      rebuildOrderHeap();
          3    0    0           2          2       2         1       0     0      garbageCollect();
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      return res;
     23,599    1    1           7          2       2         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  bool SimpSolver::eliminate_()
         16    1    1           0          0       0        12       1     0  {
          6    0    0           0          0       0         2       1     0      if (!simplify())
          .    .    .           .          .       .         .       .     .          return false;
          4    0    0           2          2       0         0       0     0      else if (!use_simplification)
          .    .    .           .          .       .         .       .     .          return true;
          .    .    .           .          .       .         .       .     .  
          6    0    0           2          0       0         2       2     0      int trail_size_last = trail.size();
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Main simplification loop:
          .    .    .           .          .       .         .       .     .      //
         57    3    3          18          9       2         6       0     0      while (n_touched > 0 || bwdsub_assigns < trail.size() || elim_heap.size() > 0){
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          gatherTouchedClauses();
          .    .    .           .          .       .         .       .     .          // printf("  ## (time = %6.2f s) BWD-SUB: queue = %d, trail = %d\n", cpuTime(), subsumption_queue.size(), trail.size() - bwdsub_assigns);
         29    0    0           2          0       0         0       0     0          if ((subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()) && 
         18    2    2           0          0       0         6       0     0              !backwardSubsumptionCheck(true)){
          .    .    .           .          .       .         .       .     .              ok = false; goto cleanup; }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          // Empty elim_heap and return immediately on user-interrupt:
         35    0    0          14          2       0         7       0     0          if (asynch_interrupt){
          .    .    .           .          .       .         .       .     .              assert(bwdsub_assigns == trail.size());
          .    .    .           .          .       .         .       .     .              assert(subsumption_queue.size() == 0);
          .    .    .           .          .       .         .       .     .              assert(n_touched == 0);
          .    .    .           .          .       .         .       .     .              elim_heap.clear();
          .    .    .           .          .       .         .       .     .              goto cleanup; }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          // printf("  ## (time = %6.2f s) ELIM: vars = %d\n", cpuTime(), elim_heap.size());
    689,210    0    0     275,674      9,456       1   137,841       6     1          for (int cnt = 0; !elim_heap.empty(); cnt++){
          .    .    .           .          .       .         .       .     .              Var elim = elim_heap.removeMin();
          .    .    .           .          .       .         .       .     .              
    275,680    4    3     137,840          0       0         0       0     0              if (asynch_interrupt) break;
          .    .    .           .          .       .         .       .     .  
    551,360    0    0     275,680    193,748   5,353         0       0     0              if (isEliminated(elim) || value(elim) != l_Undef) continue;
          .    .    .           .          .       .         .       .     .  
    266,586    0    0     133,293      2,273       0         0       0     0              if (verbosity >= 2 && cnt % 100 == 0)
          .    .    .           .          .       .         .       .     .                  printf("c elimination left: %10d\r", elim_heap.size());
          .    .    .           .          .       .         .       .     .  
    266,586    1    1     133,293          7       1         0       0     0              if (use_asymm){
          .    .    .           .          .       .         .       .     .                  // Temporarily freeze variable. Otherwise, it would immediately end up on the queue again:
          .    .    .           .          .       .         .       .     .                  bool was_frozen = frozen[elim];
          .    .    .           .          .       .         .       .     .                  frozen[elim] = true;
          .    .    .           .          .       .         .       .     .                  if (!asymmVar(elim)){
          .    .    .           .          .       .         .       .     .                      ok = false; goto cleanup; }
          .    .    .           .          .       .         .       .     .                  frozen[elim] = was_frozen; }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .              // At this point, the variable may have been set by assymetric branching, so check it
          .    .    .           .          .       .         .       .     .              // again. Also, don't eliminate frozen variables:
  1,599,516   10    1     666,465     98,705   3,619   133,293       0     0              if (use_elim && value(elim) == l_Undef && !frozen[elim] && !eliminateVar(elim)){
          .    .    .           .          .       .         .       .     .                  ok = false; goto cleanup; }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .              checkGarbage(simp_garbage_frac);
          .    .    .           .          .       .         .       .     .          }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .          assert(subsumption_queue.size() == 0);
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .   cleanup:
          .    .    .           .          .       .         .       .     .      // To get an accurate number of clauses.
          4    2    2           2          0       0         0       0     0      if (trail_size_last != trail.size())
          2    0    0           0          0       0         1       0     0          removeSatisfied();
          .    .    .           .          .       .         .       .     .      else{
          .    .    .           .          .       .         .       .     .          int i,j;
  1,559,141    1    1           1          1       0         0       0     0          for (i = j = 0; i < clauses.size(); i++)
  3,582,639    1    1   1,559,137    459,746 260,972         0       0     0              if (ca[clauses[i]].mark() == 0)
  3,284,309    0    0     547,385          0       0   547,385  34,204     0                  clauses[j++] = clauses[i];
          1    0    0           0          0       0         0       0     0          clauses.shrink(i - j);
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .      checkGarbage();
          .    .    .           .          .       .         .       .     .  
         12    1    1           4          3       1         0       0     0      if (verbosity >= 1 && elimclauses.size() > 0)
          8    0    0           2          2       2         2       0     0          printf("c |  Eliminated clauses:     %10.2f Mb                                      |\n", 
          6    0    0           0          0       0         0       0     0                 double(elimclauses.size() * sizeof(uint32_t)) / (1024*1024));
          .    .    .           .          .       .         .       .     .  
          2    0    0           2          0       0         0       0     0      return ok;
         16    0    0          14          4       3         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  //=================================================================================================
          .    .    .           .          .       .         .       .     .  // Garbage Collection methods:
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          9    1    1           0          0       0         7       0     0  void SimpSolver::relocAll(ClauseAllocator& to)
          .    .    .           .          .       .         .       .     .  {
         30   14   14          15         15       0         0       0     0      if (!use_simplification) return;
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // All occurs lists:
          .    .    .           .          .       .         .       .     .      //
          .    .    .           .          .       .         .       .     .      occurs.cleanAll();
    144,164    2    2           1          0       0         3       0     0      for (int i = 0; i < nVars(); i++){
          .    .    .           .          .       .         .       .     .          vec<CRef>& cs = occurs[i];
 10,449,854    1    1   5,188,888     18,824   9,989    44,352       0     0          for (int j = 0; j < cs.size(); j++)
          .    .    .           .          .       .         .       .     .              ca.reloc(cs[j], to);
          .    .    .           .          .       .         .       .     .      }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Subsumption queue:
          .    .    .           .          .       .         .       .     .      //
          7    1    1           2          0       0         0       0     0      for (int i = 0; i < subsumption_queue.size(); i++)
          .    .    .           .          .       .         .       .     .          ca.reloc(subsumption_queue[i], to);
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .      // Temporary clause:
          .    .    .           .          .       .         .       .     .      //
          .    .    .           .          .       .         .       .     .      ca.reloc(bwdsub_tmpunit, to);
          8    0    0           7          1       1         0       0     0  }
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  
          .    .    .           .          .       .         .       .     .  void SimpSolver::garbageCollect()
         45   14   14           0          0       0        15       0     0  {
          .    .    .           .          .       .         .       .     .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
          .    .    .           .          .       .         .       .     .      // is not precise but should avoid some unnecessary reallocations for the new region:
         30    0    0          30          1       0         0       0     0      ClauseAllocator to(ca.size() - ca.wasted()); 
          .    .    .           .          .       .         .       .     .  
         30    0    0          15          1       0        15       0     0      to.extra_clause_field = ca.extra_clause_field; // NOTE: this is important to keep (or lose) the extra fields.
          .    .    .           .          .       .         .       .     .      relocAll(to);
         45    0    0           0          0       0        15       0     0      Solver::relocAll(to);
         30    0    0          15         15      15         0       0     0      if (verbosity >= 2)
          .    .    .           .          .       .         .       .     .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
          .    .    .           .          .       .         .       .     .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
          .    .    .           .          .       .         .       .     .      to.moveTo(ca);
        106   19   19          48          3       2        25       0     0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/8/cmath
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr    DLmr Dw          D1mw    DLmw 

-- line 410 ----------------------------------------
          .    .    .          .       .    .           .       .    .  #endif
          .    .    .          .       .    .           .       .    .  
          .    .    .          .       .    .           .       .    .    template<typename _Tp, typename _Up>
          .    .    .          .       .    .           .       .    .      inline _GLIBCXX_CONSTEXPR
          .    .    .          .       .    .           .       .    .      typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
          .    .    .          .       .    .           .       .    .      pow(_Tp __x, _Up __y)
          .    .    .          .       .    .           .       .    .      {
          .    .    .          .       .    .           .       .    .        typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
264,571,488   10    7 39,214,676 371,424   10 101,547,937 330,447    0        return pow(__type(__x), __type(__y));
          .    .    .          .       .    .           .       .    .      }
          .    .    .          .       .    .           .       .    .  
          .    .    .          .       .    .           .       .    .    using ::sin;
          .    .    .          .       .    .           .       .    .  
          .    .    .          .       .    .           .       .    .  #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
          .    .    .          .       .    .           .       .    .    inline _GLIBCXX_CONSTEXPR float
          .    .    .          .       .    .           .       .    .    sin(float __x)
          .    .    .          .       .    .           .       .    .    { return __builtin_sinf(__x); }
-- line 426 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr      DLmr   Dw        D1mw   DLmw 

-- line 36 ----------------------------------------
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  template <class T, class LessThan>
         .    .    .          .         .      .         .      .    .  void selectionSort(T* array, int size, LessThan lt)
         .    .    .          .         .      .         .      .    .  {
         .    .    .          .         .      .         .      .    .      int     i, j, best_i;
         .    .    .          .         .      .         .      .    .      T       tmp;
         .    .    .          .         .      .         .      .    .  
19,776,270   53   27  3,826,802         0      0   100,204    813    0      for (i = 0; i < size-1; i++){
         .    .    .          .         .      .         .      .    .          best_i = i;
46,320,044  128   73  7,544,183        56      0         0      0    0          for (j = i+1; j < size; j++){
89,772,207  276  160  4,680,599        51      0         0      0    0              if (lt(array[j], array[best_i]))
         .    .    .          .         .      .         .      .    .                  best_i = j;
         .    .    .          .         .      .         .      .    .          }
18,284,363    0    0  2,977,155         0      0 7,653,604      0    0          tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
         .    .    .          .         .      .         .      .    .      }
         .    .    .          .         .      .         .      .    .  }
         .    .    .          .         .      .         .      .    .  template <class T> static inline void selectionSort(T* array, int size) {
         .    .    .          .         .      .         .      .    .      selectionSort(array, size, LessThan_default<T>()); }
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  template <class T, class LessThan>
 6,520,712   61   31          0         0      0 4,382,591 23,146  228  void sort(T* array, int size, LessThan lt)
         .    .    .          .         .      .         .      .    .  {
 4,177,004   41   24          0         0      0         0      0    0      if (size <= 15)
         .    .    .          .         .      .         .      .    .          selectionSort(array, size, lt);
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .      else{
   531,550    0    0    106,310     6,836     14         0      0    0          T           pivot = array[size / 2];
         .    .    .          .         .      .         .      .    .          T           tmp;
   106,310    0    0          0         0      0         0      0    0          int         i = -1;
         .    .    .          .         .      .         .      .    .          int         j = size;
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .          for(;;){
42,612,776   39   22 11,981,796 3,382,439 58,484         0      0    0              do i++; while(lt(array[i], pivot));
55,788,088    4    2 13,947,022 2,913,075 20,133         0      0    0              do j--; while(lt(pivot, array[j]));
         .    .    .          .         .      .         .      .    .  
 4,374,052    0    0          0         0      0         0      0    0              if (i >= j) break;
         .    .    .          .         .      .         .      .    .  
15,930,608   35   21          0         0      0 4,161,432  1,652    0              tmp = array[i]; array[i] = array[j]; array[j] = tmp;
         .    .    .          .         .      .         .      .    .          }
         .    .    .          .         .      .         .      .    .  
   318,930    0    0          0         0      0   106,310 11,050   58          sort(array    , i     , lt);
   106,310    0    0          0         0      0         0      0    0          sort(&array[i], size-i, lt);
         .    .    .          .         .      .         .      .    .      }
 6,308,014    0    0  5,292,128     2,986      0         0      0    0  }
         .    .    .          .         .      .         .      .    .  template <class T> static inline void sort(T* array, int size) {
         .    .    .          .         .      .         .      .    .      sort(array, size, LessThan_default<T>()); }
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  //=================================================================================================
         .    .    .          .         .      .         .      .    .  // For 'vec's:
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {
 2,728,728   39   22  1,819,152        14      0   909,576     32    0      sort((T*)v, v.size(), lt); }
         .    .    .          .         .      .         .      .    .  template <class T> void sort(vec<T>& v) {
         .    .    .          .         .      .         .      .    .      sort(v, LessThan_default<T>()); }
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  //=================================================================================================
         .    .    .          .         .      .         .      .    .  }
         .    .    .          .         .      .         .      .    .  
         .    .    .          .         .      .         .      .    .  #endif
-- line 98 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir            I1mr   ILmr Dr          D1mr        DLmr    Dw          D1mw       DLmw   

-- line 31 ----------------------------------------
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  template<class Comp>
            .      .    .           .           .       .           .          .      .  class Heap {
            .      .    .           .           .       .           .          .      .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
            .      .    .           .           .       .           .          .      .      vec<int> heap;     // Heap of integers
            .      .    .           .           .       .           .          .      .      vec<int> indices;  // Each integers position (index) in the Heap
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .      // Index "traversal" functions
  411,706,036     12   11           0           0       0           0          0      0      static inline int left  (int i) { return i*2+1; }
1,851,211,968     18   14 735,607,106 195,083,371 146,320           0          0      0      static inline int right (int i) { return (i+1)*2; }
  345,395,764     11   11  22,461,510           0       0           0          0      0      static inline int parent(int i) { return (i-1) >> 1; }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
   44,923,020     17   11           0           0       0  44,923,020          0      0      void percolateUp(int i)
            .      .    .           .           .       .           .          .      .      {
  125,118,648      0    0  83,381,182   8,661,337   7,153  19,275,956          0      0          int x  = heap[i];
            .      .    .           .           .       .           .          .      .          int p  = parent(i);
            .      .    .           .           .       .           .          .      .          
1,067,054,564     71   24 340,943,076  65,655,411  34,104   4,368,512          0      0          while (i != 0 && lt(x, heap[p])){
  111,388,574     30   15           0           0       0 111,388,574          0      0              heap[i]          = heap[p];
  111,388,574      0    0           0           0       0 111,388,574 35,756,607 19,157              indices[heap[p]] = i;
            .      .    .           .           .       .           .          .      .              i                = p;
  159,819,604      0    0           0           0       0           0          0      0              p                = parent(p);
            .      .    .           .           .       .           .          .      .          }
   60,919,672     14    6  10,888,495           0       0  50,031,177          0      0          heap   [i] = x;
   80,058,780      4    4  10,076,763           1       0  50,875,819          5      0          indices[x] = i;
   94,942,474      0    0  67,384,530           0       0           0          0      0      }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
  559,884,710      0    0  79,983,530           0       0 479,901,180          0      0      void percolateDown(int i)
            .      .    .           .           .       .           .          .      .      {
  311,809,634  8,419   49 193,610,310  53,067,595  11,799 117,698,870          0      0          int x = heap[i];
1,773,324,190 26,601   57 394,723,073          14       0           0          0      0          while (left(i) < heap.size()){
2,726,943,177     12   12 365,632,221   9,875,169   3,266           0          0      0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
  899,540,609     18   15           0           0       0           0          0      0              if (!lt(heap[child], x)) break;
  299,480,767      0    0           0           0       0 299,480,767          0      0              heap[i]          = heap[child];
  299,774,542      0    0     293,775           0       0 299,480,767 78,120,917 19,133              indices[heap[i]] = i;
  272,357,398      0    0           0           0       0           0          0      0              i                = child;
            .      .    .           .           .       .           .          .      .          }
  220,203,879     18   16 110,111,349          13       0 110,092,530          0      0          heap   [i] = x;
  160,603,168      4    3  24,436,342           0       0 110,092,530     48,890      0          indices[x] = i;
  566,203,970      0    0 559,884,710           0       0           0          0      0      }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .    public:
            .      .    .           .           .       .           .          .      .      Heap(const Comp& c) : lt(c) { }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .      int  size      ()          const { return heap.size(); }
   16,467,391     12    2  16,467,391     274,520      19           0          0      0      bool empty     ()          const { return heap.size() == 0; }
1,765,990,242  3,806   54 916,236,207 119,318,105  34,195           0          0      0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
   39,069,802      9    8  23,677,906     285,045      17           0          0      0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
  121,347,544      0    0  83,135,282         150       0  22,461,510     13,672      0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
  417,568,667      2    2 257,601,606           3       0  79,983,530     58,561      0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .      // Safe variant of insert/decrease/increase:
            .      .    .           .           .       .           .          .      .      void update(int n)
            .      .    .           .           .       .           .          .      .      {
            .      .    .           .           .       .           .          .      .          if (!inHeap(n))
            .      .    .           .           .       .           .          .      .              insert(n);
            .      .    .           .           .       .           .          .      .          else {
            .      .    .           .           .       .           .          .      .              percolateUp(indices[n]);
    5,002,068      0    0   2,501,034           0       0           0          0      0              percolateDown(indices[n]); }
            .      .    .           .           .       .           .          .      .      }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .      void insert(int n)
            .      .    .           .           .       .           .          .      .      {
   16,681,172      3    3           0           0       0           0          0      0          indices.growTo(n+1, -1);
            .      .    .           .           .       .           .          .      .          assert(!inHeap(n));
            .      .    .           .           .       .           .          .      .  
   33,362,344      2    2  16,681,172      25,790       0  16,681,172          0      0          indices[n] = heap.size();
      874,961      2    2           1           0       0     583,239          0      0          heap.push(n);
   33,362,344      0    0  16,681,172          25       0           0          0      0          percolateUp(indices[n]); 
            .      .    .           .           .       .           .          .      .      }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .      int  removeMin()
            .      .    .           .           .       .           .          .      .      {
   49,402,170      1    1  32,934,780     276,764       9  16,467,390          0      0          int x            = heap[0];
   32,934,780      0    0  16,467,390   1,165,656   3,587  16,467,390          0      0          heap[0]          = heap.last();
   32,934,780     26   18  16,467,390     206,936       5  16,467,390 13,699,451 19,244          indices[heap[0]] = 0;
   16,467,390      1    1           0           0       0  16,467,390    507,051     20          indices[x]       = -1;
            .      .    .           .           .       .           .          .      .          heap.pop();
   32,934,780      0    0           0           0       0           0          0      0          if (heap.size() > 1) percolateDown(0);
            .      .    .           .           .       .           .          .      .          return x; 
            .      .    .           .           .       .           .          .      .      }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .      // Rebuild the heap from scratch, using the elements in 'ns':
            .      .    .           .           .       .           .          .      .      void build(const vec<int>& ns) {
    2,163,394     14   14   1,081,697          14       3           0          0      0          for (int i = 0; i < heap.size(); i++)
    1,081,718      6    6          21           7       3   1,081,655    256,776 82,037              indices[heap[i]] = -1;
           21      0    0           0           0       0           0          0      0          heap.clear();
            .      .    .           .           .       .           .          .      .  
    2,001,939      6    6   1,000,938          21       0           0          0      0          for (int i = 0; i < ns.size(); i++){
    2,001,834      0    0   1,000,917           7       0   1,000,917     92,845      5              indices[ns[i]] = i;
            .      .    .           .           .       .           .          .      .              heap.push(ns[i]); }
            .      .    .           .           .       .           .          .      .  
    3,503,395     21   21     500,475           0       0          21          0      0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
            .      .    .           .           .       .           .          .      .              percolateDown(i);
            .      .    .           .           .       .           .          .      .      }
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .      void clear(bool dealloc = false) 
            .      .    .           .           .       .           .          .      .      { 
            4      0    0           2           0       0           0          0      0          for (int i = 0; i < heap.size(); i++)
            .      .    .           .           .       .           .          .      .              indices[heap[i]] = -1;
            .      .    .           .           .       .           .          .      .          heap.clear(dealloc); 
            .      .    .           .           .       .           .          .      .      }
            .      .    .           .           .       .           .          .      .  };
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  
            .      .    .           .           .       .           .          .      .  //=================================================================================================
            .      .    .           .           .       .           .          .      .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir            I1mr   ILmr Dr            D1mr        DLmr      Dw            D1mw       DLmw   

-- line 51 ----------------------------------------
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  //=================================================================================================
            .      .    .             .           .         .             .          .      .  // Options:
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  static const char* _cat = "CORE";
            .      .    .             .           .         .             .          .      .  
            4      0    0             0           0         0             1          0      0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
            4      0    0             0           0         0             1          0      0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
            4      0    0             0           0         0             1          0      0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
            4      1    1             0           0         0             1          0      0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
            4      0    0             0           0         0             1          0      0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
            4      0    0             0           0         0             1          0      0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
            4      0    0             0           0         0             1          0      0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
            4      0    0             0           0         0             1          0      0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
            4      0    0             0           0         0             1          0      0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
            4      1    1             0           0         0             1          0      0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
            4      0    0             0           0         0             1          0      0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
            4      1    1             0           0         0             1          0      0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
            4      1    1             0           0         0             1          0      0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
            4      1    1             0           0         0             1          0      0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
            4      1    1             0           0         0             1          0      0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
            .      .    .             .           .         .             .          .      .  
            4      1    1             0           0         0             1          0      0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
            1      1    1             0           0         0             1          0      0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
            4      0    0             0           0         0             1          0      0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
            .      .    .             .           .         .             .          .      .  
            4      1    1             0           0         0             1          0      0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  //VSIDS_props_limit
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  //=================================================================================================
            .      .    .             .           .         .             .          .      .  // Constructor/Destructor:
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            4      1    1             0           0         0             2          0      0  Solver::Solver() :
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Parameters (user settable):
            .      .    .             .           .         .             .          .      .      //
            .      .    .             .           .         .             .          .      .      drup_file        (NULL)
            .      .    .             .           .         .             .          .      .    , verbosity        (0)
            .      .    .             .           .         .             .          .      .    , step_size        (opt_step_size)
            .      .    .             .           .         .             .          .      .    , step_size_dec    (opt_step_size_dec)
            .      .    .             .           .         .             .          .      .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
            .      .    .             .           .         .             .          .      .    , garbage_frac     (opt_garbage_frac)
            .      .    .             .           .         .             .          .      .    , restart_first    (opt_restart_first)
            .      .    .             .           .         .             .          .      .    , restart_inc      (opt_restart_inc)
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .    , min_number_of_learnts_copies(opt_min_dupl_app)  
            .      .    .             .           .         .             .          .      .    , max_lbd_dup(opt_max_lbd_dup)
            .      .    .             .           .         .             .          .      .    , dupl_db_init_size(opt_dupl_db_init_size)
            3      1    1             1           0         0             1          0      0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .    // Parameters (the rest):
            .      .    .             .           .         .             .          .      .    //
            .      .    .             .           .         .             .          .      .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .    // Parameters (experimental):
            .      .    .             .           .         .             .          .      .    //
            .      .    .             .           .         .             .          .      .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
            .      .    .             .           .         .             .          .      .    //
            .      .    .             .           .         .             .          .      .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
            .      .    .             .           .         .             .          .      .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
            .      .    .             .           .         .             .          .      .    , chrono_backtrack(0), non_chrono_backtrack(0)
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .    , ok                 (true)
            .      .    .             .           .         .             .          .      .    , cla_inc            (1)
            .      .    .             .           .         .             .          .      .    , var_inc            (1)
            1      0    0             0           0         0             0          0      0    , watches_bin        (WatcherDeleted(ca))
            .      .    .             .           .         .             .          .      .    , watches            (WatcherDeleted(ca))
            .      .    .             .           .         .             .          .      .    , qhead              (0)
            .      .    .             .           .         .             .          .      .    , simpDB_assigns     (-1)
            .      .    .             .           .         .             .          .      .    , simpDB_props       (0)
            .      .    .             .           .         .             .          .      .    , order_heap_CHB     (VarOrderLt(activity_CHB))
            .      .    .             .           .         .             .          .      .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
            .      .    .             .           .         .             .          .      .    , progress_estimate  (0)
            .      .    .             .           .         .             .          .      .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
            .      .    .             .           .         .             .          .      .    // simplifyAll adjust occasion
            .      .    .             .           .         .             .          .      .    , curSimplify(1)
            .      .    .             .           .         .             .          .      .    , nbconfbeforesimplify(1000)
            .      .    .             .           .         .             .          .      .    , incSimplify(1000)
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .    , my_var_decay       (0.6)
            .      .    .             .           .         .             .          .      .    , DISTANCE           (true)
            .      .    .             .           .         .             .          .      .    , var_iLevel_inc     (1)
           94      8    8            25           2         2            63          1      0    , order_heap_distance(VarOrderLt(activity_distance))
            .      .    .             .           .         .             .          .      .  
            4      0    0             3           0         0             0          0      0  {}
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  Solver::~Solver()
            .      .    .             .           .         .             .          .      .  {
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  // simplify All
            .      .    .             .           .         .             .          .      .  //
            .      .    .             .           .         .             .          .      .  CRef Solver::simplePropagate()
   16,131,728      2    1             0           0         0    12,098,796         36      0  {
    2,016,466      0    0             0           0         0     2,016,466          0      0      CRef    confl = CRef_Undef;
    2,016,466      0    0             0           0         0     2,016,466          0      0      int     num_props = 0;
    4,032,932      0    0             0           0         0     2,016,466        352      0      watches.cleanAll();
    6,049,398     21   18     2,016,466           0         0     2,016,466          0      0      watches_bin.cleanAll();
   23,345,920      0    0    11,672,960           2         0             0          0      0      while (qhead < trail.size())
            .      .    .             .           .         .             .          .      .      {
   48,292,800      1    1    19,317,120     174,959         0    19,317,120          0      0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
            .      .    .             .           .         .             .          .      .          vec<Watcher>&  ws = watches[p];
            .      .    .             .           .         .             .          .      .          Watcher        *i, *j, *end;
    9,656,494      0    0     9,656,494           0         0             0          0      0          num_props++;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          // First, Propagate binary clauses
            .      .    .             .           .         .             .          .      .          vec<Watcher>&  wbin = watches_bin[p];
            .      .    .             .           .         .             .          .      .  
   41,685,885      0    0     9,658,560   9,208,600    17,651             0          0      0          for (int k = 0; k<wbin.size(); k++)
            .      .    .             .           .         .             .          .      .          {
            .      .    .             .           .         .             .          .      .  
    6,306,190      0    0     4,782,718   1,685,565     2,345             0          0      0              Lit imp = wbin[k].blocker;
            .      .    .             .           .         .             .          .      .  
    6,306,190      0    0             0           0         0             0          0      0              if (value(imp) == l_False)
            .      .    .             .           .         .             .          .      .              {
        4,132      0    0         2,066           0         0         2,066          0      0                  return wbin[k].cref;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
    6,302,058      6    6             0           0         0             0          0      0              if (value(imp) == l_Undef)
            .      .    .             .           .         .             .          .      .              {
    1,512,438      0    0     1,512,438           0         0             0          0      0                  simpleUncheckEnqueue(imp, wbin[k].cref);
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
  429,744,218      8    5   185,541,650   6,109,923     2,420    18,959,005          0      0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
            .      .    .             .           .         .             .          .      .          {
            .      .    .             .           .         .             .          .      .              // Try to avoid inspecting the clause:
  166,228,662     15   12   166,228,662  23,372,000    74,601             0          0      0              Lit blocker = i->blocker;
  332,457,324      0    0   166,228,662   5,910,962        87             0          0      0              if (value(blocker) == l_True)
            .      .    .             .           .         .             .          .      .              {
            .      .    .             .           .         .             .          .      .                  *j++ = *i++; continue;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Make sure the false literal is data[1]:
  244,191,626      0    0   122,095,813           0         0             0          0      0              CRef     cr = i->cref;
            .      .    .             .           .         .             .          .      .              Clause&  c = ca[cr];
            .      .    .             .           .         .             .          .      .              Lit      false_lit = ~p;
  366,287,439      0    0   122,095,813  97,777,243   101,351             0          0      0              if (c[0] == false_lit)
  144,814,755      0    0    48,271,585   2,307,957     4,088    96,543,170          0      0                  c[0] = c[1], c[1] = false_lit;
            .      .    .             .           .         .             .          .      .              assert(c[1] == false_lit);
            .      .    .             .           .         .             .          .      .              //  i++;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // If 0th watch is true, then clause is already satisfied.
            .      .    .             .           .         .             .          .      .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
            .      .    .             .           .         .             .          .      .              // why not simply do i->blocker=first in this case?
            .      .    .             .           .         .             .          .      .              Lit     first = c[0];
            .      .    .             .           .         .             .          .      .              //  Watcher w     = Watcher(cr, first);
  306,898,510      0    0    31,353,442     917,883         4             0          0      0              if (first != blocker && value(first) == l_True)
            .      .    .             .           .         .             .          .      .              {
   10,497,651      0    0             0           0         0    10,497,651          0      0                  i->blocker = first;
  218,522,000      0    0    54,630,500           0         0    54,630,500     19,751      0                  *j++ = *i++; continue;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Look for new watch:
            .      .    .             .           .         .             .          .      .              //if (incremental)
            .      .    .             .           .         .             .          .      .              //{ // ----------------- INCREMENTAL MODE
            .      .    .             .           .         .             .          .      .              //	int choosenPos = -1;
            .      .    .             .           .         .             .          .      .              //	for (int k = 2; k < c.size(); k++)
            .      .    .             .           .         .             .          .      .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
            .      .    .             .           .         .             .          .      .              //		Watcher w = Watcher(cr, first); i++;
            .      .    .             .           .         .             .          .      .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
            .      .    .             .           .         .             .          .      .              //		watches[~c[1]].push(w);
            .      .    .             .           .         .             .          .      .              //		goto NextClause;
            .      .    .             .           .         .             .          .      .              //	}
            .      .    .             .           .         .             .          .      .              //}
            .      .    .             .           .         .             .          .      .              else
            .      .    .             .           .         .             .          .      .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
  369,575,720     23   18             0           0         0             0          0      0                  for (int k = 2; k < c.size(); k++)
            .      .    .             .           .         .             .          .      .                  {
            .      .    .             .           .         .             .          .      .  
  666,863,444      0    0             0           0         0             0          0      0                      if (value(c[k]) != l_False)
            .      .    .             .           .         .             .          .      .                      {
            .      .    .             .           .         .             .          .      .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
            .      .    .             .           .         .             .          .      .                          // the blocker is first in the watcher. However,
            .      .    .             .           .         .             .          .      .                          // the blocker in the corresponding watcher in ~first is not c[1]
            .      .    .             .           .         .             .          .      .                          Watcher w = Watcher(cr, first); i++;
  419,377,444      0    0   104,844,361           0         0   209,688,722          0      0                          c[1] = c[k]; c[k] = false_lit;
            .      .    .             .           .         .             .          .      .                          watches[~c[1]].push(w);
  104,844,361      0    0             0           0         0             0          0      0                          goto NextClause;
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Did not find watch -- clause is unit under assignment:
    6,753,801      0    0             0           0         0     6,753,801          0      0              i->blocker = first;
   27,015,204      2    2     6,753,801           0         0     6,753,801      2,476      0              *j++ = *i++;
   13,507,602     23   18             0           0         0             0          0      0              if (value(first) == l_False)
            .      .    .             .           .         .             .          .      .              {
      675,712      7    7             0           0         0       114,481          0      0                  confl = cr;
      228,962     22   17       114,481           0         0       114,481        460      0                  qhead = trail.size();
            .      .    .             .           .         .             .          .      .                  // Copy the remaining watches:
    3,353,438      4    3       203,831         960         0             0          0      0                  while (i < end)
    1,358,407      0    0     1,358,407     135,919       606     1,358,407      1,274      0                      *j++ = *i++;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              else
            .      .    .             .           .         .             .          .      .              {
            .      .    .             .           .         .             .          .      .                  simpleUncheckEnqueue(first, cr);
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  NextClause:;
            .      .    .             .           .         .             .          .      .          }
   18,605,022     23   17             0           0         0             0          0      0          ws.shrink(i - j);
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
    4,028,800      0    0     4,028,800     126,076         0             0          0      0      s_propagations += num_props;
            .      .    .             .           .         .             .          .      .  
    2,014,400      0    0     2,014,400           0         0             0          0      0      return confl;
   98,795,160     23   19    14,115,262     125,588         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
            .      .    .             .           .         .             .          .      .      assert(value(p) == l_Undef);
    8,151,758      0    0             0           0         0     8,151,758          0      0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
   20,336,448     23   18    10,168,224       9,489         0    10,168,224  7,923,437  5,131      vardata[var(p)].reason = from;
    8,655,786      0    0     8,655,786           0         0             0          0      0      trail.push_(p);
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::cancelUntilTrailRecord()
            .      .    .             .           .         .             .          .      .  {
   21,453,328      0    0       446,752         820         0             0          0      0      for (int c = trail.size() - 1; c >= trailRecord; c--)
            .      .    .             .           .         .             .          .      .      {
      223,376     24   18       223,376           0         0             0          0      0          Var x = var(trail[c]);
   10,838,352      0    0       223,376           0         0    10,168,224    307,745      0          assigns[x] = l_Undef;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      }
      223,376      0    0             0           0         0       223,376         25      0      qhead = trailRecord;
      446,752      0    0             0           0         0             0          0      0      trail.shrink(trail.size() - trailRecord);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::litsEnqueue(int cutP, Clause& c)
            .      .    .             .           .         .             .          .      .  {
            .      .    .             .           .         .             .          .      .      for (int i = cutP; i < c.size(); i++)
            .      .    .             .           .         .             .          .      .      {
            .      .    .             .           .         .             .          .      .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  bool Solver::removed(CRef cr) {
            .      .    .             .           .         .             .          .      .      return ca[cr].mark() == 1;
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
    2,445,146     19   15             0           0         0     1,333,716          0      0  {
      222,286      0    0             0           0         0             0          0      0      int pathC = 0;
      222,286      0    0             0           0         0             0          0      0      Lit p = lit_Undef;
      666,858      0    0       222,286           0         0             0          0      0      int index = trail.size() - 1;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      do{
    8,004,282     23   18             0           0         0             0          0      0          if (confl != CRef_Undef){
            .      .    .             .           .         .             .          .      .              reason_clause.push(confl);
            .      .    .             .           .         .             .          .      .              Clause& c = ca[confl];
            .      .    .             .           .         .             .          .      .              // Special case for binary clauses
            .      .    .             .           .         .             .          .      .              // The first one has to be SAT
    8,281,792     31   18             0           0         0             0          0      0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                  assert(value(c[1]) == l_True);
            .      .    .             .           .         .             .          .      .                  Lit tmp = c[0];
      153,123      0    0        51,041       2,747         6       102,082          0      0                  c[0] = c[1], c[1] = tmp;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              // if True_confl==true, then choose p begin with the 1th index of c;
   22,642,169      0    0     4,756,375     150,598         0             0          0      0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
            .      .    .             .           .         .             .          .      .                  Lit q = c[j];
   13,755,746      0    0     6,877,873   1,684,547       469             0          0      0                  if (!seen[var(q)]){
    3,779,859      0    0             0           0         0     3,779,859          0      0                      seen[var(q)] = 1;
   11,339,577      0    0     3,779,859           0         0             0          0      0                      pathC++;
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          else if (confl == CRef_Undef){
            .      .    .             .           .         .             .          .      .              out_learnt.push(~p);
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
   13,386,982     23   18     3,779,858           4         0             0          0      0          if (pathC == 0) break;
            .      .    .             .           .         .             .          .      .          // Select next clause to look at:
   71,752,029      0    0    23,917,344   1,547,530       438             0          0      0          while (!seen[var(trail[index--])]);
            .      .    .             .           .         .             .          .      .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
            .      .    .             .           .         .             .          .      .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
    7,559,716      0    0     3,779,858     142,906         0             0          0      0          if (trailRecord > index + 1) break;
            .      .    .             .           .         .             .          .      .          p = trail[index + 1];
            .      .    .             .           .         .             .          .      .          confl = reason(var(p));
    3,779,855      0    0             0           0         0     3,779,855          0      0          seen[var(p)] = 0;
    3,779,855      0    0             0           0         0             0          0      0          pathC--;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      } while (pathC >= 0);
    2,222,860     27   20     1,556,002       2,466         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::simplifyLearnt(Clause& c)
    2,010,384     46   36             0           0         0     1,340,256         26      0  {
            .      .    .             .           .         .             .          .      .      ////
      223,376      0    0       223,376         161         0             0          0      0      original_length_record += c.size();
            .      .    .             .           .         .             .          .      .  
      446,752      0    0       223,376           4         0       223,376      1,424      0      trailRecord = trail.size();// record the start pointer
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      vec<Lit> falseLit;
            .      .    .             .           .         .             .          .      .      falseLit.clear();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
            .      .    .             .           .         .             .          .      .  
      233,094     22   17             0           0         0             0          0      0      bool True_confl = false;
            .      .    .             .           .         .             .          .      .      int beforeSize, afterSize;
            .      .    .             .           .         .             .          .      .      beforeSize = c.size();
            .      .    .             .           .         .             .          .      .      int i, j;
            .      .    .             .           .         .             .          .      .      CRef confl;
            .      .    .             .           .         .             .          .      .  
    7,158,198     23   18             0           0         0             0          0      0      for (i = 0, j = 0; i < c.size(); i++){
    4,323,200      0    0             0           0         0             0          0      0          if (value(c[i]) == l_Undef){
            .      .    .             .           .         .             .          .      .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
            .      .    .             .           .         .             .          .      .              simpleUncheckEnqueue(~c[i]);
    7,949,317      0    0     2,016,466           0         0     2,016,466        513      0              c[j++] = c[i];
    6,049,398      0    0             0           0         0     2,016,466         24      0              confl = simplePropagate();
    6,049,398     23   19     2,016,466     123,407         0             0          0      0              if (confl != CRef_Undef){
            .      .    .             .           .         .             .          .      .                  break;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          else{
      290,268      0    0             0           0         0             0          0      0              if (value(c[i]) == l_True){
            .      .    .             .           .         .             .          .      .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
      422,956     23   16       105,739           0         0       105,739         82      0                  c[j++] = c[i];
      105,739      9    7             0           0         0             0          0      0                  True_confl = true;
            .      .    .             .           .         .             .          .      .                  confl = reason(var(c[i]));
            .      .    .             .           .         .             .          .      .                  break;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              else{
            .      .    .             .           .         .             .          .      .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
            .      .    .             .           .         .             .          .      .                  falseLit.push(c[i]);
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .      c.shrink(c.size() - j);
            .      .    .             .           .         .             .          .      .      afterSize = c.size();
            .      .    .             .           .         .             .          .      .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      if (confl != CRef_Undef || True_confl == true){
      222,286      0    0             0           0         0             0          0      0          simp_learnt_clause.clear();
      222,286      0    0             0           0         0             0          0      0          simp_reason_clause.clear();
      444,572      0    0             0           0         0             0          0      0          if (True_confl == true){
            .      .    .             .           .         .             .          .      .              simp_learnt_clause.push(c.last());
            .      .    .             .           .         .             .          .      .          }
    1,556,002     14   10             0           0         0       222,286          0      0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
            .      .    .             .           .         .             .          .      .  
      666,858      0    0       222,286           0         0             0          0      0          if (simp_learnt_clause.size() < c.size()){
      946,230     23   18       401,005           0         0             0          0      0              for (i = 0; i < simp_learnt_clause.size(); i++){
    1,459,800      0    0       364,950          43         0       364,950      4,740      0                  c[i] = simp_learnt_clause[i];
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              c.shrink(c.size() - i);
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      cancelUntilTrailRecord();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      ////
      223,376      0    0       223,376          40         0             0          0      0      simplified_length_record += c.size();
            .      .    .             .           .         .             .          .      .  
    1,787,008      0    0     1,563,632     143,247         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
            .      .    .             .           .         .             .          .      .  {
            .      .    .             .           .         .             .          .      .      int beforeSize, afterSize;
            .      .    .             .           .         .             .          .      .      int learnts_x_size_before = learnts_x.size();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      int ci, cj, li, lj;
            .      .    .             .           .         .             .          .      .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
            .      .    .             .           .         .             .          .      .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      return true;
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  bool Solver::simplifyLearnt_core()
          253      0    0             0           0         0           138          0      0  {
            .      .    .             .           .         .             .          .      .      int beforeSize, afterSize;
            .      .    .             .           .         .             .          .      .      int learnts_core_size_before = learnts_core.size();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      int ci, cj, li, lj;
            .      .    .             .           .         .             .          .      .      bool sat, false_lit;
            .      .    .             .           .         .             .          .      .      unsigned int nblevels;
            .      .    .             .           .         .             .          .      .      ////
            .      .    .             .           .         .             .          .      .      //printf("learnts_x size : %d\n", learnts_x.size());
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      ////
            .      .    .             .           .         .             .          .      .      int nbSimplified = 0;
            .      .    .             .           .         .             .          .      .      int nbSimplifing = 0;
            .      .    .             .           .         .             .          .      .  
    1,301,283     23   17            23           0         0             0          0      0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
    1,951,788     23   18     1,301,192      40,682    30,282             0          0      0          CRef cr = learnts_core[ci];
            .      .    .             .           .         .             .          .      .          Clause& c = ca[cr];
            .      .    .             .           .         .             .          .      .  
    1,301,192      0    0             0           0         0             0          0      0          if (removed(cr)) continue;
    1,301,192      0    0       650,596      77,216    20,861             0          0      0          else if (c.simplified()){
    1,205,350      0    0             0           0         0       602,675          0      0              learnts_core[cj++] = learnts_core[ci];
            .      .    .             .           .         .             .          .      .              ////
    1,808,057      0    0       602,675           0         0             0          0      0              nbSimplified++;
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          else{
            .      .    .             .           .         .             .          .      .              int saved_size=c.size();
            .      .    .             .           .         .             .          .      .              //         if (drup_file){
            .      .    .             .           .         .             .          .      .              //                 add_oc.clear();
            .      .    .             .           .         .             .          .      .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
            .      .    .             .           .         .             .          .      .              ////
            .      .    .             .           .         .             .          .      .              nbSimplifing++;
       47,919      0    0             0           0         0             0          0      0              sat = false_lit = false;
      846,508      0    0             0           0         0             0          0      0              for (int i = 0; i < c.size(); i++){
      846,534      0    0             0           0         0             0          0      0                  if (value(c[i]) == l_True){
            .      .    .             .           .         .             .          .      .                      sat = true;
            .      .    .             .           .         .             .          .      .                      break;
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .                  else if (value(c[i]) == l_False){
      942,342     23   18             0           0         0        47,919          0      0                      false_lit = true;
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              if (sat){
          105      1    1            30           0         0            30          0      0                  removeClause(cr);
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              else{
      287,436      0    0             0           0         0       143,718          0      0                  detachClause(cr, true);
            .      .    .             .           .         .             .          .      .  
      191,624     23   18        95,812           0         0             0          0      0                  if (false_lit){
        4,733      0    0           338           0         0             0          0      0                      for (li = lj = 0; li < c.size(); li++){
        3,212      0    0             0           0         0             0          0      0                          if (value(c[li]) != l_False){
        4,212      0    0             0           0         0         1,404          0      0                              c[lj++] = c[li];
            .      .    .             .           .         .             .          .      .                          }
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                      c.shrink(li - lj);
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                  beforeSize = c.size();
            .      .    .             .           .         .             .          .      .                  assert(c.size() > 1);
            .      .    .             .           .         .             .          .      .                  // simplify a learnt clause c
      191,624      0    0             0           0         0        95,812          0      0                  simplifyLearnt(c);
            .      .    .             .           .         .             .          .      .                  assert(c.size() > 0);
            .      .    .             .           .         .             .          .      .                  afterSize = c.size();
            .      .    .             .           .         .             .          .      .                  
      214,496      0    0       143,718      30,299         0             0          0      0                  if(drup_file && saved_size !=c.size()){
            .      .    .             .           .         .             .          .      .  #ifdef BIN_DRUP
            .      .    .             .           .         .             .          .      .                      binDRUP('a', c , drup_file);
            .      .    .             .           .         .             .          .      .                      //                    binDRUP('d', add_oc, drup_file);
            .      .    .             .           .         .             .          .      .  #else
            .      .    .             .           .         .             .          .      .                      for (int i = 0; i < c.size(); i++)
            .      .    .             .           .         .             .          .      .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .             .           .         .             .          .      .                      fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
            .      .    .             .           .         .             .          .      .                      //                    for (int i = 0; i < add_oc.size(); i++)
            .      .    .             .           .         .             .          .      .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
            .      .    .             .           .         .             .          .      .                      //                    fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
            .      .    .             .           .         .             .          .      .  
       95,812      0    0             0           0         0             0          0      0                  if (c.size() == 1){
            .      .    .             .           .         .             .          .      .                      // when unit clause occur, enqueue and propagate
            5      1    1             1           0         0             1          0      0                      uncheckedEnqueue(c[0]);
            3      0    0             1           0         0             0          0      0                      if (propagate() != CRef_Undef){
            .      .    .             .           .         .             .          .      .                          ok = false;
            .      .    .             .           .         .             .          .      .                          return false;
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                      // delete the clause memory in logic
            .      .    .             .           .         .             .          .      .                      c.mark(1);
            .      .    .             .           .         .             .          .      .                      ca.free(cr);
            .      .    .             .           .         .             .          .      .  //#ifdef BIN_DRUP
            .      .    .             .           .         .             .          .      .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
            .      .    .             .           .         .             .          .      .  //#else
            .      .    .             .           .         .             .          .      .  //                    fprintf(drup_file, "d ");
            .      .    .             .           .         .             .          .      .  //                    for (int i = 0; i < c.size(); i++)
            .      .    .             .           .         .             .          .      .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .             .           .         .             .          .      .  //                    fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  //#endif
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .                  else{
      143,715      0    0             0           0         0        47,905          0      0                      attachClause(cr);
      287,430     17   14       143,715      60,483         0        47,905      2,743      0                      learnts_core[cj++] = learnts_core[ci];
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                      nblevels = computeLBD(c);
       95,810     22   17             0           0         0             0          0      0                      if (nblevels < c.lbd()){
            .      .    .             .           .         .             .          .      .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
            .      .    .             .           .         .             .          .      .                          c.set_lbd(nblevels);
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                      c.setSimplified(true);
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
           23      0    0             0           0         0             0          0      0      learnts_core.shrink(ci - cj);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
            .      .    .             .           .         .             .          .      .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
            .      .    .             .           .         .             .          .      .  
           23     18   14             0           0         0             0          0      0      return true;
            .      .    .             .           .         .             .          .      .  
          184      0    0           161          23         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
    4,975,605      2    2             0           0         0     3,317,070          0      0  int Solver::is_duplicate(std::vector<uint32_t>&c){
    1,105,690      0    0             0           0         0     1,105,690     14,071      0     auto time_point_0 = std::chrono::high_resolution_clock::now();
      552,845      0    0       552,845     335,538         5             0          0      0      dupl_db_size++;
    1,302,866    538   14       433,958           0         0             0          0      0      int res = 0;    
            .      .    .             .           .         .             .          .      .      
    1,105,690      0    0     1,105,690           0         0             0          0      0      int sz = c.size();
            .      .    .             .           .         .             .          .      .      std::vector<uint32_t> tmp(c);    
            .      .    .             .           .         .             .          .      .      sort(tmp.begin(),tmp.end());
            .      .    .             .           .         .             .          .      .      
      552,845 86,061   19             0           0         0       552,845          0      0      uint64_t hash = 0;    
            .      .    .             .           .         .             .          .      .      
   18,336,634  2,538   27             0           0         0       552,845          0      0      for (int i =0; i<sz; i++) {
   69,569,370      0    0     6,956,937           0         0             0          0      0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
            .      .    .             .           .         .             .          .      .      }    
            .      .    .             .           .         .             .          .      .      
      552,845      0    0             0           0         0       552,845          0      0      int32_t head = tmp[0];
            .      .    .             .           .         .             .          .      .      auto it0 = ht.find(head);
    2,692,093      0    0       552,839           0         0             0          0      0      if (it0 != ht.end()){
            .      .    .             .           .         .             .          .      .          auto it1=ht[head].find(sz);
    1,057,610      0    0             0           0         0             0          0      0          if (it1 != ht[head].end()){
      397,255      0    0             0           0         0       397,255          0      0              auto it2 = ht[head][sz].find(hash);
    1,191,765      0    0             0           0         0       397,255          0      0              if (it2 != ht[head][sz].end()){
      355,173      0    0       118,391      22,387     5,270       118,391          0      0                  it2->second++;
      118,391      0    0             0           0         0             0          0      0                  res = it2->second;            
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              else{
      278,864      0    0             0           0         0       278,864          0      0                  ht[head][sz][hash]=1;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          else{            
      263,100     39    4             0           0         0       131,550          0      0              ht[head][sz][hash]=1;
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }else{        
      458,494  9,390   24             0           0         0       458,494          2      0          ht[head][sz][hash]=1;
            .      .    .             .           .         .             .          .      .      } 
      552,845     54    9             0           0         0       552,845          0      0      auto time_point_1 = std::chrono::high_resolution_clock::now();
            .      .    .             .           .         .             .          .      .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
            .      .    .             .           .         .             .          .      .      return res;
    4,975,605      0    0     3,869,915          18         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  bool Solver::simplifyLearnt_tier2()
          253     23   17             0           0         0           138          0      0  {
            .      .    .             .           .         .             .          .      .      int beforeSize, afterSize;
            .      .    .             .           .         .             .          .      .      int learnts_tier2_size_before = learnts_tier2.size();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      int ci, cj, li, lj;
            .      .    .             .           .         .             .          .      .      bool sat, false_lit;
            .      .    .             .           .         .             .          .      .      unsigned int nblevels;
            .      .    .             .           .         .             .          .      .      ////
            .      .    .             .           .         .             .          .      .      //printf("learnts_x size : %d\n", learnts_x.size());
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      ////
            .      .    .             .           .         .             .          .      .      int nbSimplified = 0;
            .      .    .             .           .         .             .          .      .      int nbSimplifing = 0;
            .      .    .             .           .         .             .          .      .  
      471,295     23    7            23           0         0             0          0      0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
      706,839      0    0       471,226      14,820     1,467             0          0      0          CRef cr = learnts_tier2[ci];
            .      .    .             .           .         .             .          .      .          Clause& c = ca[cr];
            .      .    .             .           .         .             .          .      .  
      471,226      0    0             0           0         0             0          0      0          if (removed(cr)) continue;
      471,226      0    0       235,613      23,558       910             0          0      0          else if (c.simplified()){
      120,286      0    0             0           0         0        60,143        267      0              learnts_tier2[cj++] = learnts_tier2[ci];
            .      .    .             .           .         .             .          .      .              ////
      531,369      0    0        60,143           0         0             0          0      0              nbSimplified++;
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          else{
            .      .    .             .           .         .             .          .      .              int saved_size=c.size();
            .      .    .             .           .         .             .          .      .              //            if (drup_file){
            .      .    .             .           .         .             .          .      .              //                    add_oc.clear();
            .      .    .             .           .         .             .          .      .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
            .      .    .             .           .         .             .          .      .              ////
            .      .    .             .           .         .             .          .      .              nbSimplifing++;
      175,470      0    0             0           0         0             0          0      0              sat = false_lit = false;
    4,069,430      0    0             0           0         0             0          0      0              for (int i = 0; i < c.size(); i++){
    4,069,430      0    0             0           0         0             0          0      0                  if (value(c[i]) == l_True){
            .      .    .             .           .         .             .          .      .                      sat = true;
            .      .    .             .           .         .             .          .      .                      break;
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .                  else if (value(c[i]) == l_False){
    4,420,370      3    3             0           0         0       175,470          0      0                      false_lit = true;
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              if (sat){
            .      .    .             .           .         .             .          .      .                  removeClause(cr);
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              else{
    1,052,820     15   12             0           0         0       526,410         22      0                  detachClause(cr, true);
            .      .    .             .           .         .             .          .      .  
      701,880      0    0       350,940           3         0             0          0      0                  if (false_lit){
        1,855      2    2            98           0         0             0          0      0                      for (li = lj = 0; li < c.size(); li++){
        1,414      0    0             0           0         0             0          0      0                          if (value(c[li]) != l_False){
        1,944      0    0             0           0         0           648          0      0                              c[lj++] = c[li];
            .      .    .             .           .         .             .          .      .                          }
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                      c.shrink(li - lj);
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                  beforeSize = c.size();
            .      .    .             .           .         .             .          .      .                  assert(c.size() > 1);
            .      .    .             .           .         .             .          .      .                  // simplify a learnt clause c
      877,350      0    0             0           0         0       526,410          0      0                  simplifyLearnt(c);
            .      .    .             .           .         .             .          .      .                  assert(c.size() > 0);
            .      .    .             .           .         .             .          .      .                  afterSize = c.size();
            .      .    .             .           .         .             .          .      .                  
      701,880     17   14       350,940     122,676         0             0          0      0                  if(drup_file && saved_size!=c.size()){
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  #ifdef BIN_DRUP
            .      .    .             .           .         .             .          .      .                      binDRUP('a', c , drup_file);
            .      .    .             .           .         .             .          .      .                      //                    binDRUP('d', add_oc, drup_file);
            .      .    .             .           .         .             .          .      .  #else
            .      .    .             .           .         .             .          .      .                      for (int i = 0; i < c.size(); i++)
            .      .    .             .           .         .             .          .      .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .             .           .         .             .          .      .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
            .      .    .             .           .         .             .          .      .                      //                    for (int i = 0; i < add_oc.size(); i++)
            .      .    .             .           .         .             .          .      .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
            .      .    .             .           .         .             .          .      .                      //                    fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
            .      .    .             .           .         .             .          .      .  
      350,940      0    0             0           0         0             0          0      0                  if (c.size() == 1){
            .      .    .             .           .         .             .          .      .                      // when unit clause occur, enqueue and propagate
            .      .    .             .           .         .             .          .      .                      uncheckedEnqueue(c[0]);
            .      .    .             .           .         .             .          .      .                      if (propagate() != CRef_Undef){
            .      .    .             .           .         .             .          .      .                          ok = false;
            .      .    .             .           .         .             .          .      .                          return false;
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                      // delete the clause memory in logic
            .      .    .             .           .         .             .          .      .                      c.mark(1);
-- line 838 ----------------------------------------
-- line 845 ----------------------------------------
            .      .    .             .           .         .             .          .      .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .             .           .         .             .          .      .  //                    fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  //#endif
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .                  else{
            .      .    .             .           .         .             .          .      .                      
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                      nblevels = computeLBD(c);
      350,940      0    0             0           0         0             0          0      0                      if (nblevels < c.lbd()){
            .      .    .             .           .         .             .          .      .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
            .      .    .             .           .         .             .          .      .                          c.set_lbd(nblevels);
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                       //duplicate learnts 
            .      .    .             .           .         .             .          .      .                      int id = 0;                    
            .      .    .             .           .         .             .          .      .                      
            .      .    .             .           .         .             .          .      .                      std::vector<uint32_t> tmp;
    6,523,847      0    0     4,776,327           1         0             0          0      0                      for (int i = 0; i < c.size(); i++)                           
    3,418,178      0    0     1,709,089           2         0     1,709,089          0      0                          tmp.push_back(c[i].x);
      701,880      0    0             0           0         0       175,470          0      0                      id = is_duplicate(tmp);
            .      .    .             .           .         .             .          .      .                       
            .      .    .             .           .         .             .          .      .                                          
            .      .    .             .           .         .             .          .      .                      //duplicate learnts 
            .      .    .             .           .         .             .          .      .  
      701,880      3    3       175,470           0         0             0          0      0                      if (id < min_number_of_learnts_copies+2){
      525,384      5    4             0           0         0       175,128          0      0                          attachClause(cr);
      851,826      0    0       525,384     248,154         0       175,128    128,903      0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
      700,512     21   16       175,128           0         0             0          0      0                          if (id == min_number_of_learnts_copies+1){                            
          601      0    0           601           0         0             0          0      0                              duplicates_added_minimization++;                                  
            .      .    .             .           .         .             .          .      .                          }
      349,054      0    0       174,527     126,043         0             0          0      0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
            .      .    .             .           .         .             .          .      .                          //if (id == min_number_of_learnts_copies+1){
            .      .    .             .           .         .             .          .      .                              cj--;
            8      6    6             0           0         0             0          0      0                              learnts_core.push(cr);
            .      .    .             .           .         .             .          .      .                              c.mark(CORE);
            .      .    .             .           .         .             .          .      .                          }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                          c.setSimplified(true);
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
           23     17   16             0           0         0             0          0      0      learnts_tier2.shrink(ci - cj);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
            .      .    .             .           .         .             .          .      .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
            .      .    .             .           .         .             .          .      .  
           23      0    0             0           0         0             0          0      0      return true;
            .      .    .             .           .         .             .          .      .  
          184      0    0           161          23         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  bool Solver::simplifyAll()
          115      6    6             0           0         0            69          0      0  {
            .      .    .             .           .         .             .          .      .      ////
           46      0    0             0           0         0            23          0      0      simplified_length_record = original_length_record = 0;
            .      .    .             .           .         .             .          .      .  
           92      0    0            23          22         0             0          0      0      if (!ok || propagate() != CRef_Undef)
            .      .    .             .           .         .             .          .      .          return ok = false;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      //// cleanLearnts(also can delete these code), here just for analyzing
            .      .    .             .           .         .             .          .      .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
            .      .    .             .           .         .             .          .      .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
            .      .    .             .           .         .             .          .      .      //local_learnts_dirty = tier2_learnts_dirty = false;
            .      .    .             .           .         .             .          .      .  
           92      0    0             0           0         0            23          0      0      if (!simplifyLearnt_core()) return ok = false;
           92     23   19             0           0         0            23          0      0      if (!simplifyLearnt_tier2()) return ok = false;
            .      .    .             .           .         .             .          .      .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      checkGarbage();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      ////
            .      .    .             .           .         .             .          .      .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
            .      .    .             .           .         .             .          .      .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      return true;
          115      0    0            92          23         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  //=================================================================================================
            .      .    .             .           .         .             .          .      .  // Minor methods:
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
            .      .    .             .           .         .             .          .      .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
            .      .    .             .           .         .             .          .      .  //
            .      .    .             .           .         .             .          .      .  Var Solver::newVar(bool sign, bool dvar)
      720,780      1    1             0           0         0       576,624          0      0  {
            .      .    .             .           .         .             .          .      .      int v = nVars();
            .      .    .             .           .         .             .          .      .      watches_bin.init(mkLit(v, false));
            .      .    .             .           .         .             .          .      .      watches_bin.init(mkLit(v, true ));
            .      .    .             .           .         .             .          .      .      watches  .init(mkLit(v, false));
            .      .    .             .           .         .             .          .      .      watches  .init(mkLit(v, true ));
           25      1    1             0           0         0             0          0      0      assigns  .push(l_Undef);
           25      1    1             0           0         0             0          0      0      vardata  .push(mkVarData(CRef_Undef, 0));
           25      0    0             0           0         0             0          0      0      activity_CHB  .push(0);
      216,284      0    0        72,078       1,423         0            25          0      0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
            .      .    .             .           .         .             .          .      .  
           25      1    1             0           0         0             0          0      0      picked.push(0);
           25      0    0             0           0         0             0          0      0      conflicted.push(0);
           25      0    0             0           0         0             0          0      0      almost_conflicted.push(0);
            .      .    .             .           .         .             .          .      .  #ifdef ANTI_EXPLORATION
           25      0    0             0           0         0             0          0      0      canceled.push(0);
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .  
           25      0    0             0           0         0             0          0      0      seen     .push(0);
           25      0    0             0           0         0             0          0      0      seen2    .push(0);
           25      0    0             0           0         0             0          0      0      polarity .push(sign);
           25      0    0             0           0         0             0          0      0      decision .push();
      360,390      1    1             0           0         0       144,156      2,511      0      trail    .capacity(v+1);
            .      .    .             .           .         .             .          .      .      setDecisionVar(v, dvar);
            .      .    .             .           .         .             .          .      .  
           25      0    0             0           0         0             0          0      0      activity_distance.push(0);
           25      1    1             0           0         0             0          0      0      var_iLevel.push(0);
           25      0    0             0           0         0             0          0      0      var_iLevel_tmp.push(0);
           25      0    0             0           0         0             0          0      0      pathCs.push(0);
            .      .    .             .           .         .             .          .      .      return v;
      648,702      0    0       504,546         633         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  bool Solver::addClause_(vec<Lit>& ps)
    6,366,759      2    2             0           0         0     5,457,222          5      0  {
            .      .    .             .           .         .             .          .      .      assert(decisionLevel() == 0);
    2,728,611      1    1       909,537           0         0             0          0      0      if (!ok) return false;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Check if clause is satisfied and remove false/duplicate literals:
            .      .    .             .           .         .             .          .      .      sort(ps);
            .      .    .             .           .         .             .          .      .      Lit p; int i, j;
            .      .    .             .           .         .             .          .      .  
    1,819,074      0    0       909,537         224         0             0          0      0      if (drup_file){
            .      .    .             .           .         .             .          .      .          add_oc.clear();
      909,537      2    2       909,537           0         0             0          0      0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
            .      .    .             .           .         .             .          .      .  
   12,771,078      0    0             0           0         0             0          0      0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
   21,902,829      0    0     3,720,123           0         0             0          0      0          if (value(ps[i]) == l_True || ps[i] == ~p)
            .      .    .             .           .         .             .          .      .              return true;
   14,463,826      4    4             0           0         0             0          0      0          else if (value(ps[i]) != l_False && ps[i] != p)
   10,743,735      0    0     3,581,245           0         0     3,581,245          0      0              ps[j++] = p = ps[i];
    6,720,656      0    0       840,082           0         0             0          0      0      ps.shrink(i - j);
            .      .    .             .           .         .             .          .      .  
    1,680,164      3    3             0           0         0             0          0      0      if (drup_file && i != j){
            .      .    .             .           .         .             .          .      .  #ifdef BIN_DRUP
            .      .    .             .           .         .             .          .      .          binDRUP('a', ps, drup_file);
      840,082      0    0       840,082           0         0             0          0      0          binDRUP('d', add_oc, drup_file);
            .      .    .             .           .         .             .          .      .  #else
            .      .    .             .           .         .             .          .      .          for (int i = 0; i < ps.size(); i++)
            .      .    .             .           .         .             .          .      .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
            .      .    .             .           .         .             .          .      .          fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          fprintf(drup_file, "d ");
            .      .    .             .           .         .             .          .      .          for (int i = 0; i < add_oc.size(); i++)
            .      .    .             .           .         .             .          .      .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
            .      .    .             .           .         .             .          .      .          fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .      
    1,680,164      0    0             0           0         0             0          0      0      if (ps.size() == 0)
            .      .    .             .           .         .             .          .      .          return ok = false;
    1,680,164      3    3             0           0         0             0          0      0      else if (ps.size() == 1){
        6,468      1    1         2,156           0         0         1,078          0      0          uncheckedEnqueue(ps[0]);
        4,312      0    0             0           0         0         1,078          4      0          return ok = (propagate() == CRef_Undef);
            .      .    .             .           .         .             .          .      .      }else{
      839,004      0    0             0           0         0       839,004          0      0          CRef cr = ca.alloc(ps, false);
            .      .    .             .           .         .             .          .      .          //auto ca_size=ca.size();
            .      .    .             .           .         .             .          .      .          //printf("ca size:%d\n",ca_size);
    2,517,012      0    0             0           0         0       839,004          0      0          clauses.push(cr);
    2,517,012      1    1       839,004           0         0       839,004          0      0          attachClause(cr);
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
      839,004      0    0             0           0         0             0          0      0      return true;
   10,004,907      0    0     6,366,759         128         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
   16,758,000      7    5             0           0         0    10,054,800        573      0  void Solver::attachClause(CRef cr) {
            .      .    .             .           .         .             .          .      .      const Clause& c = ca[cr];
            .      .    .             .           .         .             .          .      .      assert(c.size() > 1);
    6,673,365      0    0     1,675,800          12         0             0          0      0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
            .      .    .             .           .         .             .          .      .      ws[~c[0]].push(Watcher(cr, c[1]));
            .      .    .             .           .         .             .          .      .      ws[~c[1]].push(Watcher(cr, c[0]));
    4,169,559      0    0     2,493,759     441,506         8             0          0      0      if (c.learnt()) learnts_literals += c.size();
   14,264,241      1    1    12,588,441         739         0             0          0      0      else            clauses_literals += c.size(); }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
    6,035,682     66   27             0           0         0     4,023,788         43      0  void Solver::detachClause(CRef cr, bool strict) {
            .      .    .             .           .         .             .          .      .      const Clause& c = ca[cr];
            .      .    .             .           .         .             .          .      .      assert(c.size() > 1);
    4,023,788      0    0             0           0         0             0          0      0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
            .      .    .             .           .         .             .          .      .      
    4,023,788      0    0             0           0         0             0          0      0      if (strict){
            .      .    .             .           .         .             .          .      .          remove(ws[~c[0]], Watcher(cr, c[1]));
            .      .    .             .           .         .             .          .      .          remove(ws[~c[1]], Watcher(cr, c[0]));
            .      .    .             .           .         .             .          .      .      }else{
            .      .    .             .           .         .             .          .      .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
            .      .    .             .           .         .             .          .      .          ws.smudge(~c[0]);
            .      .    .             .           .         .             .          .      .          ws.smudge(~c[1]);
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
    2,707,342      7    6     1,701,395      15,045     3,331             0          0      0      if (c.learnt()) learnts_literals -= c.size();
    6,346,181      0    0     5,340,234         324         1             0          0      0      else            clauses_literals -= c.size(); }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
    6,109,872    100   46             0           0         0     3,054,936         20      0  void Solver::removeClause(CRef cr) {
            .      .    .             .           .         .             .          .      .      Clause& c = ca[cr];
            .      .    .             .           .         .             .          .      .  
    2,291,202      0    0       763,734         150         0             0          0      0      if (drup_file){
            .      .    .             .           .         .             .          .      .          if (c.mark() != 1){
            .      .    .             .           .         .             .          .      .  #ifdef BIN_DRUP
            .      .    .             .           .         .             .          .      .              binDRUP('d', c, drup_file);
            .      .    .             .           .         .             .          .      .  #else
            .      .    .             .           .         .             .          .      .              fprintf(drup_file, "d ");
            .      .    .             .           .         .             .          .      .              for (int i = 0; i < c.size(); i++)
            .      .    .             .           .         .             .          .      .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .             .           .         .             .          .      .              fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .          }else
            .      .    .             .           .         .             .          .      .              printf("c Bug. I don't expect this to happen.\n");
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
    3,054,936     45   30             0           0         0       763,734          0      0      detachClause(cr);
            .      .    .             .           .         .             .          .      .      // Don't leave pointers to free'd memory!
            .      .    .             .           .         .             .          .      .      if (locked(c)){
        8,018      0    0           545           0         0             0          0      0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
        6,928      0    0             0           0         0         3,464          0      0          vardata[var(implied)].reason = CRef_Undef; }
            .      .    .             .           .         .             .          .      .      c.mark(1);
            .      .    .             .           .         .             .          .      .      ca.free(cr);
    4,582,404      0    0     3,818,670           3         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  bool Solver::satisfied(const Clause& c) const {
   51,517,668     15   15             0           0         0             0          0      0      for (int i = 0; i < c.size(); i++)
   59,688,900      0    0    21,715,592     201,505     2,485             0          0      0          if (value(c[i]) == l_True)
       46,293      1    1             0           0         0             0          0      0              return true;
    1,915,931      0    0       981,112           0         0             0          0      0      return false; }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
            .      .    .             .           .         .             .          .      .  //
    5,396,454  3,921   34             0           0         0     3,597,636          0      0  void Solver::cancelUntil(int bLevel) {
            .      .    .             .           .         .             .          .      .  	
    2,405,778      8    1         4,677           1         0       599,606          1      0      if (decisionLevel() > bLevel){
            .      .    .             .           .         .             .          .      .  #ifdef PRINT_OUT
            .      .    .             .           .         .             .          .      .  		std::cout << "bt " << bLevel << "\n";
            .      .    .             .           .         .             .          .      .  #endif				
    1,199,212      0    0             0           0         0       599,606          1      0  		add_tmp.clear();
  562,238,374  7,379   25   113,766,808     784,763        37             0          0      0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
            .      .    .             .           .         .             .          .      .          {
            .      .    .             .           .         .             .          .      .              Var      x  = var(trail[c]);
            .      .    .             .           .         .             .          .      .  
  221,537,556      0    0   110,768,778  85,516,451     4,696             0          0      0  			if (level(x) <= bLevel)
            .      .    .             .           .         .             .          .      .  			{
            .      .    .             .           .         .             .          .      .  				add_tmp.push(trail[c]);
            .      .    .             .           .         .             .          .      .  			}
            .      .    .             .           .         .             .          .      .  			else
            .      .    .             .           .         .             .          .      .  			{
  220,998,176      0    0   110,499,088      72,966         0             0          0      0  				 if (!VSIDS){
  207,261,909      0    0   138,174,606         268         0             0          0      0  					uint32_t age = conflicts - picked[x];
  138,174,606      0    0    69,087,303  56,954,163     6,541             0          0      0  					if (age > 0){
  690,617,650  1,467   21   276,247,060 112,087,700     9,872             0          0      0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
   69,061,765      0    0    69,061,765  52,949,994     7,782             0          0      0  						double old_activity = activity_CHB[x];
  483,432,355    100    8   138,123,530     324,310         1    69,061,765          0      0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
            .      .    .             .           .         .             .          .      .  						if (order_heap_CHB.inHeap(x)){
  387,408,150    641   14             0           0         0   193,704,075         44      0  							if (activity_CHB[x] > old_activity)
            .      .    .             .           .         .             .          .      .  								order_heap_CHB.decrease(x);
            .      .    .             .           .         .             .          .      .  							else
            .      .    .             .           .         .             .          .      .  								order_heap_CHB.increase(x);
            .      .    .             .           .         .             .          .      .  						}
            .      .    .             .           .         .             .          .      .  					}
            .      .    .             .           .         .             .          .      .  #ifdef ANTI_EXPLORATION
  138,174,606      0    0    69,087,303           0         0    69,087,303 57,080,764  5,974  					canceled[x] = conflicts;
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .  				}
            .      .    .             .           .         .             .          .      .  				
  220,998,176    657   23   110,499,088         125         0   110,499,088 44,375,457  1,046  				assigns [x] = l_Undef;
            .      .    .             .           .         .             .          .      .  #ifdef PRINT_OUT
            .      .    .             .           .         .             .          .      .  				std::cout << "undo " << x << "\n";
            .      .    .             .           .         .             .          .      .  #endif				
  220,998,176      0    0   110,499,088         122         0             0          0      0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
  110,499,088      0    0   110,499,088           0         0             0          0      0  					polarity[x] = sign(trail[c]);
            .      .    .             .           .         .             .          .      .  				insertVarOrder(x);
            .      .    .             .           .         .             .          .      .  			}
            .      .    .             .           .         .             .          .      .          }
      599,606      0    0             0           0         0       599,606          0      0          qhead = trail_lim[bLevel];
    1,199,212      0    0             0           0         0             0          0      0          trail.shrink(trail.size() - trail_lim[bLevel]);
    1,798,818      0    0       599,606           0         0             0          0      0          trail_lim.shrink(trail_lim.size() - bLevel);
    2,338,198      1    1       599,606           0         0             0          0      0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
            .      .    .             .           .         .             .          .      .  		{
       27,054      0    0         9,018           0         0             0          0      0  			trail.push_(add_tmp[nLitId]);
            .      .    .             .           .         .             .          .      .  		}
            .      .    .             .           .         .             .          .      .  		
            .      .    .             .           .         .             .          .      .  		add_tmp.clear();
    4,796,848      0    0     4,197,242     270,423         0             0          0      0      } }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  //=================================================================================================
            .      .    .             .           .         .             .          .      .  // Major methods:
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  Lit Solver::pickBranchLit()
   61,901,880    293   10             0           0         0    46,426,410         83      0  {
            .      .    .             .           .         .             .          .      .      Var next = var_Undef;
            .      .    .             .           .         .             .          .      .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
   31,746,474  5,438   24     9,771,902     572,191        32             0          0      0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Random decision:
            .      .    .             .           .         .             .          .      .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
            .      .    .             .           .         .             .          .      .          next = order_heap[irand(random_seed,order_heap.size())];
            .      .    .             .           .         .             .          .      .          if (value(next) == l_Undef && decision[next])
            .      .    .             .           .         .             .          .      .              rnd_decisions++; }*/
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Activity based decision:
  127,220,075  1,647    4    55,872,302  16,563,146     6,409             0          0      0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
   32,659,102      0    0             0           0         0             0          0      0          if (order_heap.empty())
            1      0    0             0           0         0             0          0      0              return lit_Undef;
            .      .    .             .           .         .             .          .      .          else{
            .      .    .             .           .         .             .          .      .  #ifdef ANTI_EXPLORATION
   32,659,100      0    0    16,329,550      29,780         1             0          0      0              if (!VSIDS){
            .      .    .             .           .         .             .          .      .                  Var v = order_heap_CHB[0];
   16,572,020      0    0    16,572,020       6,784        10             0          0      0                  uint32_t age = conflicts - canceled[v];
   32,901,398      0    0    15,391,896   9,884,133     7,578     1,058,803          0      0                  while (age > 0){
            .      .    .             .           .         .             .          .      .                      double decay = pow(0.95, age);
   14,211,772      0    0     7,105,886      39,657         4     7,105,886          0      0                      activity_CHB[v] *= decay;
            .      .    .             .           .         .             .          .      .                      if (order_heap_CHB.inHeap(v))
            .      .    .             .           .         .             .          .      .                          order_heap_CHB.increase(v);
   21,317,658      0    0    14,211,772          21         0     7,105,886        612      0                      canceled[v] = conflicts;
            .      .    .             .           .         .             .          .      .                      v = order_heap_CHB[0];
            .      .    .             .           .         .             .          .      .                      age = conflicts - canceled[v];
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .              next = order_heap.removeMin();
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .  
   30,950,936      0    0    15,475,468   6,827,235     3,450             0          0      0      return mkLit(next, polarity[next]);
   69,639,614      0    0    54,164,145      93,795         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
            .      .    .             .           .         .             .          .      .  {
            .      .    .             .           .         .             .          .      .  	ConflictData data;
            .      .    .             .           .         .             .          .      .  	Clause& conflCls = ca[cind];
            .      .    .             .           .         .             .          .      .  	data.nHighestLevel = level(var(conflCls[0]));
    2,353,326      0    0     1,176,663      10,670         0             0          0      0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
            .      .    .             .           .         .             .          .      .  	{
            .      .    .             .           .         .             .          .      .  		return data;
            .      .    .             .           .         .             .          .      .  	}
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  	int highestId = 0;
            .      .    .             .           .         .             .          .      .      data.bOnlyOneLitFromHighest = true;
            .      .    .             .           .         .             .          .      .  	// find the largest decision level in the clause
      412,828     59   21             0           0         0             0          0      0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
            .      .    .             .           .         .             .          .      .  	{
            .      .    .             .           .         .             .          .      .  		int nLevel = level(var(conflCls[nLitId]));
      278,659      0    0             0           0         0             0          0      0  		if (nLevel > data.nHighestLevel)
            .      .    .             .           .         .             .          .      .  		{
            .      .    .             .           .         .             .          .      .  			highestId = nLitId;
            .      .    .             .           .         .             .          .      .  			data.nHighestLevel = nLevel;
        1,349      0    0             0           0         0             0          0      0  			data.bOnlyOneLitFromHighest = true;
            .      .    .             .           .         .             .          .      .  		}
            .      .    .             .           .         .             .          .      .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
            .      .    .             .           .         .             .          .      .  		{
      271,914      0    0             0           0         0             0          0      0  			data.bOnlyOneLitFromHighest = false;
            .      .    .             .           .         .             .          .      .  		}
            .      .    .             .           .         .             .          .      .  	}
            .      .    .             .           .         .             .          .      .  
       34,554    485   23             0           0         0             0          0      0  	if (highestId != 0)
            .      .    .             .           .         .             .          .      .  	{
            .      .    .             .           .         .             .          .      .  		std::swap(conflCls[0], conflCls[highestId]);
        2,524      0    0             0           0         0             0          0      0  		if (highestId > 1)
            .      .    .             .           .         .             .          .      .  		{
        3,168      0    0             0           0         0             0          0      0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
            .      .    .             .           .         .             .          .      .  			//ws.smudge(~conflCls[highestId]);
            .      .    .             .           .         .             .          .      .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
            .      .    .             .           .         .             .          .      .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
            .      .    .             .           .         .             .          .      .  		}
            .      .    .             .           .         .             .          .      .  	}
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  	return data;
            .      .    .             .           .         .             .          .      .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
            .      .    .             .           .         .             .          .      .  |  
            .      .    .             .           .         .             .          .      .  |    Post-conditions:
            .      .    .             .           .         .             .          .      .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
            .      .    .             .           .         .             .          .      .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
            .      .    .             .           .         .             .          .      .  |        rest of literals. There may be others from the same level though.
            .      .    .             .           .         .             .          .      .  |  
            .      .    .             .           .         .             .          .      .  |________________________________________________________________________________________________@*/
            .      .    .             .           .         .             .          .      .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
    7,734,077    157   24             0           0         0     5,354,361          0      0  {
      594,929      0    0             0           0         0       594,929          0      0      int pathC = 0;
      594,929      0    0             0           0         0             0          0      0      Lit p     = lit_Undef;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Generate conflict clause:
            .      .    .             .           .         .             .          .      .      //
            .      .    .             .           .         .             .          .      .      out_learnt.push();      // (leave room for the asserting literal)
    1,189,858      0    0       594,929         674         0             0          0      0      int index   = trail.size() - 1;
      594,929      0    0       594,929           0         0             0          0      0      int nDecisionLevel = level(var(ca[confl][0]));
            .      .    .             .           .         .             .          .      .      assert(nDecisionLevel == level(var(ca[confl][0])));
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      do{
            .      .    .             .           .         .             .          .      .          assert(confl != CRef_Undef); // (otherwise should be UIP)
            .      .    .             .           .         .             .          .      .          Clause& c = ca[confl];
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
   96,604,534      0    0             0           0         0             0          0      0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
            .      .    .             .           .         .             .          .      .              assert(value(c[1]) == l_True);
            .      .    .             .           .         .             .          .      .              Lit tmp = c[0];
      201,423      0    0        67,141       3,505        11       134,282          0      0              c[0] = c[1], c[1] = tmp; }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          // Update LBD if improved.
   56,738,532      2    2       810,588          54         0             0          0      0          if (c.learnt() && c.mark() != CORE){
            .      .    .             .           .         .             .          .      .              int lbd = computeLBD(c);
    3,049,980      0    0             0           0         0             0          0      0              if (lbd < c.lbd()){
      303,952      0    0             0           0         0             0          0      0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
            .      .    .             .           .         .             .          .      .                  c.set_lbd(lbd);
      303,952      0    0       151,976      86,823         0             0          0      0                  if (lbd <= core_lbd_cut){
            6      3    3             0           0         0             3          0      0                      learnts_core.push(confl);
            .      .    .             .           .         .             .          .      .                      c.mark(CORE);
      374,007      0    0        51,573           0         0             0          0      0                  }else if (lbd <= 6 && c.mark() == LOCAL){
            .      .    .             .           .         .             .          .      .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
            .      .    .             .           .         .             .          .      .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
    4,211,295      5    4             0           0         0     1,213,254    442,724     14                      learnts_tier2.push(confl);
            .      .    .             .           .         .             .          .      .                      c.mark(TIER2); }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
    2,953,618      0    0     1,476,809       1,667         0             0          0      0              if (c.mark() == TIER2)
    3,024,092     26   18       756,023      70,845         0       756,023     81,799    130                  c.touched() = conflicts;
    1,464,968      0    0       732,484           0         0             0          0      0              else if (c.mark() == LOCAL)
            .      .    .             .           .         .             .          .      .                  claBumpActivity(c);
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .  
  468,658,790     15   11   143,973,802          52         0    24,214,404         12      0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
  119,759,398      0    0   119,759,398   6,529,861     1,132             0          0      0              Lit q = c[j];
            .      .    .             .           .         .             .          .      .  
  394,260,815      3    3   171,340,071  46,881,794     2,423             0          0      0              if (!seen[var(q)] && level(var(q)) > 0){
  103,153,384      0    0    51,576,692      15,540         0             0          0      0                  if (VSIDS){
            .      .    .             .           .         .             .          .      .                      varBumpActivity(var(q), .5);
           32      0    0             0           0         0            16          0      0                      add_tmp.push(q);
            .      .    .             .           .         .             .          .      .                  }else
   38,879,560      0    0    38,879,560  28,008,976     2,406             0          0      0                      conflicted[var(q)]++;
   51,576,692      0    0             0           0         0    51,576,692         32      0                  seen[var(q)] = 1;
  103,153,384      0    0    51,576,692          32         0             0          0      0                  if (level(var(q)) >= nDecisionLevel){
   48,428,808      0    0    48,428,808          40         0             0          0      0                      pathC++;
            .      .    .             .           .         .             .          .      .                  }else
            .      .    .             .           .         .             .          .      .                      out_learnt.push(q);
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          
            .      .    .             .           .         .             .          .      .          // Select next clause to look at:
            .      .    .             .           .         .             .          .      .  		do {
  449,363,088      0    0   184,588,116  18,713,215     7,420             0          0      0  			while (!seen[var(trail[index--])]);
            .      .    .             .           .         .             .          .      .  			p  = trail[index+1];
   48,447,686      0    0    24,223,843   1,443,513         0             0          0      0  		} while (level(var(p)) < nDecisionLevel);
            .      .    .             .           .         .             .          .      .  		
   48,428,808      0    0    24,214,404           0         0    24,214,404     27,917      0          confl = reason(var(p));
   24,214,404      0    0             0           0         0    24,214,404          0      0          seen[var(p)] = 0;
   48,428,808      0    0    48,428,808       1,024         0             0          0      0          pathC--;
            .      .    .             .           .         .             .          .      .  
  142,906,708      0    0    47,238,950      26,329         0             0          0      0      }while (pathC > 0);
      594,929      0    0       594,929       1,418         0             0          0      0      out_learnt[0] = ~p;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Simplify conflict clause:
            .      .    .             .           .         .             .          .      .      //
            .      .    .             .           .         .             .          .      .      int i, j;
    1,189,858      0    0             0           0         0       594,929          0      0      out_learnt.copyTo(analyze_toclear);
    1,784,787      0    0       594,929       1,097         0             0          0      0      if (ccmin_mode == 2){
      594,926    359   26             0           0         0             0          0      0          uint32_t abstract_level = 0;
   55,914,434    301   17             0           0         0             0          0      0          for (i = 1; i < out_learnt.size(); i++)
   28,552,140      0    0       594,926           0         0             0          0      0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
            .      .    .             .           .         .             .          .      .  
  197,485,276     13   10    81,491,938      10,240         0       594,926      4,629      0          for (i = j = 1; i < out_learnt.size(); i++)
  196,371,989      6    4    44,478,522   9,676,633         0    21,482,989          0      0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
   68,986,599      2    0    22,995,533      92,467         0    22,995,533    202,290      0                  out_learnt[j++] = out_learnt[i];
            .      .    .             .           .         .             .          .      .          
            .      .    .             .           .         .             .          .      .      }else if (ccmin_mode == 1){
            .      .    .             .           .         .             .          .      .          for (i = j = 1; i < out_learnt.size(); i++){
            .      .    .             .           .         .             .          .      .              Var x = var(out_learnt[i]);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              if (reason(x) == CRef_Undef)
            .      .    .             .           .         .             .          .      .                  out_learnt[j++] = out_learnt[i];
            .      .    .             .           .         .             .          .      .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
            .      .    .             .           .         .             .          .      .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
            .      .    .             .           .         .             .          .      .                          out_learnt[j++] = out_learnt[i];
            .      .    .             .           .         .             .          .      .                          break; }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }else
            .      .    .             .           .         .             .          .      .          i = j = out_learnt.size();
            .      .    .             .           .         .             .          .      .  
    1,189,858      0    0       594,929     492,849        15             0          0      0      max_literals += out_learnt.size();
   17,047,801      2    2     4,113,218           0         0             0          0      0      out_learnt.shrink(i - j);
      594,929    318   16       594,929           0         0             0          0      0      tot_literals += out_learnt.size();
            .      .    .             .           .         .             .          .      .  
    1,189,858      0    0       594,929      85,264         0       594,929      1,770      0      out_lbd = computeLBD(out_learnt);
    7,123,938  8,193   60     3,164,438       9,114         0             0          0      0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
    1,328,635 24,764   38       189,805           0         0       379,610          0      0          if (binResMinimize(out_learnt))
        1,692      0    0           564           0         0           564          0      0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Find correct backtrack level:
            .      .    .             .           .         .             .          .      .      //
    1,179,530      0    0             0           0         0             0          0      0      if (out_learnt.size() == 1)
            9      0    0             3           0         0             3          0      0          out_btlevel = 0;
            .      .    .             .           .         .             .          .      .      else{
    1,189,432      0    0             0           0         0             0          0      0          int max_i = 1;
            .      .    .             .           .         .             .          .      .          // Find the first literal assigned at the next-highest level:
   90,889,949      0    0             0           0         0             0          0      0          for (int i = 2; i < out_learnt.size(); i++)
   71,558,081      0    0    22,400,039      35,950         0             0          0      0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
            .      .    .             .           .         .             .          .      .                  max_i = i;
            .      .    .             .           .         .             .          .      .          // Swap-in this literal at index 1:
            .      .    .             .           .         .             .          .      .          Lit p             = out_learnt[max_i];
    1,189,852      3    0       594,926         259         0       594,926        152      0          out_learnt[max_i] = out_learnt[1];
      594,926      0    0             0           0         0       594,926          0      0          out_learnt[1]     = p;
    1,189,852      0    0       594,926       2,134         0       594,926      1,539      0          out_btlevel       = level(var(p));
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
    1,189,858  2,444   25       594,929      74,895         0             0          0      0      if (VSIDS){
   46,109,653  5,568   17    13,567,939      50,328         0             0          0      0          for (int i = 0; i < add_tmp.size(); i++){
            .      .    .             .           .         .             .          .      .              Var v = var(add_tmp[i]);
   38,091,396      0    0    12,697,132   3,536,660         0             0          0      0              if (level(v) >= out_btlevel - 1)
            .      .    .             .           .         .             .          .      .                  varBumpActivity(v, 1);
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          add_tmp.clear();
            .      .    .             .           .         .             .          .      .      }else{
      609,320      0    0       304,660         121         0       304,660     21,623      0          seen[var(p)] = true;
   57,316,517      0    0       304,660           0         0             0          0      0          for(int i = out_learnt.size() - 1; i >= 0; i--){
            .      .    .             .           .         .             .          .      .              Var v = var(out_learnt[i]);
            .      .    .             .           .         .             .          .      .              CRef rea = reason(v);
   35,976,838      0    0             0           0         0             0          0      0              if (rea != CRef_Undef){
            .      .    .             .           .         .             .          .      .                  const Clause& reaC = ca[rea];
  278,022,716      0    0             0           0         0             0          0      0                  for (int i = 0; i < reaC.size(); i++){
            .      .    .             .           .         .             .          .      .                      Lit l = reaC[i];
  225,652,692      0    0   112,826,346   8,813,422       173             0          0      0                      if (!seen[var(l)]){
   36,138,483      0    0             0           0         0    36,138,483          0      0                          seen[var(l)] = true;
   36,138,483      0    0    36,138,483  27,759,860     2,910             0          0      0                          almost_conflicted[var(l)]++;
            .      .    .             .           .         .             .          .      .                          analyze_toclear.push(l); } } } } }
            .      .    .             .           .         .             .          .      .  
  287,880,793  2,756   19   143,048,003           0         0    71,226,537  2,174,083      0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
    4,759,432      0    0     4,164,503     272,581         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  // Try further learnt clause minimization by means of binary clause resolution.
            .      .    .             .           .         .             .          .      .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
       78,225      0    0             0           0         0        62,580        114      0  {
            .      .    .             .           .         .             .          .      .      // Preparation: remember which false variables we have in 'out_learnt'.
      569,415     10    7       189,805           0         0       189,805          0      0      counter++;
    4,304,202      0    0       379,610           0         0             0          0      0      for (int i = 1; i < out_learnt.size(); i++)
    1,583,107      0    0       189,802           0         0     1,393,305  1,311,266 39,552          seen2[var(out_learnt[i])] = counter;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Get the list of binary clauses containing 'out_learnt[0]'.
            .      .    .             .           .         .             .          .      .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
            .      .    .             .           .         .             .          .      .  
       15,645      0    0             0           0         0             0          0      0      int to_remove = 0;
      825,715      4    2       189,805      90,259         1           564          0      0      for (int i = 0; i < ws.size(); i++){
       56,092      0    0        56,092      12,157         0             0          0      0          Lit the_other = ws[i].blocker;
            .      .    .             .           .         .             .          .      .          // Does 'the_other' appear negatively in 'out_learnt'?
      225,504     21   14        97,675      30,007     1,393             0          0      0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
          568      0    0             0           0         0             0          0      0              to_remove++;
        1,704      0    0             0           0         0           568          0      0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Shrink.
       46,935     27    8             0           0         0             0          0      0      if (to_remove > 0){
          564      0    0             0           0         0             0          0      0          int last = out_learnt.size() - 1;
       43,261    233   25           564           0         0             0          0      0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
       11,852      0    0         5,926           0         0             0          0      0              if (seen2[var(out_learnt[i])] != counter)
        2,675      0    0         1,070           0         0           535          0      0                  out_learnt[i--] = out_learnt[last--];
            .      .    .             .           .         .             .          .      .          out_learnt.shrink(to_remove);
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .      return to_remove != 0;
      252,385      1    1       252,385           0         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
            .      .    .             .           .         .             .          .      .  // visiting literals at levels that cannot be removed later.
            .      .    .             .           .         .             .          .      .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
  214,829,890 28,708    5             0           0         0   128,897,934    322,993      0  {
   42,965,978      0    0             0           0         0    21,482,989          0      0      analyze_stack.clear(); analyze_stack.push(p);
   64,448,967      0    0    42,965,978       2,518         0    21,482,989          0      0      int top = analyze_toclear.size();
  275,958,476      0    0             0           0         0             0          0      0      while (analyze_stack.size() > 0){
            .      .    .             .           .         .             .          .      .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
            .      .    .             .           .         .             .          .      .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          // Special handling for binary clauses like in 'analyze()'.
  295,754,228     27   19             0           0         0             0          0      0          if (c.size() == 2 && value(c[0]) == l_False){
            .      .    .             .           .         .             .          .      .              assert(value(c[1]) == l_True);
            .      .    .             .           .         .             .          .      .              Lit tmp = c[0];
      215,745      0    0        71,915       4,355        18       143,830          0      0              c[0] = c[1], c[1] = tmp; }
            .      .    .             .           .         .             .          .      .  
1,098,144,668      0    0             0           0         0             0          0      0          for (int i = 1; i < c.size(); i++){
  446,840,716    292   25   446,840,716  27,311,499     6,893             0          0      0              Lit p  = c[i];
1,727,092,622      0    0   893,681,432  21,514,010       796             0          0      0              if (!seen[var(p)] && level(var(p)) > 0){
  745,163,988      0    0   193,267,992           0         0             0          0      0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
  176,151,758      0    0             0           0         0   176,151,758          0      0                      seen[var(p)] = 1;
            .      .    .             .           .         .             .          .      .                      analyze_stack.push(p);
            7      0    0             0           0         0             0          0      0                      analyze_toclear.push(p);
            .      .    .             .           .         .             .          .      .                  }else{
  738,096,021  1,170   37   203,253,389      81,314         0             0          0      0                      for (int j = top; j < analyze_toclear.size(); j++)
  324,568,703      0    0   155,547,782           0         0   169,020,921  1,534,364      0                          seen[var(analyze_toclear[j])] = 0;
   34,232,468     29   14    17,116,234           0         0             0          0      0                      analyze_toclear.shrink(analyze_toclear.size() - top);
   17,116,234      0    0             0           0         0             0          0      0                      return false;
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
    8,733,510      0    0             0           0         0             0          0      0      return true;
  171,863,912      0    0   150,380,923     101,203         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  /*_________________________________________________________________________________________________
            .      .    .             .           .         .             .          .      .  |
            .      .    .             .           .         .             .          .      .  |  analyzeFinal : (p : Lit)  ->  [void]
            .      .    .             .           .         .             .          .      .  |  
            .      .    .             .           .         .             .          .      .  |  Description:
            .      .    .             .           .         .             .          .      .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      seen[var(p)] = 0;
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
1,105,036,390      6    6             0           0         0   552,518,195          0      0  {
            .      .    .             .           .         .             .          .      .      assert(value(p) == l_Undef);
            .      .    .             .           .         .             .          .      .      Var x = var(p);
  221,007,278      0    0   110,503,639     142,153         9             0          0      0      if (!VSIDS){
  207,275,553      0    0   138,183,702     154,984        17    69,091,851 60,704,448 23,733          picked[x] = conflicts;
  138,183,702      0    0    69,091,851           0         0    69,091,851 60,288,098 22,920          conflicted[x] = 0;
  138,183,702      2    2    69,091,851           0         0    69,091,851 60,691,603 22,199          almost_conflicted[x] = 0;
            .      .    .             .           .         .             .          .      .  #ifdef ANTI_EXPLORATION
   69,091,851      0    0    69,091,851           0         0             0          0      0          uint32_t age = conflicts - canceled[var(p)];
  138,183,702      0    0    69,091,851  59,816,070    20,307             0          0      0          if (age > 0){
            .      .    .             .           .         .             .          .      .              double decay = pow(0.95, age);
   62,332,514      0    0    31,166,257  26,450,124    16,061    31,166,257          0      0              activity_CHB[var(p)] *= decay;
            .      .    .             .           .         .             .          .      .              if (order_heap_CHB.inHeap(var(p)))
   31,166,257      0    0             0           0         0             0          0      0                  order_heap_CHB.increase(var(p));
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
  110,503,639      1    1   110,503,639         294         8             0          0      0      assigns[x] = lbool(!sign(p));
  221,007,278      0    0             0           0         0   221,007,278 93,073,078 71,061      vardata[x] = mkVarData(from, level);
  110,503,639      4    4   110,503,639           0         0             0          0      0      trail.push_(p);
  773,525,473      0    0   663,021,834         223         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  unsigned number_watch_changed_total=0;
            .      .    .             .           .         .             .          .      .  unsigned number_clause_read_total=0;
            .      .    .             .           .         .             .          .      .  unsigned times_only_access_watch=0;
            .      .    .             .           .         .             .          .      .  /*_________________________________________________________________________________________________
            .      .    .             .           .         .             .          .      .  |
            .      .    .             .           .         .             .          .      .  |  propagate : [void]  ->  [Clause*]
            .      .    .             .           .         .             .          .      .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
            .      .    .             .           .         .             .          .      .  |  Description:
            .      .    .             .           .         .             .          .      .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
            .      .    .             .           .         .             .          .      .  |    otherwise CRef_Undef.
            .      .    .             .           .         .             .          .      .  |  
            .      .    .             .           .         .             .          .      .  |    Post-conditions:
            .      .    .             .           .         .             .          .      .  |      * the propagation queue is empty, even if there was a conflict.
            .      .    .             .           .         .             .          .      .  |________________________________________________________________________________________________@*/
            .      .    .             .           .         .             .          .      .  CRef Solver::propagate_()
   66,729,040      5    5             0           0         0    50,046,780          0      0  {
            .      .    .             .           .         .             .          .      .      //auto start_time=std::chrono::steady_clock::now();
    8,341,130      0    0             0           0         0     8,341,130          0      0      CRef    confl     = CRef_Undef;
    8,341,130      0    0             0           0         0     8,341,130         33      0      int     num_props = 0;
   16,682,260      0    0             0           0         0     8,341,130     61,143      2      watches.cleanAll();
   16,682,260      5    5             0           0         0     8,341,130          0      0      watches_bin.cleanAll();
            .      .    .             .           .         .             .          .      .      
  395,878,243      1    1   276,388,084      63,031         2             0          0      0      while (qhead < trail.size()){
  523,636,960      0    0   209,454,784   1,006,436         1   104,727,392          0      0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
            .      .    .             .           .         .             .          .      .          int currLevel = level(var(p));
            .      .    .             .           .         .             .          .      .          vec<Watcher>&  ws  = watches[p];
            .      .    .             .           .         .             .          .      .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          Watcher        *i, *j, *end;
  154,988,150      0    0   154,988,150     219,446         0             0          0      0          num_props++;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
            .      .    .             .           .         .             .          .      .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
  335,359,251      5    5   104,727,392 102,968,743   267,300             0          0      0          for (int k = 0; k < ws_bin.size(); k++){
    9,269,895      0    0     9,269,895   3,503,806    15,177             0          0      0              Lit the_other = ws_bin[k].blocker;
1,240,847,131      0    0 1,212,443,164           0         0             0          0      0              if (value(the_other) == l_False){
       19,436      0    0         9,718           0         0         9,718          0      0                  confl = ws_bin[k].cref;
            .      .    .             .           .         .             .          .      .                  //auto end_time=std::chrono::steady_clock::now();
            .      .    .             .           .         .             .          .      .                  //auto duration=end_time-start_time;
            .      .    .             .           .         .             .          .      .  #ifdef LOOSE_PROP_STAT
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                  return confl;
            .      .    .             .           .         .             .          .      .  #else
            .      .    .             .           .         .             .          .      .                  goto ExitProp;
            .      .    .             .           .         .             .          .      .  #endif
   11,926,616      8    6             0           0         0             0          0      0              }else if(value(the_other) == l_Undef)
            .      .    .             .           .         .             .          .      .              {
   13,733,940      2    2     8,240,364          29         0     2,746,788          0      0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
            .      .    .             .           .         .             .          .      .  #ifdef  PRINT_OUT                
            .      .    .             .           .         .             .          .      .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
            .      .    .             .           .         .             .          .      .  #endif                
            .      .    .             .           .         .             .          .      .  			}
            .      .    .             .           .         .             .          .      .          }
  209,435,348      0    0   209,435,348  91,122,305    96,724             0          0      0          total_Watchers+=ws.size();
  104,717,674      0    0   104,717,674           0         0             0          0      0          total_indexs++;//number of rounds
            .      .    .             .           .         .             .          .      .          //int count=0;
  100,713,564      0    0             0           0         0             0          0      0          bool no_clause_access=true;
  100,713,564      0    0             0           0         0   100,713,564          0      0          bool no_implication_added=true;
  100,713,564      0    0             0           0         0   100,713,564          0      0          bool no_change_other_watch=true;
3,956,154,130     11   11 1,770,643,772           0         0   104,717,674          0      0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
            .      .    .             .           .         .             .          .      .              // Try to avoid inspecting the clause:
            .      .    .             .           .         .             .          .      .              //count++;
1,665,926,098      3    3 1,665,926,098 284,347,184 1,298,817             0          0      0              Lit blocker = i->blocker;
3,331,852,196      0    0 1,665,926,098     500,416        25             0          0      0              total_access_watches++;
3,331,852,196      0    0 1,665,926,098  75,069,506     4,844             0          0      0              if (value(blocker) == l_True){
            .      .    .             .           .         .             .          .      .                  
4,397,882,168      0    0 1,099,470,542           0         0 1,099,470,542    123,103      0                  *j++ = *i++; continue; }//no clause accessed
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Make sure the false literal is data[1]:
  569,566,167      0    0       504,680           0         0             0          0      0              no_clause_access=false;
1,699,366,668      4    4 1,132,911,112     490,683        25   566,455,556          0      0              total_clause_access_times++;
1,132,911,112      0    0   566,455,556           0         0             0          0      0              CRef     cr        = i->cref;
            .      .    .             .           .         .             .          .      .              //std::cout<<"cr: "<<cr<<"\n";
            .      .    .             .           .         .             .          .      .              Clause&  c         = ca[cr];
            .      .    .             .           .         .             .          .      .              Lit      false_lit = ~p;
  566,455,556      0    0   566,455,556           0         0             0          0      0              total_clause_access_size+=2;
1,699,366,668      0    0 1,132,911,112 464,979,937 1,819,713             0          0      0              if (c[0] == false_lit)
1,020,035,096      0    0   510,017,548  11,879,592    64,840   510,017,548          0      0                  c[0] = c[1], c[1] = false_lit;
            .      .    .             .           .         .             .          .      .              assert(c[1] == false_lit);
            .      .    .             .           .         .             .          .      .              i++;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // If 0th watch is true, then clause is already satisfied.
            .      .    .             .           .         .             .          .      .              Lit     first = c[0];
            .      .    .             .           .         .             .          .      .              Watcher w     = Watcher(cr, first);
1,426,113,572      0    0   146,601,230   4,367,210       427             0          0      0              if (first != blocker && value(first) == l_True){
  338,917,866      0    0             0           0         0   225,945,244     47,380      0                  *j++ = w; continue; }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Look for new watch:
3,167,970,408      2    2             0           0         0             0          0      0              for (int k = 2; k < c.size(); k++)
            .      .    .             .           .         .             .          .      .              {
5,220,495,285      0    0             0           0         0 1,107,140,799          0      0                  total_clause_access_size++;
3,382,557,489      0    0   261,310,023           0         0             0          0      0                  if (value(c[k]) != l_False){
1,413,890,476  6,601    1   706,945,238           0         0   706,945,238          0      0                      c[1] = c[k]; c[k] = false_lit;
  353,472,619      0    0   353,472,619           0         0             0          0      0                      total_change_other_watch++;
  353,472,619      0    0             0           0         0   353,472,619        209      0                      no_change_other_watch=false;
            .      .    .             .           .         .             .          .      .                      watches[~c[1]].push(w);
            .      .    .             .           .         .             .          .      .                      goto NextClause; }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Did not find watch -- clause is unit under assignment:
  300,618,156      0    0             0           0         0   200,020,630     22,611      0              *j++ = w;
  200,020,630      0    0             0           0         0             0          0      0              if (value(first) == l_False){
      587,211      0    0       587,211       9,441         0             0          0      0                  time_find_conflict++;
    3,523,266     34    3     2,348,844       9,031         0             0          0      0                  total_find_conflict_length+=i-(Watcher*)ws;
    1,174,422      0    0     1,174,422           0         0             0          0      0                  total_find_conflict_allsize+=ws.size();
            .      .    .             .           .         .             .          .      .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
      587,211      0    0             0           0         0       587,211          0      0                  confl = cr;
    1,174,422      0    0       587,211           0         0       587,211      1,409      0                  qhead = trail.size();
            .      .    .             .           .         .             .          .      .                  // Copy the remaining watches:
            .      .    .             .           .         .             .          .      .  
   25,343,471      5    3     1,091,891           0         0             0          0      0                  while (i < end)
   11,286,239      0    0    11,286,239   1,324,766     8,848    11,286,239     15,885      0                      *j++ = *i++;
            .      .    .             .           .         .             .          .      .              }else
            .      .    .             .           .         .             .          .      .              {//new implecate
   99,423,104      0    0             0           0         0    99,423,104         56      0                  no_implication_added=false;
   99,423,104      0    0    99,423,104     487,816        18             0          0      0                  total_push_new_implication++;
  298,269,312      0    0   198,846,208      33,928         0             0          0      0  				if (currLevel == decisionLevel())
            .      .    .             .           .         .             .          .      .  				{
  198,846,208      0    0             0           0         0             0          0      0  					uncheckedEnqueue(first, currLevel, cr);
            .      .    .             .           .         .             .          .      .  #ifdef PRINT_OUT					
            .      .    .             .           .         .             .          .      .  					std::cout << "i " << first << " l " << currLevel << "\n";
            .      .    .             .           .         .             .          .      .  #endif					
            .      .    .             .           .         .             .          .      .  				}
            .      .    .             .           .         .             .          .      .  				else
            .      .    .             .           .         .             .          .      .  				{
            .      .    .             .           .         .             .          .      .  					int nMaxLevel = currLevel;
    2,276,002      0    0             0           0         0             0          0      0  					int nMaxInd = 1;
            .      .    .             .           .         .             .          .      .  					// pass over all the literals in the clause and find the one with the biggest level
   12,288,104      0    0     1,138,001           0         0             0          0      0  					for (int nInd = 2; nInd < c.size(); ++nInd)
            .      .    .             .           .         .             .          .      .  					{
            .      .    .             .           .         .             .          .      .  						int nLevel = level(var(c[nInd]));
    7,826,756      0    0             0           0         0             0          0      0  						if (nLevel > nMaxLevel)
            .      .    .             .           .         .             .          .      .  						{
            .      .    .             .           .         .             .          .      .  							nMaxLevel = nLevel;
            .      .    .             .           .         .             .          .      .  							nMaxInd = nInd;
            .      .    .             .           .         .             .          .      .  						}
            .      .    .             .           .         .             .          .      .  					}
            .      .    .             .           .         .             .          .      .  
    2,276,002      1    1             0           0         0             0          0      0  					if (nMaxInd != 1)
            .      .    .             .           .         .             .          .      .  					{
            .      .    .             .           .         .             .          .      .  						std::swap(c[1], c[nMaxInd]);
            .      .    .             .           .         .             .          .      .  						*j--; // undo last watch
       43,022      0    0        43,022           0         0             0          0      0                          total_change_other_watch++;
       43,022      0    0             0           0         0        43,022          0      0                          no_change_other_watch=false;
            .      .    .             .           .         .             .          .      .  						watches[~c[1]].push(w);
            .      .    .             .           .         .             .          .      .  					}
            .      .    .             .           .         .             .          .      .  					
  498,253,521      0    0    99,423,104           0         0    99,423,104          0      0  					uncheckedEnqueue(first, nMaxLevel, cr);
            .      .    .             .           .         .             .          .      .  #ifdef PRINT_OUT					
            .      .    .             .           .         .             .          .      .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
            .      .    .             .           .         .             .          .      .  #endif	
            .      .    .             .           .         .             .          .      .  				}
            .      .    .             .           .         .             .          .      .  			}
            .      .    .             .           .         .             .          .      .  
      504,680     35   17             0           0         0             0          0      0  NextClause:;
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
  503,567,820      0    0   100,713,564           0         0             0          0      0          if(no_clause_access==true){
   19,759,930    255   19    19,759,930      18,968         2             0          0      0              total_no_clause_access++;
            .      .    .             .           .         .             .          .      .          }
  217,182,948    175   22   100,713,564           0         0             0          0      0          if(no_implication_added==true){
   43,152,144      3    2    39,148,034     140,978         4             0          0      0              total_no_implication_added++;
            .      .    .             .           .         .             .          .      .          }
  219,888,040      0    0   100,713,564           0         0             0          0      0          if(no_change_other_watch==true){
   54,447,198    177    6    54,447,198          85         0             0          0      0              total_no_change_other_watch++;
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          ws.shrink(i - j);
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  ExitProp:;
   16,662,824      5    5    16,662,824     416,560         0             0          0      0      propagations += num_props;
    8,331,412      0    0     8,331,412           0         0             0          0      0      simpDB_props -= num_props;
            .      .    .             .           .         .             .          .      .  
    8,331,412      0    0     8,331,412           0         0             0          0      0      return confl;
  258,901,951  4,227    5    58,387,910     711,835         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  /*_________________________________________________________________________________________________
            .      .    .             .           .         .             .          .      .  |
            .      .    .             .           .         .             .          .      .  |  reduceDB : ()  ->  [void]
            .      .    .             .           .         .             .          .      .  |  
            .      .    .             .           .         .             .          .      .  |  Description:
            .      .    .             .           .         .             .          .      .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
            .      .    .             .           .         .             .          .      .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
            .      .    .             .           .         .             .          .      .  |________________________________________________________________________________________________@*/
            .      .    .             .           .         .             .          .      .  struct reduceDB_lt { 
            .      .    .             .           .         .             .          .      .      ClauseAllocator& ca;
            .      .    .             .           .         .             .          .      .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
   22,958,182     78   45    22,518,130   6,964,787    43,417             0          0      0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
            .      .    .             .           .         .             .          .      .  };
            .      .    .             .           .         .             .          .      .  void Solver::reduceDB()
          234     39   23             0           0         0           156          0      0  {
            .      .    .             .           .         .             .          .      .      int     i, j;
            .      .    .             .           .         .             .          .      .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
            .      .    .             .           .         .             .          .      .      //local_learnts_dirty = false;
            .      .    .             .           .         .             .          .      .  
           39      0    0             0           0         0             0          0      0      sort(learnts_local, reduceDB_lt(ca));
            .      .    .             .           .         .             .          .      .  
          195      0    0            39          39         0             0          0      0      int limit = learnts_local.size() / 2;
    1,912,187     39   23             0           0         0             0          0      0      for (i = j = 0; i < learnts_local.size(); i++){
    2,867,988     39   24     1,911,992      59,767         0             0          0      0          Clause& c = ca[learnts_local[i]];
    1,911,992      0    0       955,996     947,197     1,827             0          0      0          if (c.mark() == LOCAL)
    3,627,656      0    0       939,749           0         0             0          0      0              if (c.removable() && !locked(c) && i < limit)
    2,360,135      0    0       472,027           0         0       472,027          0      0                  removeClause(learnts_local[i]);
            .      .    .             .           .         .             .          .      .              else{
       65,037      0    0             0           0         0             0          0      0                  if (!c.removable()) limit++;
            .      .    .             .           .         .             .          .      .                  c.removable(true);
    2,371,104      0    0       467,722           0         0       467,722     29,344      0                  learnts_local[j++] = learnts_local[i]; }
            .      .    .             .           .         .             .          .      .      }
           39      0    0             0           0         0             0          0      0      learnts_local.shrink(i - j);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      checkGarbage();
          221      0    0           182          39         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  void Solver::reduceDB_Tier2()
          354     59   23             0           0         0           295          0      0  {
            .      .    .             .           .         .             .          .      .      int i, j;
    1,920,620     57   22            59          47         0             0          0      0      for (i = j = 0; i < learnts_tier2.size(); i++){
    2,327,835     59   22     1,551,890      48,547     6,831             0          0      0          Clause& c = ca[learnts_tier2[i]];
    1,551,890      0    0             0           0         0             0          0      0          if (c.mark() == TIER2)
    3,723,990     52   19     1,489,596     461,406    50,774             0          0      0              if (!locked(c) && c.touched() + 30000 < conflicts){
            .      .    .             .           .         .             .          .      .                  learnts_local.push(learnts_tier2[i]);
            .      .    .             .           .         .             .          .      .                  c.mark(LOCAL);
            .      .    .             .           .         .             .          .      .                  //c.removable(true);
            .      .    .             .           .         .             .          .      .                  c.activity() = 0;
            .      .    .             .           .         .             .          .      .                  claBumpActivity(c);
            .      .    .             .           .         .             .          .      .              }else
    2,958,785      0    0       591,757           0         0       591,757     32,039      0                  learnts_tier2[j++] = learnts_tier2[i];
            .      .    .             .           .         .             .          .      .      }
           59      0    0             0           0         0             0          0      0      learnts_tier2.shrink(i - j);
          354      0    0           354          59         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::removeSatisfied(vec<CRef>& cs)
           90      0    0             0           0         0            40          0      0  {
            .      .    .             .           .         .             .          .      .      int i, j;
   14,884,573      6    6     2,976,919           6         0             0          0      0      for (i = j = 0; i < cs.size(); i++){
    8,930,724      0    0     5,953,816     186,064   166,713             0          0      0          Clause& c = ca[cs[i]];
            .      .    .             .           .         .             .          .      .          if (satisfied(c))
          202      5    5             1           0         0            67         18      0              removeClause(cs[i]);
            .      .    .             .           .         .             .          .      .          else
    5,953,682      0    0             0           0         0     2,976,841          0      0              cs[j++] = cs[i];
            .      .    .             .           .         .             .          .      .      }
           10      0    0             0           0         0             0          0      0      cs.shrink(i - j);
           60      1    1            50           8         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
           72      0    0             0           0         0            60          0      0  {
            .      .    .             .           .         .             .          .      .      int i, j;
      272,556      5    5            12           6         0             0          0      0      for (i = j = 0; i < cs.size(); i++){
      401,718      0    0       267,812       8,376     5,154             0          0      0          Clause& c = ca[cs[i]];
      267,812      0    0             0           0         0             0          0      0          if (c.mark() == valid_mark)
            .      .    .             .           .         .             .          .      .              if (satisfied(c))
           24      1    1             6           0         0             6          3      0                  removeClause(cs[i]);
            .      .    .             .           .         .             .          .      .              else
      657,910      0    0       131,582           0         0       131,582      1,812      0                  cs[j++] = cs[i];
            .      .    .             .           .         .             .          .      .      }
           10      0    0             0           0         0             0          0      0      cs.shrink(i - j);
           72      5    5            72          10         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::rebuildOrderHeap()
           63      3    3             0           0         0            42          0      0  {
            .      .    .             .           .         .             .          .      .      vec<Var> vs;
    1,009,120      0    0             7           0         0             7          1      0      for (Var v = 0; v < nVars(); v++)
    2,749,128      0    0     1,374,564      15,728     7,313             0          0      0          if (decision[v] && value(v) == l_Undef)
            .      .    .             .           .         .             .          .      .              vs.push(v);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      order_heap_CHB  .build(vs);
            .      .    .             .           .         .             .          .      .      order_heap_VSIDS.build(vs);
            .      .    .             .           .         .             .          .      .      order_heap_distance.build(vs);
           56      7    7            49           7         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  /*_________________________________________________________________________________________________
            .      .    .             .           .         .             .          .      .  |
            .      .    .             .           .         .             .          .      .  |  simplify : [void]  ->  [bool]
            .      .    .             .           .         .             .          .      .  |  
            .      .    .             .           .         .             .          .      .  |  Description:
            .      .    .             .           .         .             .          .      .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
            .      .    .             .           .         .             .          .      .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
            .      .    .             .           .         .             .          .      .  |________________________________________________________________________________________________@*/
            .      .    .             .           .         .             .          .      .  bool Solver::simplify()
       16,092    497    9             0           0         0        10,728          0      0  {
            .      .    .             .           .         .             .          .      .      assert(decisionLevel() == 0);
            .      .    .             .           .         .             .          .      .  
       13,410      0    0         2,682       2,654         1             0          0      0      if (!ok || propagate() != CRef_Undef)
            .      .    .             .           .         .             .          .      .          return ok = false;
            .      .    .             .           .         .             .          .      .  
        8,146    465   26         5,414           0         0             0          0      0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
            .      .    .             .           .         .             .          .      .          return true;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Remove satisfied clauses:
           18      0    0             0           0         0             6          0      0      removeSatisfied(learnts_core); // Should clean core first.
           24      0    0             0           0         0             6          0      0      safeRemoveSatisfied(learnts_tier2, TIER2);
           24      6    6             0           0         0             6          0      0      safeRemoveSatisfied(learnts_local, LOCAL);
           12      0    0             6           6         1             0          0      0      if (remove_satisfied)        // Can be turned off.
           20     10   10             0           0         0             5          0      0          removeSatisfied(clauses);
            .      .    .             .           .         .             .          .      .      checkGarbage();
           12      1    1             0           0         0             6          0      0      rebuildOrderHeap();
            .      .    .             .           .         .             .          .      .  
           12      0    0             6           6         2             6          6      0      simpDB_assigns = nAssigns();
           18      0    0            12          12         1             6          0      0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
            .      .    .             .           .         .             .          .      .  
            6      0    0             0           0         0             0          0      0      return true;
       18,774      0    0        13,410           7         1             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  // pathCs[k] is the number of variables assigned at level k,
            .      .    .             .           .         .             .          .      .  // it is initialized to 0 at the begining and reset to 0 after the function execution
       76,816      4    3             0           0         0        57,612          0      0  bool Solver::collectFirstUIP(CRef confl){
       19,204      0    0             0           0         0         9,602          0      0      involved_lits.clear();
      478,502      5    3             0           0         0             0          0      0      int max_level=1;
            .      .    .             .           .         .             .          .      .      Clause& c=ca[confl]; int minLevel=decisionLevel();
      139,234      0    0         9,602           0         0             0          0      0      for(int i=0; i<c.size(); i++) {
            .      .    .             .           .         .             .          .      .          Var v=var(c[i]);
            .      .    .             .           .         .             .          .      .          //        assert(!seen[v]);
      136,836     27    2        45,612      14,881         0             0          0      0          if (level(v)>0) {
       91,224      0    0        45,612       7,221         1        45,612     35,422     25              seen[v]=1;
      100,826      0    0        55,214      15,204         1        45,612     43,814  2,419              var_iLevel_tmp[v]=1;
       45,612      0    0        45,612      27,435       506             0          0      0              pathCs[level(v)]++;
            .      .    .             .           .         .             .          .      .              if (minLevel>level(v)) {
            .      .    .             .           .         .             .          .      .                  minLevel=level(v);
            .      .    .             .           .         .             .          .      .                  assert(minLevel>0);
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              //    varBumpActivity(v);
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
       28,806      0    0        19,204       9,329         0             0          0      0      int limit=trail_lim[minLevel-1];
  209,083,340      0    0         9,602           0         0             0          0      0      for(int i=trail.size()-1; i>=limit; i--) {
  104,522,466     71    2   104,522,466   3,247,544         0             0          0      0          Lit p=trail[i]; Var v=var(p);
  104,522,466      0    0    52,261,233  14,894,791     1,441             0          0      0          if (seen[v]) {
            .      .    .             .           .         .             .          .      .              int currentDecLevel=level(v);
            .      .    .             .           .         .             .          .      .              //      if (currentDecLevel==decisionLevel())
            .      .    .             .           .         .             .          .      .              //      	varBumpActivity(v);
      369,521      0    0             0           0         0       369,521          0      0              seen[v]=0;
      739,042      0    0       369,521      83,244         0             0          0      0              if (--pathCs[currentDecLevel]!=0) {
            .      .    .             .           .         .             .          .      .                  Clause& rc=ca[reason(v)];
      889,790      5    3       631,335      34,117         0             0          0      0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
      420,890      0    0             0           0         0             0          0      0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
      474,604      0    0             0           0         0             0          0      0                  if (rc.size()==2 && value(rc[0])==l_False) {
            .      .    .             .           .         .             .          .      .                      // Special case for binary clauses
            .      .    .             .           .         .             .          .      .                      // The first one has to be SAT
            .      .    .             .           .         .             .          .      .                      assert(value(rc[1]) != l_False);
            .      .    .             .           .         .             .          .      .                      Lit tmp = rc[0];
        7,194      0    0         2,398         103         4         4,796          0      0                      rc[0] =  rc[1], rc[1] = tmp;
            .      .    .             .           .         .             .          .      .                  }
    1,663,572      0    0             0           0         0             0          0      0                  for (int j = 1; j < rc.size(); j++){
            .      .    .             .           .         .             .          .      .                      Lit q = rc[j]; Var v1=var(q);
    1,296,396      0    0             0           0         0             0          0      0                      if (level(v1) > 0) {
    1,296,396      0    0             0           0         0             0          0      0                          if (minLevel>level(v1)) {
       87,020      0    0        43,510      20,402         0             0          0      0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
            .      .    .             .           .         .             .          .      .                          }
    1,944,594      0    0     1,296,396      62,607        51             0          0      0                          if (seen[v1]) {
      648,578      0    0       324,289      37,839         0             0          0      0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
      383,344      0    0             0           0         0       191,672          0      0                                  var_iLevel_tmp[v1]=reasonVarLevel;
            .      .    .             .           .         .             .          .      .                          }
            .      .    .             .           .         .             .          .      .                          else {
      323,909      0    0             0           0         0       323,909    274,693 10,217                              var_iLevel_tmp[v1]=reasonVarLevel;
            .      .    .             .           .         .             .          .      .                              //   varBumpActivity(v1);
      323,909      0    0             0           0         0       323,909          0      0                              seen[v1] = 1;
      971,727      4    1       647,818     111,210       194             0          0      0                              pathCs[level(v1)]++;
            .      .    .             .           .         .             .          .      .                          }
            .      .    .             .           .         .             .          .      .                      }
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              involved_lits.push(p);
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
       28,806  2,061    1         9,602          20         0         9,602          0      0      double inc=var_iLevel_inc;
            .      .    .             .           .         .             .          .      .      vec<int> level_incs; level_incs.clear();
      431,061      0    0       160,902           0         0             0          0      0      for(int i=0;i<max_level;i++){
      180,106      4    1        90,053           0         0             0          0      0          level_incs.push(inc);
      270,159      0    0       180,106           7         0        90,053          0      0          inc = inc/my_var_decay;
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
      777,450      0    0       379,123           0         0             0          0      0      for(int i=0;i<involved_lits.size();i++){
        9,602      0    0         9,602           0         0             0          0      0          Var v =var(involved_lits[i]);
            .      .    .             .           .         .             .          .      .          //        double old_act=activity_distance[v];
            .      .    .             .           .         .             .          .      .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
    3,479,321  6,475    3     1,146,971     623,727     3,481       379,123          0      0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
            .      .    .             .           .         .             .          .      .  
      739,042      0    0             0           0         0             0          0      0          if(activity_distance[v]>1e100){
            .      .    .             .           .         .             .          .      .              for(int vv=0;vv<nVars();vv++)
       48,010    369    1        19,204      19,070         2        19,204          0      0                  activity_distance[vv] *= 1e-100;
            .      .    .             .           .         .             .          .      .              var_iLevel_inc*=1e-100;
       19,536     31    2             0           0         0             0          0      0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .          if (order_heap_distance.inHeap(v))
            .      .    .             .           .         .             .          .      .              order_heap_distance.decrease(v);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          //        var_iLevel_inc *= (1 / my_var_decay);
            .      .    .             .           .         .             .          .      .      }
       48,010    505    1        19,204           0         0         9,602        765      0      var_iLevel_inc=level_incs[level_incs.size()-1];
            .      .    .             .           .         .             .          .      .      return true;
       86,418      0    0        67,214       8,897         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  struct UIPOrderByILevel_Lt {
            .      .    .             .           .         .             .          .      .      Solver& solver;
            .      .    .             .           .         .             .          .      .      const vec<double>&  var_iLevel;
            .      .    .             .           .         .             .          .      .      bool operator () (Lit x, Lit y) const
            .      .    .             .           .         .             .          .      .      {
            .      .    .             .           .         .             .          .      .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
            .      .    .             .           .         .             .          .      .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
            .      .    .             .           .         .             .          .      .  |    Search for a model the specified number of conflicts. 
            .      .    .             .           .         .             .          .      .  |  
            .      .    .             .           .         .             .          .      .  |  Output:
            .      .    .             .           .         .             .          .      .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
            .      .    .             .           .         .             .          .      .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
            .      .    .             .           .         .             .          .      .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
            .      .    .             .           .         .             .          .      .  |________________________________________________________________________________________________@*/
            .      .    .             .           .         .             .          .      .  lbool Solver::search(int& nof_conflicts)
       29,447  2,656   31             0           0         0        18,739          0      0  {
            .      .    .             .           .         .             .          .      .      assert(ok);
            .      .    .             .           .         .             .          .      .      int         backtrack_level;
            .      .    .             .           .         .             .          .      .      int         lbd;
            .      .    .             .           .         .             .          .      .      vec<Lit>    learnt_clause;
            .      .    .             .           .         .             .          .      .      bool        cached = false;
        2,677      0    0         2,677          48         1             0          0      0      starts++;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // simplify
            .      .    .             .           .         .             .          .      .      //
       10,708      2    2         8,031       2,677        24             0          0      0      if (conflicts >= curSimplify * nbconfbeforesimplify){
            .      .    .             .           .         .             .          .      .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
            .      .    .             .           .         .             .          .      .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
            .      .    .             .           .         .             .          .      .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
            .      .    .             .           .         .             .          .      .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
           23     10    9            23          23        16             0          0      0          nbSimplifyAll++;
           69     23   16             0           0         0            23          0      0          if (!simplifyAll()){
            .      .    .             .           .         .             .          .      .              return l_False;
            .      .    .             .           .         .             .          .      .          }
          161      0    0            46          46         0            23          0      0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
           69      0    0            23           0         0            23          0      0          nbconfbeforesimplify += incSimplify;
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      for (;;){
            .      .    .             .           .         .             .          .      .          CRef confl = propagate();
            .      .    .             .           .         .             .          .      .  
   16,674,680      0    0             0           0         0             0          0      0          if (confl != CRef_Undef){
            .      .    .             .           .         .             .          .      .              // CONFLICT
    1,790,787      0    0       596,929       2,171         0             0          0      0              if (VSIDS){
      581,770      0    0       290,870     192,107         0            30          0      0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
            .      .    .             .           .         .             .          .      .              }else
    1,836,636    309   14       918,318     245,295         1       306,106          0      0                  if (step_size > min_step_size) step_size -= step_size_dec;
            .      .    .             .           .         .             .          .      .  
    2,387,716    381   30     1,193,858     494,808        12       596,929          0      0              conflicts++; nof_conflicts--;
            .      .    .             .           .         .             .          .      .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
            .      .    .             .           .         .             .          .      .              ConflictData data = FindConflictLevel(confl);
    1,193,858    282   19             0           0         0             0          0      0              if (data.nHighestLevel == 0) return l_False;
       65,108      0    0        30,554           0         0             0          0      0              if (data.bOnlyOneLitFromHighest)
            .      .    .             .           .         .             .          .      .              {
        2,000    158    0             0           0         0             0          0      0  				cancelUntil(data.nHighestLevel - 1);
            .      .    .             .           .         .             .          .      .  				continue;
            .      .    .             .           .         .             .          .      .  			}
            .      .    .             .           .         .             .          .      .  			
            .      .    .             .           .         .             .          .      .              learnt_clause.clear();
    1,189,858      0    0             0           0         0       594,929    371,678      3              if(conflicts>50000) DISTANCE=0;
            .      .    .             .           .         .             .          .      .              else DISTANCE=1;
    1,770,396      0    0             0           0         0             0          0      0              if(VSIDS && DISTANCE)
       38,408      4    3             0           0         0         9,602          0      0                  collectFirstUIP(confl);
            .      .    .             .           .         .             .          .      .  
    3,569,574     30   20             0           0         0       594,929          0      0              analyze(confl, learnt_clause, backtrack_level, lbd);
            .      .    .             .           .         .             .          .      .              // check chrono backtrack condition
    8,301,013     28   17     2,970,646     157,337         0             0          0      0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
            .      .    .             .           .         .             .          .      .              {
       28,292      0    0        28,292         295         0             0          0      0  				++chrono_backtrack;
       28,292      0    0             0           0         0             0          0      0  				cancelUntil(data.nHighestLevel -1);
            .      .    .             .           .         .             .          .      .  			}
            .      .    .             .           .         .             .          .      .  			else // default behavior
            .      .    .             .           .         .             .          .      .  			{
      566,637  5,205    7       566,637      72,824         0             0          0      0  				++non_chrono_backtrack;
            .      .    .             .           .         .             .          .      .  				cancelUntil(backtrack_level);
            .      .    .             .           .         .             .          .      .  			}
            .      .    .             .           .         .             .          .      .  
    1,784,787      0    0       594,929     244,405         0       594,929          0      0              lbd--;
    1,189,858      0    0       594,929           0         0             0          0      0              if (VSIDS){
      290,269    181    8             0           0         0       290,269          0      0                  cached = false;
      870,807    957    9       870,807     233,355         0             0          0      0                  conflicts_VSIDS++;
            .      .    .             .           .         .             .          .      .                  lbd_queue.push(lbd);
    2,322,152      0    0       870,807           0         0       290,269          0      0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
            .      .    .             .           .         .             .          .      .  
    1,784,787     26   15       594,929           0         0             0          0      0              if (learnt_clause.size() == 1){
           21      0    0             6           3         0             3          0      0                  uncheckedEnqueue(learnt_clause[0]);
            .      .    .             .           .         .             .          .      .              }else{
            .      .    .             .           .         .             .          .      .                  CRef cr = ca.alloc(learnt_clause, true);
      594,926      0    0       594,926           0         0             0          0      0                  ca[cr].set_lbd(lbd);
            .      .    .             .           .         .             .          .      .                  //duplicate learnts 
            .      .    .             .           .         .             .          .      .                  int  id = 0;
    1,189,852      0    0       594,926     530,073        22             0          0      0                  if (lbd <= max_lbd_dup){                        
            .      .    .             .           .         .             .          .      .                      std::vector<uint32_t> tmp;
   23,317,098      0    0    14,988,794           0         0       377,375          0      0                      for (int i = 0; i < learnt_clause.size(); i++)
   15,743,544     16   12    10,495,696           0         0     5,247,848          0      0                          tmp.push_back(learnt_clause[i].x);
    1,132,125     11    4       377,375           0         0       377,375          0      0                      id = is_duplicate(tmp);             
    1,886,875      0    0       377,375           0         0             0          0      0                      if (id == min_number_of_learnts_copies +1){
           59      0    0            59          21         0             0          0      0                          duplicates_added_conflicts++;                        
            .      .    .             .           .         .             .          .      .                      }                    
      754,750      0    0             0           0         0             0          0      0                      if (id == min_number_of_learnts_copies){
          532      0    0           532         189         0             0          0      0                          duplicates_added_tier2++;
            .      .    .             .           .         .             .          .      .                      }                                        
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .                  //duplicate learnts
            .      .    .             .           .         .             .          .      .  
    3,456,368      0    0     1,161,555     274,112        12             0          0      0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
           15      7    4             0           0         0             0          0      0                      learnts_core.push(cr);
            .      .    .             .           .         .             .          .      .                      ca[cr].mark(CORE);
    1,846,226  8,044   24             0           0         0             0          0      0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
           22      2    1             0           0         0             0          0      0                      learnts_tier2.push(cr);
            .      .    .             .           .         .             .          .      .                      ca[cr].mark(TIER2);
      840,176      0    0       210,044         276         0       210,044         11      0                      ca[cr].touched() = conflicts;
            .      .    .             .           .         .             .          .      .                  }else{
           23     23    5             0           0         0             0          0      0                      learnts_local.push(cr);
            .      .    .             .           .         .             .          .      .                      claBumpActivity(ca[cr]); }
    1,784,778  3,368   29             0           0         0       594,926          0      0                  attachClause(cr);
            .      .    .             .           .         .             .          .      .  
    3,569,556      0    0     1,784,778          45         0       594,926          0      0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
            .      .    .             .           .         .             .          .      .  #ifdef PRINT_OUT
            .      .    .             .           .         .             .          .      .                  std::cout << "new " << ca[cr] << "\n";
            .      .    .             .           .         .             .          .      .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
            .      .    .             .           .         .             .          .      .  #endif                
            .      .    .             .           .         .             .          .      .              }
    1,784,787      0    0       594,929     117,774         8             0          0      0              if (drup_file){
            .      .    .             .           .         .             .          .      .  #ifdef BIN_DRUP
            .      .    .             .           .         .             .          .      .                  binDRUP('a', learnt_clause, drup_file);
            .      .    .             .           .         .             .          .      .  #else
            .      .    .             .           .         .             .          .      .                  for (int i = 0; i < learnt_clause.size(); i++)
            .      .    .             .           .         .             .          .      .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
            .      .    .             .           .         .             .          .      .                  fprintf(drup_file, "0\n");
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
    1,784,787  1,709   23     1,189,858     263,447        13             0          0      0              if (VSIDS) varDecayActivity();
            .      .    .             .           .         .             .          .      .              claDecayActivity();
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              /*if (--learntsize_adjust_cnt == 0){
            .      .    .             .           .         .             .          .      .                  learntsize_adjust_confl *= learntsize_adjust_inc;
            .      .    .             .           .         .             .          .      .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
            .      .    .             .           .         .             .          .      .                  max_learnts             *= learntsize_inc;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
            .      .    .             .           .         .             .          .      .                             (int)conflicts,
            .      .    .             .           .         .             .          .      .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
            .      .    .             .           .         .             .          .      .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
            .      .    .             .           .         .             .          .      .              }*/
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .          }else{
            .      .    .             .           .         .             .          .      .              // NO CONFLICT
            .      .    .             .           .         .             .          .      .              bool restart = false;
   23,221,233     25    4     7,740,411      18,936         0             0          0      0              if (!VSIDS)
            .      .    .             .           .         .             .          .      .                  restart = nof_conflicts <= 0;
    6,703,452      1    1     3,351,726           0         0             0          0      0              else if (!cached){
    2,104,800      1    1       633,144     129,112         1       159,351          0      0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
            .      .    .             .           .         .             .          .      .                  cached = true;
            .      .    .             .           .         .             .          .      .              }
   13,166,055      0    0     4,388,685     353,372        11             0          0      0              if (restart /*|| !withinBudget()*/){
            .      .    .             .           .         .             .          .      .                  lbd_queue.clear();
            .      .    .             .           .         .             .          .      .                  cached = false;
            .      .    .             .           .         .             .          .      .                  // Reached bound on number of conflicts:
        8,028      0    0             0           0         0         5,352      1,508     12                  progress_estimate = progressEstimate();
            .      .    .             .           .         .             .          .      .                  cancelUntil(0);
        5,352      0    0             0           0         0             0          0      0                  return l_Undef; }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Simplify the set of problem clauses:
   23,326,812     65   19     7,737,735           0         0       105,565          0      0              if (decisionLevel() == 0 && !simplify())
            .      .    .             .           .         .             .          .      .                  return l_False;
            .      .    .             .           .         .             .          .      .  
   23,213,205    139    7    15,475,470     426,200        10             0          0      0              if (conflicts >= next_T2_reduce){
          118      0    0             0           0         0            59          0      0                  next_T2_reduce = conflicts + 10000;
          236      0    0            59           0         0            59          0      0                  reduceDB_Tier2(); }
   15,475,470     26    4     7,737,735      15,189         2             0          0      0              if (conflicts >= next_L_reduce){
           78      0    0             0           0         0            39          0      0                  next_L_reduce = conflicts + 15000;
           78      0    0             0           0         0            39          0      0                  reduceDB(); }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              Lit next = lit_Undef;
            .      .    .             .           .         .             .          .      .              /*while (decisionLevel() < assumptions.size()){
            .      .    .             .           .         .             .          .      .                  // Perform user provided assumption:
            .      .    .             .           .         .             .          .      .                  Lit p = assumptions[decisionLevel()];
            .      .    .             .           .         .             .          .      .                  if (value(p) == l_True){
            .      .    .             .           .         .             .          .      .                      // Dummy decision level:
            .      .    .             .           .         .             .          .      .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
            .      .    .             .           .         .             .          .      .                  }else{
            .      .    .             .           .         .             .          .      .                      next = p;
            .      .    .             .           .         .             .          .      .                      break;
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              if (next == lit_Undef)*/{
            .      .    .             .           .         .             .          .      .                  // New variable decision:
    7,737,735      0    0     7,737,735          39        13             0          0      0                  decisions++;
   23,213,205  1,484   27             0           0         0     7,737,735          0      0                  next = pickBranchLit();
            .      .    .             .           .         .             .          .      .  
   15,475,470      0    0             0           0         0             0          0      0                  if (next == lit_Undef)
            .      .    .             .           .         .             .          .      .                      // Model found:
            2      0    0             0           0         0             0          0      0                      return l_True;
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .              // Increase decision level and enqueue 'next'
            .      .    .             .           .         .             .          .      .              newDecisionLevel();
   46,426,404     33   11     7,737,734           0         0     7,737,734          0      0              uncheckedEnqueue(next, decisionLevel());
            .      .    .             .           .         .             .          .      .  #ifdef PRINT_OUT            
            .      .    .             .           .         .             .          .      .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
            .      .    .             .           .         .             .          .      .  #endif            
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
       24,093     59   15        18,739       2,677        23             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  double Solver::progressEstimate() const
       16,056      3    3             0           0         0        13,380          0      0  {
        5,352      0    0             0           0         0             0          0      0      double  progress = 0;
       13,380      0    0         5,352         882         0         2,676          0      0      double  F = 1.0 / nVars();
            .      .    .             .           .         .             .          .      .  
    2,840,979      3    3             0           0         0             0          0      0      for (int i = 0; i <= decisionLevel(); i++){
    2,824,923      0    0     1,879,714           0         0             0          0      0          int beg = i == 0 ? 0 : trail_lim[i - 1];
    3,767,456      0    0     1,882,390      60,107       536             0          0      0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
    5,663,226     17   13       945,209           0         0             0          0      0          progress += pow(F, i) * (end - beg);
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
        5,352      0    0             0           0         0             0          0      0      return progress / nVars();
       18,732      0    0        16,056          62         0             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  /*
            .      .    .             .           .         .             .          .      .    Finite subsequences of the Luby-sequence:
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .    0: 1
            .      .    .             .           .         .             .          .      .    1: 1 1 2
            .      .    .             .           .         .             .          .      .    2: 1 1 2 1 1 2 4
            .      .    .             .           .         .             .          .      .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .   */
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  static double luby(double y, int x){
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Find the finite subsequence that contains index 'x', and the
            .      .    .             .           .         .             .          .      .      // size of that subsequence:
            .      .    .             .           .         .             .          .      .      int size, seq;
       32,283      0    0             0           0         0             0          0      0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
            .      .    .             .           .         .             .          .      .  
       17,950      1    1             0           0         0             0          0      0      while (size-1 != x){
        9,988      0    0             0           0         0             0          0      0          size = (size-1)>>1;
        4,994      0    0             0           0         0             0          0      0          seq--;
       14,982      0    0             0           0         0             0          0      0          x = x % size;
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      return pow(y, seq);
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  static bool switch_mode = false;
            .      .    .             .           .         .             .          .      .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
            .      .    .             .           .         .             .          .      .  
            8      1    1             0           0         0             6          0      0  uint32_t Solver::reduceduplicates(){
            .      .    .             .           .         .             .          .      .      uint32_t removed_duplicates = 0;
            .      .    .             .           .         .             .          .      .      std::vector<std::vector<uint64_t>> tmp;
            .      .    .             .           .         .             .          .      .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
       46,317      0    0             2           0         0             0          0      0      for (auto & outer_mp: ht){//variables
      353,265      0    0             0           0         0             0          0      0          for (auto &inner_mp:outer_mp.second){//sizes
    1,081,868      0    0             0           0         0             0          0      0              for (auto &in_in_mp: inner_mp.second){
    1,197,102      1    1       399,034     364,589   240,379             0          0      0                  if (in_in_mp.second >= 2){
            .      .    .             .           .         .             .          .      .                  //min_number_of_learnts_copies
    1,054,460      1    1       421,784       2,482     2,282       421,784          0      0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
            .      .    .             .           .         .             .          .      .                  }
            .      .    .             .           .         .             .          .      .              }                    
            .      .    .             .           .         .             .          .      .           }
            .      .    .             .           .         .             .          .      .      }          
            3      0    0             1           1         1             1          0      0      removed_duplicates = dupl_db_size-tmp.size();  
            .      .    .             .           .         .             .          .      .      ht.clear();
      738,127      1    1       316,339          96         3             0          0      0      for (auto i=0;i<tmp.size();i++){
    1,054,460      0    0       527,230     118,691   118,628       316,338         14      2          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .      return removed_duplicates;
            9      0    0             8           2         1             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  // NOTE: assumptions passed in member-variable 'assumptions'.
            .      .    .             .           .         .             .          .      .  lbool Solver::solve_()
            8      0    0             0           0         0             6          0      0  {
            .      .    .             .           .         .             .          .      .      //signal(SIGALRM, SIGALRM_switch);
            .      .    .             .           .         .             .          .      .      //alarm(2500);
            .      .    .             .           .         .             .          .      .  
            1      1    1             0           0         0             0          0      0      model.clear();
            .      .    .             .           .         .             .          .      .      conflict.clear();
            2      1    1             1           0         0             0          0      0      if (!ok) return l_False;
            .      .    .             .           .         .             .          .      .  
            1      1    1             1           0         0             0          0      0      solves++;
            .      .    .             .           .         .             .          .      .  
            5      0    0             2           1         1             1          0      0      max_learnts               = nClauses() * learntsize_factor;
            3      0    0             1           1         1             0          0      0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
            1      0    0             0           0         0             1          1      1      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
            .      .    .             .           .         .             .          .      .      lbool   status            = l_Undef;
            .      .    .             .           .         .             .          .      .  
            3      0    0             1           0         0             0          0      0      if (verbosity >= 1){
            2      0    0             0           0         0             1          0      0          printf("c ============================[ Search Statistics ]==============================\n");
            2      1    1             0           0         0             1          0      0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
            2      0    0             0           0         0             1          0      0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
            2      0    0             0           0         0             1          0      0          printf("c ===============================================================================\n");
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      add_tmp.clear();
            .      .    .             .           .         .             .          .      .  
            1      0    0             0           0         0             1          0      0      VSIDS = true;
            1      1    1             0           0         0             1          0      0      int init = 10000;
          240      0    0            48          48         0             0          0      0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
          192      3    2             0           0         0            48          0      0          status = search(init);
            1      0    0             0           0         0             1          0      0      VSIDS = false;
            .      .    .             .           .         .             .          .      .  
            3      1    1             0           0         0             2          2      0      duplicates_added_conflicts = 0;
            .      .    .             .           .         .             .          .      .      duplicates_added_minimization=0;
            .      .    .             .           .         .             .          .      .      duplicates_added_tier2 =0;    
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      dupl_db_size=0;
            1      0    0             1           1         0             0          0      0      size_t dupl_db_size_limit = dupl_db_init_size;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // Search:
            1      0    0             0           0         0             0          0      0      int curr_restarts = 0;
            1      0    0             0           0         0             0          0      0      uint64_t curr_props = 0;
            .      .    .             .           .         .             .          .      .      uint32_t removed_duplicates =0;
        5,258  2,601   23             0           0         0             0          0      0      while (status == l_Undef /*&& withinBudget()*/){
        5,258      1    1         2,629       1,880         0             0          0      0          if (dupl_db_size >= dupl_db_size_limit){    
            4      1    1             1           1         0             1          0      0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
            4      0    0             1           0         0             1          0      0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
            4      0    0             1           0         0             1          0      0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
            4      1    1             1           1         0             1          0      0              printf("c Duptime: %i\n",duptime.count());
            4      0    0             1           0         0             1          0      0              printf("c Number of conflicts: %i\n",conflicts);
            4      0    0             1           1         0             1          0      0              printf("c Core size: %i\n",learnts_core.size());
            .      .    .             .           .         .             .          .      .              
            2      0    0             0           0         0             1          0      0              removed_duplicates = reduceduplicates();
            8      1    1             2           2         2             0          0      0              dupl_db_size_limit*=1.1;
            2      0    0             1           1         1             0          0      0              dupl_db_size -= removed_duplicates;
            5      0    0             0           0         0             1          0      0              printf("c removed duplicates %i\n",removed_duplicates);
            .      .    .             .           .         .             .          .      .          }   
       15,774     51   18         5,258       4,506         2             0          0      0          if (propagations - curr_props >  VSIDS_props_limit){
            3      0    0             0           0         0             0          0      0              curr_props = propagations;
            3      0    0             0           0         0             3          0      0              switch_mode = true;
           16      0    0             0           0         0             3          0      0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
            .      .    .             .           .         .             .          .      .          }     
        5,258      0    0         2,629           1         1             0          0      0          if (VSIDS){
        1,882      0    0             0           0         0         1,882      1,882      0              int weighted = INT32_MAX;
        7,528  1,881    6             0           0         0         1,882          0      0              status = search(weighted);
            .      .    .             .           .         .             .          .      .          }else{
        4,482    717   20         1,494           0         0           747        746      1              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          747      0    0             0           0         0             0          0      0              curr_restarts++;
        3,735    747   16             0           0         0           747          0      0              status = search(nof_conflicts);
            .      .    .             .           .         .             .          .      .          }
        5,258    745   16         2,629       2,629        25             0          0      0          if (switch_mode){ 
            3      0    0             0           0         0             3          0      0              switch_mode = false;
            .      .    .             .           .         .             .          .      .              VSIDS = !VSIDS;
            6      0    0             3           0         0             0          0      0              if (VSIDS){
            4      2    2             0           0         0             2          0      0                  printf("c Switched to VSIDS.\n");
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              else{
            3      1    1             0           0         0             1          0      0                 printf("c Switched to LRB.\n");
            .      .    .             .           .         .             .          .      .              }
            .      .    .             .           .         .             .          .      .              //            reduceduplicates();            
            6      1    1             3           3         3             3          0      0              fflush(stdout);
            .      .    .             .           .         .             .          .      .              picked.clear();
            .      .    .             .           .         .             .          .      .              conflicted.clear();
            .      .    .             .           .         .             .          .      .              almost_conflicted.clear();
            .      .    .             .           .         .             .          .      .  #ifdef ANTI_EXPLORATION
            .      .    .             .           .         .             .          .      .              canceled.clear();
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            3      1    1             1           1         0             0          0      0      if (verbosity >= 1)
            2      0    0             0           0         0             1          0      0          printf("c ===============================================================================\n");
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  #ifdef BIN_DRUP
            3      0    0             1           0         0             0          0      0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
            .      .    .             .           .         .             .          .      .  #endif
            .      .    .             .           .         .             .          .      .  
            2      1    1             0           0         0             0          0      0      if (status == l_True){
            .      .    .             .           .         .             .          .      .          // Extend & copy model:
            .      .    .             .           .         .             .          .      .          model.growTo(nVars());
        9,067      2    2         4,505       1,126        12         4,518      1,127      0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
            .      .    .             .           .         .             .          .      .      }else if (status == l_False && conflict.size() == 0)
            .      .    .             .           .         .             .          .      .          ok = false;
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      cancelUntil(0);
            1      0    0             0           0         0             0          0      0      return status;
            8      1    1             7           2         1             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  //=================================================================================================
            .      .    .             .           .         .             .          .      .  // Writing CNF to DIMACS:
            .      .    .             .           .         .             .          .      .  // 
            .      .    .             .           .         .             .          .      .  // FIXME: this needs to be rewritten completely.
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  static Var mapVar(Var x, vec<Var>& map, Var& max)
            .      .    .             .           .         .             .          .      .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
            .      .    .             .           .         .             .          .      .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
            .      .    .             .           .         .             .          .      .  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  //=================================================================================================
            .      .    .             .           .         .             .          .      .  // Garbage Collection methods:
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::relocAll(ClauseAllocator& to)
          150     25   25             0           0         0           120          0      0  {
            .      .    .             .           .         .             .          .      .      // All watchers:
            .      .    .             .           .         .             .          .      .      //
            .      .    .             .           .         .             .          .      .      // for (int i = 0; i < watches.size(); i++)
           30      0    0             0           0         0            15          1      1      watches.cleanAll();
           30      0    0             0           0         0            15          0      0      watches_bin.cleanAll();
   10,811,790     15   15     7,568,205       2,962         1     1,081,200         14      1      for (int v = 0; v < nVars(); v++)
    4,324,680      0    0     2,162,340           0         0             0          0      0          for (int s = 0; s < 2; s++){
            .      .    .             .           .         .             .          .      .              Lit p = mkLit(v, s);
            .      .    .             .           .         .             .          .      .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
            .      .    .             .           .         .             .          .      .              vec<Watcher>& ws = watches[p];
   85,098,951      0    0    38,699,208     540,600   492,927             0          0      0              for (int j = 0; j < ws.size(); j++)
            .      .    .             .           .         .             .          .      .                  ca.reloc(ws[j].cref, to);
            .      .    .             .           .         .             .          .      .              vec<Watcher>& ws_bin = watches_bin[p];
   17,536,539      6    6     6,608,568     543,012   494,861             0          0      0              for (int j = 0; j < ws_bin.size(); j++)
            .      .    .             .           .         .             .          .      .                  ca.reloc(ws_bin[j].cref, to);
            .      .    .             .           .         .             .          .      .          }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // All reasons:
            .      .    .             .           .         .             .          .      .      //
      204,024      0    0            45          15        15             0          0      0      for (int i = 0; i < trail.size(); i++){
            .      .    .             .           .         .             .          .      .          Var v = var(trail[i]);
            .      .    .             .           .         .             .          .      .  
      262,696      0    0        29,381      28,500     2,867             0          0      0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
      146,935      0    0        29,381           0         0        29,381         13     12              ca.reloc(vardata[v].reason, to);
            .      .    .             .           .         .             .          .      .      }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // All learnt:
            .      .    .             .           .         .             .          .      .      //
    1,309,833     14   14       654,908          31        31             0          0      0      for (int i = 0; i < learnts_core.size(); i++)
            .      .    .             .           .         .             .          .      .          ca.reloc(learnts_core[i], to);
      273,192     44   44       136,595          26         0             0          0      0      for (int i = 0; i < learnts_tier2.size(); i++)
            .      .    .             .           .         .             .          .      .          ca.reloc(learnts_tier2[i], to);
      336,272     15   15       168,107          15        15             0          0      0      for (int i = 0; i < learnts_local.size(); i++)
      504,231      0    0             0           0         0       168,077         13      0          ca.reloc(learnts_local[i], to);
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      // All original:
            .      .    .             .           .         .             .          .      .      //
            .      .    .             .           .         .             .          .      .      int i, j;
   16,421,139     15   15            60          28         2             0          0      0      for (i = j = 0; i < clauses.size(); i++)
   16,421,004      0    0             0           0         0             0          0      0          if (ca[clauses[i]].mark() != 1){
   24,631,536     14   14     8,210,502           0         0     8,210,502          1      1              ca.reloc(clauses[i], to);
   82,105,005     14   14    32,841,993           0         0     8,210,502          0      0              clauses[j++] = clauses[i]; }
           15     14   14             0           0         0             0          0      0      clauses.shrink(i - j);
          120     14   14           105          15        15             0          0      0  }
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .  void Solver::garbageCollect()
            .      .    .             .           .         .             .          .      .  {
            .      .    .             .           .         .             .          .      .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
            .      .    .             .           .         .             .          .      .      // is not precise but should avoid some unnecessary reallocations for the new region:
            .      .    .             .           .         .             .          .      .      ClauseAllocator to(ca.size() - ca.wasted());
            .      .    .             .           .         .             .          .      .  
            .      .    .             .           .         .             .          .      .      relocAll(to);
            .      .    .             .           .         .             .          .      .      if (verbosity >= 2)
            .      .    .             .           .         .             .          .      .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
            .      .    .             .           .         .             .          .      .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
            .      .    .             .           .         .             .          .      .      to.moveTo(ca);
          155     18   18            47           4         4            61          0      0  }

--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr             D1mr          DLmr       Dw             D1mw        DLmw      
--------------------------------------------------------------------------------
147,942,342,686 633,000 6,735 47,078,307,198 3,273,049,442 25,881,285 16,663,935,138 829,332,978 7,701,554  events annotated

