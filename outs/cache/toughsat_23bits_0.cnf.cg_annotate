--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/toughsat_23bits_0.cnf
Data file:        toughsat_23bits_0.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr             D1mr          DLmr    Dw             D1mw        DLmw      
--------------------------------------------------------------------------------
300,731,613,940 994,409 5,276 96,504,854,212 4,728,822,742 666,879 34,736,034,013 839,796,193 1,188,080  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr             D1mr          DLmr    Dw             D1mw        DLmw     file:function
--------------------------------------------------------------------------------
125,702,606,898   1,539   28 47,544,605,090 2,518,461,403  80,753 15,456,936,231   3,490,326       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
 49,952,723,581       8    3  9,049,528,722   394,465,828  25,103  6,796,241,753           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
 28,645,470,042  36,007    6  6,964,599,542   220,549,021     162  4,191,890,202 484,268,996  71,098  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
 26,125,866,542     196   36  6,860,761,776   940,303,825       2  2,663,374,933   8,414,217       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
 17,892,885,240      47   10  4,506,896,007   179,053,537       1              0           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
 11,972,628,775      30    7  2,916,056,364    74,964,959       0  2,179,259,002 214,129,754  14,713  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
  5,413,807,793       3    2  5,363,448,570    19,268,693       0     50,359,007           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
  3,665,366,502       0    0  1,832,683,251           199       0              0           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
  3,055,715,824  17,224   50  1,124,546,377    27,929,232       2    196,110,661     713,786      31  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  1,882,481,874   7,688   18    730,333,032    26,630,398       0    228,553,614   6,600,909       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
  1,712,993,890       8    4    738,995,138    24,852,787       0    521,039,097  75,101,976      14  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  1,656,903,715   1,925   33    405,178,591       578,647       0    145,239,122   2,913,420   1,294  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  1,628,332,928 171,017   69    351,474,539    10,629,368      31    158,492,603   1,451,651       0  ???:__ieee754_pow_fma
  1,612,966,014       0    0    806,483,007           823       0              0           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::simplePropagate()
  1,552,411,959   4,863   16    538,808,361     7,914,514       8    182,565,812     320,592       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  1,316,260,206     858   15    341,329,516    24,552,539     241     11,226,502       9,670       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  1,304,345,699  11,146    4    497,699,277    33,987,739       0    324,876,348   3,390,976       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  1,151,906,848       0    0  1,151,906,848            19       0              0           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::simplePropagate()
  1,081,527,831 148,858    7    275,834,071             0       0    188,177,688   1,118,160      29  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  1,066,989,850     310    7    501,752,891     8,143,790       1     66,526,209     701,786       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    952,318,969     151   25    426,644,220    11,491,712       7     67,192,975          13       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
    691,880,725      65   18    138,873,719     8,666,328      10     72,376,454   4,652,744       3  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
    656,076,593     250   16    148,025,514    12,852,042       0     45,873,959           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h:Minisat::Solver::detachClause(unsigned int, bool)
    637,273,220      22    7    205,176,904     5,717,341       0    121,347,160   2,137,411       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
    514,002,539      67    2    144,336,011    24,124,092      49              0           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
    495,781,721     908   28    118,980,182     7,854,197     292     13,222,296     800,450       0  ???:__exp1_fma
    465,279,498     748   21    209,330,603     9,363,875       3     66,478,512   1,113,389       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
    437,107,286     205    3    184,063,010     1,210,780       1              0           0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    374,492,356       1    1    129,327,739       648,551       0    115,836,878   4,242,503      15  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
    347,510,842       0    0    231,673,826       951,509       0     57,918,405   4,197,563       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    334,848,578     720    9    102,643,346        27,100       0     10,003,740     316,753       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    307,746,744     379   49     77,698,525     8,900,829  67,301     45,262,429   2,012,947 251,042  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr         D1mr      DLmr Dw         D1mw DLmw 

-- line 30 ----------------------------------------
          .    .    .          .         .    .          .    .    .  
          .    .    .          .         .    .          .    .    .  //=================================================================================================
          .    .    .          .         .    .          .    .    .  // Removing and searching for elements:
          .    .    .          .         .    .          .    .    .  //
          .    .    .          .         .    .          .    .    .  
          .    .    .          .         .    .          .    .    .  template<class V, class T>
          .    .    .          .         .    .          .    .    .  static inline void remove(V& ts, const T& t)
          .    .    .          .         .    .          .    .    .  {
     10,317  146    1          0         0    0          0    0    0      int j = 0;
333,967,185   52   11 56,019,578 7,251,285    0          0    0    0      for (; j < ts.size() && ts[j] != t; j++);
          .    .    .          .         .    .          .    .    .      assert(j < ts.size());
323,106,641   56    8 92,265,595 5,602,248    0 45,986,071    0    0      for (; j < ts.size()-1; j++) ts[j] = ts[j+1];
          .    .    .          .         .    .          .    .    .      ts.pop();
          .    .    .          .         .    .          .    .    .  }
          .    .    .          .         .    .          .    .    .  
          .    .    .          .         .    .          .    .    .  
          .    .    .          .         .    .          .    .    .  template<class V, class T>
          .    .    .          .         .    .          .    .    .  static inline bool find(V& ts, const T& t)
          .    .    .          .         .    .          .    .    .  {
          .    .    .          .         .    .          .    .    .      int j = 0;
  3,474,102    1    1    725,832    47,098    0          0    0    0      for (; j < ts.size() && ts[j] != t; j++);
          .    .    .          .         .    .          .    .    .      return j < ts.size();
          .    .    .          .         .    .          .    .    .  }
          .    .    .          .         .    .          .    .    .  
          .    .    .          .         .    .          .    .    .  
          .    .    .          .         .    .          .    .    .  //=================================================================================================
          .    .    .          .         .    .          .    .    .  // Copying vectors with support for nested vector types:
          .    .    .          .         .    .          .    .    .  //
          .    .    .          .         .    .          .    .    .  
-- line 58 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr            D1mr    DLmr  Dw        D1mw DLmw 

-- line 40 ----------------------------------------
            .     .    .             .       .     .         .    .    .      void capacity(uint32_t min_cap);
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .   public:
            .     .    .             .       .     .         .    .    .      // TODO: make this a class for better type-checking?
            .     .    .             .       .     .         .    .    .      typedef uint32_t Ref;
            .     .    .             .       .     .         .    .    .      enum { Ref_Undef = UINT32_MAX };
            .     .    .             .       .     .         .    .    .      enum { Unit_Size = sizeof(uint32_t) };
            .     .    .             .       .     .         .    .    .  
          196     1    1             0       0     0       156    0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
            .     .    .             .       .     .         .    .    .      ~RegionAllocator()
            .     .    .             .       .     .         .    .    .      {
            .     .    .             .       .     .         .    .    .          if (memory != NULL)
            .     .    .             .       .     .         .    .    .              ::free(memory);
            .     .    .             .       .     .         .    .    .      }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .      uint32_t size      () const      { return sz; }
            .     .    .             .       .     .         .    .    .      uint32_t wasted    () const      { return wasted_; }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .      Ref      alloc     (int size); 
    1,551,551     0    0       517,182       0     0   517,182    0    0      void     free      (int size)    { wasted_ += size; }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
5,476,498,166   177   20 2,725,672,720 825,427 6,052   198,393    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    5,656,147     0    0     5,656,147 734,132    19         0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
            .     .    .             .       .     .         .    .    .  
    9,656,745 6,435    4       625,142       0     0         0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
      654,579     0    0             0       0     0         0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
            .     .    .             .       .     .         .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
            .     .    .             .       .     .         .    .    .          return  (Ref)(t - &memory[0]); }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .      void     moveTo(RegionAllocator& to) {
          152     0    0            38       0     0        38    0    0          if (to.memory != NULL) ::free(to.memory);
           76     0    0            38       0     0        38    0    0          to.memory = memory;
           76     0    0            38       0     0        38    0    0          to.sz = sz;
            .     .    .             .       .     .         .    .    .          to.cap = cap;
           76     0    0            38       0     0        38    0    0          to.wasted_ = wasted_;
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .          memory = NULL;
            .     .    .             .       .     .         .    .    .          sz = cap = wasted_ = 0;
            .     .    .             .       .     .         .    .    .      }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  };
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  template<class T>
          462    28    2             0       0     0       154   37    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
            .     .    .             .       .     .         .    .    .  {
    9,050,106     1    0     3,016,702       0     0         0    0    0      if (cap >= min_cap) return;
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .      uint32_t prev_cap = cap;
        2,273     0    0             0       0     0        77    0    0      while (cap < min_cap){
            .     .    .             .       .     .         .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
            .     .    .             .       .     .         .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
            .     .    .             .       .     .         .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
            .     .    .             .       .     .         .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        6,588     0    0             0       0     0         0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
        1,098     0    0             0       0     0         0    0    0          cap += delta;
            .     .    .             .       .     .         .    .    .  
        2,196     0    0             0       0     0         0    0    0          if (cap <= prev_cap)
            .     .    .             .       .     .         .    .    .              throw OutOfMemoryException();
            .     .    .             .       .     .         .    .    .      }
            .     .    .             .       .     .         .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .      assert(cap > 0);
          154     2    1             0       0     0        77   36    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
          308     0    0           231       0     0         0    0    0  }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  template<class T>
            .     .    .             .       .     .         .    .    .  typename RegionAllocator<T>::Ref
       73,540     2    1             0       0     0    55,155    0    0  RegionAllocator<T>::alloc(int size)
            .     .    .             .       .     .         .    .    .  { 
            .     .    .             .       .     .         .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
            .     .    .             .       .     .         .    .    .      assert(size > 0);
   16,206,168     0    0     3,016,663  54,802     0 7,781,307   32    0      capacity(sz + size);
            .     .    .             .       .     .         .    .    .  
    9,601,577     0    0     5,389,786       0     0         0    0    0      uint32_t prev_sz = sz;
    3,016,663     2    1             0       0     0 3,016,663    0    0      sz += size;
            .     .    .             .       .     .         .    .    .      
            .     .    .             .       .     .         .    .    .      // Handle overflow:
   13,207,888    58   10     2,391,521       0     0         0    0    0      if (sz < prev_sz)
            2     1    1             1       1     0         0    0    0          throw OutOfMemoryException();
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .      return prev_sz;
       73,540     0    0        73,540       0     0         0    0    0  }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  //=================================================================================================
            .     .    .             .       .     .         .    .    .  }
            .     .    .             .       .     .         .    .    .  
            .     .    .             .       .     .         .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir             I1mr    ILmr Dr            D1mr        DLmr Dw            D1mw        DLmw   

-- line 40 ----------------------------------------
             .       .    .             .           .    .             .           .      .      int sz;
             .       .    .             .           .    .             .           .      .      int cap;
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .      // Don't allow copying (error prone):
             .       .    .             .           .    .             .           .      .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
             .       .    .             .           .    .             .           .      .               vec        (vec<T>& other) { assert(0); }
             .       .    .             .           .    .             .           .      .               
             .       .    .             .           .    .             .           .      .      // Helpers for calculating next capacity:
     1,280,573      10    6             0           0    0             0           0      0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
             .       .    .             .           .    .             .           .      .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .             .           .    .             .           .      .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  public:
             .       .    .             .           .    .             .           .      .      // Constructors:
       342,024      30   24             2           0    0       338,625       1,650    635      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
            50       0    0             0           0    0            50           0      0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
             .       .    .             .           .    .             .           .      .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
             .       .    .             .           .    .             .           .      .     ~vec()                                                          { clear(true); }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .      // Pointer to first element:
             .       .    .             .           .    .             .           .      .      operator T*       (void)           { return data; }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .      // Size operations:
             .       .    .             .           .    .             .           .      .      int      size     (void) const     { return sz; }
   180,043,250     353    1    24,731,723     949,769    0     7,589,380           0      0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
             .       .    .             .           .    .             .           .      .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
             .       .    .             .           .    .             .           .      .      int      capacity (void) const     { return cap; }
             .       .    .             .           .    .             .           .      .      void     capacity (int min_cap);
             .       .    .             .           .    .             .           .      .      void     growTo   (int size);
             .       .    .             .           .    .             .           .      .      void     growTo   (int size, const T& pad);
             .       .    .             .           .    .             .           .      .      void     clear    (bool dealloc = false);
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .      // Stack interface:
     2,439,203     101    3     1,218,261          15    0       609,456          74      0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
23,388,688,566  38,498  102 8,151,688,531 294,007,529  161 6,554,127,453 705,202,085 93,511      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
   277,723,231       0    0    68,947,209           0    0   135,021,018   5,275,396     15      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
    64,895,004       2    0     2,524,312           0    0    31,261,727           1      0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
             .       .    .             .           .    .             .           .      .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
             .       .    .             .           .    .             .           .      .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
             .       .    .             .           .    .             .           .      .      // happen given the way capacities are calculated (below). Essentially, all capacities are
             .       .    .             .           .    .             .           .      .      // even, but INT_MAX is odd.
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .      const T& last  (void) const        { return data[sz-1]; }
    28,451,049       0    0             0           0    0             0           0      0      T&       last  (void)              { return data[sz-1]; }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .      // Vector interface:
11,939,134,528     760   25    35,083,166           0    0     2,755,358           4      0      const T& operator [] (int index) const { return data[index]; }
 8,364,471,505     274   42 2,490,946,205   2,996,448   42    84,083,948           7      0      T&       operator [] (int index)       { return data[index]; }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .      // Duplicatation (preferred instead):
   142,676,124      17    4    47,963,220       6,533    0    23,071,458           0      0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
       107,794       1    0       107,722           4    0            48           0      0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
             .       .    .             .           .    .             .           .      .  };
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  template<class T>
       320,064       0    0             0           0    0       160,032           0      0  void vec<T>::capacity(int min_cap) {
     2,330,559      49   11       776,853           1    0             0           0      0      if (cap >= min_cap) return;
     1,120,547      14    6             0           0    0             8           0      0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     2,080,879      85   14       160,096          10    0       480,220         353      0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
             .       .    .             .           .    .             .           .      .          throw OutOfMemoryException();
       934,169       1    1       934,169           0    0             0           0      0   }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  template<class T>
             .       .    .             .           .    .             .           .      .  void vec<T>::growTo(int size, const T& pad) {
     7,584,750       7    7     2,527,571         156    0             0           0      0      if (sz >= size) return;
        13,580       4    4         1,358           0    0         6,111           0      0      capacity(size);
        76,729       7    7        12,223           0    0         6,112         254      0      for (int i = sz; i < size; i++) data[i] = pad;
     3,430,330      10    2         2,646           0    0         6,111           0      0      sz = size; }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  template<class T>
        13,580       1    1             0           0    0         5,432           0      0  void vec<T>::growTo(int size) {
     1,229,887       1    1         4,756          59    0         2,716           0      0      if (sz >= size) return;
     2,428,510     436    3             0           0    0     1,214,243           0      0      capacity(size);
     8,549,408      22   10     2,433,918           0    0     1,213,563           0      0      for (int i = sz; i < size; i++) new (&data[i]) T();
     1,834,666       0    0       614,989           6    0       610,191           3      0      sz = size; }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  template<class T>
             .       .    .             .           .    .             .           .      .  void vec<T>::clear(bool dealloc) {
    70,863,209 149,335   30    18,916,425     729,613    0           675           0      0      if (data != NULL){
         1,363       0    0             1           0    0             0           0      0          for (int i = 0; i < sz; i++) data[i].~T();
   124,130,339      13    4     6,909,603           0    0    26,502,687           0      0          sz = 0;
        72,594       5    5         3,376           0    0        68,528           4      0          if (dealloc) free(data), data = NULL, cap = 0; } }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  //=================================================================================================
             .       .    .             .           .    .             .           .      .  }
             .       .    .             .           .    .             .           .      .  
             .       .    .             .           .    .             .           .      .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir          I1mr   ILmr Dr          D1mr       DLmr Dw          D1mw      DLmw 

-- line 31 ----------------------------------------
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  template<class Comp>
          .      .    .           .          .    .           .         .    .  class Heap {
          .      .    .           .          .    .           .         .    .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
          .      .    .           .          .    .           .         .    .      vec<int> heap;     // Heap of integers
          .      .    .           .          .    .           .         .    .      vec<int> indices;  // Each integers position (index) in the Heap
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .      // Index "traversal" functions
 72,042,090     13    3           0          0    0           0         0    0      static inline int left  (int i) { return i*2+1; }
267,820,046     12    3 107,034,595 28,011,494   15           0         0    0      static inline int right (int i) { return (i+1)*2; }
163,359,873      9    6  21,334,283          0    0           0         0    0      static inline int parent(int i) { return (i-1) >> 1; }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
 42,668,566     13    3           0          0    0  42,668,566         7    0      void percolateUp(int i)
          .      .    .           .          .    .           .         .    .      {
111,353,992      0    0  67,611,123  3,011,732    1  22,408,586         0    0          int x  = heap[i];
          .      .    .           .          .    .           .         .    .          int p  = parent(i);
          .      .    .           .          .    .           .         .    .          
491,241,161     16    7 164,301,991 10,884,212    2   3,447,563         0    0          while (i != 0 && lt(x, heap[p])){
 35,943,308     27    3           0          0    0  35,943,308         0    0              heap[i]          = heap[p];
 35,943,308      0    0           0          0    0  35,943,308 3,958,528    0              indices[heap[p]] = i;
          .      .    .           .          .    .           .         .    .              i                = p;
 38,242,426      0    0           0          0    0           0         0    0              p                = parent(p);
          .      .    .           .          .    .           .         .    .          }
 46,276,840      9    5  11,208,172          0    0  35,068,668         0    0          heap   [i] = x;
 49,167,097      2    2  11,214,389          0    0  35,075,655         0    0          indices[x] = i;
 84,936,861      0    0  64,002,849          0    0           0         0    0      }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
239,006,278      0    0  34,143,754          0    0 204,862,524        17    0      void percolateDown(int i)
          .      .    .           .          .    .           .         .    .      {
110,814,961  1,153    7  72,051,191 11,726,022    0  38,751,920         0    0          int x = heap[i];
291,559,869 10,062   13  70,229,461          0    0           0         0    0          while (left(i) < heap.size()){
380,490,781     11    7  53,044,866  1,652,342    1           0         0    0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
139,679,164     33    2           0          0    0           0         0    0              if (!lt(heap[child], x)) break;
 34,245,748      0    0           0          0    0  34,245,748         0    0              heap[i]          = heap[child];
 34,258,427      0    0      12,679          0    0  34,245,748 6,479,190    2              indices[heap[i]] = i;
 25,432,162      0    0           0          0    0           0         0    0              i                = child;
          .      .    .           .          .    .           .         .    .          }
 75,557,555     23    9  37,779,163          0    0  37,778,392         0    0          heap   [i] = x;
 44,781,143      2    1   3,509,008          0    0  37,778,392         0    0          indices[x] = i;
242,686,514      1    0 239,006,278          0    0           0         0    0      }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .    public:
          .      .    .           .          .    .           .         .    .      Heap(const Comp& c) : lt(c) { }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .      int  size      ()          const { return heap.size(); }
  2,524,313      0    0   2,524,313    327,213    0           0         0    0      bool empty     ()          const { return heap.size() == 0; }
945,925,831  1,630   23 486,930,050 17,248,650    1           0         0    0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
  6,848,489      3    1   4,245,100    272,398    0           0         0    0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
109,170,844      0    0  75,919,705          0    0  21,334,283         0    0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
177,880,803      5    3 109,593,294          0    0  34,143,754         0    0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .      // Safe variant of insert/decrease/increase:
          .      .    .           .          .    .           .         .    .      void update(int n)
          .      .    .           .          .    .           .         .    .      {
          .      .    .           .          .    .           .         .    .          if (!inHeap(n))
          .      .    .           .          .    .           .         .    .              insert(n);
          .      .    .           .          .    .           .         .    .          else {
          .      .    .           .          .    .           .         .    .              percolateUp(indices[n]);
     15,516      0    0       7,758          0    0           0         0    0              percolateDown(indices[n]); }
          .      .    .           .          .    .           .         .    .      }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .      void insert(int n)
          .      .    .           .          .    .           .         .    .      {
  2,526,213      2    2           0          0    0           0         0    0          indices.growTo(n+1, -1);
          .      .    .           .          .    .           .         .    .          assert(!inHeap(n));
          .      .    .           .          .    .           .         .    .  
  5,052,426      1    1   2,526,213          0    0   2,526,213         0    0          indices[n] = heap.size();
      3,176      1    1           0          0    0       2,080         0    0          heap.push(n);
  5,052,426      0    0   2,526,213          0    0           0         0    0          percolateUp(indices[n]); 
          .      .    .           .          .    .           .         .    .      }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .      int  removeMin()
          .      .    .           .          .    .           .         .    .      {
  7,572,936      1    1   5,048,624    201,185    0   2,524,312        60    0          int x            = heap[0];
  5,048,624      0    0   2,524,312    447,848    0   2,524,312         0    0          heap[0]          = heap.last();
  5,048,624     11    6   2,524,312          0    0   2,524,312 1,166,037    1          indices[heap[0]] = 0;
  2,524,312      1    1           0          0    0   2,524,312   400,700    0          indices[x]       = -1;
          .      .    .           .          .    .           .         .    .          heap.pop();
  5,048,624      0    0           0          0    0           0         0    0          if (heap.size() > 1) percolateDown(0);
          .      .    .           .          .    .           .         .    .          return x; 
          .      .    .           .          .    .           .         .    .      }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .      // Rebuild the heap from scratch, using the elements in 'ns':
          .      .    .           .          .    .           .         .    .      void build(const vec<int>& ns) {
     47,518     19    4      23,759         24    0           0         0    0          for (int i = 0; i < heap.size(); i++)
     23,795     12    2          36          0    0      23,687     1,548   43              indices[heap[i]] = -1;
         36      0    0           0          0    0           0         0    0          heap.clear();
          .      .    .           .          .    .           .         .    .  
     47,604     12    2      23,748          0    0           0         0    0          for (int i = 0; i < ns.size(); i++){
     47,424      0    0      23,712          0    0      23,712         0    0              indices[ns[i]] = i;
          .      .    .           .          .    .           .         .    .              heap.push(ns[i]); }
          .      .    .           .          .    .           .         .    .  
     83,322     35    6      11,886          0    0          36         0    0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
          .      .    .           .          .    .           .         .    .              percolateDown(i);
          .      .    .           .          .    .           .         .    .      }
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .      void clear(bool dealloc = false) 
          .      .    .           .          .    .           .         .    .      { 
          4      0    0           2          1    0           0         0    0          for (int i = 0; i < heap.size(); i++)
          .      .    .           .          .    .           .         .    .              indices[heap[i]] = -1;
          .      .    .           .          .    .           .         .    .          heap.clear(dealloc); 
          .      .    .           .          .    .           .         .    .      }
          .      .    .           .          .    .           .         .    .  };
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  
          .      .    .           .          .    .           .         .    .  //=================================================================================================
          .      .    .           .          .    .           .         .    .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr            D1mr          DLmr    Dw            D1mw       DLmw 

-- line 51 ----------------------------------------
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  //=================================================================================================
             .      .    .             .             .       .             .          .    .  // Options:
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  static const char* _cat = "CORE";
             .      .    .             .             .       .             .          .    .  
             4      0    0             0             0       0             1          0    0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
             4      0    0             0             0       0             1          0    0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
             4      0    0             0             0       0             1          0    0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
             4      1    1             0             0       0             1          0    0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
             4      0    0             0             0       0             1          0    0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
             4      0    0             0             0       0             1          0    0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
             4      0    0             0             0       0             1          0    0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
             4      0    0             0             0       0             1          0    0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
             4      0    0             0             0       0             1          0    0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
             4      1    1             0             0       0             1          0    0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
             4      0    0             0             0       0             1          0    0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
             4      1    1             0             0       0             1          0    0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
             4      1    1             0             0       0             1          0    0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
             4      1    1             0             0       0             1          0    0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
             4      1    1             0             0       0             1          0    0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
             .      .    .             .             .       .             .          .    .  
             4      1    1             0             0       0             1          0    0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
             1      1    1             0             0       0             1          0    0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
             4      0    0             0             0       0             1          0    0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
             .      .    .             .             .       .             .          .    .  
             4      1    1             0             0       0             1          0    0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  //VSIDS_props_limit
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  //=================================================================================================
             .      .    .             .             .       .             .          .    .  // Constructor/Destructor:
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             4      1    1             0             0       0             2          0    0  Solver::Solver() :
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Parameters (user settable):
             .      .    .             .             .       .             .          .    .      //
             .      .    .             .             .       .             .          .    .      drup_file        (NULL)
             .      .    .             .             .       .             .          .    .    , verbosity        (0)
             .      .    .             .             .       .             .          .    .    , step_size        (opt_step_size)
             .      .    .             .             .       .             .          .    .    , step_size_dec    (opt_step_size_dec)
             .      .    .             .             .       .             .          .    .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
             .      .    .             .             .       .             .          .    .    , garbage_frac     (opt_garbage_frac)
             .      .    .             .             .       .             .          .    .    , restart_first    (opt_restart_first)
             .      .    .             .             .       .             .          .    .    , restart_inc      (opt_restart_inc)
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .    , min_number_of_learnts_copies(opt_min_dupl_app)  
             .      .    .             .             .       .             .          .    .    , max_lbd_dup(opt_max_lbd_dup)
             .      .    .             .             .       .             .          .    .    , dupl_db_init_size(opt_dupl_db_init_size)
             3      1    1             1             0       0             1          0    0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .    // Parameters (the rest):
             .      .    .             .             .       .             .          .    .    //
             .      .    .             .             .       .             .          .    .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .    // Parameters (experimental):
             .      .    .             .             .       .             .          .    .    //
             .      .    .             .             .       .             .          .    .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
             .      .    .             .             .       .             .          .    .    //
             .      .    .             .             .       .             .          .    .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
             .      .    .             .             .       .             .          .    .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
             .      .    .             .             .       .             .          .    .    , chrono_backtrack(0), non_chrono_backtrack(0)
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .    , ok                 (true)
             .      .    .             .             .       .             .          .    .    , cla_inc            (1)
             .      .    .             .             .       .             .          .    .    , var_inc            (1)
             1      0    0             0             0       0             0          0    0    , watches_bin        (WatcherDeleted(ca))
             .      .    .             .             .       .             .          .    .    , watches            (WatcherDeleted(ca))
             .      .    .             .             .       .             .          .    .    , qhead              (0)
             .      .    .             .             .       .             .          .    .    , simpDB_assigns     (-1)
             .      .    .             .             .       .             .          .    .    , simpDB_props       (0)
             .      .    .             .             .       .             .          .    .    , order_heap_CHB     (VarOrderLt(activity_CHB))
             .      .    .             .             .       .             .          .    .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
             .      .    .             .             .       .             .          .    .    , progress_estimate  (0)
             .      .    .             .             .       .             .          .    .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
             .      .    .             .             .       .             .          .    .    // simplifyAll adjust occasion
             .      .    .             .             .       .             .          .    .    , curSimplify(1)
             .      .    .             .             .       .             .          .    .    , nbconfbeforesimplify(1000)
             .      .    .             .             .       .             .          .    .    , incSimplify(1000)
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .    , my_var_decay       (0.6)
             .      .    .             .             .       .             .          .    .    , DISTANCE           (true)
             .      .    .             .             .       .             .          .    .    , var_iLevel_inc     (1)
            94      8    8            25             2       2            63          1    0    , order_heap_distance(VarOrderLt(activity_distance))
             .      .    .             .             .       .             .          .    .  
             4      0    0             3             0       0             0          0    0  {}
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  Solver::~Solver()
             .      .    .             .             .       .             .          .    .  {
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  // simplify All
             .      .    .             .             .       .             .          .    .  //
             .      .    .             .             .       .             .          .    .  CRef Solver::simplePropagate()
    15,288,648      1    0             0             0       0    11,466,486      1,978    0  {
     1,911,081      0    0             0             0       0     1,911,081          0    0      CRef    confl = CRef_Undef;
     1,911,081      0    0             0             0       0     1,911,081         13    0      int     num_props = 0;
     3,822,162      0    0             0             0       0     1,911,081      1,082    0      watches.cleanAll();
     5,733,243     23    4     1,911,081            13       0     1,911,081          0    0      watches_bin.cleanAll();
    21,559,886      0    0    10,779,943             0       0             0          0    0      while (qhead < trail.size())
             .      .    .             .             .       .             .          .    .      {
    44,352,215      1    1    17,740,886       413,079       0    17,740,886          0    0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .      .    .             .             .       .             .          .    .          vec<Watcher>&  ws = watches[p];
             .      .    .             .             .       .             .          .    .          Watcher        *i, *j, *end;
     8,868,862      0    0     8,868,862             0       0             0          0    0          num_props++;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          // First, Propagate binary clauses
             .      .    .             .             .       .             .          .    .          vec<Watcher>&  wbin = watches_bin[p];
             .      .    .             .             .       .             .          .    .  
    46,248,155      0    0     8,870,443     8,296,237       0             0          0    0          for (int k = 0; k<wbin.size(); k++)
             .      .    .             .             .       .             .          .    .          {
             .      .    .             .             .       .             .          .    .  
    10,063,994      0    0     7,305,891     2,499,144       0             0          0    0              Lit imp = wbin[k].blocker;
             .      .    .             .             .       .             .          .    .  
    10,063,994      0    0             0             0       0             0          0    0              if (value(imp) == l_False)
             .      .    .             .             .       .             .          .    .              {
         3,162      0    0         1,581             0       0         1,581          0    0                  return wbin[k].cref;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
    10,060,832      4    3             0             0       0             0          0    0              if (value(imp) == l_Undef)
             .      .    .             .             .       .             .          .    .              {
     1,436,494      0    0     1,436,494             0       0             0          0    0                  simpleUncheckEnqueue(imp, wbin[k].cref);
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
 2,387,938,802      5    1 1,167,370,678     3,245,220       0    17,551,537          0    0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
             .      .    .             .             .       .             .          .    .          {
             .      .    .             .             .       .             .          .    .              // Try to avoid inspecting the clause:
 1,149,632,954     24    5 1,149,632,954   143,898,882       2             0          0    0              Lit blocker = i->blocker;
 2,299,265,908      0    0 1,149,632,954     3,344,306       0             0          0    0              if (value(blocker) == l_True)
             .      .    .             .             .       .             .          .    .              {
             .      .    .             .             .       .             .          .    .                  *j++ = *i++; continue;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Make sure the false literal is data[1]:
 1,612,966,014      0    0   806,483,007             0       0             0          0    0              CRef     cr = i->cref;
             .      .    .             .             .       .             .          .    .              Clause&  c = ca[cr];
             .      .    .             .             .       .             .          .    .              Lit      false_lit = ~p;
 2,419,449,021      0    0   806,483,007   757,518,279       0             0          0    0              if (c[0] == false_lit)
   943,208,127      0    0   314,402,709    18,159,904       0   628,805,418          0    0                  c[0] = c[1], c[1] = false_lit;
             .      .    .             .             .       .             .          .    .              assert(c[1] == false_lit);
             .      .    .             .             .       .             .          .    .              //  i++;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // If 0th watch is true, then clause is already satisfied.
             .      .    .             .             .       .             .          .    .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
             .      .    .             .             .       .             .          .    .              // why not simply do i->blocker=first in this case?
             .      .    .             .             .       .             .          .    .              Lit     first = c[0];
             .      .    .             .             .       .             .          .    .              //  Watcher w     = Watcher(cr, first);
 2,049,750,186      0    0   218,392,086       370,755       0             0          0    0              if (first != blocker && value(first) == l_True)
             .      .    .             .             .       .             .          .    .              {
    81,787,149      0    0             0             0       0    81,787,149          0    0                  i->blocker = first;
 1,699,748,384      0    0   424,937,096             0       0   424,937,096  3,014,829    0                  *j++ = *i++; continue;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Look for new watch:
             .      .    .             .             .       .             .          .    .              //if (incremental)
             .      .    .             .             .       .             .          .    .              //{ // ----------------- INCREMENTAL MODE
             .      .    .             .             .       .             .          .    .              //	int choosenPos = -1;
             .      .    .             .             .       .             .          .    .              //	for (int k = 2; k < c.size(); k++)
             .      .    .             .             .       .             .          .    .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
             .      .    .             .             .       .             .          .    .              //		Watcher w = Watcher(cr, first); i++;
             .      .    .             .             .       .             .          .    .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
             .      .    .             .             .       .             .          .    .              //		watches[~c[1]].push(w);
             .      .    .             .             .       .             .          .    .              //		goto NextClause;
             .      .    .             .             .       .             .          .    .              //	}
             .      .    .             .             .       .             .          .    .              //}
             .      .    .             .             .       .             .          .    .              else
             .      .    .             .             .       .             .          .    .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
 2,650,042,389     24    3             0             0       0             0          0    0                  for (int k = 2; k < c.size(); k++)
             .      .    .             .             .       .             .          .    .                  {
             .      .    .             .             .       .             .          .    .  
 4,430,403,868      0    0             0             0       0             0          0    0                      if (value(c[k]) != l_False)
             .      .    .             .             .       .             .          .    .                      {
             .      .    .             .             .       .             .          .    .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
             .      .    .             .             .       .             .          .    .                          // the blocker is first in the watcher. However,
             .      .    .             .             .       .             .          .    .                          // the blocker in the corresponding watcher in ~first is not c[1]
             .      .    .             .             .       .             .          .    .                          Watcher w = Watcher(cr, first); i++;
 2,873,370,124      0    0   718,342,531             0       0 1,436,685,062          0    0                          c[1] = c[k]; c[k] = false_lit;
             .      .    .             .             .       .             .          .    .                          watches[~c[1]].push(w);
   718,342,531      0    0             0             0       0             0          0    0                          goto NextClause;
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Did not find watch -- clause is unit under assignment:
     6,353,327      0    0             0             0       0     6,353,327          0    0              i->blocker = first;
    25,413,308      2    0     6,353,327             0       0     6,353,327     30,479    0              *j++ = *i++;
    12,706,654     24    4             0             0       0             0          0    0              if (value(first) == l_False)
             .      .    .             .             .       .             .          .    .              {
       707,741     16    3             0             0       0       109,038          0    0                  confl = cr;
       218,076     22    3       109,038         2,821       0       109,038          0    0                  qhead = trail.size();
             .      .    .             .             .       .             .          .    .                  // Copy the remaining watches:
    17,570,214      1    0       206,971         1,763       0             0          0    0                  while (i < end)
     8,469,098      0    0     8,469,098     1,034,844       0     8,469,098     50,434    0                      *j++ = *i++;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              else
             .      .    .             .             .       .             .          .    .              {
             .      .    .             .             .       .             .          .    .                  simpleUncheckEnqueue(first, cr);
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  NextClause:;
             .      .    .             .             .       .             .          .    .          }
    17,365,350     24    4             0             0       0             0          0    0          ws.shrink(i - j);
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
     3,819,000      0    0     3,819,000       661,405       0             0          0    0      s_propagations += num_props;
             .      .    .             .             .       .             .          .    .  
     1,909,500      0    0     1,909,500             0       0             0          0    0      return confl;
   504,818,370     25    5    13,377,567       671,768       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
             .      .    .             .             .       .             .          .    .      assert(value(p) == l_Undef);
     7,680,783      0    0             0             0       0     7,680,783          0    0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
    19,183,728     24    5     9,591,864       185,405       0     9,591,864  6,711,428    0      vardata[var(p)].reason = from;
     8,155,370      0    0     8,155,370             0       0             0          0    0      trail.push_(p);
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::cancelUntilTrailRecord()
             .      .    .             .             .       .             .          .    .  {
    19,939,813      0    0       302,434             0       0             0          0    0      for (int c = trail.size() - 1; c >= trailRecord; c--)
             .      .    .             .             .       .             .          .    .      {
       151,217     24    5       151,217             0       0             0          0    0          Var x = var(trail[c]);
    10,045,515      0    0       151,217             4       0     9,591,864    107,424    0          assigns[x] = l_Undef;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      }
       151,217      0    0             0             0       0       151,217          0    0      qhead = trailRecord;
       302,434      0    0             0             0       0             0          0    0      trail.shrink(trail.size() - trailRecord);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::litsEnqueue(int cutP, Clause& c)
             .      .    .             .             .       .             .          .    .  {
             .      .    .             .             .       .             .          .    .      for (int i = cutP; i < c.size(); i++)
             .      .    .             .             .       .             .          .    .      {
             .      .    .             .             .       .             .          .    .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  bool Solver::removed(CRef cr) {
             .      .    .             .             .       .             .          .    .      return ca[cr].mark() == 1;
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
     1,640,573     23    5             0             0       0       894,858          0    0  {
       149,143      0    0             0             0       0             0          0    0      int pathC = 0;
       149,143      0    0             0             0       0             0          0    0      Lit p = lit_Undef;
       447,429      0    0       149,143             0       0             0          0    0      int index = trail.size() - 1;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      do{
     9,497,852     24    4             0             0       0             0          0    0          if (confl != CRef_Undef){
             .      .    .             .             .       .             .          .    .              reason_clause.push(confl);
             .      .    .             .             .       .             .          .    .              Clause& c = ca[confl];
             .      .    .             .             .       .             .          .    .              // Special case for binary clauses
             .      .    .             .             .       .             .          .    .              // The first one has to be SAT
    12,287,500     33    5             0             0       0             0          0    0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                  assert(value(c[1]) == l_True);
             .      .    .             .             .       .             .          .    .                  Lit tmp = c[0];
       260,256      0    0        86,752         5,396       0       173,504          0    0                  c[0] = c[1], c[1] = tmp;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              // if True_confl==true, then choose p begin with the 1th index of c;
    35,788,992      0    0     6,545,080       144,332       0             0          0    0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
             .      .    .             .             .       .             .          .    .                  Lit q = c[j];
    23,341,912      0    0    11,670,956       478,316       0             0          0    0                  if (!seen[var(q)]){
     4,599,812      0    0             0             0       0     4,599,812          0    0                      seen[var(q)] = 1;
    13,799,436      0    0     4,599,812             0       0             0          0    0                      pathC++;
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          else if (confl == CRef_Undef){
             .      .    .             .             .       .             .          .    .              out_learnt.push(~p);
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
    16,686,000     24    5     4,599,806             0       0             0          0    0          if (pathC == 0) break;
             .      .    .             .             .       .             .          .    .          // Select next clause to look at:
    70,451,371      0    0    23,483,798       890,020       0             0          0    0          while (!seen[var(trail[index--])]);
             .      .    .             .             .       .             .          .    .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
             .      .    .             .             .       .             .          .    .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
     9,199,612      0    0     4,599,806             0       0             0          0    0          if (trailRecord > index + 1) break;
             .      .    .             .             .       .             .          .    .          p = trail[index + 1];
             .      .    .             .             .       .             .          .    .          confl = reason(var(p));
     4,599,783      0    0             0             0       0     4,599,783          0    0          seen[var(p)] = 0;
     4,599,783      0    0             0             0       0             0          0    0          pathC--;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      } while (pathC >= 0);
     1,491,430     25    4     1,044,001            95       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::simplifyLearnt(Clause& c)
     1,360,953     48    8             0             0       0       907,302        358    0  {
             .      .    .             .             .       .             .          .    .      ////
       151,217      0    0       151,217         3,029       0             0          0    0      original_length_record += c.size();
             .      .    .             .             .       .             .          .    .  
       302,434      0    0       151,217         1,479       0       151,217          0    0      trailRecord = trail.size();// record the start pointer
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      vec<Lit> falseLit;
             .      .    .             .             .       .             .          .    .      falseLit.clear();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
             .      .    .             .             .       .             .          .    .  
       221,238     22    4             0             0       0             0          0    0      bool True_confl = false;
             .      .    .             .             .       .             .          .    .      int beforeSize, afterSize;
             .      .    .             .             .       .             .          .    .      beforeSize = c.size();
             .      .    .             .             .       .             .          .    .      int i, j;
             .      .    .             .             .       .             .          .    .      CRef confl;
             .      .    .             .             .       .             .          .    .  
     6,722,448     24    3             0             0       0             0          0    0      for (i = 0, j = 0; i < c.size(); i++){
     4,175,050      0    0             0             0       0             0          0    0          if (value(c[i]) == l_Undef){
             .      .    .             .             .       .             .          .    .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
             .      .    .             .             .       .             .          .    .              simpleUncheckEnqueue(~c[i]);
     7,533,705      0    0     1,911,081             0       0     1,911,081      9,339    0              c[j++] = c[i];
     5,733,243      0    0             0             0       0     1,911,081          0    0              confl = simplePropagate();
     5,733,243     24    5     1,911,081       667,339       0             0          0    0              if (confl != CRef_Undef){
             .      .    .             .             .       .             .          .    .                  break;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          else{
       352,888      0    0             0             0       0             0          0    0              if (value(c[i]) == l_True){
             .      .    .             .             .       .             .          .    .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
       154,096     18    5        38,524             0       0        38,524        351    0                  c[j++] = c[i];
        38,524      8    2             0             0       0             0          0    0                  True_confl = true;
             .      .    .             .             .       .             .          .    .                  confl = reason(var(c[i]));
             .      .    .             .             .       .             .          .    .                  break;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              else{
             .      .    .             .             .       .             .          .    .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
             .      .    .             .             .       .             .          .    .                  falseLit.push(c[i]);
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .      c.shrink(c.size() - j);
             .      .    .             .             .       .             .          .    .      afterSize = c.size();
             .      .    .             .             .       .             .          .    .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      if (confl != CRef_Undef || True_confl == true){
       149,143      0    0             0             0       0             0          0    0          simp_learnt_clause.clear();
       149,143      0    0             0             0       0             0          0    0          simp_reason_clause.clear();
       298,286      0    0             0             0       0             0          0    0          if (True_confl == true){
             .      .    .             .             .       .             .          .    .              simp_learnt_clause.push(c.last());
             .      .    .             .             .       .             .          .    .          }
     1,044,001     16    3             0             0       0       149,143          0    0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
             .      .    .             .             .       .             .          .    .  
       447,429      0    0       149,143             0       0             0          0    0          if (simp_learnt_clause.size() < c.size()){
     1,211,936     25    5       532,928             0       0             0          0    0              for (i = 0; i < simp_learnt_clause.size(); i++){
     1,985,632      0    0       496,408             1       0       496,408      8,250    0                  c[i] = simp_learnt_clause[i];
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              c.shrink(c.size() - i);
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      cancelUntilTrailRecord();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      ////
       151,217      0    0       151,217             0       0             0          0    0      simplified_length_record += c.size();
             .      .    .             .             .       .             .          .    .  
     1,209,736      0    0     1,058,519       147,272       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
             .      .    .             .             .       .             .          .    .  {
             .      .    .             .             .       .             .          .    .      int beforeSize, afterSize;
             .      .    .             .             .       .             .          .    .      int learnts_x_size_before = learnts_x.size();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      int ci, cj, li, lj;
             .      .    .             .             .       .             .          .    .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .      .    .             .             .       .             .          .    .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      return true;
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  bool Solver::simplifyLearnt_core()
           264      0    0             0             0       0           144          0    0  {
             .      .    .             .             .       .             .          .    .      int beforeSize, afterSize;
             .      .    .             .             .       .             .          .    .      int learnts_core_size_before = learnts_core.size();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      int ci, cj, li, lj;
             .      .    .             .             .       .             .          .    .      bool sat, false_lit;
             .      .    .             .             .       .             .          .    .      unsigned int nblevels;
             .      .    .             .             .       .             .          .    .      ////
             .      .    .             .             .       .             .          .    .      //printf("learnts_x size : %d\n", learnts_x.size());
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      ////
             .      .    .             .             .       .             .          .    .      int nbSimplified = 0;
             .      .    .             .             .       .             .          .    .      int nbSimplifing = 0;
             .      .    .             .             .       .             .          .    .  
       869,509     24    4            24             0       0             0          0    0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     1,304,130     24    4       869,420        27,194      53             0          0    0          CRef cr = learnts_core[ci];
             .      .    .             .             .       .             .          .    .          Clause& c = ca[cr];
             .      .    .             .             .       .             .          .    .  
       869,420      0    0             0             0       0             0          0    0          if (removed(cr)) continue;
       869,420      0    0       434,710        52,342       0             0          0    0          else if (c.simplified()){
       816,500      0    0             0             0       0       408,250         26    0              learnts_core[cj++] = learnts_core[ci];
             .      .    .             .             .       .             .          .    .              ////
     1,224,870      0    0       408,250             0       0             0          0    0              nbSimplified++;
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          else{
             .      .    .             .             .       .             .          .    .              int saved_size=c.size();
             .      .    .             .             .       .             .          .    .              //         if (drup_file){
             .      .    .             .             .       .             .          .    .              //                 add_oc.clear();
             .      .    .             .             .       .             .          .    .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .      .    .             .             .       .             .          .    .              ////
             .      .    .             .             .       .             .          .    .              nbSimplifing++;
        26,432      0    0             0             0       0             0          0    0              sat = false_lit = false;
       588,826      0    0             0             0       0             0          0    0              for (int i = 0; i < c.size(); i++){
       588,884      0    0             0             0       0             0          0    0                  if (value(c[i]) == l_True){
             .      .    .             .             .       .             .          .    .                      sat = true;
             .      .    .             .             .       .             .          .    .                      break;
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .                  else if (value(c[i]) == l_False){
       641,634     24    4             0             0       0        26,432         21    0                      false_lit = true;
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              if (sat){
           399      4    1           114             0       0           114          0    0                  removeClause(cr);
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              else{
       158,418      0    0             0             0       0        79,209          0    0                  detachClause(cr, true);
             .      .    .             .             .       .             .          .    .  
       105,612     24    5        52,806           138       0             0          0    0                  if (false_lit){
         6,757      0    0           518             0       0             0          0    0                      for (li = lj = 0; li < c.size(); li++){
         4,426      0    0             0             0       0             0          0    0                          if (value(c[li]) != l_False){
         5,649      0    0             0             0       0         1,883          0    0                              c[lj++] = c[li];
             .      .    .             .             .       .             .          .    .                          }
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                      c.shrink(li - lj);
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                  beforeSize = c.size();
             .      .    .             .             .       .             .          .    .                  assert(c.size() > 1);
             .      .    .             .             .       .             .          .    .                  // simplify a learnt clause c
       105,612      0    0             0             0       0        52,806          0    0                  simplifyLearnt(c);
             .      .    .             .             .       .             .          .    .                  assert(c.size() > 0);
             .      .    .             .             .       .             .          .    .                  afterSize = c.size();
             .      .    .             .             .       .             .          .    .                  
       133,192      0    0        79,209        49,524       0             0          0    0                  if(drup_file && saved_size !=c.size()){
             .      .    .             .             .       .             .          .    .  #ifdef BIN_DRUP
             .      .    .             .             .       .             .          .    .                      binDRUP('a', c , drup_file);
             .      .    .             .             .       .             .          .    .                      //                    binDRUP('d', add_oc, drup_file);
             .      .    .             .             .       .             .          .    .  #else
             .      .    .             .             .       .             .          .    .                      for (int i = 0; i < c.size(); i++)
             .      .    .             .             .       .             .          .    .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .             .             .       .             .          .    .                      fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
             .      .    .             .             .       .             .          .    .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .      .    .             .             .       .             .          .    .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .      .    .             .             .       .             .          .    .                      //                    fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .      .    .             .             .       .             .          .    .  
        52,806      0    0             0             0       0             0          0    0                  if (c.size() == 1){
             .      .    .             .             .       .             .          .    .                      // when unit clause occur, enqueue and propagate
            15      3    1             3             0       0             3          0    0                      uncheckedEnqueue(c[0]);
             9      0    0             3             0       0             0          0    0                      if (propagate() != CRef_Undef){
             .      .    .             .             .       .             .          .    .                          ok = false;
             .      .    .             .             .       .             .          .    .                          return false;
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                      // delete the clause memory in logic
             .      .    .             .             .       .             .          .    .                      c.mark(1);
             .      .    .             .             .       .             .          .    .                      ca.free(cr);
             .      .    .             .             .       .             .          .    .  //#ifdef BIN_DRUP
             .      .    .             .             .       .             .          .    .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
             .      .    .             .             .       .             .          .    .  //#else
             .      .    .             .             .       .             .          .    .  //                    fprintf(drup_file, "d ");
             .      .    .             .             .       .             .          .    .  //                    for (int i = 0; i < c.size(); i++)
             .      .    .             .             .       .             .          .    .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .             .             .       .             .          .    .  //                    fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  //#endif
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .                  else{
        79,200      0    0             0             0       0        26,400          0    0                      attachClause(cr);
       158,400     23    4        79,200        49,683       0        26,400      1,500    0                      learnts_core[cj++] = learnts_core[ci];
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                      nblevels = computeLBD(c);
        52,800     23    4             0             0       0             0          0    0                      if (nblevels < c.lbd()){
             .      .    .             .             .       .             .          .    .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .      .    .             .             .       .             .          .    .                          c.set_lbd(nblevels);
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                      c.setSimplified(true);
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
            24      0    0             0             0       0             0          0    0      learnts_core.shrink(ci - cj);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .      .    .             .             .       .             .          .    .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
             .      .    .             .             .       .             .          .    .  
            24     17    3             0             0       0             0          0    0      return true;
             .      .    .             .             .       .             .          .    .  
           192      0    0           168            24       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
     4,763,061      2    2             0             0       0     3,175,374          0    0  int Solver::is_duplicate(std::vector<uint32_t>&c){
     1,058,458      0    0             0             0       0     1,058,458         65    0     auto time_point_0 = std::chrono::high_resolution_clock::now();
       529,229      0    0       529,229       310,055       0             0          0    0      dupl_db_size++;
     1,277,650    139    2       283,016             0       0             0          0    0      int res = 0;    
             .      .    .             .             .       .             .          .    .      
     1,058,458      0    0     1,058,458             0       0             0          0    0      int sz = c.size();
             .      .    .             .             .       .             .          .    .      std::vector<uint32_t> tmp(c);    
             .      .    .             .             .       .             .          .    .      sort(tmp.begin(),tmp.end());
             .      .    .             .             .       .             .          .    .      
       529,229 84,817    1             0             0       0       529,229          0    0      uint64_t hash = 0;    
             .      .    .             .             .       .             .          .    .      
    24,474,058  1,303    1             0             0       0       529,229          0    0      for (int i =0; i<sz; i++) {
   101,201,130      0    0    10,120,113             0       0             0          0    0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
             .      .    .             .             .       .             .          .    .      }    
             .      .    .             .             .       .             .          .    .      
       529,229      0    0             0             0       0       529,229          0    0      int32_t head = tmp[0];
             .      .    .             .             .       .             .          .    .      auto it0 = ht.find(head);
     2,643,735      0    0       529,224             0       0             0          0    0      if (it0 != ht.end()){
             .      .    .             .             .       .             .          .    .          auto it1=ht[head].find(sz);
     1,056,858      0    0             0             0       0             0          0    0          if (it1 != ht[head].end()){
       515,703      0    0             0             0       0       515,703          0    0              auto it2 = ht[head][sz].find(hash);
     1,547,109      0    0             0             0       0       515,703          0    0              if (it2 != ht[head][sz].end()){
        95,736      0    0        31,912         7,981     102        31,912          0    0                  it2->second++;
        31,912      0    0             0             0       0             0          0    0                  res = it2->second;            
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              else{
       483,791      0    0             0             0       0       483,791          0    0                  ht[head][sz][hash]=1;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          else{            
        25,452      1    1             0             0       0        12,726          0    0              ht[head][sz][hash]=1;
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }else{        
       498,117    604    3             0             0       0       498,117         47    0          ht[head][sz][hash]=1;
             .      .    .             .             .       .             .          .    .      } 
       529,229     19    1             0             0       0       529,229          0    0      auto time_point_1 = std::chrono::high_resolution_clock::now();
             .      .    .             .             .       .             .          .    .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
             .      .    .             .             .       .             .          .    .      return res;
     4,763,061      0    0     3,704,603           318       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  bool Solver::simplifyLearnt_tier2()
           264     24    5             0             0       0           144          0    0  {
             .      .    .             .             .       .             .          .    .      int beforeSize, afterSize;
             .      .    .             .             .       .             .          .    .      int learnts_tier2_size_before = learnts_tier2.size();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      int ci, cj, li, lj;
             .      .    .             .             .       .             .          .    .      bool sat, false_lit;
             .      .    .             .             .       .             .          .    .      unsigned int nblevels;
             .      .    .             .             .       .             .          .    .      ////
             .      .    .             .             .       .             .          .    .      //printf("learnts_x size : %d\n", learnts_x.size());
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      ////
             .      .    .             .             .       .             .          .    .      int nbSimplified = 0;
             .      .    .             .             .       .             .          .    .      int nbSimplifing = 0;
             .      .    .             .             .       .             .          .    .  
       396,858     20    2            24            24       0             0          0    0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
       595,179      0    0       396,786        13,771       0             0          0    0          CRef cr = learnts_tier2[ci];
             .      .    .             .             .       .             .          .    .          Clause& c = ca[cr];
             .      .    .             .             .       .             .          .    .  
       396,786      0    0             0             0       0             0          0    0          if (removed(cr)) continue;
       396,780      0    0       198,390        23,380       0             0          0    0          else if (c.simplified()){
       146,938      0    0             0             0       0        73,469        558    0              learnts_tier2[cj++] = learnts_tier2[ci];
             .      .    .             .             .       .             .          .    .              ////
       470,253      0    0        73,469             0       0             0          0    0              nbSimplified++;
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          else{
             .      .    .             .             .       .             .          .    .              int saved_size=c.size();
             .      .    .             .             .       .             .          .    .              //            if (drup_file){
             .      .    .             .             .       .             .          .    .              //                    add_oc.clear();
             .      .    .             .             .       .             .          .    .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .      .    .             .             .       .             .          .    .              ////
             .      .    .             .             .       .             .          .    .              nbSimplifing++;
       124,869      0    0             0             0       0             0          0    0              sat = false_lit = false;
     4,432,300      0    0             0             0       0             0          0    0              for (int i = 0; i < c.size(); i++){
     4,432,410      0    0             0             0       0             0          0    0                  if (value(c[i]) == l_True){
             .      .    .             .             .       .             .          .    .                      sat = true;
             .      .    .             .             .       .             .          .    .                      break;
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .                  else if (value(c[i]) == l_False){
     4,681,934      9    3             0             0       0       124,869          0    0                      false_lit = true;
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              if (sat){
           535      0    0           107             0       0           107          0    0                  removeClause(cr);
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              else{
       748,884     21    3             0             0       0       374,442         22    0                  detachClause(cr, true);
             .      .    .             .             .       .             .          .    .  
       499,256      0    0       249,628           648       0             0          0    0                  if (false_lit){
        56,848      7    2         2,348             2       0             0          0    0                      for (li = lj = 0; li < c.size(); li++){
        46,282      0    0             0             0       0             0          0    0                          if (value(c[li]) != l_False){
        65,415      0    0             0             0       0        21,805          0    0                              c[lj++] = c[li];
             .      .    .             .             .       .             .          .    .                          }
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                      c.shrink(li - lj);
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                  beforeSize = c.size();
             .      .    .             .             .       .             .          .    .                  assert(c.size() > 1);
             .      .    .             .             .       .             .          .    .                  // simplify a learnt clause c
       624,070      0    0             0             0       0       374,442          0    0                  simplifyLearnt(c);
             .      .    .             .             .       .             .          .    .                  assert(c.size() > 0);
             .      .    .             .             .       .             .          .    .                  afterSize = c.size();
             .      .    .             .             .       .             .          .    .                  
       499,256     23    5       249,628       244,387       0             0          0    0                  if(drup_file && saved_size!=c.size()){
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  #ifdef BIN_DRUP
             .      .    .             .             .       .             .          .    .                      binDRUP('a', c , drup_file);
             .      .    .             .             .       .             .          .    .                      //                    binDRUP('d', add_oc, drup_file);
             .      .    .             .             .       .             .          .    .  #else
             .      .    .             .             .       .             .          .    .                      for (int i = 0; i < c.size(); i++)
             .      .    .             .             .       .             .          .    .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .             .             .       .             .          .    .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
             .      .    .             .             .       .             .          .    .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .      .    .             .             .       .             .          .    .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .      .    .             .             .       .             .          .    .                      //                    fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .      .    .             .             .       .             .          .    .  
       249,628      0    0             0             0       0             0          0    0                  if (c.size() == 1){
             .      .    .             .             .       .             .          .    .                      // when unit clause occur, enqueue and propagate
             5      0    0             1             0       0             1          0    0                      uncheckedEnqueue(c[0]);
             3      0    0             1             0       0             0          0    0                      if (propagate() != CRef_Undef){
             .      .    .             .             .       .             .          .    .                          ok = false;
             .      .    .             .             .       .             .          .    .                          return false;
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                      // delete the clause memory in logic
             .      .    .             .             .       .             .          .    .                      c.mark(1);
             .      .    .             .             .       .             .          .    .                      ca.free(cr);
             .      .    .             .             .       .             .          .    .  //#ifdef BIN_DRUP
             .      .    .             .             .       .             .          .    .  //                    binDRUP('d', c, drup_file);
-- line 841 ----------------------------------------
-- line 845 ----------------------------------------
             .      .    .             .             .       .             .          .    .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .             .             .       .             .          .    .  //                    fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  //#endif
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .                  else{
             .      .    .             .             .       .             .          .    .                      
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                      nblevels = computeLBD(c);
       249,626      0    0             0             0       0             0          0    0                      if (nblevels < c.lbd()){
             .      .    .             .             .       .             .          .    .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .      .    .             .             .       .             .          .    .                          c.set_lbd(nblevels);
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                       //duplicate learnts 
             .      .    .             .             .       .             .          .    .                      int id = 0;                    
             .      .    .             .             .       .             .          .    .                      
             .      .    .             .             .       .             .          .    .                      std::vector<uint32_t> tmp;
     6,309,409      0    0     4,655,389             0       0             0          0    0                      for (int i = 0; i < c.size(); i++)                           
     3,270,010      0    0     1,635,005             0       0     1,635,005          0    0                          tmp.push_back(c[i].x);
       499,252      0    0             0             0       0       124,813          0    0                      id = is_duplicate(tmp);
             .      .    .             .             .       .             .          .    .                       
             .      .    .             .             .       .             .          .    .                                          
             .      .    .             .             .       .             .          .    .                      //duplicate learnts 
             .      .    .             .             .       .             .          .    .  
       499,252      3    3       124,813       122,713       0             0          0    0                      if (id < min_number_of_learnts_copies+2){
       369,861      3    1             0             0       0       123,287          0    0                          attachClause(cr);
       611,284      0    0       369,861       241,699       0       123,287    112,199    0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
       493,148     24    5       123,287             0       0             0          0    0                          if (id == min_number_of_learnts_copies+1){                            
           298      0    0           298             0       0             0          0    0                              duplicates_added_minimization++;                                  
             .      .    .             .             .       .             .          .    .                          }
       245,978      0    0       122,989       120,846       0             0          0    0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
             .      .    .             .             .       .             .          .    .                          //if (id == min_number_of_learnts_copies+1){
             .      .    .             .             .       .             .          .    .                              cj--;
             .      .    .             .             .       .             .          .    .                              learnts_core.push(cr);
             .      .    .             .             .       .             .          .    .                              c.mark(CORE);
             .      .    .             .             .       .             .          .    .                          }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                          c.setSimplified(true);
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
            24     18    5             0             0       0             0          0    0      learnts_tier2.shrink(ci - cj);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .      .    .             .             .       .             .          .    .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
             .      .    .             .             .       .             .          .    .  
            24      0    0             0             0       0             0          0    0      return true;
             .      .    .             .             .       .             .          .    .  
           192      0    0           168            24       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  bool Solver::simplifyAll()
           120     11    4             0             0       0            72          0    0  {
             .      .    .             .             .       .             .          .    .      ////
            48      0    0             0             0       0            24          0    0      simplified_length_record = original_length_record = 0;
             .      .    .             .             .       .             .          .    .  
            96      0    0            24             8       0             0          0    0      if (!ok || propagate() != CRef_Undef)
             .      .    .             .             .       .             .          .    .          return ok = false;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      //// cleanLearnts(also can delete these code), here just for analyzing
             .      .    .             .             .       .             .          .    .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .      .    .             .             .       .             .          .    .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
             .      .    .             .             .       .             .          .    .      //local_learnts_dirty = tier2_learnts_dirty = false;
             .      .    .             .             .       .             .          .    .  
            96      0    0             0             0       0            24          0    0      if (!simplifyLearnt_core()) return ok = false;
            96     24    5             0             0       0            24          0    0      if (!simplifyLearnt_tier2()) return ok = false;
             .      .    .             .             .       .             .          .    .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      checkGarbage();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      ////
             .      .    .             .             .       .             .          .    .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
             .      .    .             .             .       .             .          .    .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      return true;
           120      0    0            96             0       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  //=================================================================================================
             .      .    .             .             .       .             .          .    .  // Minor methods:
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
             .      .    .             .             .       .             .          .    .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
             .      .    .             .             .       .             .          .    .  //
             .      .    .             .             .       .             .          .    .  Var Solver::newVar(bool sign, bool dvar)
         6,790      1    1             0             0       0         5,432          0    0  {
             .      .    .             .             .       .             .          .    .      int v = nVars();
             .      .    .             .             .       .             .          .    .      watches_bin.init(mkLit(v, false));
             .      .    .             .             .       .             .          .    .      watches_bin.init(mkLit(v, true ));
             .      .    .             .             .       .             .          .    .      watches  .init(mkLit(v, false));
             .      .    .             .             .       .             .          .    .      watches  .init(mkLit(v, true ));
            14      1    1             0             0       0             0          0    0      assigns  .push(l_Undef);
            14      1    1             0             0       0             0          0    0      vardata  .push(mkVarData(CRef_Undef, 0));
            14      0    0             0             0       0             0          0    0      activity_CHB  .push(0);
         2,065      0    0           679            71       0            14          0    0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
             .      .    .             .             .       .             .          .    .  
            14      1    1             0             0       0             0          0    0      picked.push(0);
            14      0    0             0             0       0             0          0    0      conflicted.push(0);
            14      0    0             0             0       0             0          0    0      almost_conflicted.push(0);
             .      .    .             .             .       .             .          .    .  #ifdef ANTI_EXPLORATION
            14      0    0             0             0       0             0          0    0      canceled.push(0);
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .  
            14      0    0             0             0       0             0          0    0      seen     .push(0);
            14      0    0             0             0       0             0          0    0      seen2    .push(0);
            14      0    0             0             0       0             0          0    0      polarity .push(sign);
            14      0    0             0             0       0             0          0    0      decision .push();
         3,395      1    1             0             0       0         1,358         81    0      trail    .capacity(v+1);
             .      .    .             .             .       .             .          .    .      setDecisionVar(v, dvar);
             .      .    .             .             .       .             .          .    .  
            14      0    0             0             0       0             0          0    0      activity_distance.push(0);
            14      1    1             0             0       0             0          0    0      var_iLevel.push(0);
            14      0    0             0             0       0             0          0    0      var_iLevel_tmp.push(0);
            14      0    0             0             0       0             0          0    0      pathCs.push(0);
             .      .    .             .             .       .             .          .    .      return v;
         6,111      0    0         4,753             6       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  bool Solver::addClause_(vec<Lit>& ps)
       130,200      2    1             0             0       0       111,600          0    0  {
             .      .    .             .             .       .             .          .    .      assert(decisionLevel() == 0);
        55,800      1    1        18,600             0       0             0          0    0      if (!ok) return false;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Check if clause is satisfied and remove false/duplicate literals:
             .      .    .             .             .       .             .          .    .      sort(ps);
             .      .    .             .             .       .             .          .    .      Lit p; int i, j;
             .      .    .             .             .       .             .          .    .  
        37,200      0    0        18,600            20       0             0          0    0      if (drup_file){
             .      .    .             .             .       .             .          .    .          add_oc.clear();
        18,600      2    1        18,600             0       0             0          0    0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
             .      .    .             .             .       .             .          .    .  
       427,605      0    0             0             0       0             0          0    0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
       726,064      0    0       130,346             0       0             0          0    0          if (value(ps[i]) == l_True || ps[i] == ~p)
             .      .    .             .             .       .             .          .    .              return true;
       520,532      4    2             0             0       0             0          0    0          else if (value(ps[i]) != l_False && ps[i] != p)
       389,265      0    0       129,755             0       0       129,755          0    0              ps[j++] = p = ps[i];
       147,112      0    0        18,389             0       0             0          0    0      ps.shrink(i - j);
             .      .    .             .             .       .             .          .    .  
        36,778      2    1             0             0       0             0          0    0      if (drup_file && i != j){
             .      .    .             .             .       .             .          .    .  #ifdef BIN_DRUP
             .      .    .             .             .       .             .          .    .          binDRUP('a', ps, drup_file);
        18,389      0    0        18,389             0       0             0          0    0          binDRUP('d', add_oc, drup_file);
             .      .    .             .             .       .             .          .    .  #else
             .      .    .             .             .       .             .          .    .          for (int i = 0; i < ps.size(); i++)
             .      .    .             .             .       .             .          .    .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
             .      .    .             .             .       .             .          .    .          fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          fprintf(drup_file, "d ");
             .      .    .             .             .       .             .          .    .          for (int i = 0; i < add_oc.size(); i++)
             .      .    .             .             .       .             .          .    .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .      .    .             .             .       .             .          .    .          fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .      
        36,778      0    0             0             0       0             0          0    0      if (ps.size() == 0)
             .      .    .             .             .       .             .          .    .          return ok = false;
        36,778      2    1             0             0       0             0          0    0      else if (ps.size() == 1){
            24      0    0             8             0       0             4          0    0          uncheckedEnqueue(ps[0]);
            16      0    0             0             0       0             4          1    0          return ok = (propagate() == CRef_Undef);
             .      .    .             .             .       .             .          .    .      }else{
        18,385      0    0             0             0       0        18,385          0    0          CRef cr = ca.alloc(ps, false);
             .      .    .             .             .       .             .          .    .          //auto ca_size=ca.size();
             .      .    .             .             .       .             .          .    .          //printf("ca size:%d\n",ca_size);
        55,155      0    0             0             0       0        18,385          0    0          clauses.push(cr);
        55,155      2    1        18,385             0       0        18,385          0    0          attachClause(cr);
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
        18,385      0    0             0             0       0             0          0    0      return true;
       204,600      0    0       130,200             5       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
     7,756,000      8    2             0             0       0     4,653,600          0    0  void Solver::attachClause(CRef cr) {
             .      .    .             .             .       .             .          .    .      const Clause& c = ca[cr];
             .      .    .             .             .       .             .          .    .      assert(c.size() > 1);
     3,101,845      0    0       775,600            88       0             0          0    0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .      .    .             .             .       .             .          .    .      ws[~c[0]].push(Watcher(cr, c[1]));
             .      .    .             .             .       .             .          .    .      ws[~c[1]].push(Watcher(cr, c[0]));
     2,307,643      0    0     1,532,043       233,363       0             0          0    0      if (c.learnt()) learnts_literals += c.size();
     6,223,957      1    0     5,448,357            11       0             0          0    0      else            clauses_literals += c.size(); }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
     4,015,002     74    2             0             0       0     2,676,668         85    0  void Solver::detachClause(CRef cr, bool strict) {
             .      .    .             .             .       .             .          .    .      const Clause& c = ca[cr];
             .      .    .             .             .       .             .          .    .      assert(c.size() > 1);
     2,676,668      0    0             0             0       0             0          0    0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .      .    .             .             .       .             .          .    .      
     2,676,668      0    0             0             0       0             0          0    0      if (strict){
             .      .    .             .             .       .             .          .    .          remove(ws[~c[0]], Watcher(cr, c[1]));
             .      .    .             .             .       .             .          .    .          remove(ws[~c[1]], Watcher(cr, c[0]));
             .      .    .             .             .       .             .          .    .      }else{
             .      .    .             .             .       .             .          .    .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
             .      .    .             .             .       .             .          .    .          ws.smudge(~c[0]);
             .      .    .             .             .       .             .          .    .          ws.smudge(~c[1]);
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
     2,004,775      9    0     1,335,608         2,699       0             0          0    0      if (c.learnt()) learnts_literals -= c.size();
     4,017,728      0    0     3,348,561           964       0             0          0    0      else            clauses_literals -= c.size(); }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
     4,137,424    130    4             0             0       0     2,068,712         73    0  void Solver::removeClause(CRef cr) {
             .      .    .             .             .       .             .          .    .      Clause& c = ca[cr];
             .      .    .             .             .       .             .          .    .  
     1,551,534      0    0       517,178           119       0             0          0    0      if (drup_file){
             .      .    .             .             .       .             .          .    .          if (c.mark() != 1){
             .      .    .             .             .       .             .          .    .  #ifdef BIN_DRUP
             .      .    .             .             .       .             .          .    .              binDRUP('d', c, drup_file);
             .      .    .             .             .       .             .          .    .  #else
             .      .    .             .             .       .             .          .    .              fprintf(drup_file, "d ");
             .      .    .             .             .       .             .          .    .              for (int i = 0; i < c.size(); i++)
             .      .    .             .             .       .             .          .    .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .             .             .       .             .          .    .              fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .          }else
             .      .    .             .             .       .             .          .    .              printf("c Bug. I don't expect this to happen.\n");
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
     2,068,712     56    3             0             0       0       517,178          0    0      detachClause(cr);
             .      .    .             .             .       .             .          .    .      // Don't leave pointers to free'd memory!
             .      .    .             .             .       .             .          .    .      if (locked(c)){
            56      0    0            14             0       0             0          0    0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
            28      0    0             0             0       0            14          0    0          vardata[var(implied)].reason = CRef_Undef; }
             .      .    .             .             .       .             .          .    .      c.mark(1);
             .      .    .             .             .       .             .          .    .      ca.free(cr);
     3,103,068      0    0     2,585,890             0       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  bool Solver::satisfied(const Clause& c) const {
    14,756,648     30    5             0             0       0             0          0    0      for (int i = 0; i < c.size(); i++)
    15,754,884      0    0     6,881,220         1,160       0             0          0    0          if (value(c[i]) == l_True)
           650      1    1             0             0       0             0          0    0              return true;
        36,098      0    0        18,374             0       0             0          0    0      return false; }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
             .      .    .             .             .       .             .          .    .  //
     5,472,963  1,891    3             0             0       0     3,648,642          0    0  void Solver::cancelUntil(int bLevel) {
             .      .    .             .             .       .             .          .    .  	
     2,435,104      6    2         1,339             0       0       608,107          0    0      if (decisionLevel() > bLevel){
             .      .    .             .             .       .             .          .    .  #ifdef PRINT_OUT
             .      .    .             .             .       .             .          .    .  		std::cout << "bt " << bLevel << "\n";
             .      .    .             .             .       .             .          .    .  #endif				
     1,216,214      0    0             0             0       0       608,107          2    0  		add_tmp.clear();
   298,106,553  5,407    3    60,959,146       539,119       0             0          0    0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
             .      .    .             .             .       .             .          .    .          {
             .      .    .             .             .       .             .          .    .              Var      x  = var(trail[c]);
             .      .    .             .             .       .             .          .    .  
   115,837,222      0    0    57,918,611     7,627,645       0             0          0    0  			if (level(x) <= bLevel)
             .      .    .             .             .       .             .          .    .  			{
             .      .    .             .             .       .             .          .    .  				add_tmp.push(trail[c]);
             .      .    .             .             .       .             .          .    .  			}
             .      .    .             .             .       .             .          .    .  			else
             .      .    .             .             .       .             .          .    .  			{
   115,836,810      0    0    57,918,405             3       0             0          0    0  				 if (!VSIDS){
   102,119,094      0    0    68,079,396           263       0             0          0    0  					uint32_t age = conflicts - picked[x];
    68,079,396      0    0    34,039,698     5,703,712       0             0          0    0  					if (age > 0){
   340,214,080    145    1   136,085,632     7,679,212       0             0          0    0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
    34,021,408      0    0    34,021,408     4,870,196       0             0          0    0  						double old_activity = activity_CHB[x];
   238,149,856     17    1    68,042,816       171,228       0    34,021,408          0    0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
             .      .    .             .             .       .             .          .    .  						if (order_heap_CHB.inHeap(x)){
   195,418,494     49    0             0             0       0    97,709,247          0    0  							if (activity_CHB[x] > old_activity)
             .      .    .             .             .       .             .          .    .  								order_heap_CHB.decrease(x);
             .      .    .             .             .       .             .          .    .  							else
             .      .    .             .             .       .             .          .    .  								order_heap_CHB.increase(x);
             .      .    .             .             .       .             .          .    .  						}
             .      .    .             .             .       .             .          .    .  					}
             .      .    .             .             .       .             .          .    .  #ifdef ANTI_EXPLORATION
    68,079,396      0    0    34,039,698        38,833       0    34,039,698  5,669,273    0  					canceled[x] = conflicts;
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .  				}
             .      .    .             .             .       .             .          .    .  				
   115,836,810    178    9    57,918,405           157       0    57,918,405    931,634    0  				assigns [x] = l_Undef;
             .      .    .             .             .       .             .          .    .  #ifdef PRINT_OUT
             .      .    .             .             .       .             .          .    .  				std::cout << "undo " << x << "\n";
             .      .    .             .             .       .             .          .    .  #endif				
   115,836,810      0    0    57,918,405             0       0             0          0    0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
    57,918,405      0    0    57,918,405             0       0             0          0    0  					polarity[x] = sign(trail[c]);
             .      .    .             .             .       .             .          .    .  				insertVarOrder(x);
             .      .    .             .             .       .             .          .    .  			}
             .      .    .             .             .       .             .          .    .          }
       608,107      0    0             0             0       0       608,107          0    0          qhead = trail_lim[bLevel];
     1,216,214      0    0             0             0       0             0          0    0          trail.shrink(trail.size() - trail_lim[bLevel]);
     1,824,321      0    0       608,107             0       0             0          0    0          trail_lim.shrink(trail_lim.size() - bLevel);
     1,824,733      1    1       608,107             0       0             0          0    0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
             .      .    .             .             .       .             .          .    .  		{
           132      0    0            44             0       0             0          0    0  			trail.push_(add_tmp[nLitId]);
             .      .    .             .             .       .             .          .    .  		}
             .      .    .             .             .       .             .          .    .  		
             .      .    .             .             .       .             .          .    .  		add_tmp.clear();
     4,864,856      0    0     4,256,749            30       0             0          0    0      } }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  //=================================================================================================
             .      .    .             .             .       .             .          .    .  // Major methods:
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  Lit Solver::pickBranchLit()
     7,474,248     74    1             0             0       0     5,605,686          0    0  {
             .      .    .             .             .       .             .          .    .      Var next = var_Undef;
             .      .    .             .             .       .             .          .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
     5,280,400    124    2     1,600,688       458,776       0             0          0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Random decision:
             .      .    .             .             .       .             .          .    .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
             .      .    .             .             .       .             .          .    .          next = order_heap[irand(random_seed,order_heap.size())];
             .      .    .             .             .       .             .          .    .          if (value(next) == l_Undef && decision[next])
             .      .    .             .             .       .             .          .    .              rnd_decisions++; }*/
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Activity based decision:
    17,568,771    106    1     7,850,104       684,358       1             0          0    0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
     5,047,266      0    0             0             0       0             0          0    0          if (order_heap.empty())
             1      0    0             0             0       0             0          0    0              return lit_Undef;
             .      .    .             .             .       .             .          .    .          else{
             .      .    .             .             .       .             .          .    .  #ifdef ANTI_EXPLORATION
     5,047,264      0    0     2,523,632            11       0             0          0    0              if (!VSIDS){
             .      .    .             .             .       .             .          .    .                  Var v = order_heap_CHB[0];
     3,283,422      0    0     3,283,422        40,567       0             0          0    0                  uint32_t age = conflicts - canceled[v];
     5,948,256      0    0     2,603,389       842,911       0       370,739          2    0                  while (age > 0){
             .      .    .             .             .       .             .          .    .                      double decay = pow(0.95, age);
     1,923,356      0    0       961,678        22,023       0       961,678          0    0                      activity_CHB[v] *= decay;
             .      .    .             .             .       .             .          .    .                      if (order_heap_CHB.inHeap(v))
             .      .    .             .             .       .             .          .    .                          order_heap_CHB.increase(v);
     2,885,034      0    0     1,923,356             0       0       961,678          0    0                      canceled[v] = conflicts;
             .      .    .             .             .       .             .          .    .                      v = order_heap_CHB[0];
             .      .    .             .             .       .             .          .    .                      age = conflicts - canceled[v];
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .              next = order_heap.removeMin();
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .  
     3,737,120      0    0     1,868,560       615,638       0             0          0    0      return mkLit(next, polarity[next]);
     8,408,528      0    0     6,539,967             0       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
             .      .    .             .             .       .             .          .    .  {
             .      .    .             .             .       .             .          .    .  	ConflictData data;
             .      .    .             .             .       .             .          .    .  	Clause& conflCls = ca[cind];
             .      .    .             .             .       .             .          .    .  	data.nHighestLevel = level(var(conflCls[0]));
     2,427,068      0    0     1,213,534        15,425       0             0          0    0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
             .      .    .             .             .       .             .          .    .  	{
             .      .    .             .             .       .             .          .    .  		return data;
             .      .    .             .             .       .             .          .    .  	}
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  	int highestId = 0;
             .      .    .             .             .       .             .          .    .      data.bOnlyOneLitFromHighest = true;
             .      .    .             .             .       .             .          .    .  	// find the largest decision level in the clause
            98      1    1             0             0       0             0          0    0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
             .      .    .             .             .       .             .          .    .  	{
             .      .    .             .             .       .             .          .    .  		int nLevel = level(var(conflCls[nLitId]));
            56      0    0             0             0       0             0          0    0  		if (nLevel > data.nHighestLevel)
             .      .    .             .             .       .             .          .    .  		{
             .      .    .             .             .       .             .          .    .  			highestId = nLitId;
             .      .    .             .             .       .             .          .    .  			data.nHighestLevel = nLevel;
             2      0    0             0             0       0             0          0    0  			data.bOnlyOneLitFromHighest = true;
             .      .    .             .             .       .             .          .    .  		}
             .      .    .             .             .       .             .          .    .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
             .      .    .             .             .       .             .          .    .  		{
            46      0    0             0             0       0             0          0    0  			data.bOnlyOneLitFromHighest = false;
             .      .    .             .             .       .             .          .    .  		}
             .      .    .             .             .       .             .          .    .  	}
             .      .    .             .             .       .             .          .    .  
            12      2    1             0             0       0             0          0    0  	if (highestId != 0)
             .      .    .             .             .       .             .          .    .  	{
             .      .    .             .             .       .             .          .    .  		std::swap(conflCls[0], conflCls[highestId]);
             4      0    0             0             0       0             0          0    0  		if (highestId > 1)
             .      .    .             .             .       .             .          .    .  		{
             4      0    0             0             0       0             0          0    0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
             .      .    .             .             .       .             .          .    .  			//ws.smudge(~conflCls[highestId]);
             .      .    .             .             .       .             .          .    .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
             .      .    .             .             .       .             .          .    .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
             .      .    .             .             .       .             .          .    .  		}
             .      .    .             .             .       .             .          .    .  	}
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  	return data;
             .      .    .             .             .       .             .          .    .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
             .      .    .             .             .       .             .          .    .  |  
             .      .    .             .             .       .             .          .    .  |    Post-conditions:
             .      .    .             .             .       .             .          .    .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
             .      .    .             .             .       .             .          .    .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
             .      .    .             .             .       .             .          .    .  |        rest of literals. There may be others from the same level though.
             .      .    .             .             .       .             .          .    .  |  
             .      .    .             .             .       .             .          .    .  |________________________________________________________________________________________________@*/
             .      .    .             .             .       .             .          .    .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
     7,887,984     34    8             0             0       0     5,460,912          0    0  {
       606,768      0    0             0             0       0       606,768     14,641    0      int pathC = 0;
       606,768      0    0             0             0       0             0          0    0      Lit p     = lit_Undef;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Generate conflict clause:
             .      .    .             .             .       .             .          .    .      //
             .      .    .             .             .       .             .          .    .      out_learnt.push();      // (leave room for the asserting literal)
     1,213,536      0    0       606,768             0       0             0          0    0      int index   = trail.size() - 1;
       606,768      0    0       606,768             0       0             0          0    0      int nDecisionLevel = level(var(ca[confl][0]));
             .      .    .             .             .       .             .          .    .      assert(nDecisionLevel == level(var(ca[confl][0])));
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      do{
             .      .    .             .             .       .             .          .    .          assert(confl != CRef_Undef); // (otherwise should be UIP)
             .      .    .             .             .       .             .          .    .          Clause& c = ca[confl];
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
    85,930,024      0    0             0             0       0             0          0    0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
             .      .    .             .             .       .             .          .    .              assert(value(c[1]) == l_True);
             .      .    .             .             .       .             .          .    .              Lit tmp = c[0];
       215,688      0    0        71,896         4,092       0       143,792          0    0              c[0] = c[1], c[1] = tmp; }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          // Update LBD if improved.
    65,018,734      0    0     1,522,468             0       0             0          0    0          if (c.learnt() && c.mark() != CORE){
             .      .    .             .             .       .             .          .    .              int lbd = computeLBD(c);
     4,586,078      0    0             0             0       0             0          0    0              if (lbd < c.lbd()){
       478,430      0    0             0             0       0             0          0    0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
             .      .    .             .             .       .             .          .    .                  c.set_lbd(lbd);
       478,430      0    0       239,215       132,812       0             0          0    0                  if (lbd <= core_lbd_cut){
            22      5    0             0             0       0            11          0    0                      learnts_core.push(confl);
             .      .    .             .             .       .             .          .    .                      c.mark(CORE);
       669,902      0    0       101,631             0       0             0          0    0                  }else if (lbd <= 6 && c.mark() == LOCAL){
             .      .    .             .             .       .             .          .    .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
             .      .    .             .             .       .             .          .    .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     4,398,012      2    2             0             0       0     1,288,854    553,201    0                      learnts_tier2.push(confl);
             .      .    .             .             .       .             .          .    .                      c.mark(TIER2); }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
     4,434,998      0    0     2,217,499             0       0             0          0    0              if (c.mark() == TIER2)
     4,582,980     20    2     1,145,745         2,774       0     1,145,745    138,440   31                  c.touched() = conflicts;
     2,218,826      0    0     1,109,413             0       0             0          0    0              else if (c.mark() == LOCAL)
             .      .    .             .             .       .             .          .    .                  claBumpActivity(c);
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .  
   446,599,438      6    1   133,494,524             2       0    21,295,829         13    0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
   112,198,695      0    0   112,198,695     6,269,834       1             0          0    0              Lit q = c[j];
             .      .    .             .             .       .             .          .    .  
   355,747,347      1    1   155,982,014     9,197,057       1             0          0    0              if (!seen[var(q)] && level(var(q)) > 0){
    87,521,038      0    0    43,760,519            58       0             0          0    0                  if (VSIDS){
             .      .    .             .             .       .             .          .    .                      varBumpActivity(var(q), .5);
            22      1    1             0             0       0            11          0    0                      add_tmp.push(q);
             .      .    .             .             .       .             .          .    .                  }else
    28,134,229      0    0    28,134,229     3,723,689       0             0          0    0                      conflicted[var(q)]++;
    43,760,519      0    0             0             0       0    43,760,519          0    0                  seen[var(q)] = 1;
    87,521,038      0    0    43,760,519             0       0             0          0    0                  if (level(var(q)) >= nDecisionLevel){
    42,591,658      0    0    42,591,658             2       0             0          0    0                      pathC++;
             .      .    .             .             .       .             .          .    .                  }else
             .      .    .             .             .       .             .          .    .                      out_learnt.push(q);
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          
             .      .    .             .             .       .             .          .    .          // Select next clause to look at:
             .      .    .             .             .       .             .          .    .  		do {
   319,777,928      0    0   132,170,337     4,911,760       0             0          0    0  			while (!seen[var(trail[index--])]);
             .      .    .             .             .       .             .          .    .  			p  = trail[index+1];
    42,591,692      1    1    21,295,846         7,957       0             0          0    0  		} while (level(var(p)) < nDecisionLevel);
             .      .    .             .             .       .             .          .    .  		
    42,591,658      0    0    21,295,829             0       0    21,295,829          0    0          confl = reason(var(p));
    21,295,829      0    0             0             0       0    21,295,829          0    0          seen[var(p)] = 0;
    42,591,658      0    0    42,591,658             4       0             0          0    0          pathC--;
             .      .    .             .             .       .             .          .    .  
   125,347,902      0    0    41,378,122            18       0             0          0    0      }while (pathC > 0);
       606,768      0    0       606,768             9       0             0          0    0      out_learnt[0] = ~p;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Simplify conflict clause:
             .      .    .             .             .       .             .          .    .      //
             .      .    .             .             .       .             .          .    .      int i, j;
     1,213,536      0    0             0             0       0       606,768          0    0      out_learnt.copyTo(analyze_toclear);
     1,820,304      0    0       606,768             1       0             0          0    0      if (ccmin_mode == 2){
       606,759    157    3             0             0       0             0          0    0          uint32_t abstract_level = 0;
    46,142,916    181    3             0             0       0             0          0    0          for (i = 1; i < out_learnt.size(); i++)
    23,678,208      0    0       606,759             0       0             0          0    0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
             .      .    .             .             .       .             .          .    .  
   163,320,420     17    2    66,787,311            14       0       606,759          0    0          for (i = j = 1; i < out_learnt.size(); i++)
   145,452,782     12    1    31,192,181         2,126       0    16,613,684          0    0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
    43,735,491      8    2    14,578,497             0       0    14,578,497         24    0                  out_learnt[j++] = out_learnt[i];
             .      .    .             .             .       .             .          .    .          
             .      .    .             .             .       .             .          .    .      }else if (ccmin_mode == 1){
             .      .    .             .             .       .             .          .    .          for (i = j = 1; i < out_learnt.size(); i++){
             .      .    .             .             .       .             .          .    .              Var x = var(out_learnt[i]);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              if (reason(x) == CRef_Undef)
             .      .    .             .             .       .             .          .    .                  out_learnt[j++] = out_learnt[i];
             .      .    .             .             .       .             .          .    .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
             .      .    .             .             .       .             .          .    .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
             .      .    .             .             .       .             .          .    .                          out_learnt[j++] = out_learnt[i];
             .      .    .             .             .       .             .          .    .                          break; }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }else
             .      .    .             .             .       .             .          .    .          i = j = out_learnt.size();
             .      .    .             .             .       .             .          .    .  
     1,213,536      0    0       606,768       560,246       0             0          0    0      max_literals += out_learnt.size();
    13,853,500      1    1     3,311,683             0       0             0          0    0      out_learnt.shrink(i - j);
       606,768     65    1       606,768             0       0             0          0    0      tot_literals += out_learnt.size();
             .      .    .             .             .       .             .          .    .  
     1,213,536      0    0       606,768           950       0       606,768          0    0      out_lbd = computeLBD(out_learnt);
     6,952,148  5,854    7     3,121,462             0       0             0          0    0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
       613,690  2,309    2        87,670             0       0       175,340          0    0          if (binResMinimize(out_learnt))
         3,324      0    0         1,108             0       0         1,108          0    0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Find correct backtrack level:
             .      .    .             .             .       .             .          .    .      //
     1,198,750      0    0             0             0       0             0          0    0      if (out_learnt.size() == 1)
            36      0    0            12             0       0            12          0    0          out_btlevel = 0;
             .      .    .             .             .       .             .          .    .      else{
     1,213,394      0    0             0             0       0             0          0    0          int max_i = 1;
             .      .    .             .             .       .             .          .    .          // Find the first literal assigned at the next-highest level:
    57,327,707      0    0             0             0       0             0          0    0          for (int i = 2; i < out_learnt.size(); i++)
    45,837,322      0    0    13,970,554             0       0             0          0    0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
             .      .    .             .             .       .             .          .    .                  max_i = i;
             .      .    .             .             .       .             .          .    .          // Swap-in this literal at index 1:
             .      .    .             .             .       .             .          .    .          Lit p             = out_learnt[max_i];
     1,213,512      1    0       606,756             0       0       606,756          0    0          out_learnt[max_i] = out_learnt[1];
       606,756      0    0             0             0       0       606,756          0    0          out_learnt[1]     = p;
     1,213,512      0    0       606,756             0       0       606,756          0    0          out_btlevel       = level(var(p));
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
     1,213,536    602    4       606,768           796       0             0          0    0      if (VSIDS){
    54,653,227  6,793    8    16,297,216        24,938       0             0          0    0          for (int i = 0; i < add_tmp.size(); i++){
             .      .    .             .             .       .             .          .    .              Var v = var(add_tmp[i]);
    46,878,870      0    0    15,626,290       168,754       0             0          0    0              if (level(v) >= out_btlevel - 1)
             .      .    .             .             .       .             .          .    .                  varBumpActivity(v, 1);
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          add_tmp.clear();
             .      .    .             .             .       .             .          .    .      }else{
       766,252      0    0       383,126             0       0       383,126         10    0          seen[var(p)] = true;
    33,287,371      0    0       383,126             0       0             0          0    0          for(int i = out_learnt.size() - 1; i >= 0; i--){
             .      .    .             .             .       .             .          .    .              Var v = var(out_learnt[i]);
             .      .    .             .             .       .             .          .    .              CRef rea = reason(v);
    19,381,990      0    0             0             0       0             0          0    0              if (rea != CRef_Undef){
             .      .    .             .             .       .             .          .    .                  const Clause& reaC = ca[rea];
   105,365,790      0    0             0             0       0             0          0    0                  for (int i = 0; i < reaC.size(); i++){
             .      .    .             .             .       .             .          .    .                      Lit l = reaC[i];
    85,552,402      0    0    42,776,201       128,789       0             0          0    0                      if (!seen[var(l)]){
     9,408,900      0    0             0             0       0     9,408,900          0    0                          seen[var(l)] = true;
     9,408,900      0    0     9,408,900     2,737,392       0             0          0    0                          almost_conflicted[var(l)]++;
             .      .    .             .             .       .             .          .    .                          analyze_toclear.push(l); } } } } }
             .      .    .             .             .       .             .          .    .  
   143,095,168  1,154    0    70,637,432             0       0    35,015,332      7,457    0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
     4,854,144      0    0     4,247,376        55,158       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  // Try further learnt clause minimization by means of binary clause resolution.
             .      .    .             .             .       .             .          .    .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
       115,985      0    0             0             0       0        92,788          0    0  {
             .      .    .             .             .       .             .          .    .      // Preparation: remember which false variables we have in 'out_learnt'.
       263,010     10    4        87,670             0       0        87,670          0    0      counter++;
     2,852,246      0    0       175,340             0       0             0          0    0      for (int i = 1; i < out_learnt.size(); i++)
     1,163,240      0    0        87,661             0       0     1,075,579    539,339   85          seen2[var(out_learnt[i])] = counter;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Get the list of binary clauses containing 'out_learnt[0]'.
             .      .    .             .             .       .             .          .    .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
             .      .    .             .             .       .             .          .    .  
        23,197      0    0             0             0       0             0          0    0      int to_remove = 0;
       460,927      2    2        87,670        55,139       0         1,108          0    0      for (int i = 0; i < ws.size(); i++){
        88,651      0    0        88,651        18,962       0             0          0    0          Lit the_other = ws[i].blocker;
             .      .    .             .             .       .             .          .    .          // Does 'the_other' appear negatively in 'out_learnt'?
       356,978     11    4       156,479        25,251       8             0          0    0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
         1,187      0    0             0             0       0             0          0    0              to_remove++;
         3,561      0    0             0             0       0         1,187          0    0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Shrink.
        69,591     10    3             0             0       0             0          0    0      if (to_remove > 0){
         1,108      0    0             0             0       0             0          0    0          int last = out_learnt.size() - 1;
       112,989     37    3         1,105             0       0             0          0    0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
        31,296      0    0        15,648             0       0             0          0    0              if (seen2[var(out_learnt[i])] != counter)
         5,320      0    0         2,128             0       0         1,064          0    0                  out_learnt[i--] = out_learnt[last--];
             .      .    .             .             .       .             .          .    .          out_learnt.shrink(to_remove);
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .      return to_remove != 0;
       180,458      0    0       180,458             0       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
             .      .    .             .             .       .             .          .    .  // visiting literals at levels that cannot be removed later.
             .      .    .             .             .       .             .          .    .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
   166,136,840  4,243    2             0             0       0    99,682,104    320,592    0  {
    33,227,368      0    0             0             0       0    16,613,684          0    0      analyze_stack.clear(); analyze_stack.push(p);
    49,841,052      0    0    33,227,368             0       0    16,613,684          0    0      int top = analyze_toclear.size();
    72,637,714      0    0             0             0       0             0          0    0      while (analyze_stack.size() > 0){
             .      .    .             .             .       .             .          .    .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
             .      .    .             .             .       .             .          .    .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          // Special handling for binary clauses like in 'analyze()'.
    64,856,992     29    5             0             0       0             0          0    0          if (c.size() == 2 && value(c[0]) == l_False){
             .      .    .             .             .       .             .          .    .              assert(value(c[1]) == l_True);
             .      .    .             .             .       .             .          .    .              Lit tmp = c[0];
       106,266      0    0        35,422         1,878       1        70,844          0    0              c[0] = c[1], c[1] = tmp; }
             .      .    .             .             .       .             .          .    .  
   222,680,070      0    0             0             0       0             0          0    0          for (int i = 1; i < c.size(); i++){
    95,630,694     38    4    95,630,694     7,523,283       7             0          0    0              Lit p  = c[i];
   356,525,770      0    0   191,261,388       389,324       0             0          0    0              if (!seen[var(p)] && level(var(p)) > 0){
   124,428,364      0    0    34,787,726             0       0             0          0    0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
    26,060,235      0    0             0             0       0    26,060,235          0    0                      seen[var(p)] = 1;
             .      .    .             .             .       .             .          .    .                      analyze_stack.push(p);
             5      0    0             0             0       0             0          0    0                      analyze_toclear.push(p);
             .      .    .             .             .       .             .          .    .                  }else{
   124,028,756    520    3    40,980,243             0       0             0          0    0                      for (int j = top; j < analyze_toclear.size(); j++)
    41,387,502      0    0    17,862,241             0       0    23,525,261          0    0                          seen[var(analyze_toclear[j])] = 0;
    17,454,982     23    1     8,727,491             0       0             0          0    0                      analyze_toclear.shrink(analyze_toclear.size() - top);
     8,727,491      0    0             0             0       0             0          0    0                      return false;
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
    15,772,386      0    0             0             0       0             0          0    0      return true;
   132,909,472     10    1   116,295,788            29       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  /*_________________________________________________________________________________________________
             .      .    .             .             .       .             .          .    .  |
             .      .    .             .             .       .             .          .    .  |  analyzeFinal : (p : Lit)  ->  [void]
             .      .    .             .             .       .             .          .    .  |  
             .      .    .             .             .       .             .          .    .  |  Description:
             .      .    .             .             .       .             .          .    .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      seen[var(p)] = 0;
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
   579,184,390      4    2             0             0       0   289,592,195          0    0  {
             .      .    .             .             .       .             .          .    .      assert(value(p) == l_Undef);
             .      .    .             .             .       .             .          .    .      Var x = var(p);
   115,836,878      0    0    57,918,439     1,090,612       0             0          0    0      if (!VSIDS){
   102,119,163      0    0    68,079,442       874,670       0    34,039,721 15,356,015    0          picked[x] = conflicts;
    68,079,442      0    0    34,039,721             0       0    34,039,721 15,498,521    0          conflicted[x] = 0;
    68,079,442      1    1    34,039,721             0       0    34,039,721 15,144,589    0          almost_conflicted[x] = 0;
             .      .    .             .             .       .             .          .    .  #ifdef ANTI_EXPLORATION
    34,039,721      0    0    34,039,721       416,039       0             0          0    0          uint32_t age = conflicts - canceled[var(p)];
    68,079,442      0    0    34,039,721    14,836,533       0             0          0    0          if (age > 0){
             .      .    .             .             .       .             .          .    .              double decay = pow(0.95, age);
    26,981,722      0    0    13,490,861     7,634,626       0    13,490,861          0    0              activity_CHB[var(p)] *= decay;
             .      .    .             .             .       .             .          .    .              if (order_heap_CHB.inHeap(var(p)))
    13,490,861      0    0             0             0       0             0          0    0                  order_heap_CHB.increase(var(p));
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
    57,918,439      1    0    57,918,439           307       0             0          0    0      assigns[x] = lbool(!sign(p));
   115,836,878      0    0             0             0       0   115,836,878 29,102,851   14      vardata[x] = mkVarData(from, level);
    57,918,439      2    1    57,918,439             0       0             0          0    0      trail.push_(p);
   405,429,073      0    0   347,510,634             0       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  unsigned number_watch_changed_total=0;
             .      .    .             .             .       .             .          .    .  unsigned number_clause_read_total=0;
             .      .    .             .             .       .             .          .    .  unsigned times_only_access_watch=0;
             .      .    .             .             .       .             .          .    .  /*_________________________________________________________________________________________________
             .      .    .             .             .       .             .          .    .  |
             .      .    .             .             .       .             .          .    .  |  propagate : [void]  ->  [Clause*]
             .      .    .             .             .       .             .          .    .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
             .      .    .             .             .       .             .          .    .  |  Description:
             .      .    .             .             .       .             .          .    .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
             .      .    .             .             .       .             .          .    .  |    otherwise CRef_Undef.
             .      .    .             .             .       .             .          .    .  |  
             .      .    .             .             .       .             .          .    .  |    Post-conditions:
             .      .    .             .             .       .             .          .    .  |      * the propagation queue is empty, even if there was a conflict.
             .      .    .             .             .       .             .          .    .  |________________________________________________________________________________________________@*/
             .      .    .             .             .       .             .          .    .  CRef Solver::propagate_()
    12,350,136      4    2             0             0       0     9,262,602          0    0  {
             .      .    .             .             .       .             .          .    .      //auto start_time=std::chrono::steady_clock::now();
     1,543,767      0    0             0             0       0     1,543,767          0    0      CRef    confl     = CRef_Undef;
     1,543,767      0    0             0             0       0     1,543,767         11    0      int     num_props = 0;
     3,087,534      0    0             0             0       0     1,543,767    117,203    0      watches.cleanAll();
     3,087,534      4    2             0             0       0     1,543,767          0    0      watches_bin.cleanAll();
             .      .    .             .             .       .             .          .    .      
   196,811,916      1    1   144,425,880       426,321       0             0          0    0      while (qhead < trail.size()){
   251,795,035      0    0   100,718,014     1,505,258       0    50,359,007          0    0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .      .    .             .             .       .             .          .    .          int currLevel = level(var(p));
             .      .    .             .             .       .             .          .    .          vec<Watcher>&  ws  = watches[p];
             .      .    .             .             .       .             .          .    .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          Watcher        *i, *j, *end;
    90,988,535      0    0    90,988,535       461,151       0             0          0    0          num_props++;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
             .      .    .             .             .       .             .          .    .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
   220,768,756      2    1    50,359,007    46,052,618     184             0          0    0          for (int k = 0; k < ws_bin.size(); k++){
    29,024,583      0    0    29,024,583     9,791,872      17             0          0    0              Lit the_other = ws_bin[k].blocker;
 3,913,317,700      0    0 3,829,281,269             0       0             0          0    0              if (value(the_other) == l_False){
        18,392      1    0         9,196             0       0         9,196          0    0                  confl = ws_bin[k].cref;
             .      .    .             .             .       .             .          .    .                  //auto end_time=std::chrono::steady_clock::now();
             .      .    .             .             .       .             .          .    .                  //auto duration=end_time-start_time;
             .      .    .             .             .       .             .          .    .  #ifdef LOOSE_PROP_STAT
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                  return confl;
             .      .    .             .             .       .             .          .    .  #else
             .      .    .             .             .       .             .          .    .                  goto ExitProp;
             .      .    .             .             .       .             .          .    .  #endif
    40,685,544      6    1             0             0       0             0          0    0              }else if(value(the_other) == l_Undef)
             .      .    .             .             .       .             .          .    .              {
    20,183,125      1    0    12,109,875             0       0     4,036,625    173,349    0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
             .      .    .             .             .       .             .          .    .  #ifdef  PRINT_OUT                
             .      .    .             .             .       .             .          .    .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
             .      .    .             .             .       .             .          .    .  #endif                
             .      .    .             .             .       .             .          .    .  			}
             .      .    .             .             .       .             .          .    .          }
   100,699,622      0    0   100,699,622    29,815,472      11             0          0    0          total_Watchers+=ws.size();
    50,349,811      0    0    50,349,811             0       0             0          0    0          total_indexs++;//number of rounds
             .      .    .             .             .       .             .          .    .          //int count=0;
    50,031,533      0    0             0             0       0             0          0    0          bool no_clause_access=true;
    50,031,533      0    0             0             0       0    50,031,533          0    0          bool no_implication_added=true;
    50,031,533      0    0             0             0       0    50,031,533          0    0          bool no_change_other_watch=true;
10,827,240,544      7    4 5,313,079,789             0       0    50,349,811          0    0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             .      .    .             .             .       .             .          .    .              // Try to avoid inspecting the clause:
             .      .    .             .             .       .             .          .    .              //count++;
 5,262,729,978      2    1 5,262,729,978   694,739,267  16,523             0          0    0              Lit blocker = i->blocker;
10,525,459,956      0    0 5,262,729,978       281,827       0             0          0    0              total_access_watches++;
10,525,459,956      0    0 5,262,729,978    12,183,675       0             0          0    0              if (value(blocker) == l_True){
             .      .    .             .             .       .             .          .    .                  
13,720,186,908      0    0 3,430,046,727             0       0 3,430,046,727  1,202,219    0                  *j++ = *i++; continue; }//no clause accessed
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Make sure the false literal is data[1]:
 1,836,011,140      0    0       546,063             0       0             0          0    0              no_clause_access=false;
 5,498,049,753      3    2 3,665,366,502       456,953       0 1,832,683,251          0    0              total_clause_access_times++;
 3,665,366,502      0    0 1,832,683,251             0       0             0          0    0              CRef     cr        = i->cref;
             .      .    .             .             .       .             .          .    .              //std::cout<<"cr: "<<cr<<"\n";
             .      .    .             .             .       .             .          .    .              Clause&  c         = ca[cr];
             .      .    .             .             .       .             .          .    .              Lit      false_lit = ~p;
 1,832,683,251      0    0 1,832,683,251             0       0             0          0    0              total_clause_access_size+=2;
 5,498,049,753      0    0 3,665,366,502 1,667,322,796  61,947             0          0    0              if (c[0] == false_lit)
 3,485,341,604      0    0 1,742,670,802    48,987,978   1,622 1,742,670,802          0    0                  c[0] = c[1], c[1] = false_lit;
             .      .    .             .             .       .             .          .    .              assert(c[1] == false_lit);
             .      .    .             .             .       .             .          .    .              i++;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // If 0th watch is true, then clause is already satisfied.
             .      .    .             .             .       .             .          .    .              Lit     first = c[0];
             .      .    .             .             .       .             .          .    .              Watcher w     = Watcher(cr, first);
 4,662,464,652      0    0   498,549,075       716,808       0             0          0    0              if (first != blocker && value(first) == l_True){
 1,197,703,626      0    0             0             0       0   798,469,084    430,472    0                  *j++ = w; continue; }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Look for new watch:
 7,862,718,230      1    1             0             0       0             0          0    0              for (int k = 2; k < c.size(); k++)
             .      .    .             .             .       .             .          .    .              {
14,021,720,138      0    0             0             0       0 3,045,783,981          0    0                  total_clause_access_size++;
 9,731,751,970      0    0   773,286,590             0       0             0          0    0                  if (value(c[k]) != l_False){
 5,522,041,508    832    0 2,761,020,754             0       0 2,761,020,754          0    0                      c[1] = c[k]; c[k] = false_lit;
 1,380,510,377      0    0 1,380,510,377             0       0             0          0    0                      total_change_other_watch++;
 1,380,510,377      0    0             0             0       0 1,380,510,377          0    0                      no_change_other_watch=false;
             .      .    .             .             .       .             .          .    .                      watches[~c[1]].push(w);
             .      .    .             .             .       .             .          .    .                      goto NextClause; }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Did not find watch -- clause is unit under assignment:
   159,412,570      0    0             0             0       0   105,876,664     38,498    0              *j++ = w;
   105,876,664      0    0             0             0       0             0          0    0              if (value(first) == l_False){
       597,574      0    0       597,574             0       0             0          0    0                  time_find_conflict++;
     3,585,444      2    2     2,390,296         8,434       0             0          0    0                  total_find_conflict_length+=i-(Watcher*)ws;
     1,195,148      0    0     1,195,148             0       0             0          0    0                  total_find_conflict_allsize+=ws.size();
             .      .    .             .             .       .             .          .    .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
       597,574      0    0             0             0       0       597,574          0    0                  confl = cr;
     1,195,148      0    0       597,574         2,713       0       597,574          0    0                  qhead = trail.size();
             .      .    .             .             .       .             .          .    .                  // Copy the remaining watches:
             .      .    .             .             .       .             .          .    .  
    70,369,878      3    2     1,143,637            16       0             0          0    0                  while (i < end)
    33,742,515      0    0    33,742,515     4,145,982     449    33,742,515     64,042    0                      *j++ = *i++;
             .      .    .             .             .       .             .          .    .              }else
             .      .    .             .             .       .             .          .    .              {//new implecate
    52,340,758      0    0             0             0       0    52,340,758          0    0                  no_implication_added=false;
    52,340,758      0    0    52,340,758             0       0             0          0    0                  total_push_new_implication++;
   157,022,274      0    0   104,681,516       176,834       0             0          0    0  				if (currLevel == decisionLevel())
             .      .    .             .             .       .             .          .    .  				{
   104,681,516      0    0             0             0       0             0          0    0  					uncheckedEnqueue(first, currLevel, cr);
             .      .    .             .             .       .             .          .    .  #ifdef PRINT_OUT					
             .      .    .             .             .       .             .          .    .  					std::cout << "i " << first << " l " << currLevel << "\n";
             .      .    .             .             .       .             .          .    .  #endif					
             .      .    .             .             .       .             .          .    .  				}
             .      .    .             .             .       .             .          .    .  				else
             .      .    .             .             .       .             .          .    .  				{
             .      .    .             .             .       .             .          .    .  					int nMaxLevel = currLevel;
           216      0    0             0             0       0             0          0    0  					int nMaxInd = 1;
             .      .    .             .             .       .             .          .    .  					// pass over all the literals in the clause and find the one with the biggest level
         1,156      0    0           108             0       0             0          0    0  					for (int nInd = 2; nInd < c.size(); ++nInd)
             .      .    .             .             .       .             .          .    .  					{
             .      .    .             .             .       .             .          .    .  						int nLevel = level(var(c[nInd]));
           824      0    0             0             0       0             0          0    0  						if (nLevel > nMaxLevel)
             .      .    .             .             .       .             .          .    .  						{
             .      .    .             .             .       .             .          .    .  							nMaxLevel = nLevel;
             .      .    .             .             .       .             .          .    .  							nMaxInd = nInd;
             .      .    .             .             .       .             .          .    .  						}
             .      .    .             .             .       .             .          .    .  					}
             .      .    .             .             .       .             .          .    .  
           216      2    1             0             0       0             0          0    0  					if (nMaxInd != 1)
             .      .    .             .             .       .             .          .    .  					{
             .      .    .             .             .       .             .          .    .  						std::swap(c[1], c[nMaxInd]);
             .      .    .             .             .       .             .          .    .  						*j--; // undo last watch
            37      0    0            37             0       0             0          0    0                          total_change_other_watch++;
            37      0    0             0             0       0            37          0    0                          no_change_other_watch=false;
             .      .    .             .             .       .             .          .    .  						watches[~c[1]].push(w);
             .      .    .             .             .       .             .          .    .  					}
             .      .    .             .             .       .             .          .    .  					
   261,703,898      0    0    52,340,758             0       0    52,340,758  1,464,532    0  					uncheckedEnqueue(first, nMaxLevel, cr);
             .      .    .             .             .       .             .          .    .  #ifdef PRINT_OUT					
             .      .    .             .             .       .             .          .    .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
             .      .    .             .             .       .             .          .    .  #endif	
             .      .    .             .             .       .             .          .    .  				}
             .      .    .             .             .       .             .          .    .  			}
             .      .    .             .             .       .             .          .    .  
       546,063     42    0             0             0       0             0          0    0  NextClause:;
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
   250,157,665      0    0    50,031,533             0       0             0          0    0          if(no_clause_access==true){
     4,502,288    179    1     4,502,288           367       0             0          0    0              total_no_clause_access++;
             .      .    .             .             .       .             .          .    .          }
   104,247,076     10    3    50,031,533             0       0             0          0    0          if(no_implication_added==true){
    22,675,411      1    0    22,357,133             6       0             0          0    0              total_no_implication_added++;
             .      .    .             .             .       .             .          .    .          }
   105,101,985      0    0    50,031,533             0       0             0          0    0          if(no_change_other_watch==true){
     9,711,087    101    1     9,711,087             0       0             0          0    0              total_no_change_other_watch++;
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          ws.shrink(i - j);
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  ExitProp:;
     3,069,142      3    1     3,069,142       428,245       0             0          0    0      propagations += num_props;
     1,534,571      0    0     1,534,571             0       0             0          0    0      simpDB_props -= num_props;
             .      .    .             .             .       .             .          .    .  
     1,534,571      0    0     1,534,571             0       0             0          0    0      return confl;
   672,512,255    332    2    10,806,369       956,810       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  /*_________________________________________________________________________________________________
             .      .    .             .             .       .             .          .    .  |
             .      .    .             .             .       .             .          .    .  |  reduceDB : ()  ->  [void]
             .      .    .             .             .       .             .          .    .  |  
             .      .    .             .             .       .             .          .    .  |  Description:
             .      .    .             .             .       .             .          .    .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
             .      .    .             .             .       .             .          .    .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
             .      .    .             .             .       .             .          .    .  |________________________________________________________________________________________________@*/
             .      .    .             .             .       .             .          .    .  struct reduceDB_lt { 
             .      .    .             .             .       .             .          .    .      ClauseAllocator& ca;
             .      .    .             .             .       .             .          .    .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    26,757,384     80    4    26,229,044     9,253,190   1,173             0          0    0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
             .      .    .             .             .       .             .          .    .  };
             .      .    .             .             .       .             .          .    .  void Solver::reduceDB()
           240     40    1             0             0       0           160          0    0  {
             .      .    .             .             .       .             .          .    .      int     i, j;
             .      .    .             .             .       .             .          .    .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .      .    .             .             .       .             .          .    .      //local_learnts_dirty = false;
             .      .    .             .             .       .             .          .    .  
            40      0    0             0             0       0             0          0    0      sort(learnts_local, reduceDB_lt(ca));
             .      .    .             .             .       .             .          .    .  
           200      0    0            40            40       0             0          0    0      int limit = learnts_local.size() / 2;
     2,127,012     40    2             0             0       0             0          0    0      for (i = j = 0; i < learnts_local.size(); i++){
     3,190,218     40    2     2,126,812        66,491       0             0          0    0          Clause& c = ca[learnts_local[i]];
     2,126,812      0    0     1,063,406     1,057,938     178             0          0    0          if (c.mark() == LOCAL)
     3,877,088      0    0     1,022,210             0       0             0          0    0              if (c.removable() && !locked(c) && i < limit)
     2,573,300      0    0       514,660             0       0       514,660          0    0                  removeClause(learnts_local[i]);
             .      .    .             .             .       .             .          .    .              else{
       105,614      0    0             0             0       0             0          0    0                  if (!c.removable()) limit++;
             .      .    .             .             .       .             .          .    .                  c.removable(true);
     2,620,142      0    0       507,550             0       0       507,550     31,757    0                  learnts_local[j++] = learnts_local[i]; }
             .      .    .             .             .       .             .          .    .      }
            40      0    0             0             0       0             0          0    0      learnts_local.shrink(i - j);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      checkGarbage();
           203      0    0           163            40       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  void Solver::reduceDB_Tier2()
           360     50    2             0             0       0           300          0    0  {
             .      .    .             .             .       .             .          .    .      int i, j;
     1,598,130     30    1            60            29       0             0          0    0      for (i = j = 0; i < learnts_tier2.size(); i++){
     1,981,788     44    3     1,321,192        41,336       0             0          0    0          Clause& c = ca[learnts_tier2[i]];
     1,321,192      0    0             0             0       0             0          0    0          if (c.mark() == TIER2)
     3,156,765     37    1     1,262,706       500,462       0             0          0    0              if (!locked(c) && c.touched() + 30000 < conflicts){
             .      .    .             .             .       .             .          .    .                  learnts_local.push(learnts_tier2[i]);
             .      .    .             .             .       .             .          .    .                  c.mark(LOCAL);
             .      .    .             .             .       .             .          .    .                  //c.removable(true);
             .      .    .             .             .       .             .          .    .                  c.activity() = 0;
             .      .    .             .             .       .             .          .    .                  claBumpActivity(c);
             .      .    .             .             .       .             .          .    .              }else
     2,611,535      0    0       522,307             0       0       522,307     26,320    0                  learnts_tier2[j++] = learnts_tier2[i];
             .      .    .             .             .       .             .          .    .      }
            60      0    0             0             0       0             0          0    0      learnts_tier2.shrink(i - j);
           360      0    0           360            60       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::removeSatisfied(vec<CRef>& cs)
           180      0    0             0             0       0            80          0    0  {
             .      .    .             .             .       .             .          .    .      int i, j;
     1,437,473      9    2       287,503            11       0             0          0    0      for (i = j = 0; i < cs.size(); i++){
       862,446      0    0       574,964        17,985       0             0          0    0          Clause& c = ca[cs[i]];
             .      .    .             .             .       .             .          .    .          if (satisfied(c))
         3,703      9    2             1             0       0         1,234         57    0              removeClause(cs[i]);
             .      .    .             .             .       .             .          .    .          else
       572,496      0    0             0             0       0       286,248        201    0              cs[j++] = cs[i];
             .      .    .             .             .       .             .          .    .      }
            20      0    0             0             0       0             0          0    0      cs.shrink(i - j);
           120      2    0           100            31       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
           132      0    0             0             0       0           110          0    0  {
             .      .    .             .             .       .             .          .    .      int i, j;
       404,697     10    2            22            11       0             0          0    0      for (i = j = 0; i < cs.size(); i++){
       593,082      0    0       395,388        12,374       0             0          0    0          Clause& c = ca[cs[i]];
       395,388      0    0             0             0       0             0          0    0          if (c.mark() == valid_mark)
             .      .    .             .             .       .             .          .    .              if (satisfied(c))
           320      3    0            80             0       0            80         16    0                  removeClause(cs[i]);
             .      .    .             .             .       .             .          .    .              else
       965,660      0    0       193,132             0       0       193,132      2,245    0                  cs[j++] = cs[i];
             .      .    .             .             .       .             .          .    .      }
            20      0    0             0             0       0             0          0    0      cs.shrink(i - j);
           132      6    2           132            39       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::rebuildOrderHeap()
           108      3    2             0             0       0            72          0    0  {
             .      .    .             .             .       .             .          .    .      vec<Var> vs;
        16,356      0    0            12             0       0            12          0    0      for (Var v = 0; v < nVars(); v++)
        48,822      0    0        24,411           232       0             0          0    0          if (decision[v] && value(v) == l_Undef)
             .      .    .             .             .       .             .          .    .              vs.push(v);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      order_heap_CHB  .build(vs);
             .      .    .             .             .       .             .          .    .      order_heap_VSIDS.build(vs);
             .      .    .             .             .       .             .          .    .      order_heap_distance.build(vs);
            96     12    2            84             6       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  /*_________________________________________________________________________________________________
             .      .    .             .             .       .             .          .    .  |
             .      .    .             .             .       .             .          .    .  |  simplify : [void]  ->  [bool]
             .      .    .             .             .       .             .          .    .  |  
             .      .    .             .             .       .             .          .    .  |  Description:
             .      .    .             .             .       .             .          .    .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
             .      .    .             .             .       .             .          .    .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
             .      .    .             .             .       .             .          .    .  |________________________________________________________________________________________________@*/
             .      .    .             .             .       .             .          .    .  bool Solver::simplify()
         8,088    281    2             0             0       0         5,392          0    0  {
             .      .    .             .             .       .             .          .    .      assert(decisionLevel() == 0);
             .      .    .             .             .       .             .          .    .  
         6,740      0    0         1,348           435       1             0          0    0      if (!ok || propagate() != CRef_Undef)
             .      .    .             .             .       .             .          .    .          return ok = false;
             .      .    .             .             .       .             .          .    .  
         4,476     99    2         2,912             0       0             0          0    0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
             .      .    .             .             .       .             .          .    .          return true;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Remove satisfied clauses:
            33      0    0             0             0       0            11          0    0      removeSatisfied(learnts_core); // Should clean core first.
            44      0    0             0             0       0            11          0    0      safeRemoveSatisfied(learnts_tier2, TIER2);
            44     11    2             0             0       0            11          0    0      safeRemoveSatisfied(learnts_local, LOCAL);
            22      0    0            11            11       0             0          0    0      if (remove_satisfied)        // Can be turned off.
            40     20    3             0             0       0            10          0    0          removeSatisfied(clauses);
             .      .    .             .             .       .             .          .    .      checkGarbage();
            22      1    1             0             0       0            11          0    0      rebuildOrderHeap();
             .      .    .             .             .       .             .          .    .  
            22      0    0            11            11       0            11          0    0      simpDB_assigns = nAssigns();
            33      0    0            22            11       0            11          0    0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
             .      .    .             .             .       .             .          .    .  
            11      0    0             0             0       0             0          0    0      return true;
         9,436      0    0         6,740             0       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  // pathCs[k] is the number of variables assigned at level k,
             .      .    .             .             .       .             .          .    .  // it is initialized to 0 at the begining and reset to 0 after the function execution
        81,952      4    1             0             0       0        61,464          0    0  bool Solver::collectFirstUIP(CRef confl){
        20,488      0    0             0             0       0        10,244          0    0      involved_lits.clear();
       357,330      4    1             0             0       0             0          0    0      int max_level=1;
             .      .    .             .             .       .             .          .    .      Clause& c=ca[confl]; int minLevel=decisionLevel();
       160,503      0    0        10,244             0       0             0          0    0      for(int i=0; i<c.size(); i++) {
             .      .    .             .             .       .             .          .    .          Var v=var(c[i]);
             .      .    .             .             .       .             .          .    .          //        assert(!seen[v]);
       163,848      8    1        54,616         6,723       0             0          0    0          if (level(v)>0) {
       108,910      0    0        54,455         6,259       0        54,455     13,457    0              seen[v]=1;
       119,154      0    0        64,699        14,849       0        54,455     31,072    0              var_iLevel_tmp[v]=1;
        54,455      0    0        54,455        24,116       0             0          0    0              pathCs[level(v)]++;
             .      .    .             .             .       .             .          .    .              if (minLevel>level(v)) {
             .      .    .             .             .       .             .          .    .                  minLevel=level(v);
             .      .    .             .             .       .             .          .    .                  assert(minLevel>0);
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              //    varBumpActivity(v);
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
        30,732      0    0        20,488         8,680       0             0          0    0      int limit=trail_lim[minLevel-1];
    10,605,540      0    0        10,244             0       0             0          0    0      for(int i=trail.size()-1; i>=limit; i--) {
     5,282,282     33    1     5,282,282       136,104       0             0          0    0          Lit p=trail[i]; Var v=var(p);
     5,282,282      0    0     2,641,141        71,464       0             0          0    0          if (seen[v]) {
             .      .    .             .             .       .             .          .    .              int currentDecLevel=level(v);
             .      .    .             .             .       .             .          .    .              //      if (currentDecLevel==decisionLevel())
             .      .    .             .             .       .             .          .    .              //      	varBumpActivity(v);
       331,917      0    0             0             0       0       331,917          0    0              seen[v]=0;
       663,834      0    0       331,917             0       0             0          0    0              if (--pathCs[currentDecLevel]!=0) {
             .      .    .             .             .       .             .          .    .                  Clause& rc=ca[reason(v)];
       642,952      5    1       443,799             0       0             0          0    0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
       295,866      0    0             0             0       0             0          0    0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
       328,280      0    0             0             0       0             0          0    0                  if (rc.size()==2 && value(rc[0])==l_False) {
             .      .    .             .             .       .             .          .    .                      // Special case for binary clauses
             .      .    .             .             .       .             .          .    .                      // The first one has to be SAT
             .      .    .             .             .       .             .          .    .                      assert(value(rc[1]) != l_False);
             .      .    .             .             .       .             .          .    .                      Lit tmp = rc[0];
         7,785      0    0         2,595            75       0         5,190          0    0                      rc[0] =  rc[1], rc[1] = tmp;
             .      .    .             .             .       .             .          .    .                  }
     1,434,074      0    0             0             0       0             0          0    0                  for (int j = 1; j < rc.size(); j++){
             .      .    .             .             .       .             .          .    .                      Lit q = rc[j]; Var v1=var(q);
     1,170,622      0    0             0             0       0             0          0    0                      if (level(v1) > 0) {
     1,165,604      0    0             0             0       0             0          0    0                          if (minLevel>level(v1)) {
       105,840      0    0        52,920        18,572       0             0          0    0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
             .      .    .             .             .       .             .          .    .                          }
     1,748,406      0    0     1,165,604         5,204       0             0          0    0                          if (seen[v1]) {
       610,680      0    0       305,340             0       0             0          0    0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
       449,294      0    0             0             0       0       224,647          0    0                                  var_iLevel_tmp[v1]=reasonVarLevel;
             .      .    .             .             .       .             .          .    .                          }
             .      .    .             .             .       .             .          .    .                          else {
       277,462      0    0             0             0       0       277,462     80,452    0                              var_iLevel_tmp[v1]=reasonVarLevel;
             .      .    .             .             .       .             .          .    .                              //   varBumpActivity(v1);
       277,462      0    0             0             0       0       277,462          0    0                              seen[v1] = 1;
       832,386      4    1       554,924        48,240       0             0          0    0                              pathCs[level(v1)]++;
             .      .    .             .             .       .             .          .    .                          }
             .      .    .             .             .       .             .          .    .                      }
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              involved_lits.push(p);
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
        30,732    355    1        10,244             0       0        10,244          0    0      double inc=var_iLevel_inc;
             .      .    .             .             .       .             .          .    .      vec<int> level_incs; level_incs.clear();
       415,652      0    0       153,968             0       0             0          0    0      for(int i=0;i<max_level;i++){
       174,456      4    1        87,228             0       0             0          0    0          level_incs.push(inc);
       261,684      0    0       174,456             0       0        87,228          0    0          inc = inc/my_var_decay;
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
       704,810      0    0       342,161             0       0             0          0    0      for(int i=0;i<involved_lits.size();i++){
        10,244      0    0        10,244             0       0             0          0    0          Var v =var(involved_lits[i]);
             .      .    .             .             .       .             .          .    .          //        double old_act=activity_distance[v];
             .      .    .             .             .       .             .          .    .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
     3,151,157  5,108    2     1,036,727        88,360       0       342,161          0    0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
             .      .    .             .             .       .             .          .    .  
       663,834      0    0             0             0       0             0          0    0          if(activity_distance[v]>1e100){
             .      .    .             .             .       .             .          .    .              for(int vv=0;vv<nVars();vv++)
        51,220    347    1        20,488        14,697       0        20,488          0    0                  activity_distance[vv] *= 1e-100;
             .      .    .             .             .       .             .          .    .              var_iLevel_inc*=1e-100;
        12,633     11    1             0             0       0             0          0    0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .          if (order_heap_distance.inHeap(v))
             .      .    .             .             .       .             .          .    .              order_heap_distance.decrease(v);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          //        var_iLevel_inc *= (1 / my_var_decay);
             .      .    .             .             .       .             .          .    .      }
        51,220    147    1        20,488             0       0        10,244          0    0      var_iLevel_inc=level_incs[level_incs.size()-1];
             .      .    .             .             .       .             .          .    .      return true;
        92,196      0    0        71,708            16       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  struct UIPOrderByILevel_Lt {
             .      .    .             .             .       .             .          .    .      Solver& solver;
             .      .    .             .             .       .             .          .    .      const vec<double>&  var_iLevel;
             .      .    .             .             .       .             .          .    .      bool operator () (Lit x, Lit y) const
             .      .    .             .             .       .             .          .    .      {
             .      .    .             .             .       .             .          .    .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
             .      .    .             .             .       .             .          .    .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
             .      .    .             .             .       .             .          .    .  |    Search for a model the specified number of conflicts. 
             .      .    .             .             .       .             .          .    .  |  
             .      .    .             .             .       .             .          .    .  |  Output:
             .      .    .             .             .       .             .          .    .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
             .      .    .             .             .       .             .          .    .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
             .      .    .             .             .       .             .          .    .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
             .      .    .             .             .       .             .          .    .  |________________________________________________________________________________________________@*/
             .      .    .             .             .       .             .          .    .  lbool Solver::search(int& nof_conflicts)
        14,707  1,092    2             0             0       0         9,359         24    0  {
             .      .    .             .             .       .             .          .    .      assert(ok);
             .      .    .             .             .       .             .          .    .      int         backtrack_level;
             .      .    .             .             .       .             .          .    .      int         lbd;
             .      .    .             .             .       .             .          .    .      vec<Lit>    learnt_clause;
             .      .    .             .             .       .             .          .    .      bool        cached = false;
         1,337      0    0         1,337            22       0             0          0    0      starts++;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // simplify
             .      .    .             .             .       .             .          .    .      //
         5,348      2    2         4,011         1,337       1             0          0    0      if (conflicts >= curSimplify * nbconfbeforesimplify){
             .      .    .             .             .       .             .          .    .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
             .      .    .             .             .       .             .          .    .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
             .      .    .             .             .       .             .          .    .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
             .      .    .             .             .       .             .          .    .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
            24     12    3            24             6       0             0          0    0          nbSimplifyAll++;
            72     24    4             0             0       0            24          0    0          if (!simplifyAll()){
             .      .    .             .             .       .             .          .    .              return l_False;
             .      .    .             .             .       .             .          .    .          }
           168      0    0            48             0       0            24          0    0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
            72      0    0            24             0       0            24          0    0          nbconfbeforesimplify += incSimplify;
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      for (;;){
             .      .    .             .             .       .             .          .    .          CRef confl = propagate();
             .      .    .             .             .       .             .          .    .  
     3,084,774      0    0             0             0       0             0          0    0          if (confl != CRef_Undef){
             .      .    .             .             .       .             .          .    .              // CONFLICT
     1,820,310      0    0       606,770         9,989       0             0          0    0              if (VSIDS){
       447,412      0    0       223,691       211,157       1            30          0    0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
             .      .    .             .             .       .             .          .    .              }else
     2,169,381     17    0     1,106,253       339,897       0       340,001          0    0                  if (step_size > min_step_size) step_size -= step_size_dec;
             .      .    .             .             .       .             .          .    .  
     2,427,080     58    9     1,213,540       544,473       0       606,770          0    0              conflicts++; nof_conflicts--;
             .      .    .             .             .       .             .          .    .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
             .      .    .             .             .       .             .          .    .              ConflictData data = FindConflictLevel(confl);
     1,213,540      2    1             0             0       0             0          0    0              if (data.nHighestLevel == 0) return l_False;
            20      0    0             8             0       0             0          0    0              if (data.bOnlyOneLitFromHighest)
             .      .    .             .             .       .             .          .    .              {
             2      1    0             0             0       0             0          0    0  				cancelUntil(data.nHighestLevel - 1);
             .      .    .             .             .       .             .          .    .  				continue;
             .      .    .             .             .       .             .          .    .  			}
             .      .    .             .             .       .             .          .    .  			
             .      .    .             .             .       .             .          .    .              learnt_clause.clear();
     1,213,536      0    0             0             0       0       606,768    512,972    0              if(conflicts>50000) DISTANCE=0;
             .      .    .             .             .       .             .          .    .              else DISTANCE=1;
     1,660,820      0    0             0             0       0             0          0    0              if(VSIDS && DISTANCE)
        40,976      4    1             0             0       0        10,244          0    0                  collectFirstUIP(confl);
             .      .    .             .             .       .             .          .    .  
     3,640,608     50    2             0             0       0       606,768          0    0              analyze(confl, learnt_clause, backtrack_level, lbd);
             .      .    .             .             .       .             .          .    .              // check chrono backtrack condition
     8,466,759     32    2     3,029,841         9,498       0             0          0    0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
             .      .    .             .             .       .             .          .    .              {
            11      0    0            11             0       0             0          0    0  				++chrono_backtrack;
            11      0    0             0             0       0             0          0    0  				cancelUntil(data.nHighestLevel -1);
             .      .    .             .             .       .             .          .    .  			}
             .      .    .             .             .       .             .          .    .  			else // default behavior
             .      .    .             .             .       .             .          .    .  			{
       606,757    274    4       606,757             2       0             0          0    0  				++non_chrono_backtrack;
             .      .    .             .             .       .             .          .    .  				cancelUntil(backtrack_level);
             .      .    .             .             .       .             .          .    .  			}
             .      .    .             .             .       .             .          .    .  
     1,820,304      0    0       606,768             0       0       606,768          0    0              lbd--;
     1,213,536      0    0       606,768             0       0             0          0    0              if (VSIDS){
       223,642      7    5             0             0       0       223,642          0    0                  cached = false;
       670,926     21    6       670,926       162,683       0             0          0    0                  conflicts_VSIDS++;
             .      .    .             .             .       .             .          .    .                  lbd_queue.push(lbd);
     1,789,136      0    0       670,926             0       0       223,642          0    0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
             .      .    .             .             .       .             .          .    .  
     1,820,304     27    4       606,768             0       0             0          0    0              if (learnt_clause.size() == 1){
            84      4    0            24             3       0            12          0    0                  uncheckedEnqueue(learnt_clause[0]);
             .      .    .             .             .       .             .          .    .              }else{
             .      .    .             .             .       .             .          .    .                  CRef cr = ca.alloc(learnt_clause, true);
       606,756      0    0       606,756             0       0             0          0    0                  ca[cr].set_lbd(lbd);
             .      .    .             .             .       .             .          .    .                  //duplicate learnts 
             .      .    .             .             .       .             .          .    .                  int  id = 0;
     1,213,512      0    0       606,756       574,717       0             0          0    0                  if (lbd <= max_lbd_dup){                        
             .      .    .             .             .       .             .          .    .                      std::vector<uint32_t> tmp;
    36,406,367      0    0    24,646,492             0       0       404,416          0    0                      for (int i = 0; i < learnt_clause.size(); i++)
    25,455,324      7    1    16,970,216             0       0     8,485,108          0    0                          tmp.push_back(learnt_clause[i].x);
     1,213,248      2    1       404,416             0       0       404,416          0    0                      id = is_duplicate(tmp);             
     2,022,080      0    0       404,416           284       0             0          0    0                      if (id == min_number_of_learnts_copies +1){
             9      0    0             9             0       0             0          0    0                          duplicates_added_conflicts++;                        
             .      .    .             .             .       .             .          .    .                      }                    
       808,832      0    0             0             0       0             0          0    0                      if (id == min_number_of_learnts_copies){
           192      0    0           192             0       0             0          0    0                          duplicates_added_tier2++;
             .      .    .             .             .       .             .          .    .                      }                                        
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .                  //duplicate learnts
             .      .    .             .             .       .             .          .    .  
     3,599,160      0    0     1,203,168       287,598       0             0          0    0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
            13      5    1             0             0       0             0          0    0                      learnts_core.push(cr);
             .      .    .             .             .       .             .          .    .                      ca[cr].mark(CORE);
     2,130,174  1,105    4             0             0       0             0          0    0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
            22      2    1             0             0       0             0          0    0                      learnts_tier2.push(cr);
             .      .    .             .             .       .             .          .    .                      ca[cr].mark(TIER2);
       510,948      0    0       127,737             4       0       127,737         79    0                      ca[cr].touched() = conflicts;
             .      .    .             .             .       .             .          .    .                  }else{
            23     21    1             0             0       0             0          0    0                      learnts_local.push(cr);
             .      .    .             .             .       .             .          .    .                      claBumpActivity(ca[cr]); }
     1,820,268    916    3             0             0       0       606,756          0    0                  attachClause(cr);
             .      .    .             .             .       .             .          .    .  
     3,640,536      0    0     1,820,268           346       0       606,756          0    0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
             .      .    .             .             .       .             .          .    .  #ifdef PRINT_OUT
             .      .    .             .             .       .             .          .    .                  std::cout << "new " << ca[cr] << "\n";
             .      .    .             .             .       .             .          .    .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
             .      .    .             .             .       .             .          .    .  #endif                
             .      .    .             .             .       .             .          .    .              }
     1,820,304      0    0       606,768        28,275       0             0          0    0              if (drup_file){
             .      .    .             .             .       .             .          .    .  #ifdef BIN_DRUP
             .      .    .             .             .       .             .          .    .                  binDRUP('a', learnt_clause, drup_file);
             .      .    .             .             .       .             .          .    .  #else
             .      .    .             .             .       .             .          .    .                  for (int i = 0; i < learnt_clause.size(); i++)
             .      .    .             .             .       .             .          .    .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
             .      .    .             .             .       .             .          .    .                  fprintf(drup_file, "0\n");
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
     1,820,304    680    3     1,213,536       211,594       0             0          0    0              if (VSIDS) varDecayActivity();
             .      .    .             .             .       .             .          .    .              claDecayActivity();
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              /*if (--learntsize_adjust_cnt == 0){
             .      .    .             .             .       .             .          .    .                  learntsize_adjust_confl *= learntsize_adjust_inc;
             .      .    .             .             .       .             .          .    .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
             .      .    .             .             .       .             .          .    .                  max_learnts             *= learntsize_inc;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
             .      .    .             .             .       .             .          .    .                             (int)conflicts,
             .      .    .             .             .       .             .          .    .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
             .      .    .             .             .       .             .          .    .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
             .      .    .             .             .       .             .          .    .              }*/
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .          }else{
             .      .    .             .             .       .             .          .    .              // NO CONFLICT
             .      .    .             .             .       .             .          .    .              bool restart = false;
     2,806,851     25    5       935,617        96,528       0             0          0    0              if (!VSIDS)
             .      .    .             .             .       .             .          .    .                  restart = nof_conflicts <= 0;
       710,286      1    1       355,143       193,460       0             0          0    0              else if (!cached){
     1,889,622      0    0       534,495       196,263       0       113,379          0    0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
             .      .    .             .             .       .             .          .    .                  cached = true;
             .      .    .             .             .       .             .          .    .              }
     1,741,422      0    0       580,474       289,039       0             0          0    0              if (restart /*|| !withinBudget()*/){
             .      .    .             .             .       .             .          .    .                  lbd_queue.clear();
             .      .    .             .             .       .             .          .    .                  cached = false;
             .      .    .             .             .       .             .          .    .                  // Reached bound on number of conflicts:
         4,008      0    0             0             0       0         2,672          0    0                  progress_estimate = progressEstimate();
             .      .    .             .             .       .             .          .    .                  cancelUntil(0);
         2,672      0    0             0             0       0             0          0    0                  return l_Undef; }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Simplify the set of problem clauses:
     2,910,395     28    1       934,281             0       0       103,509          0    0              if (decisionLevel() == 0 && !simplify())
             .      .    .             .             .       .             .          .    .                  return l_False;
             .      .    .             .             .       .             .          .    .  
     2,802,843      8    1     1,868,562           345       1             0          0    0              if (conflicts >= next_T2_reduce){
           120      0    0             0             0       0            60          0    0                  next_T2_reduce = conflicts + 10000;
           240      0    0            60             0       0            60          0    0                  reduceDB_Tier2(); }
     1,868,562     24    3       934,281             0       0             0          0    0              if (conflicts >= next_L_reduce){
            80      0    0             0             0       0            40          0    0                  next_L_reduce = conflicts + 15000;
            80      0    0             0             0       0            40          0    0                  reduceDB(); }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              Lit next = lit_Undef;
             .      .    .             .             .       .             .          .    .              /*while (decisionLevel() < assumptions.size()){
             .      .    .             .             .       .             .          .    .                  // Perform user provided assumption:
             .      .    .             .             .       .             .          .    .                  Lit p = assumptions[decisionLevel()];
             .      .    .             .             .       .             .          .    .                  if (value(p) == l_True){
             .      .    .             .             .       .             .          .    .                      // Dummy decision level:
             .      .    .             .             .       .             .          .    .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
             .      .    .             .             .       .             .          .    .                  }else{
             .      .    .             .             .       .             .          .    .                      next = p;
             .      .    .             .             .       .             .          .    .                      break;
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              if (next == lit_Undef)*/{
             .      .    .             .             .       .             .          .    .                  // New variable decision:
       934,281      0    0       934,281            40       0             0          0    0                  decisions++;
     2,802,843    315    5             0             0       0       934,281          0    0                  next = pickBranchLit();
             .      .    .             .             .       .             .          .    .  
     1,868,562      0    0             0             0       0             0          0    0                  if (next == lit_Undef)
             .      .    .             .             .       .             .          .    .                      // Model found:
             2      0    0             0             0       0             0          0    0                      return l_True;
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .              // Increase decision level and enqueue 'next'
             .      .    .             .             .       .             .          .    .              newDecisionLevel();
     5,605,680     26    4       934,280             0       0       934,280          0    0              uncheckedEnqueue(next, decisionLevel());
             .      .    .             .             .       .             .          .    .  #ifdef PRINT_OUT            
             .      .    .             .             .       .             .          .    .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
             .      .    .             .             .       .             .          .    .  #endif            
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
        12,033     26    0         9,359         1,850       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  double Solver::progressEstimate() const
         8,016      4    3             0             0       0         6,680          0    0  {
         2,672      0    0             0             0       0             0          0    0      double  progress = 0;
         6,680      0    0         2,672           824       0         1,336          0    0      double  F = 1.0 / nVars();
             .      .    .             .             .       .             .          .    .  
       140,252      3    3             0             0       0             0          0    0      for (int i = 0; i <= decisionLevel(); i++){
       132,236      0    0        86,376             0       0             0          0    0          int beg = i == 0 ? 0 : trail_lim[i - 1];
       176,760      0    0        87,712         3,439       0             0          0    0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
       271,152     10    1        45,860             0       0             0          0    0          progress += pow(F, i) * (end - beg);
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
         2,672      0    0             0             0       0             0          0    0      return progress / nVars();
         9,352      0    0         8,016             0       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  /*
             .      .    .             .             .       .             .          .    .    Finite subsequences of the Luby-sequence:
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .    0: 1
             .      .    .             .             .       .             .          .    .    1: 1 1 2
             .      .    .             .             .       .             .          .    .    2: 1 1 2 1 1 2 4
             .      .    .             .             .       .             .          .    .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .   */
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  static double luby(double y, int x){
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Find the finite subsequence that contains index 'x', and the
             .      .    .             .             .       .             .          .    .      // size of that subsequence:
             .      .    .             .             .       .             .          .    .      int size, seq;
        40,883      0    0             0             0       0             0          0    0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
             .      .    .             .             .       .             .          .    .  
        22,775      0    0             0             0       0             0          0    0      while (size-1 != x){
        12,746      0    0             0             0       0             0          0    0          size = (size-1)>>1;
         6,373      0    0             0             0       0             0          0    0          seq--;
        19,119      0    0             0             0       0             0          0    0          x = x % size;
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      return pow(y, seq);
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  static bool switch_mode = false;
             .      .    .             .             .       .             .          .    .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
             .      .    .             .             .       .             .          .    .  
             8      1    1             0             0       0             6          0    0  uint32_t Solver::reduceduplicates(){
             .      .    .             .             .       .             .          .    .      uint32_t removed_duplicates = 0;
             .      .    .             .             .       .             .          .    .      std::vector<std::vector<uint64_t>> tmp;
             .      .    .             .             .       .             .          .    .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
         1,603      0    0             2             0       0             0          0    0      for (auto & outer_mp: ht){//variables
        27,264      0    0             0             0       0             0          0    0          for (auto &inner_mp:outer_mp.second){//sizes
       983,338      0    0             0             0       0             0          0    0              for (auto &in_in_mp: inner_mp.second){
     1,437,702      1    1       479,234       459,369 146,088             0          0    0                  if (in_in_mp.second >= 2){
             .      .    .             .             .       .             .          .    .                  //min_number_of_learnts_copies
       285,910      1    1       114,364           204      40       114,364        189    0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
             .      .    .             .             .       .             .          .    .                  }
             .      .    .             .             .       .             .          .    .              }                    
             .      .    .             .             .       .             .          .    .           }
             .      .    .             .             .       .             .          .    .      }          
             3      0    0             1             1       0             1          0    0      removed_duplicates = dupl_db_size-tmp.size();  
             .      .    .             .             .       .             .          .    .      ht.clear();
       200,142      1    1        85,774             5       0             0          0    0      for (auto i=0;i<tmp.size();i++){
       285,910      0    0       142,955        32,179      16        85,773          4    0          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .      return removed_duplicates;
             9      0    0             8             3       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  // NOTE: assumptions passed in member-variable 'assumptions'.
             .      .    .             .             .       .             .          .    .  lbool Solver::solve_()
             8      0    0             0             0       0             6          0    0  {
             .      .    .             .             .       .             .          .    .      //signal(SIGALRM, SIGALRM_switch);
             .      .    .             .             .       .             .          .    .      //alarm(2500);
             .      .    .             .             .       .             .          .    .  
             1      1    1             0             0       0             0          0    0      model.clear();
             .      .    .             .             .       .             .          .    .      conflict.clear();
             2      1    1             1             0       0             0          0    0      if (!ok) return l_False;
             .      .    .             .             .       .             .          .    .  
             1      1    1             1             1       0             0          0    0      solves++;
             .      .    .             .             .       .             .          .    .  
             5      0    0             2             0       0             1          0    0      max_learnts               = nClauses() * learntsize_factor;
             3      0    0             1             1       0             0          0    0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
             1      0    0             0             0       0             1          1    0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
             .      .    .             .             .       .             .          .    .      lbool   status            = l_Undef;
             .      .    .             .             .       .             .          .    .  
             3      0    0             1             0       0             0          0    0      if (verbosity >= 1){
             2      0    0             0             0       0             1          0    0          printf("c ============================[ Search Statistics ]==============================\n");
             2      1    1             0             0       0             1          0    0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
             2      0    0             0             0       0             1          0    0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
             2      0    0             0             0       0             1          0    0          printf("c ===============================================================================\n");
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      add_tmp.clear();
             .      .    .             .             .       .             .          .    .  
             1      0    0             0             0       0             1          1    0      VSIDS = true;
             1      1    1             0             0       0             1          0    0      int init = 10000;
           150      0    0            30             0       0             0          0    0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
           120      3    0             0             0       0            30          0    0          status = search(init);
             1      0    0             0             0       0             1          0    0      VSIDS = false;
             .      .    .             .             .       .             .          .    .  
             3      1    1             0             0       0             2          1    0      duplicates_added_conflicts = 0;
             .      .    .             .             .       .             .          .    .      duplicates_added_minimization=0;
             .      .    .             .             .       .             .          .    .      duplicates_added_tier2 =0;    
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      dupl_db_size=0;
             1      0    0             1             0       0             0          0    0      size_t dupl_db_size_limit = dupl_db_init_size;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // Search:
             1      0    0             0             0       0             0          0    0      int curr_restarts = 0;
             1      0    0             0             0       0             0          0    0      uint64_t curr_props = 0;
             .      .    .             .             .       .             .          .    .      uint32_t removed_duplicates =0;
         2,614    317    0             0             0       0             0          0    0      while (status == l_Undef /*&& withinBudget()*/){
         2,614      1    1         1,307           383       0             0          0    0          if (dupl_db_size >= dupl_db_size_limit){    
             4      1    1             1             0       0             1          0    0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             4      0    0             1             1       0             1          0    0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             4      0    0             1             0       0             1          0    0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             4      1    1             1             0       0             1          0    0              printf("c Duptime: %i\n",duptime.count());
             4      0    0             1             0       0             1          0    0              printf("c Number of conflicts: %i\n",conflicts);
             4      0    0             1             1       0             1          0    0              printf("c Core size: %i\n",learnts_core.size());
             .      .    .             .             .       .             .          .    .              
             2      0    0             0             0       0             1          0    0              removed_duplicates = reduceduplicates();
             8      1    1             2             2       0             0          0    0              dupl_db_size_limit*=1.1;
             2      0    0             1             1       1             0          0    0              dupl_db_size -= removed_duplicates;
             5      0    0             0             0       0             1          0    0              printf("c removed duplicates %i\n",removed_duplicates);
             .      .    .             .             .       .             .          .    .          }   
         7,842     42    2         2,614         1,270       1             0          0    0          if (propagations - curr_props >  VSIDS_props_limit){
             1      0    0             0             0       0             0          0    0              curr_props = propagations;
             1      0    0             0             0       0             1          0    0              switch_mode = true;
             6      0    0             0             0       0             1          0    0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
             .      .    .             .             .       .             .          .    .          }     
         2,614      0    0         1,307             1       0             0          0    0          if (VSIDS){
           388      0    0             0             0       0           388          0    0              int weighted = INT32_MAX;
         1,552    387    1             0             0       0           388          0    0              status = search(weighted);
             .      .    .             .             .       .             .          .    .          }else{
         5,514    881    1         1,838             0       0           919          0    0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
           919      0    0             0             0       0             0          0    0              curr_restarts++;
         4,595    917    0             0             0       0           919          0    0              status = search(nof_conflicts);
             .      .    .             .             .       .             .          .    .          }
         2,614    917    0         1,307         1,307       2             0          0    0          if (switch_mode){ 
             1      0    0             0             0       0             1          0    0              switch_mode = false;
             .      .    .             .             .       .             .          .    .              VSIDS = !VSIDS;
             2      0    0             1             0       0             0          0    0              if (VSIDS){
             2      1    1             0             0       0             1          0    0                  printf("c Switched to VSIDS.\n");
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              else{
             .      .    .             .             .       .             .          .    .                 printf("c Switched to LRB.\n");
             .      .    .             .             .       .             .          .    .              }
             .      .    .             .             .       .             .          .    .              //            reduceduplicates();            
             2      0    0             1             1       1             1          0    0              fflush(stdout);
             .      .    .             .             .       .             .          .    .              picked.clear();
             .      .    .             .             .       .             .          .    .              conflicted.clear();
             .      .    .             .             .       .             .          .    .              almost_conflicted.clear();
             .      .    .             .             .       .             .          .    .  #ifdef ANTI_EXPLORATION
             .      .    .             .             .       .             .          .    .              canceled.clear();
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             3      1    1             1             1       0             0          0    0      if (verbosity >= 1)
             2      0    0             0             0       0             1          0    0          printf("c ===============================================================================\n");
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  #ifdef BIN_DRUP
             3      0    0             1             0       0             0          0    0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
             .      .    .             .             .       .             .          .    .  #endif
             .      .    .             .             .       .             .          .    .  
             2      1    1             0             0       0             0          0    0      if (status == l_True){
             .      .    .             .             .       .             .          .    .          // Extend & copy model:
             .      .    .             .             .       .             .          .    .          model.growTo(nVars());
           115      1    1            43             1       0            49          0    0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
             .      .    .             .             .       .             .          .    .      }else if (status == l_False && conflict.size() == 0)
             .      .    .             .             .       .             .          .    .          ok = false;
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      cancelUntil(0);
             1      0    0             0             0       0             0          0    0      return status;
             8      1    1             7             1       1             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  //=================================================================================================
             .      .    .             .             .       .             .          .    .  // Writing CNF to DIMACS:
             .      .    .             .             .       .             .          .    .  // 
             .      .    .             .             .       .             .          .    .  // FIXME: this needs to be rewritten completely.
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  static Var mapVar(Var x, vec<Var>& map, Var& max)
             .      .    .             .             .       .             .          .    .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
             .      .    .             .             .       .             .          .    .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
             .      .    .             .             .       .             .          .    .  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  //=================================================================================================
             .      .    .             .             .       .             .          .    .  // Garbage Collection methods:
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::relocAll(ClauseAllocator& to)
           380     46    8             0             0       0           304          0    0  {
             .      .    .             .             .       .             .          .    .      // All watchers:
             .      .    .             .             .       .             .          .    .      //
             .      .    .             .             .       .             .          .    .      // for (int i = 0; i < watches.size(); i++)
            76      0    0             0             0       0            38          0    0      watches.cleanAll();
            76      0    0             0             0       0            38          0    0      watches_bin.cleanAll();
       258,248     10    3       180,652         5,411       0        25,878         38    0      for (int v = 0; v < nVars(); v++)
       103,208      0    0        51,604             0       0             0          0    0          for (int s = 0; s < 2; s++){
             .      .    .             .             .       .             .          .    .              Lit p = mkLit(v, s);
             .      .    .             .             .       .             .          .    .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
             .      .    .             .             .       .             .          .    .              vec<Watcher>& ws = watches[p];
    17,599,229     15    4     9,570,488        12,956       2             0          0    0              for (int j = 0; j < ws.size(); j++)
             .      .    .             .             .       .             .          .    .                  ca.reloc(ws[j].cref, to);
             .      .    .             .             .       .             .          .    .              vec<Watcher>& ws_bin = watches_bin[p];
       499,253      2    1       201,960        16,253       9             0          0    0              for (int j = 0; j < ws_bin.size(); j++)
             .      .    .             .             .       .             .          .    .                  ca.reloc(ws_bin[j].cref, to);
             .      .    .             .             .       .             .          .    .          }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // All reasons:
             .      .    .             .             .       .             .          .    .      //
        15,384      0    0           114             0       0             0          0    0      for (int i = 0; i < trail.size(); i++){
             .      .    .             .             .       .             .          .    .          Var v = var(trail[i]);
             .      .    .             .             .       .             .          .    .  
        26,588      0    0         5,716         5,414       0             0          0    0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
        28,656      0    0         5,716             0       0         5,716          0    0              ca.reloc(vardata[v].reason, to);
             .      .    .             .             .       .             .          .    .      }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // All learnt:
             .      .    .             .             .       .             .          .    .      //
     1,860,741     38    3       930,351            43       0             0          0    0      for (int i = 0; i < learnts_core.size(); i++)
             .      .    .             .             .       .             .          .    .          ca.reloc(learnts_core[i], to);
       736,391    114    6       368,195           149       0             0          0    0      for (int i = 0; i < learnts_tier2.size(); i++)
             .      .    .             .             .       .             .          .    .          ca.reloc(learnts_tier2[i], to);
       943,753     38    2       471,801            37       0             0          0    0      for (int i = 0; i < learnts_local.size(); i++)
     1,415,175      0    0             0             0       0       471,725          0    0          ca.reloc(learnts_local[i], to);
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      // All original:
             .      .    .             .             .       .             .          .    .      //
             .      .    .             .             .       .             .          .    .      int i, j;
     1,271,282     38    2           152            37       0             0          0    0      for (i = j = 0; i < clauses.size(); i++)
     1,270,940      0    0             0             0       0             0          0    0          if (ca[clauses[i]].mark() != 1){
     1,906,486     38    2       635,470            37       0       635,470          0    0              ca.reloc(clauses[i], to);
     6,354,662     32    2     2,541,842             0       0       635,470          0    0              clauses[j++] = clauses[i]; }
            38     38    2             0             0       0             0          0    0      clauses.shrink(i - j);
           304     38    2           266            38       0             0          0    0  }
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .  void Solver::garbageCollect()
             .      .    .             .             .       .             .          .    .  {
             .      .    .             .             .       .             .          .    .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
             .      .    .             .             .       .             .          .    .      // is not precise but should avoid some unnecessary reallocations for the new region:
             .      .    .             .             .       .             .          .    .      ClauseAllocator to(ca.size() - ca.wasted());
             .      .    .             .             .       .             .          .    .  
             .      .    .             .             .       .             .          .    .      relocAll(to);
             .      .    .             .             .       .             .          .    .      if (verbosity >= 2)
             .      .    .             .             .       .             .          .    .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
             .      .    .             .             .       .             .          .    .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
             .      .    .             .             .       .             .          .    .      to.moveTo(ca);
           155     18   18            47             4       4            61          0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr            D1mr        DLmr   Dw            D1mw      DLmw    

-- line 54 ----------------------------------------
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  struct Lit {
             .     .    .             .           .      .             .         .       .      int     x;
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      // Use this as a constructor:
             .     .    .             .           .      .             .         .       .      friend Lit mkLit(Var var, bool sign );
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      bool operator == (Lit p) const { return x == p.x; }
    88,134,316     0    0    45,542,658  22,794,604    222             0         0       0      bool operator != (Lit p) const { return x != p.x; }
             .     .    .             .           .      .             .         .       .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
             .     .    .             .           .      .             .         .       .  };
             .     .    .             .           .      .             .         .       .  
       145,682     1    1             0           0      0             3         0       0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 6,075,017,769    29    9 2,906,092,794      32,048     65   100,669,834     9,670       0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
             .     .    .             .           .      .             .         .       .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
18,972,106,578     8    4   233,584,735           0      0   117,747,925 4,198,085       0  inline  bool sign      (Lit p)              { return p.x & 1; }
29,766,406,619 7,004   19   393,018,000   4,000,302      7 5,262,736,977         0       0  inline  int  var       (Lit p)              { return p.x >> 1; }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  // Mapping Literals to and from compact integers suitable for array indexing:
             .     .    .             .           .      .             .         .       .  inline  int  toInt     (Var v)              { return v; } 
           628     0    0             0           0      0             0         0       0  inline  int  toInt     (Lit p)              { return p.x; } 
             .     .    .             .           .      .             .         .       .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
             .     .    .             .           .      .             .         .       .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
             .     .    .             .           .      .             .         .       .  const Lit lit_Error = { -1 };  // }
             .     .    .             .           .      .             .         .       .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
             .     .    .             .           .      .             .         .       .  #define l_Undef (lbool((uint8_t)2))
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  class lbool {
             .     .    .             .           .      .             .         .       .      uint8_t value;
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  public:
             .     .    .             .           .      .             .         .       .      explicit lbool(uint8_t v) : value(v) { }
             .     .    .             .           .      .             .         .       .  
           186     1    1             0           0      0            49        10       9      lbool()       : value(0) { }
             .     .    .             .           .      .             .         .       .      explicit lbool(bool x) : value(!x) { }
             .     .    .             .           .      .             .         .       .  
 1,943,742,236     1    1             0           0      0             0         0       0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
         2,037     0    0         1,358          11      0             0         0       0      bool  operator != (lbool b) const { return !(*this == b); }
 5,028,008,213    24    4 4,284,739,681   5,367,163      0             0         0       0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      lbool operator && (lbool b) const {
             .     .    .             .           .      .             .         .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
             .     .    .             .           .      .             .         .       .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
             .     .    .             .           .      .             .         .       .          return lbool(v); }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      lbool operator || (lbool b) const {
             .     .    .             .           .      .             .         .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
             .     .    .             .           .      .             .         .       .          unsigned simplified : 1;}                            header;
             .     .    .             .           .      .             .         .       .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      friend class ClauseAllocator;
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
             .     .    .             .           .      .             .         .       .      template<class V>
             .     .    .             .           .      .             .         .       .      Clause(const V& ps, bool use_extra, bool learnt) {
    10,246,385     0    0     2,409,907           0      0     3,016,663    15,676       1          header.mark      = 0;
     7,174,563     0    0     2,391,521     149,297 19,516             0         0       0          header.learnt    = learnt;
    14,477,828     3    2     2,428,293           1      0     2,409,907         0       0          header.has_extra = learnt | use_extra;
             .     .    .             .           .      .             .         .       .          header.reloced   = 0;
     3,641,803     0    0       625,141          35      0     3,016,662   338,576  18,204          header.size      = ps.size();
             .     .    .             .           .      .             .         .       .          header.lbd       = 0;
             .     .    .             .           .      .             .         .       .          header.removable = 1;
             .     .    .             .           .      .             .         .       .          //simplify
             .     .    .             .           .      .             .         .       .          //
     3,016,663     6    4     3,016,663     337,850 47,856             0         0       0          header.simplified = 0;
             .     .    .             .           .      .             .         .       .  
   104,360,876    73   12       754,186           0      0             0         0       0          for (int i = 0; i < ps.size(); i++)
    62,269,879    77    7    21,495,281   1,664,727  7,770    25,461,487 2,751,515 455,919              data[i].lit = ps[i];
             .     .    .             .           .      .             .         .       .  
     9,049,988    34    5     3,016,662           0      0             0         0       0          if (header.has_extra){
     4,762,384    13    3             0           0      0             0         0       0              if (header.learnt){
     4,725,614     2    1     1,756,038           0      0     2,362,807   147,475  21,155                  data[header.size].act = 0;
     4,725,627     0    0             0           0      0     2,362,807   147,673  21,278                  data[header.size+1].touched = 0;
             .     .    .             .           .      .             .         .       .              }else
             .     .    .             .           .      .             .         .       .                  calcAbstraction(); }
             .     .    .             .           .      .             .         .       .      }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  public:
             .     .    .             .           .      .             .         .       .      void calcAbstraction() {
             .     .    .             .           .      .             .         .       .          assert(header.has_extra);
        19,165     0    0             0           0      0             0         0       0          uint32_t abstraction = 0;
       344,592     2    1           496           0      0             0         0       0          for (int i = 0; i < size(); i++)
       591,606     2    1             0           0      0             1         0       0              abstraction |= 1 << (var(data[i].lit) & 31);
        37,546     0    0             0           0      0        19,161     1,185   1,185          data[header.size].abs = abstraction;  }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
 4,001,756,308   110   24 2,242,574,360 265,442,604  6,190 1,435,893,080        21       0      int          size        ()      const   { return header.size; }
     1,517,499    28    8       379,884      92,293      0       379,884    16,132       0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
             .     .    .             .           .      .             .         .       .      void         pop         ()              { shrink(1); }
    25,615,931     3    2       517,182           0      0             0         0       0      bool         learnt      ()      const   { return header.learnt; }
         3,908     0    0             0           0      0             0         0       0      bool         has_extra   ()      const   { return header.has_extra; }
    41,348,922    72    4     7,921,006   7,311,885  1,222    10,342,860         0       0      uint32_t     mark        ()      const   { return header.mark; }
    12,800,555    90    8     3,398,125       1,965      0     3,110,081         0       0      void         mark        (uint32_t m)    { header.mark = m; }
        77,048     0    0             0           0      0        38,524         0       0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
             .     .    .             .           .      .             .         .       .  
     7,194,207     0    0     7,194,207   5,684,052     35             0         0       0      bool         reloced     ()      const   { return header.reloced; }
             .     .    .             .           .      .             .         .       .      CRef         relocation  ()      const   { return data[0].rel; }
     9,566,084     6    3     2,391,521           0      0     4,783,042         0       0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
             .     .    .             .           .      .             .         .       .  
     7,353,684     0    0     2,442,428           0      0             0         0       0      int          lbd         ()      const   { return header.lbd; }
    17,453,523    59    8     4,381,967           0      0     2,627,133         0       0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
             .     .    .             .           .      .             .         .       .      bool         removable   ()      const   { return header.removable; }
    11,272,777     3    2     4,248,573           0      0     1,756,051         0       0      void         removable   (bool b)        { header.removable = b; }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
             .     .    .             .           .      .             .         .       .      //       subsumption operations to behave correctly.
 4,489,852,870    74   13 4,174,805,457 328,813,487 18,967             0         0       0      Lit&         operator [] (int i)         { return data[i].lit; }
    62,477,900   169   13    57,240,620   1,990,047    516             0         0       0      Lit          operator [] (int i) const   { return data[i].lit; }
             .     .    .             .           .      .             .         .       .      operator const Lit* (void) const         { return (Lit*)data; }
             .     .    .             .           .      .             .         .       .  
     1,883,788     0    0     1,883,788           2      0             0         0       0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     2,395,268     0    0       726,095     187,961      0             0         0       0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
             .     .    .             .           .      .             .         .       .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      Lit          subsumes    (const Clause& other) const;
             .     .    .             .           .      .             .         .       .      void         strengthen  (Lit p);
             .     .    .             .           .      .             .         .       .      // simplify
             .     .    .             .           .      .             .         .       .      //
    12,644,531     0    0     3,688,189           0      0     1,756,051         0       0      void setSimplified(bool b) { header.simplified = b; }
             .     .    .             .           .      .             .         .       .      bool simplified() { return header.simplified; }
             .     .    .             .           .      .             .         .       .  };
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  //=================================================================================================
             .     .    .             .           .      .             .         .       .  // ClauseAllocator -- a simple class for allocating memory for clauses:
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
             .     .    .             .           .      .             .         .       .  class ClauseAllocator : public RegionAllocator<uint32_t>
             .     .    .             .           .      .             .         .       .  {
             .     .    .             .           .      .             .         .       .      static int clauseWord32Size(int size, int extras){
     5,925,382     4    2     2,908,707     135,858     20             0         0       0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
             .     .    .             .           .      .             .         .       .  public:
             .     .    .             .           .      .             .         .       .      bool extra_clause_field;
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
             1     0    0             0           0      0             1         0       0      ClauseAllocator() : extra_clause_field(false){}
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      void moveTo(ClauseAllocator& to){
            76    14    2            38           1      0            38         0       0          to.extra_clause_field = extra_clause_field;
             .     .    .             .           .      .             .         .       .          RegionAllocator<uint32_t>::moveTo(to); }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      template<class Lits>
             .     .    .             .           .      .             .         .       .      CRef alloc(const Lits& ps, bool learnt = false)
             .     .    .             .           .      .             .         .       .      {
             .     .    .             .           .      .             .         .       .          assert(sizeof(Lit)      == sizeof(uint32_t));
             .     .    .             .           .      .             .         .       .          assert(sizeof(float)    == sizeof(uint32_t));
     5,436,897    53    7       653,855          30      0             0         0       0          int extras = learnt ? 2 : (int)extra_clause_field;
             .     .    .             .           .      .             .         .       .  
       643,526     0    0             0           0      0        18,385         0       0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
             .     .    .             .           .      .             .         .       .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .          return cid;
             .     .    .             .           .      .             .         .       .      }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    20,702,795    40    2    18,681,097      10,442      0         6,100         0       0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
         3,040     1    1         1,520           8      0             0         0       0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     2,391,521     0    0     2,391,521           0      0             0         0       0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
             .     .    .             .           .      .             .         .       .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
             .     .    .             .           .      .             .         .       .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      void free(CRef cid)
             .     .    .             .           .      .             .         .       .      {
             .     .    .             .           .      .             .         .       .          Clause& c = operator[](cid);
     1,555,454    10    2             0           0      0             0         0       0          int extras = c.learnt() ? 2 : (int)c.has_extra();
             .     .    .             .           .      .             .         .       .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
             .     .    .             .           .      .             .         .       .      }
             .     .    .             .           .      .             .         .       .  
     7,790,377    38    4             0           0      0     6,677,466        73       0      void reloc(CRef& cr, ClauseAllocator& to)
             .     .    .             .           .      .             .         .       .      {
             .     .    .             .           .      .             .         .       .          Clause& c = operator[](cr);
             .     .    .             .           .      .             .         .       .          
    25,292,066     0    0     4,802,686     797,293      0     4,802,686         0       0          if (c.reloced()) { cr = c.relocation(); return; }
             .     .    .             .           .      .             .         .       .          
     2,391,521     0    0             0           0      0     2,391,521         0       0          cr = to.alloc(c, c.learnt());
             .     .    .             .           .      .             .         .       .          c.relocate(cr);
             .     .    .             .           .      .             .         .       .          
             .     .    .             .           .      .             .         .       .          // Copy extra data-fields:
             .     .    .             .           .      .             .         .       .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
             .     .    .             .           .      .             .         .       .          to[cr].mark(c.mark());
     4,783,042     2    1             0           0      0             0         0       0          if (to[cr].learnt()){
     7,024,204     0    0     1,756,051      96,962    413     1,756,051         0       0              to[cr].touched() = c.touched();
     7,024,191     0    0     3,512,102      97,727    387     1,756,051         0       0              to[cr].activity() = c.activity();
             .     .    .             .           .      .             .         .       .              to[cr].set_lbd(c.lbd());
             .     .    .             .           .      .             .         .       .              to[cr].removable(c.removable());
             .     .    .             .           .      .             .         .       .              // simplify
             .     .    .             .           .      .             .         .       .              //
             .     .    .             .           .      .             .         .       .              to[cr].setSimplified(c.simplified());
             .     .    .             .           .      .             .         .       .          }
     1,270,940    76    5             0           0      0             0         0       0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     8,903,288     0    0     7,790,377           0      0             0         0       0      }
             .     .    .             .           .      .             .         .       .  };
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
             .     .    .             .           .      .             .         .       .  {
             .     .    .             .           .      .             .         .       .      for (int i = 0; i < cls.size(); ++i)
             .     .    .             .           .      .             .         .       .      {
             .     .    .             .           .      .             .         .       .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .             .           .      .             .         .       .  class OccLists
             .     .    .             .           .      .             .         .       .  {
             .     .    .             .           .      .             .         .       .      vec<Vec>  occs;
             .     .    .             .           .      .             .         .       .      vec<char> dirty;
             .     .    .             .           .      .             .         .       .      vec<Idx>  dirties;
             .     .    .             .           .      .             .         .       .      Deleted   deleted;
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  public:
             3     0    0             0           0      0             3         0       0      OccLists(const Deleted& d) : deleted(d) {}
             .     .    .             .           .      .             .         .       .      unsigned int size(){
             .     .    .             .           .      .             .         .       .          auto m_size=0;
            40     2    2             4           1      0             0         0       0          for(int i=0;i<occs.size();i++){
        15,012    14   14         5,436       1,355      0             0         0       0              m_size+=occs[i].size();
             .     .    .             .           .      .             .         .       .          }
             .     .    .             .           .      .             .         .       .          
             .     .    .             .           .      .             .         .       .          return m_size;
             .     .    .             .           .      .             .         .       .      }
         7,469     1    1             0           0      0         1,358         0       0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
             .     .    .             .           .      .             .         .       .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
    60,157,046    18    3    60,157,046     140,098      0             0         0       0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
        41,403     1    1        20,706       6,455      0           676         1       0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      void  cleanAll  ();
             .     .    .             .           .      .             .         .       .      void  clean     (const Idx& idx);
             .     .    .             .           .      .             .         .       .      void  smudge    (const Idx& idx){
     3,117,066     0    0     2,075,711       5,601     30             0         0       0          if (dirty[toInt(idx)] == 0){
        34,761    72    2             0           0      0        34,761         0       0              dirty[toInt(idx)] = 1;
            34     1    1             0           0      0             0         0       0              dirties.push(idx);
             .     .    .             .           .      .             .         .       .          }
             .     .    .             .           .      .             .         .       .      }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .      void  clear(bool free = true){
             .     .    .             .           .      .             .         .       .          occs   .clear(free);
             .     .    .             .           .      .             .         .       .          dirty  .clear(free);
             .     .    .             .           .      .             .         .       .          dirties.clear(free);
             .     .    .             .           .      .             .         .       .      }
             .     .    .             .           .      .             .         .       .  };
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  template<class Idx, class Vec, class Deleted>
           676     0    0             0           0      0           507         0       0  void OccLists<Idx,Vec,Deleted>::cleanAll()
             .     .    .             .           .      .             .         .       .  {
    27,707,255   333    1    13,819,544       1,313      1             0         0       0      for (int i = 0; i < dirties.size(); i++)
             .     .    .             .           .      .             .         .       .          // Dirties may contain duplicates so check here if a variable is already cleaned:
       101,997     0    0        67,998      21,317      0             0         0       0          if (dirty[toInt(dirties[i])])
             .     .    .             .           .      .             .         .       .              clean(dirties[i]);
             .     .    .             .           .      .             .         .       .      dirties.clear();
           676     0    0           676         106      0             0         0       0  }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  template<class Idx, class Vec, class Deleted>
             .     .    .             .           .      .             .         .       .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
             .     .    .             .           .      .             .         .       .  {
             .     .    .             .           .      .             .         .       .      Vec& vec = occs[toInt(idx)];
             .     .    .             .           .      .             .         .       .      int  i, j;
    18,552,201     2    2       136,169      35,241      0             0         0       0      for (i = j = 0; i < vec.size(); i++)
    11,754,201     0    0       138,964       6,407      0             0         0       0          if (!deleted(vec[i]))
    32,965,081     2    2     9,337,592           6      0     4,715,793    18,976       0              vec[j++] = vec[i];
        34,753    65    2             0           0      0             0         0       0      vec.shrink(i - j);
       139,796     0    0        69,518       5,018      0        34,950     2,543       0      dirty[toInt(idx)] = 0;
             .     .    .             .           .      .             .         .       .  }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  //=================================================================================================
             .     .    .             .           .      .             .         .       .  // CMap -- a class for mapping clauses to values:
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
             .     .    .             .           .      .             .         .       .  |       p          - The literal p can be deleted from 'other'
             .     .    .             .           .      .             .         .       .  |________________________________________________________________________________________________@*/
             .     .    .             .           .      .             .         .       .  inline Lit Clause::subsumes(const Clause& other) const
             .     .    .             .           .      .             .         .       .  {
             .     .    .             .           .      .             .         .       .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
             .     .    .             .           .      .             .         .       .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
             .     .    .             .           .      .             .         .       .      assert(!header.learnt);   assert(!other.header.learnt);
             .     .    .             .           .      .             .         .       .      assert(header.has_extra); assert(other.header.has_extra);
    24,863,601     0    0     8,287,867   1,079,085      0             0         0       0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
             .     .    .             .           .      .             .         .       .          return lit_Error;
             .     .    .             .           .      .             .         .       .  
        72,261     0    0             0           0      0             0         0       0      Lit        ret = lit_Undef;
             .     .    .             .           .      .             .         .       .      const Lit* c   = (const Lit*)(*this);
             .     .    .             .           .      .             .         .       .      const Lit* d   = (const Lit*)other;
             .     .    .             .           .      .             .         .       .  
       754,750     1    1       153,132           0      0             0         0       0      for (unsigned i = 0; i < header.size; i++) {
             .     .    .             .           .      .             .         .       .          // search for c[i] or ~c[i]
     6,172,025     2    2        72,261           0      0        72,261       234       0          for (unsigned j = 0; j < other.header.size; j++)
     4,155,026     0    0       990,456         497      0             0         0       0              if (c[i] == d[j])
             .     .    .             .           .      .             .         .       .                  goto ok;
       739,417     0    0             0           0      0             0         0       0              else if (ret == lit_Undef && c[i] == ~d[j]){
             .     .    .             .           .      .             .         .       .                  ret = c[i];
             .     .    .             .           .      .             .         .       .                  goto ok;
             .     .    .             .           .      .             .         .       .              }
             .     .    .             .           .      .             .         .       .  
             .     .    .             .           .      .             .         .       .          // did not find it
             .     .    .             .           .      .             .         .       .          return lit_Error;
             .     .    .             .           .      .             .         .       .  ok:;
             .     .    .             .           .      .             .         .       .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr            D1mr       DLmr Dw         D1mw   DLmw 

-- line 77 ----------------------------------------
            .     .    .             .          .    .          .      .    .  private:
            .     .    .             .          .    .          .      .    .      template<typename T>
            .     .    .             .          .    .          .      .    .      class MyQueue {
            .     .    .             .          .    .          .      .    .          int max_sz, q_sz;
            .     .    .             .          .    .          .      .    .          int ptr;
            .     .    .             .          .    .          .      .    .          int64_t sum;
            .     .    .             .          .    .          .      .    .          vec<T> q;
            .     .    .             .          .    .          .      .    .      public:
            4     1    1             0          0    0          3      0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
            .     .    .             .          .    .          .      .    .          inline bool   full () const { return q_sz == max_sz; }
            .     .    .             .          .    .          .      .    .  #ifdef INT_QUEUE_AVG
      410,316    26    2       102,579          0    0          0      0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
            .     .    .             .          .    .          .      .    .  #else
            .     .    .             .          .    .          .      .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
            .     .    .             .          .    .          .      .    .  #endif
        2,672    14    4             0          0    0      2,672    589    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
            .     .    .             .          .    .          .      .    .          void push(T e) {
    1,383,652     0    0       670,926          0    0     20,900      0    0              if (q_sz < max_sz) q_sz++;
      608,226     3    3       202,742    199,292    0          0      0    0              else sum -= q[ptr];
      670,926    11    6             0          0    0    223,642      0    0              sum += e;
      670,926     0    0             0          0    0    447,284 20,445    5              q[ptr++] = e;
      675,243     0    0       447,284          0    0      4,317      0    0              if (ptr == max_sz) ptr = 0;
            .     .    .             .          .    .          .      .    .          }
            .     .    .             .          .    .          .      .    .      };
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  public:
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .      // Constructor/Destructor:
            .     .    .             .          .    .          .      .    .      //
            .     .    .             .          .    .          .      .    .      Solver();
            .     .    .             .          .    .          .      .    .      virtual ~Solver();
           10     2    2             0          0    0          4      0    0      void print_size(std::ostream &os)
            .     .    .             .          .    .          .      .    .      {
            4     2    2             0          0    0          4      1    0          program_end_time=std::chrono::steady_clock::now();
            2     0    0             0          0    0          2      0    0          total_work_time=program_end_time-program_start_time;
            4     0    0             2          0    0          0      0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
            2     0    0             2          0    0          0      0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
            4     0    0             2          0    0          0      0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
            4     0    0             2          1    0          0      0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
            4     0    0             2          0    0          0      0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
            4     0    0             2          1    0          0      0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
            .     .    .             .          .    .          .      .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
            .     .    .             .          .    .          .      .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
            2     0    0             2          2    0          0      0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
            2     0    0             2          0    0          0      0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
            2     0    0             2          0    0          0      0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
            4     0    0             2          2    0          0      0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
            4     0    0             2          0    0          0      0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
            4     0    0             2          0    0          0      0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
            4     0    0             2          2    0          0      0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
            .     .    .             .          .    .          .      .    .          os << "total_Watchers: " << total_Watchers << "\n";
            .     .    .             .          .    .          .      .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
            .     .    .             .          .    .          .      .    .          os << "total_indexs: " << total_indexs << "\n";
            .     .    .             .          .    .          .      .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
            .     .    .             .          .    .          .      .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
            .     .    .             .          .    .          .      .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
            .     .    .             .          .    .          .      .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
            .     .    .             .          .    .          .      .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
            .     .    .             .          .    .          .      .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
            .     .    .             .          .    .          .      .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
            .     .    .             .          .    .          .      .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
            .     .    .             .          .    .          .      .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
            .     .    .             .          .    .          .      .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
            .     .    .             .          .    .          .      .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
            .     .    .             .          .    .          .      .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
            .     .    .             .          .    .          .      .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
            6     0    0             4          0    0          0      0    0      }
            .     .    .             .          .    .          .      .    .      using ull=unsigned long long;
            .     .    .             .          .    .          .      .    .      ull total_Watchers = 0;
            .     .    .             .          .    .          .      .    .      ull total_act_watchers = 0;
            .     .    .             .          .    .          .      .    .      ull total_indexs = 0;
            .     .    .             .          .    .          .      .    .      ull time_find_conflict = 0;
            .     .    .             .          .    .          .      .    .      ull total_find_conflict_length = 0;
            .     .    .             .          .    .          .      .    .      ull total_find_conflict_allsize = 0;
            .     .    .             .          .    .          .      .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
            .     .    .             .          .    .          .      .    .      {
            .     .    .             .          .    .          .      .    .          const ClauseAllocator& ca;
            .     .    .             .          .    .          .      .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
            .     .    .             .          .    .          .      .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
            .     .    .             .          .    .          .      .    .      };
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .      struct VarOrderLt {
            .     .    .             .          .    .          .      .    .          const vec<double>&  activity;
  321,093,670   488   12   226,103,323 17,318,546   70 10,917,202      0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
            .     .    .             .          .    .          .      .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
            .     .    .             .          .    .          .      .    .      };
            .     .    .             .          .    .          .      .    .      
            .     .    .             .          .    .          .      .    .      struct ConflictData
            .     .    .             .          .    .          .      .    .  	{
            .     .    .             .          .    .          .      .    .  		ConflictData() :
            .     .    .             .          .    .          .      .    .  			nHighestLevel(-1),
            .     .    .             .          .    .          .      .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
            .     .    .             .          .    .          .      .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
            .     .    .             .          .    .          .      .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
            .     .    .             .          .    .          .      .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
            .     .    .             .          .    .          .      .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
            .     .    .             .          .    .          .      .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
            .     .    .             .          .    .          .      .    .      std::chrono::nanoseconds total_duration;
            .     .    .             .          .    .          .      .    .      CRef     propagate(){
            .     .    .             .          .    .          .      .    .  
    3,087,534 1,560    4             0          0    0  1,543,767      1    0          auto start_time=std::chrono::steady_clock::now();
    4,631,301     0    0             0          0    0  1,543,767      0    0          auto ref= propagate_();
    1,543,767     0    0             0          0    0  1,543,767      0    0          auto end_time=std::chrono::steady_clock::now();
            .     .    .             .          .    .          .      .    .          auto duration=end_time-start_time;
            .     .    .             .          .    .          .      .    .          total_duration+=duration;
            .     .    .             .          .    .          .      .    .          return ref;
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .      }
            .     .    .             .          .    .          .      .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
            .     .    .             .          .    .          .      .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
            .     .    .             .          .    .          .      .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
            .     .    .             .          .    .          .      .    .      
            .     .    .             .          .    .          .      .    .  public:
            .     .    .             .          .    .          .      .    .      int      level            (Var x) const;
            .     .    .             .          .    .          .      .    .  protected:
            .     .    .             .          .    .          .      .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
            .     .    .             .          .    .          .      .    .      bool     withinBudget     ()      const;
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .      template<class V> int computeLBD(const V& c) {
   24,854,377    24    5             0          0    0          0      0    0          int lbd = 0;
            .     .    .             .          .    .          .      .    .  
    4,265,664    27    7     3,658,896    741,857    0          0      0    0          counter++;
  118,666,992     0    0       608,984          0    0          0      0    0          for (int i = 0; i < c.size(); i++){
            .     .    .             .          .    .          .      .    .              int l = level(var(c[i]));
  272,181,856     0    0   108,871,088  2,514,995    0          0      0    0              if (l != 0 && seen2[l] != counter){
   28,908,421     0    0             0          0    0 28,908,421      0    0                  seen2[l] = counter;
   44,109,378     0    0             0          0    0          0      0    0                  lbd++; } }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .          return lbd;
            .     .    .             .          .    .          .      .    .      }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  #ifdef BIN_DRUP
            .     .    .             .          .    .          .      .    .      static int buf_len;
            .     .    .             .          .    .          .      .    .      static unsigned char drup_buf[];
            .     .    .             .          .    .          .      .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
            .     .    .             .          .    .          .      .    .      }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .      template<class V>
            .     .    .             .          .    .          .      .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
            .     .    .             .          .    .          .      .    .          assert(op == 'a' || op == 'd');
            .     .    .             .          .    .          .      .    .          *buf_ptr++ = op; buf_len++;
            .     .    .             .          .    .          .      .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
            .     .    .             .          .    .          .      .    .          *buf_ptr++ = 0; buf_len++;
      124,814    23    5             0          0    0    124,814      0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
            .     .    .             .          .    .          .      .    .      }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
            .     .    .             .          .    .          .      .    .          *buf_ptr++ = 'a'; buf_len++;
            .     .    .             .          .    .          .      .    .          for (int i = 0; i < c.size(); i++)
            .     .    .             .          .    .          .      .    .              if (c[i] != l) byteDRUP(c[i]);
            .     .    .             .          .    .          .      .    .          *buf_ptr++ = 0; buf_len++;
            .     .    .             .          .    .          .      .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
            .     .    .             .          .    .          .      .    .      double    my_var_decay;
            .     .    .             .          .    .          .      .    .      bool   DISTANCE;
            .     .    .             .          .    .          .      .    .  };
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  //=================================================================================================
            .     .    .             .          .    .          .      .    .  // Implementation of inline methods:
            .     .    .             .          .    .          .      .    .  
   59,745,289     0    0    59,745,289  1,407,110    0          0      0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
  382,546,351    30    7   329,631,750 27,018,845    0 50,359,007      0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  inline void Solver::insertVarOrder(Var x) {
            .     .    .             .          .    .          .      .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
  364,047,702   204    2   113,526,922     32,405    0          0      0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    7,570,488     1    1     5,046,992    944,909    1          0      0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  inline void Solver::varDecayActivity() {
      894,568     0    0       447,284        352    0    223,642      0    0      var_inc *= (1 / var_decay); }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  inline void Solver::varBumpActivity(Var v, double mult) {
  177,201,676     5    5   107,919,180  4,136,226    3 26,828,103      0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
            .     .    .             .          .    .          .      .    .          // Rescale:
          782    30    7             1          0    0          0      0    0          for (int i = 0; i < nVars(); i++)
      106,080     0    0        26,598      4,627    0     26,520      0    0              activity_VSIDS[i] *= 1e-100;
          156     0    0            78          0    0         78      0    0          var_inc *= 1e-100; }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .      // Update order_heap with respect to new activity:
   18,834,854     0    0             0          0    0          0      0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
            .     .    .             .          .    .          .      .    .  
    2,427,072   330    0     1,213,536          4    0    606,768      0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
            .     .    .             .          .    .          .      .    .  inline void Solver::claBumpActivity (Clause& c) {
   16,655,870   151    4     4,953,007    465,933    4  1,687,464  2,423    0      if ( (c.activity() += cla_inc) > 1e20 ) {
            .     .    .             .          .    .          .      .    .          // Rescale:
      772,391    13    6            39          0    0          0      0    0          for (int i = 0; i < learnts_local.size(); i++)
    1,802,003     2    0       257,429    236,220    0    257,429      0    0              ca[learnts_local[i]].activity() *= 1e-20;
      218,809    46    2       109,385          0    0         13     13    0          cla_inc *= 1e-20; } }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
            .     .    .             .          .    .          .      .    .  inline void Solver::checkGarbage(double gf){
        6,768    31    0         2,256         83    0          0      0    0      if (ca.wasted() > ca.size() * gf)
          148     0    0            74         74    2          0      0    0          garbageCollect(); }
            .     .    .             .          .    .          .      .    .  
            .     .    .             .          .    .          .      .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
            .     .    .             .          .    .          .      .    .  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
            .     .    .             .          .    .          .      .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
            .     .    .             .          .    .          .      .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
            .     .    .             .          .    .          .      .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
            .     .    .             .          .    .          .      .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
            .     .    .             .          .    .          .      .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
            .     .    .             .          .    .          .      .    .  inline bool     Solver::locked          (const Clause& c) const {
    7,631,008    40    2     2,350,370     56,552    0          0      0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    8,080,852    62    4     2,065,466      9,237    0          0      0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
            .     .    .             .          .    .          .      .    .  }
    1,868,571     1    1       934,280          0    0          0      0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
            .     .    .             .          .    .          .      .    .  
      100,628     1    1        56,104          0    0     44,524      0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
  140,680,943   457    2    22,464,690     21,377    0          0      0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
    2,533,128     1    1     2,533,112        136    0          0      0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
6,417,412,209    29    7 6,417,412,209      1,142    0          0      0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
            .     .    .             .          .    .          .      .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
            .     .    .             .          .    .          .      .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
            .     .    .             .          .    .          .      .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
            3     0    0             2          0    0          1      1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
            .     .    .             .          .    .          .      .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
       54,418     1    1           848          6    0          0      0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
            6     1    1             3          2    0          0      0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
            .     .    .             .          .    .          .      .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
            .     .    .             .          .    .          .      .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
            .     .    .             .          .    .          .      .    .  { 
        4,074     0    0         2,037          9    0          0      0    0      if      ( b && !decision[v]) dec_vars++;
            9     0    0             6          4    0          0      0    0      else if (!b &&  decision[v]) dec_vars--;
            .     .    .             .          .    .          .      .    .  
          682     0    0             0          0    0        682      0    0      decision[v] = b;
            .     .    .             .          .    .          .      .    .      if (b && !order_heap_CHB.inHeap(v)){
            .     .    .             .          .    .          .      .    .          order_heap_CHB.insert(v);
            .     .    .             .          .    .          .      .    .          order_heap_VSIDS.insert(v);
            .     .    .             .          .    .          .      .    .          order_heap_distance.insert(v);}
            .     .    .             .          .    .          .      .    .  }
            .     .    .             .          .    .          .      .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
            .     .    .             .          .    .          .      .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
            .     .    .             .          .    .          .      .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr             D1mr          DLmr    Dw             D1mw        DLmw    
--------------------------------------------------------------------------------
295,640,849,763 357,870 1,420 95,184,717,954 4,656,214,022 338,042 34,050,936,808 827,673,801 612,093  events annotated

