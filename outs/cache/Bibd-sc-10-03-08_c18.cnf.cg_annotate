--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/Bibd-sc-10-03-08_c18.cnf
Data file:        Bibd-sc-10-03-08_c18.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir             I1mr    ILmr  Dr             D1mr        DLmr      Dw            D1mw        DLmw      
--------------------------------------------------------------------------------
37,000,521,694 365,802 6,644 10,717,590,349 963,837,612 1,671,474 3,660,929,755 230,353,463 2,692,031  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir            I1mr   ILmr Dr            D1mr        DLmr    Dw          D1mw       DLmw       file:function
--------------------------------------------------------------------------------
8,873,868,842  3,519   30 2,205,874,443 193,724,822 154,705 942,672,692     76,332         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
3,622,905,915      2    2   958,938,974  86,433,125 136,502 307,784,902          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
1,779,772,099 24,954  134   382,631,113   2,744,715      94 168,231,483    352,005         5  ???:__ieee754_pow_fma
1,341,447,667 11,230   13   193,810,347  14,935,396   5,044 121,105,643 17,242,902    81,045  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
1,224,614,649 18,786   69   429,276,050  68,053,288   4,404  82,368,947  2,631,096        13  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
1,216,212,117  3,858   15   487,541,322  72,221,012   6,117 318,443,305  3,652,030       922  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
1,193,607,173  8,507   28   454,582,335 118,709,315   8,227 153,499,359 43,102,051     2,171  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
1,075,268,366     97   21   207,582,127  14,018,913   1,633 110,058,968 13,983,102     1,239  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
1,036,106,730  6,021   23   353,232,438  17,170,397     656 106,773,119     36,448         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  975,280,811      4    4   431,236,181  35,007,189   9,536 296,845,113 96,906,572    28,148  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  892,331,227    987   30   276,051,145     653,726       3  62,673,703  1,609,048     1,490  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  786,829,881 17,934   12   209,194,338       8,014       0 134,222,499    305,543        52  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  761,135,499    469    8   336,682,439  49,932,154   8,523  61,681,780  3,725,248       271  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  759,847,898    565   29   215,228,085  17,418,050   1,483     963,518     27,475         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  743,542,273     19   17   131,939,068      95,302     790   9,797,775          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc:Minisat::SimpSolver::eliminateVar(int)
  704,387,779     17   11   204,068,800   9,297,822       3   1,827,225      4,070         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc:Minisat::SimpSolver::backwardSubsumptionCheck(bool)
  675,696,394     23    8   147,812,630   4,307,937     258   5,676,041         12         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::SimpSolver::backwardSubsumptionCheck(bool)
  631,589,796     71   37   184,769,081  29,432,914  16,954  73,534,082  4,335,778       240  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
  563,649,651    940   56   134,702,574   3,293,184   1,126  15,165,431    233,957         3  ???:__exp1_fma
  451,375,521    186   14   169,734,734  49,021,782   4,029  21,490,163          1         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  432,469,215  9,011   13   160,388,526  10,998,882     744   2,018,558    400,145     3,957  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::collectFirstUIP(unsigned int)
  397,586,229     29    9   120,752,084  20,194,001     872           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  340,431,143     16    9    74,857,533   4,834,521     972           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
  294,856,184      3    2   265,554,057  12,231,416     129  28,592,123          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
  289,760,909     12    7    28,810,387   2,878,975   4,346   3,170,614        902       343  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::SimpSolver::eliminateVar(int)
  247,234,754  1,627   13    67,571,498       1,301      10  40,364,808      1,190         0  ???:pow
  233,054,976  2,421   12    72,179,490      69,321       0  12,672,056    362,111       534  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  226,752,100     14    8    51,036,616   3,694,504   1,013  39,048,592  4,748,484    13,577  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
  205,062,742      2    2    72,570,034     125,421       2  59,922,674  1,873,824     2,108  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  180,700,522      0    0   120,305,623   1,901,291     561  29,955,362 20,954,988     2,428  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  167,004,221     39    3    54,665,715      28,293       1   1,400,759     48,077        45  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::collectFirstUIP(unsigned int)
  155,139,400    458    3    82,476,546   5,927,740   3,263           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  151,768,320      0    0    88,531,520  11,896,345   3,503  12,647,360          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  125,199,039     47    6    58,671,768  12,067,823   1,692           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::pickBranchLit()
  124,130,811      0    0    81,441,360  19,076,719   3,340           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  119,845,348      0    0    29,961,337           0       0  29,961,337     29,990         2  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  115,513,886      0    0             0           0       0           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  115,165,174  2,334    9    48,743,107   7,650,438   1,038  15,440,905          3         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::pickBranchLit()
  109,996,090     18    4    31,662,308  11,134,027     719  20,690,812  3,752,107       555  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
  109,928,716      0    0    54,964,358      10,953       0           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
  106,770,975  6,644    2     1,677,883     365,651       0           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::collectFirstUIP(unsigned int)
  105,863,472      0    0     3,992,557       1,544       0   6,989,914          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::pickBranchLit()
  100,228,134 29,484  249    18,153,427   1,002,161  11,436  16,102,798    573,917    97,276  ???:_int_malloc
   99,666,571     87    3    49,100,408  14,501,360   1,030           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   97,674,333     92   62    26,196,526   3,203,360 193,682  13,166,281    592,468   307,036  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
   93,204,408     62   54    17,445,262   1,523,583  94,195   8,011,465    149,633   149,624  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::SimpSolver::relocAll(Minisat::ClauseAllocator&) [clone .part.43]
   88,531,520      0    0    12,647,360     117,188       1  37,942,080    135,382         0  /usr/include/c++/8/cmath:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   87,593,796    406   89    25,236,077     301,946   8,586  12,365,366     17,667       166  ???:_int_free
   86,360,790      7    7    13,482,166      56,633  15,352   6,606,905          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../utils/ParseUtils.h:int Minisat::parseInt<Minisat::StreamBuffer>(Minisat::StreamBuffer&)
   85,586,140 11,982   37    15,869,672     414,369   2,961   9,053,747     22,560         0  ???:realloc
   84,854,446     11    4    24,957,190     210,537       5  14,974,314          6         0  ???:clock_gettime
   80,020,012      0    0    39,182,923          15       0           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::SimpSolver::backwardSubsumptionCheck(bool)
   79,430,682      0    0    16,154,692   1,126,344  88,455           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::safeRemoveSatisfied(Minisat::vec<unsigned int>&, unsigned int)
   74,375,127  7,564   96    22,545,996     466,336      19   5,719,636     52,122         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::search(int&)
   73,671,210     29    5    29,468,484      78,911       1   9,822,828          2         0  ???:std::chrono::_V2::steady_clock::now()
   67,972,081     48   12    14,900,621     317,232  13,254   2,160,758     44,838         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::removeSatisfied(Minisat::vec<unsigned int>&)
   66,299,971     61   14    16,324,275     223,642   2,201     167,137      2,251         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::safeRemoveSatisfied(Minisat::vec<unsigned int>&, unsigned int)
   66,116,767      2    2    46,512,827     137,495  10,303           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::SimpSolver::eliminateVar(int)
   64,668,942      0    0    43,112,628      13,846       0           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   58,571,490      1    1    11,057,985     553,339       0           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h:Minisat::SimpSolver::eliminateVar(int)
   52,355,730 14,549   69    10,806,370     526,701   8,473   7,802,207     28,593       952  ???:_int_realloc
   52,203,158     44    6     8,912,347     570,844   3,397   8,625,875    593,199   495,159  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::search(int&)
   47,486,872 10,247   79    29,421,426   1,725,554 288,567  28,441,294  1,905,903 1,186,840  ???:__memcpy_avx_unaligned_erms
   45,150,226    126   93    16,826,753     307,977  76,146   2,882,629         11         1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
   44,417,817     18   12    20,455,641      44,745     898   8,291,078     26,922       392  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::SimpSolver::eliminateVar(int)
   43,632,731     23   12    13,822,213     408,574       0   6,916,839     25,570         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::SimpSolver::eliminate(bool)
   43,044,162    508   13     6,025,519           0       0   3,347,262         34         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h:void Minisat::sort<Minisat::Lit, Minisat::LessThan_default<Minisat::Lit> >(Minisat::Lit*, int, Minisat::LessThan_default<Minisat::Lit>) [clone .constprop.285]
   42,602,523      8    5     8,069,628     152,939  20,665   3,053,181    148,764   148,583  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::addClause_(Minisat::vec<Minisat::Lit>&)
   42,092,745     17    4    10,579,171   1,828,871  10,994           0          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::removeSatisfied(Minisat::vec<unsigned int>&)
   42,083,564    268   20    15,090,130   1,280,922  11,731   1,237,731        414         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::OccLists<Minisat::Lit, Minisat::vec<Minisat::Solver::Watcher>, Minisat::Solver::WatcherDeleted>::cleanAll()
   41,407,558     40   20    12,725,461   1,849,923      15     896,751          0         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simpleAnalyze(unsigned int, Minisat::vec<Minisat::Lit>&, Minisat::vec<unsigned int>&, bool)
   41,142,192 18,690  375    41,028,735   1,090,011     975       1,319         26        16  ???:???
   38,202,039     23   10     7,142,136         233       0   4,434,213         85         0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::addClause_(Minisat::vec<Minisat::Lit>&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir            I1mr   ILmr Dr          D1mr       DLmr   Dw          D1mw       DLmw    

-- line 40 ----------------------------------------
            .      .    .           .          .      .           .          .       .      int sz;
            .      .    .           .          .      .           .          .       .      int cap;
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .      // Don't allow copying (error prone):
            .      .    .           .          .      .           .          .       .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
            .      .    .           .          .      .           .          .       .               vec        (vec<T>& other) { assert(0); }
            .      .    .           .          .      .           .          .       .               
            .      .    .           .          .      .           .          .       .      // Helpers for calculating next capacity:
    9,734,234      9    8           0          0      0           0          0       0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
            .      .    .           .          .      .           .          .       .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
            .      .    .           .          .      .           .          .       .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  public:
            .      .    .           .          .      .           .          .       .      // Constructors:
    1,108,488     28   25           2          0      0     944,224     51,741  38,808      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
           60      0    0           0          0      0          60          0       0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
            .      .    .           .          .      .           .          .       .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
            .      .    .           .          .      .           .          .       .     ~vec()                                                          { clear(true); }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .      // Pointer to first element:
            .      .    .           .          .      .           .          .       .      operator T*       (void)           { return data; }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .      // Size operations:
            .      .    .           .          .      .           .          .       .      int      size     (void) const     { return sz; }
   95,546,258    131    4   6,903,865      3,402      0   4,653,537          1       0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
            .      .    .           .          .      .           .          .       .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
            .      .    .           .          .      .           .          .       .      int      capacity (void) const     { return cap; }
            .      .    .           .          .      .           .          .       .      void     capacity (int min_cap);
            .      .    .           .          .      .           .          .       .      void     growTo   (int size);
            .      .    .           .          .      .           .          .       .      void     growTo   (int size, const T& pad);
            .      .    .           .          .      .           .          .       .      void     clear    (bool dealloc = false);
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .      // Stack interface:
      392,533    119    2     228,761      9,208      0      65,337          0       0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
1,172,683,828 15,940  137 499,278,058 19,594,552 35,463 305,172,471 25,497,151 157,920      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
  146,915,021      0    0  37,433,746     25,885      0  70,608,244  2,163,174   2,108      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
   54,062,030    183    4   3,593,461          0      0  25,271,941          0       0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
            .      .    .           .          .      .           .          .       .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
            .      .    .           .          .      .           .          .       .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
            .      .    .           .          .      .           .          .       .      // happen given the way capacities are calculated (below). Essentially, all capacities are
            .      .    .           .          .      .           .          .       .      // even, but INT_MAX is odd.
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .      const T& last  (void) const        { return data[sz-1]; }
   21,901,572      0    0           0          0      0           0          0       0      T&       last  (void)              { return data[sz-1]; }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .      // Vector interface:
1,056,573,916  2,227   28  34,607,408         54      0   6,476,864         10       0      const T& operator [] (int index) const { return data[index]; }
1,641,736,492    553   63 392,821,253    561,010 10,872  38,860,564      1,769       0      T&       operator [] (int index)       { return data[index]; }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .      // Duplicatation (preferred instead):
   63,271,964      4    4  21,133,900    452,331      0  10,469,648          0       0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
      706,221      1    0     706,134         10      0          58          0       0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
            .      .    .           .          .      .           .          .       .  };
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  template<class T>
    2,433,406      0    0           0          0      0   1,216,703          0       0  void vec<T>::capacity(int min_cap) {
    5,322,411     46   17   1,774,137         11      0           0          0       0      if (cap >= min_cap) return;
    8,517,537     18    9           0          0      0          44          0       0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
   15,927,185  1,953   21   1,216,879         38      0   3,650,350      9,784       0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
            .      .    .           .          .      .           .          .       .          throw OutOfMemoryException();
    2,859,432      2    1   2,859,432         53      0           0          0       0   }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  template<class T>
            .      .    .           .          .      .           .          .       .  void vec<T>::growTo(int size, const T& pad) {
   11,357,235      7    6   3,752,893      1,107      0           0          0       0      if (sz >= size) return;
      657,040      4    4      65,704          0      0     295,668          0       0      capacity(size);
    3,712,278      7    7     591,337          5      0     295,669      4,184     125      for (int i = sz; i < size; i++) data[i] = pad;
    6,261,236      3    3      84,464          0      0     295,668          0       0      sz = size; }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  template<class T>
      657,040      1    1           0          0      0     262,816          0       0  void vec<T>::growTo(int size) {
      918,249      1    1     229,967        237      0     131,408          0       0      if (sz >= size) return;
      325,271     86    3           0          0      0     162,621          0       0      capacity(size);
    3,536,691     15    7     588,058          0      0     129,768          0       0      for (int i = sz; i < size; i++) new (&data[i]) T();
      884,619      0    0     459,180         21      0     229,161         10       0      sz = size; }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  template<class T>
            .      .    .           .          .      .           .          .       .  void vec<T>::clear(bool dealloc) {
   38,487,612 18,848   36   9,509,405    143,263    902      98,503          0       0      if (data != NULL){
       65,709      0    0           1          0      0           0          0       0          for (int i = 0; i < sz; i++) data[i].~T();
   79,986,824     12    7   5,168,060          3      0  14,500,999        590       0          sz = 0;
      870,251      8    6     353,390          0      0     499,135         12       0          if (dealloc) free(data), data = NULL, cap = 0; } }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  //=================================================================================================
            .      .    .           .          .      .           .          .       .  }
            .      .    .           .          .      .           .          .       .  
            .      .    .           .          .      .           .          .       .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Sort.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr        D1mr    DLmr Dw        D1mw  DLmw 

-- line 36 ----------------------------------------
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  template <class T, class LessThan>
         .    .    .         .       .    .         .     .    .  void selectionSort(T* array, int size, LessThan lt)
         .    .    .         .       .    .         .     .    .  {
         .    .    .         .       .    .         .     .    .      int     i, j, best_i;
         .    .    .         .       .    .         .     .    .      T       tmp;
         .    .    .         .       .    .         .     .    .  
 6,175,903  165    5 1,041,561       0    0     7,647    73    0      for (i = 0; i < size-1; i++){
         .    .    .         .       .    .         .     .    .          best_i = i;
12,173,702  339   18 2,375,527       4    0         0     0    0          for (j = i+1; j < size; j++){
18,498,093   35   30   325,573       8    0         0     0    0              if (lt(array[j], array[best_i]))
         .    .    .         .       .    .         .     .    .                  best_i = j;
         .    .    .         .       .    .         .     .    .          }
 5,147,013    0    0   980,769       0    0 2,083,122     0    0          tmp = array[i]; array[i] = array[best_i]; array[best_i] = tmp;
         .    .    .         .       .    .         .     .    .      }
         .    .    .         .       .    .         .     .    .  }
         .    .    .         .       .    .         .     .    .  template <class T> static inline void selectionSort(T* array, int size) {
         .    .    .         .       .    .         .     .    .      selectionSort(array, size, LessThan_default<T>()); }
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  template <class T, class LessThan>
 2,158,112   10    5         0       0    0 1,441,454 1,975   32  void sort(T* array, int size, LessThan lt)
         .    .    .         .       .    .         .     .    .  {
 1,425,408    7    6         0       0    0         0     0    0      if (size <= 15)
         .    .    .         .       .    .         .     .    .          selectionSort(array, size, lt);
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .      else{
    55,694    0    0    17,974     612    0         0     0    0          T           pivot = array[size / 2];
         .    .    .         .       .    .         .     .    .          T           tmp;
     8,998    0    0         0       0    0         0     0    0          int         i = -1;
         .    .    .         .       .    .         .     .    .          int         j = size;
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .          for(;;){
 3,305,434    4    4   931,898 278,124  667         0     0    0              do i++; while(lt(array[i], pivot));
 4,310,418    0    0 1,075,470 246,482    0         0     0    0              do j--; while(lt(pivot, array[j]));
         .    .    .         .       .    .         .     .    .  
   309,892    0    0         0       0    0         0     0    0              if (i >= j) break;
         .    .    .         .       .    .         .     .    .  
 1,223,936    8    5       186       0    0   291,896   133    0              tmp = array[i]; array[i] = array[j]; array[j] = tmp;
         .    .    .         .       .    .         .     .    .          }
         .    .    .         .       .    .         .     .    .  
    26,130    0    0         0       0    0     8,998   889    6          sort(array    , i     , lt);
     8,998    0    0         0       0    0         0     0    0          sort(&array[i], size-i, lt);
         .    .    .         .       .    .         .     .    .      }
 2,141,836    0    0 1,787,576     275    0         0     0    0  }
         .    .    .         .       .    .         .     .    .  template <class T> static inline void sort(T* array, int size) {
         .    .    .         .       .    .         .     .    .      sort(array, size, LessThan_default<T>()); }
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  //=================================================================================================
         .    .    .         .       .    .         .     .    .  // For 'vec's:
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  template <class T, class LessThan> void sort(vec<T>& v, LessThan lt) {
 1,035,786    4    4   690,524       1    0   345,262   101    0      sort((T*)v, v.size(), lt); }
         .    .    .         .       .    .         .     .    .  template <class T> void sort(vec<T>& v) {
         .    .    .         .       .    .         .     .    .      sort(v, LessThan_default<T>()); }
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  //=================================================================================================
         .    .    .         .       .    .         .     .    .  }
         .    .    .         .       .    .         .     .    .  
         .    .    .         .       .    .         .     .    .  #endif
-- line 98 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr      DLmr   Dw        D1mw    DLmw 

-- line 33 ----------------------------------------
          .    .    .           .         .      .         .       .    .  using namespace Minisat;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  //=================================================================================================
          .    .    .           .         .      .         .       .    .  // Options:
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  static const char* _cat = "SIMP";
          .    .    .           .         .      .         .       .    .  
          4    1    1           0         0      0         1       0    0  static BoolOption   opt_use_asymm        (_cat, "asymm",        "Shrink clauses by asymmetric branching.", false);
          4    0    0           0         0      0         1       0    0  static BoolOption   opt_use_rcheck       (_cat, "rcheck",       "Check if a clause is already implied. (costly)", false);
          4    0    0           0         0      0         1       0    0  static BoolOption   opt_use_elim         (_cat, "elim",         "Perform variable elimination.", true);
          4    1    1           0         0      0         1       0    0  static IntOption    opt_grow             (_cat, "grow",         "Allow a variable elimination step to grow by a number of clauses.", 0);
          4    0    0           0         0      0         1       0    0  static IntOption    opt_clause_lim       (_cat, "cl-lim",       "Variables are not eliminated if it produces a resolvent with a length above this limit. -1 means no limit", 20,   IntRange(-1, INT32_MAX));
          4    0    0           0         0      0         1       0    0  static IntOption    opt_subsumption_lim  (_cat, "sub-lim",      "Do not check if subsumption against a clause larger than this. -1 means no limit.", 1000, IntRange(-1, INT32_MAX));
          4    0    0           0         0      0         1       0    0  static DoubleOption opt_simp_garbage_frac(_cat, "simp-gc-frac", "The fraction of wasted memory allowed before a garbage collection is triggered during simplification.",  0.5, DoubleRange(0, false, HUGE_VAL, false));
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  //=================================================================================================
          .    .    .           .         .      .         .       .    .  // Constructor/Destructor:
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          4    1    1           0         0      0         3       0    0  SimpSolver::SimpSolver() :
          .    .    .           .         .      .         .       .    .      parsing            (false)
          .    .    .           .         .      .         .       .    .    , grow               (opt_grow)
          .    .    .           .         .      .         .       .    .    , clause_lim         (opt_clause_lim)
          .    .    .           .         .      .         .       .    .    , subsumption_lim    (opt_subsumption_lim)
          .    .    .           .         .      .         .       .    .    , simp_garbage_frac  (opt_simp_garbage_frac)
          .    .    .           .         .      .         .       .    .    , use_asymm          (opt_use_asymm)
          .    .    .           .         .      .         .       .    .    , use_rcheck         (opt_use_rcheck)
          .    .    .           .         .      .         .       .    .    , use_elim           (opt_use_elim)
          .    .    .           .         .      .         .       .    .    , merges             (0)
          .    .    .           .         .      .         .       .    .    , asymm_lits         (0)
          .    .    .           .         .      .         .       .    .    , eliminated_vars    (0)
          .    .    .           .         .      .         .       .    .    , elimorder          (1)
          .    .    .           .         .      .         .       .    .    , use_simplification (true)
          1    0    0           0         0      0         0       0    0    , occurs             (ClauseDeleted(ca))
          .    .    .           .         .      .         .       .    .    , elim_heap          (ElimLt(n_occ))
          .    .    .           .         .      .         .       .    .    , bwdsub_assigns     (0)
         22    2    2           8         1      1        13       1    0    , n_touched          (0)
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .      vec<Lit> dummy(1,lit_Undef);
          1    0    0           0         0      0         1       0    0      ca.extra_clause_field = true; // NOTE: must happen before allocating the dummy clause below.
          1    1    1           0         0      0         1       0    0      bwdsub_tmpunit        = ca.alloc(dummy);
          1    0    0           0         0      0         1       0    0      remove_satisfied      = false;
          3    0    0           3         0      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  SimpSolver::~SimpSolver()
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
    197,112    2    2           0         0      0   164,260       0    0  Var SimpSolver::newVar(bool sign, bool dvar) {
    131,408    0    0           0         0      0    32,852       0    0      Var v = Solver::newVar(sign, dvar);
          .    .    .           .         .      .         .       .    .  
         23    0    0           0         0      0         0       0    0      frozen    .push((char)false);
         23    0    0           0         0      0         0       0    0      eliminated.push((char)false);
          .    .    .           .         .      .         .       .    .  
     65,704    0    0      32,852       161      0         0       0    0      if (use_simplification){
     65,704    1    1           0         0      0         0       0    0          n_occ     .push(0);
          .    .    .           .         .      .         .       .    .          n_occ     .push(0);
          .    .    .           .         .      .         .       .    .          occurs    .init(v);
         23    0    0           0         0      0         0       0    0          touched   .push(0);
          .    .    .           .         .      .         .       .    .          elim_heap .insert(v);
          .    .    .           .         .      .         .       .    .      }
    229,964    0    0     197,112       163      0         0       0    0      return v; }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)
          8    1    1           0         0      0         6       0    0  {
          .    .    .           .         .      .         .       .    .      vec<Var> extra_frozen;
          .    .    .           .         .      .         .       .    .      lbool    result = l_True;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      do_simp &= use_simplification;
          .    .    .           .         .      .         .       .    .  
          4    0    0           1         1      0         1       0    0      if (do_simp){
          .    .    .           .         .      .         .       .    .          // Assumptions must be temporarily frozen to run variable elimination:
          .    .    .           .         .      .         .       .    .          for (int i = 0; i < assumptions.size(); i++){
          .    .    .           .         .      .         .       .    .              Var v = var(assumptions[i]);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .              // If an assumption has been eliminated, remember it.
          .    .    .           .         .      .         .       .    .              assert(!isEliminated(v));
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .              if (!frozen[v]){
-- line 117 ----------------------------------------
-- line 119 ----------------------------------------
          .    .    .           .         .      .         .       .    .                  setFrozen(v, true);
          .    .    .           .         .      .         .       .    .                  extra_frozen.push(v);
          .    .    .           .         .      .         .       .    .              } }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          result = lbool(eliminate(turn_off_simp));
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      if (result == l_True)
          3    2    2           0         0      0         2       1    1          result = Solver::solve_();
          .    .    .           .         .      .         .       .    .      else if (verbosity >= 1)
          .    .    .           .         .      .         .       .    .          printf("c ===============================================================================\n");
          .    .    .           .         .      .         .       .    .  
          2    0    0           0         0      0         0       0    0      if (result == l_True)
          2    0    0           0         0      0         1       0    0          extendModel();
          .    .    .           .         .      .         .       .    .  
          2    0    0           1         1      0         0       0    0      if (do_simp)
          .    .    .           .         .      .         .       .    .          // Unfreeze the assumptions that were frozen:
          .    .    .           .         .      .         .       .    .          for (int i = 0; i < extra_frozen.size(); i++)
          .    .    .           .         .      .         .       .    .              setFrozen(extra_frozen[i], false);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      return result;
          9    0    0           8         1      1         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  bool SimpSolver::addClause_(vec<Lit>& ps)
  3,107,322    8    2           0         0      0 2,071,548       0    0  {
          .    .    .           .         .      .         .       .    .  #ifndef NDEBUG
          .    .    .           .         .      .         .       .    .      for (int i = 0; i < ps.size(); i++)
          .    .    .           .         .      .         .       .    .          assert(!isEliminated(var(ps[i])));
          .    .    .           .         .      .         .       .    .  #endif
          .    .    .           .         .      .         .       .    .  
    345,258    0    0     345,258       954      0         0       0    0      int nclauses = clauses.size();
          .    .    .           .         .      .         .       .    .  
    690,516    0    0     345,258        51      0         0       0    0      if (use_rcheck && implied(ps))
    345,258    0    0           0         0      0         0       0    0          return true;
          .    .    .           .         .      .         .       .    .  
  1,726,290    0    0           0         0      0   345,258       0    0      if (!Solver::addClause_(ps))
          .    .    .           .         .      .         .       .    .          return false;
          .    .    .           .         .      .         .       .    .  
  1,215,297    4    1     520,185       133      0         0       0    0      if (!parsing && drup_file) {
          .    .    .           .         .      .         .       .    .  #ifdef BIN_DRUP
          .    .    .           .         .      .         .       .    .          binDRUP('a', ps, drup_file);
          .    .    .           .         .      .         .       .    .  #else
          .    .    .           .         .      .         .       .    .          for (int i = 0; i < ps.size(); i++)
          .    .    .           .         .      .         .       .    .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
          .    .    .           .         .      .         .       .    .          fprintf(drup_file, "0\n");
          .    .    .           .         .      .         .       .    .  #endif
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
  1,726,290    4    1     690,516       137      0         0       0    0      if (use_simplification && clauses.size() == nclauses + 1){
  1,381,032    3    1     690,516        69      0   345,258       0    0          CRef          cr = clauses.last();
          .    .    .           .         .      .         .       .    .          const Clause& c  = ca[cr];
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          // NOTE: the clause is added to the queue immediately and then
          .    .    .           .         .      .         .       .    .          // again during 'gatherTouchedClauses()'. If nothing happens
          .    .    .           .         .      .         .       .    .          // in between, it will only be checked once. Otherwise, it may
          .    .    .           .         .      .         .       .    .          // be checked twice unnecessarily. This is an unfortunate
          .    .    .           .         .      .         .       .    .          // consequence of how backward subsumption is used to mimic
          .    .    .           .         .      .         .       .    .          // forward subsumption.
          .    .    .           .         .      .         .       .    .          subsumption_queue.insert(cr);
  4,725,330    3    0   1,672,149        24      0         0       0    0          for (int i = 0; i < c.size(); i++){
          .    .    .           .         .      .         .       .    .              occurs[var(c[i])].push(cr);
  1,326,891    0    0   1,326,891   317,763      1         0       0    0              n_occ[toInt(c[i])]++;
  2,653,782    0    0   1,326,891        55      0 1,326,891 139,581   10              touched[var(c[i])] = 1;
  1,326,891    2    1   1,326,891       140      0         0       0    0              n_touched++;
          .    .    .           .         .      .         .       .    .              if (elim_heap.inHeap(var(c[i])))
          .    .    .           .         .      .         .       .    .                  elim_heap.increase(var(c[i]));
          .    .    .           .         .      .         .       .    .          }
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      return true;
  2,762,064    0    0   2,416,806       246      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  void SimpSolver::removeClause(CRef cr)
  1,432,800    1    1           0         0      0 1,114,400   1,891    0  {
          .    .    .           .         .      .         .       .    .      const Clause& c = ca[cr];
          .    .    .           .         .      .         .       .    .  
    318,400    0    0     159,200        21      0         0       0    0      if (use_simplification)
  2,874,788    0    0   1,278,194     1,053      0         0       0    0          for (int i = 0; i < c.size(); i++){
    559,497    0    0     559,497    44,681      0         0       0    0              n_occ[toInt(c[i])]--;
          .    .    .           .         .      .         .       .    .              updateElimHeap(var(c[i]));
          .    .    .           .         .      .         .       .    .              occurs.smudge(var(c[i]));
          .    .    .           .         .      .         .       .    .          }
          .    .    .           .         .      .         .       .    .  
    477,600    0    0     159,200         0      0         0       0    0      Solver::removeClause(cr);
  1,114,400    0    0     955,200         9      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  bool SimpSolver::strengthenClause(CRef cr, Lit l)
    279,920    3    1           0         0      0   167,952       5    0  {
          .    .    .           .         .      .         .       .    .      Clause& c = ca[cr];
          .    .    .           .         .      .         .       .    .      assert(decisionLevel() == 0);
          .    .    .           .         .      .         .       .    .      assert(use_simplification);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // FIX: this is too inefficient but would be nice to have (properly implemented)
          .    .    .           .         .      .         .       .    .      // if (!find(subsumption_queue, &c))
          .    .    .           .         .      .         .       .    .      subsumption_queue.insert(cr);
          .    .    .           .         .      .         .       .    .  
     83,976    0    0      27,992         6      0         0       0    0      if (drup_file){
          .    .    .           .         .      .         .       .    .  #ifdef BIN_DRUP
          .    .    .           .         .      .         .       .    .          binDRUP_strengthen(c, l, drup_file);
          .    .    .           .         .      .         .       .    .  #else
          .    .    .           .         .      .         .       .    .          for (int i = 0; i < c.size(); i++)
          .    .    .           .         .      .         .       .    .              if (c[i] != l) fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
          .    .    .           .         .      .         .       .    .          fprintf(drup_file, "0\n");
          .    .    .           .         .      .         .       .    .  #endif
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
     55,984    1    1      27,992         0      0         0       0    0      if (c.size() == 2){
          .    .    .           .         .      .         .       .    .          removeClause(cr);
          .    .    .           .         .      .         .       .    .          c.strengthen(l);
          .    .    .           .         .      .         .       .    .      }else{
          .    .    .           .         .      .         .       .    .          if (drup_file){
          .    .    .           .         .      .         .       .    .  #ifdef BIN_DRUP
          .    .    .           .         .      .         .       .    .              binDRUP('d', c, drup_file);
          .    .    .           .         .      .         .       .    .  #else
          .    .    .           .         .      .         .       .    .              fprintf(drup_file, "d ");
          .    .    .           .         .      .         .       .    .              for (int i = 0; i < c.size(); i++)
          .    .    .           .         .      .         .       .    .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
          .    .    .           .         .      .         .       .    .              fprintf(drup_file, "0\n");
          .    .    .           .         .      .         .       .    .  #endif
          .    .    .           .         .      .         .       .    .          }
          .    .    .           .         .      .         .       .    .  
    111,968    7    2           0         0      0    27,992   2,200    0          detachClause(cr, true);
          .    .    .           .         .      .         .       .    .          c.strengthen(l);
     83,976  435    1           0         0      0    27,992       0    0          attachClause(cr);
          .    .    .           .         .      .         .       .    .          remove(occurs[var(l)], cr);
     27,992    0    0      27,992     8,517      0         0       0    0          n_occ[toInt(l)]--;
          .    .    .           .         .      .         .       .    .          updateElimHeap(var(l));
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
     83,976    3    1           0         0      0         0       0    0      return c.size() == 1 ? enqueue(c[0]) && propagate() == CRef_Undef : true;
    223,936    0    0     195,944         1      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  // Returns FALSE if clause is always satisfied ('out_clause' should not be used).
          .    .    .           .         .      .         .       .    .  bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
  3,312,540    1    1           0         0      0 1,806,840       0    0  {
    301,140    1    1     301,140        72      0         0       0    0      merges++;
          .    .    .           .         .      .         .       .    .      out_clause.clear();
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      bool  ps_smallest = _ps.size() < _qs.size();
  2,463,209    0    0           0         0      0         0       0    0      const Clause& ps  =  ps_smallest ? _qs : _ps;
          .    .    .           .         .      .         .       .    .      const Clause& qs  =  ps_smallest ? _ps : _qs;
          .    .    .           .         .      .         .       .    .  
  1,947,772    0    0           0         0      0         0       0    0      for (int i = 0; i < qs.size(); i++){
  1,296,778    0    0           0         0      0         0       0    0          if (var(qs[i]) != v){
  3,324,478    3    1           0         0      0         0       0    0              for (int j = 0; j < ps.size(); j++)
  4,283,970    0    0           0         0      0         0       0    0                  if (var(ps[j]) == var(qs[i]))
    329,184    0    0           0         0      0         0       0    0                      if (ps[j] == ~qs[i])
    126,213    0    0           0         0      0         0       0    0                          return false;
          .    .    .           .         .      .         .       .    .                      else
          .    .    .           .         .      .         .       .    .                          goto next;
          .    .    .           .         .      .         .       .    .              out_clause.push(qs[i]);
          .    .    .           .         .      .         .       .    .          }
          .    .    .           .         .      .         .       .    .          next:;
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
  2,073,974    3    1           0         0      0         0       0    0      for (int i = 0; i < ps.size(); i++)
  1,374,266    0    0           0         0      0         0       0    0          if (var(ps[i]) != v)
          .    .    .           .         .      .         .       .    .              out_clause.push(ps[i]);
          .    .    .           .         .      .         .       .    .  
    174,927    1    0           0         0      0         0       0    0      return true;
  2,409,120    0    0   2,107,980         0      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  // Returns FALSE if clause is always satisfied.
          .    .    .           .         .      .         .       .    .  bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)
          .    .    .           .         .      .         .       .    .  {
 23,721,681    0    0   7,907,227         0      0 7,907,227       0    0      merges++;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      bool  ps_smallest = _ps.size() < _qs.size();
 51,397,688    0    0           0         0      0         0       0    0      const Clause& ps  =  ps_smallest ? _qs : _ps;
          .    .    .           .         .      .         .       .    .      const Clause& qs  =  ps_smallest ? _ps : _qs;
          .    .    .           .         .      .         .       .    .      const Lit*  __ps  = (const Lit*)ps;
          .    .    .           .         .      .         .       .    .      const Lit*  __qs  = (const Lit*)qs;
          .    .    .           .         .      .         .       .    .  
  7,907,227    1    1           0         0      0         0       0    0      size = ps.size()-1;
          .    .    .           .         .      .         .       .    .  
101,071,119    0    0           0         0      0         0       0    0      for (int i = 0; i < qs.size(); i++){
 57,019,452    1    1  19,006,484     4,256      0         0       0    0          if (var(__qs[i]) != v){
143,648,034    0    0           0         0      0         0       0    0              for (int j = 0; j < ps.size(); j++)
213,681,450    0    0  63,049,854    22,729      0         0       0    0                  if (var(__ps[j]) == var(__qs[i]))
 13,554,924    0    0           0         0      0         0       0    0                      if (__ps[j] == ~__qs[i])
          .    .    .           .         .      .         .       .    .                          return false;
          .    .    .           .         .      .         .       .    .                      else
          .    .    .           .         .      .         .       .    .                          goto next;
 17,548,326    0    0           0         0      0         0       0    0              size++;
          .    .    .           .         .      .         .       .    .          }
          .    .    .           .         .      .         .       .    .          next:;
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      return true;
          .    .    .           .         .      .         .       .    .  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
         56    3    2           0         0      0        42       0    0  void SimpSolver::gatherTouchedClauses()
          .    .    .           .         .      .         .       .    .  {
          4    0    0           0         0      0         0       0    0      if (n_touched == 0) return;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      int i,j;
    340,676    1    1           0         0      0         0       0    0      for (i = j = 0; i < subsumption_queue.size(); i++)
    340,662    0    0           0         0      0         0       0    0          if (ca[subsumption_queue[i]].mark() == 0)
          .    .    .           .         .      .         .       .    .              ca[subsumption_queue[i]].mark(2);
          .    .    .           .         .      .         .       .    .  
    459,992    2    1          22         3      0         0       0    0      for (i = 0; i < touched.size(); i++)
    689,892    0    0     459,928     3,605     13         0       0    0          if (touched[i]){
          .    .    .           .         .      .         .       .    .              const vec<CRef>& cs = occurs.lookup(i);
  6,306,935    0    0     143,820        36      0         0       0    0              for (j = 0; j < cs.size(); j++)
 10,534,670    0    0   4,213,868 1,595,836      3         0       0    0                  if (ca[cs[j]].mark() == 0){
          .    .    .           .         .      .         .       .    .                      subsumption_queue.insert(cs[j]);
          .    .    .           .         .      .         .       .    .                      ca[cs[j]].mark(2);
          .    .    .           .         .      .         .       .    .                  }
    304,652    3    3     152,326        38      0    76,163      34    0              touched[i] = 0;
          .    .    .           .         .      .         .       .    .          }
          .    .    .           .         .      .         .       .    .  
  1,562,653    5    4           0         0      0         0       0    0      for (i = 0; i < subsumption_queue.size(); i++)
  1,248,328    0    0           0         0      0         0       0    0          if (ca[subsumption_queue[i]].mark() == 2)
          .    .    .           .         .      .         .       .    .              ca[subsumption_queue[i]].mark(0);
          .    .    .           .         .      .         .       .    .  
          7    2    2           0         0      0         7       7    0      n_touched = 0;
         56    0    0          49         7      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  bool SimpSolver::implied(const vec<Lit>& c)
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .      assert(decisionLevel() == 0);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      trail_lim.push(trail.size());
          .    .    .           .         .      .         .       .    .      for (int i = 0; i < c.size(); i++)
-- line 350 ----------------------------------------
-- line 359 ----------------------------------------
          .    .    .           .         .      .         .       .    .      bool result = propagate() != CRef_Undef;
          .    .    .           .         .      .         .       .    .      cancelUntil(0);
          .    .    .           .         .      .         .       .    .      return result;
          .    .    .           .         .      .         .       .    .  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  // Backward subsumption + backward subsumption resolution
          .    .    .           .         .      .         .       .    .  bool SimpSolver::backwardSubsumptionCheck(bool verbose)
    136,404    3    1           0         0      0   106,092       7    0  {
    855,941    0    0     825,629     2,092      0    15,156       0    0      int cnt = 0;
     15,156    2    2           0         0      0    15,156       0    0      int subsumed = 0;
     15,156    0    0           0         0      0    15,156       0    0      int deleted_literals = 0;
          .    .    .           .         .      .         .       .    .      assert(decisionLevel() == 0);
          .    .    .           .         .      .         .       .    .  
  1,729,946    1    1      30,312     2,260      0         0       0    0      while (subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()){
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          // Empty subsumption queue and return immediately on user-interrupt:
  6,616,664    1    1   3,308,332     3,645      0         0       0    0          if (asynch_interrupt){
          .    .    .           .         .      .         .       .    .              subsumption_queue.clear();
          .    .    .           .         .      .         .       .    .              bwdsub_assigns = trail.size();
          .    .    .           .         .      .         .       .    .              break; }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          // Check top-level assignments by creating a dummy clause and placing it in the queue:
          .    .    .           .         .      .         .       .    .          if (subsumption_queue.size() == 0 && bwdsub_assigns < trail.size()){
          .    .    .           .         .      .         .       .    .              Lit l = trail[bwdsub_assigns++];
          .    .    .           .         .      .         .       .    .              ca[bwdsub_tmpunit][0] = l;
          .    .    .           .         .      .         .       .    .              ca[bwdsub_tmpunit].calcAbstraction();
          .    .    .           .         .      .         .       .    .              subsumption_queue.insert(bwdsub_tmpunit); }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          CRef    cr = subsumption_queue.peek(); subsumption_queue.pop();
          .    .    .           .         .      .         .       .    .          Clause& c  = ca[cr];
          .    .    .           .         .      .         .       .    .  
  6,276,217    4    2     827,083    77,606      0         0       0    0          if (c.mark()) continue;
          .    .    .           .         .      .         .       .    .  
  2,890,306    0    0   1,445,153     2,522      0         0       0    0          if (verbose && verbosity >= 2 && cnt++ % 1000 == 0)
          .    .    .           .         .      .         .       .    .              printf("c subsumption left: %10d (%10d subsumed, %10d deleted literals)\r", subsumption_queue.size(), subsumed, deleted_literals);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          assert(c.size() > 1 || value(c[0]) == l_True);    // Unit-clauses should have been propagated before this point.
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          // Find best variable to scan:
          .    .    .           .         .      .         .       .    .          Var best = var(c[0]);
  9,490,606    0    0           0         0      0         0       0    0          for (int i = 1; i < c.size(); i++)
  8,812,344    0    0   2,313,884   554,894      0         0       0    0              if (occurs[var(c[i])].size() < occurs[best].size())
          .    .    .           .         .      .         .       .    .                  best = var(c[i]);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          // Search all candidates:
          .    .    .           .         .      .         .       .    .          vec<CRef>& _cs = occurs.lookup(best);
    810,473    0    0     810,473         0      0         0       0    0          CRef*       cs = (CRef*)_cs;
          .    .    .           .         .      .         .       .    .  
 82,418,211    1    1           0         0      0   810,473       0    0          for (int j = 0; j < _cs.size(); j++)
 79,176,319    0    0  39,182,923         9      0   810,473      12    0              if (c.mark())
          .    .    .           .         .      .         .       .    .                  break;
504,515,161    1    1 155,110,746 8,654,430      3         0       0    0              else if (!ca[cs[j]].mark() &&  cs[j] != cr && (subsumption_lim == -1 || ca[cs[j]].size() < subsumption_lim)){
          .    .    .           .         .      .         .       .    .                  Lit l = c.subsumes(ca[cs[j]]);
          .    .    .           .         .      .         .       .    .  
    109,438    0    0           0         0      0         0       0    0                  if (l == lit_Undef)
    187,089    1    1      80,181        22      0    26,727   1,872    0                      subsumed++, removeClause(cs[j]);
     55,984    0    0           0         0      0         0       0    0                  else if (l != lit_Error){
     27,992    0    0      27,992         0      0         0       0    0                      deleted_literals++;
          .    .    .           .         .      .         .       .    .  
    111,968    0    0           0         0      0    27,992   2,179    0                      if (!strengthenClause(cs[j], ~l))
          .    .    .           .         .      .         .       .    .                          return false;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .                      // Did current candidate get deleted from cs? Then check candidate at index j again:
          .    .    .           .         .      .         .       .    .                      if (var(l) == best)
          .    .    .           .         .      .         .       .    .                          j--;
          .    .    .           .         .      .         .       .    .                  }
          .    .    .           .         .      .         .       .    .              }
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
     15,156    0    0           0         0      0         0       0    0      return true;
    121,248    3    1     106,092       342      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  bool SimpSolver::asymm(Var v, CRef cr)
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .      Clause& c = ca[cr];
          .    .    .           .         .      .         .       .    .      assert(decisionLevel() == 0);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      if (c.mark() || satisfied(c)) return true;
-- line 438 ----------------------------------------
-- line 478 ----------------------------------------
          .    .    .           .         .      .         .       .    .  static void mkElimClause(vec<uint32_t>& elimclauses, Lit x)
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .      elimclauses.push(toInt(x));
          .    .    .           .         .      .         .       .    .      elimclauses.push(1);
          .    .    .           .         .      .         .       .    .  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  static void mkElimClause(vec<uint32_t>& elimclauses, Var v, Clause& c)
    436,200    7    1           0         0      0   327,150       0    0  {
     54,525    0    0      54,525         0      0         0       0    0      int first = elimclauses.size();
    277,978    0    0     168,928         0      0         0       0    0      int v_pos = -1;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Copy clause to elimclauses-vector. Remember position where the
          .    .    .           .         .      .         .       .    .      // variable 'v' occurs:
    779,475    0    0     114,425         0      0         0       0    0      for (int i = 0; i < c.size(); i++){
    337,900    5    1     168,950         2      0         0       0    0          elimclauses.push(toInt(c[i]));
          .    .    .           .         .      .         .       .    .          if (var(c[i]) == v)
          .    .    .           .         .      .         .       .    .              v_pos = i + first;
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .      assert(v_pos != -1);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Swap the first literal with the 'v' literal, so that the literal
          .    .    .           .         .      .         .       .    .      // containing 'v' will occur first in the clause:
     54,525    0    0      54,525         0      0         0       0    0      uint32_t tmp = elimclauses[v_pos];
    109,050    0    0      54,525         0      0    54,525       0    0      elimclauses[v_pos] = elimclauses[first];
     54,525    0    0           0         0      0    54,525       0    0      elimclauses[first] = tmp;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Store the length of the clause last:
          .    .    .           .         .      .         .       .    .      elimclauses.push(c.size());
    436,200    0    0     381,675         9      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  bool SimpSolver::eliminateVar(Var v)
    985,030    1    1           0         0      0   591,018       0    0  {
          .    .    .           .         .      .         .       .    .      assert(!frozen[v]);
          .    .    .           .         .      .         .       .    .      assert(!isEliminated(v));
          .    .    .           .         .      .         .       .    .      assert(value(v) == l_Undef);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Split the occurrences into positive and negative:
          .    .    .           .         .      .         .       .    .      //
          .    .    .           .         .      .         .       .    .      const vec<CRef>& cls = occurs.lookup(v);
          .    .    .           .         .      .         .       .    .      vec<CRef>        pos, neg;
  9,792,055    1    1   6,462,368    62,952    790         0       0    0      for (int i = 0; i < cls.size(); i++)
  3,132,681    1    1           0         0      0         0       0    0          (find(ca[cls[i]], mkLit(v)) ? pos : neg).push(cls[i]);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Check wether the increase in number of clauses stays within the allowed ('grow'). Moreover, no
          .    .    .           .         .      .         .       .    .      // clause must exceed the limit on the maximal clause size (if it is set):
          .    .    .           .         .      .         .       .    .      //
     98,503    0    0           0         0      0    98,503       0    0      int cnt         = 0;
          .    .    .           .         .      .         .       .    .      int clause_size = 0;
          .    .    .           .         .      .         .       .    .  
  1,288,500    1    1     644,250         0      0         0       0    0      for (int i = 0; i < pos.size(); i++)
 33,494,427    1    1   9,347,462         0      0   197,006       0    0          for (int j = 0; j < neg.size(); j++)
 15,907,639    1    1   7,806,065         0      0   295,509       0    0              if (merge(ca[pos[i]], ca[neg[j]], v, clause_size) && 
 41,726,264    1    1  15,331,985         0      0         0       0    0                  (++cnt > cls.size() + grow || (clause_lim != -1 && clause_size > clause_lim)))
          .    .    .           .         .      .         .       .    .                  return true;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Delete and store old clauses:
     45,447    0    0      30,298         0      0    15,149       0    0      eliminated[v] = true;
          .    .    .           .         .      .         .       .    .      setDecisionVar(v, false);
     15,149    0    0      15,149         0      0         0       0    0      eliminated_vars++;
          .    .    .           .         .      .         .       .    .  
     75,745    3    1      30,298         0      0         0       0    0      if (pos.size() > neg.size()){
     72,167    0    0      21,675         4      0         0       0    0          for (int i = 0; i < neg.size(); i++)
    108,375    0    0      21,675         0      0    21,675       0    0              mkElimClause(elimclauses, v, ca[neg[i]]);
          .    .    .           .         .      .         .       .    .          mkElimClause(elimclauses, mkLit(v));
          .    .    .           .         .      .         .       .    .      }else{
     82,330    2    2      32,850         5      0         0       0    0          for (int i = 0; i < pos.size(); i++)
    164,250    0    0      32,850         0      0    32,850       0    0              mkElimClause(elimclauses, v, ca[pos[i]]);
          .    .    .           .         .      .         .       .    .          mkElimClause(elimclauses, ~mkLit(v));
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Produce clauses in cross product:
     15,149    1    1           0         0      0         0       0    0      vec<Lit>& resolvent = add_tmp;
    280,822    1    1      30,298         0      0         0       0    0      for (int i = 0; i < pos.size(); i++)
  1,409,637    0    0     301,140       131      0         0       0    0          for (int j = 0; j < neg.size(); j++)
  3,314,053    2    2     617,429       208      0   491,216       0    0              if (merge(ca[pos[i]], ca[neg[j]], v, resolvent) && !addClause_(resolvent))
          .    .    .           .         .      .         .       .    .                  return false;
          .    .    .           .         .      .         .       .    .  
    340,691    0    0     162,771       595      0         0       0    0      for (int i = 0; i < cls.size(); i++)
    794,838    1    1     397,419     1,191      0   132,473       0    0          removeClause(cls[i]); 
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Free occurs list for this variable:
          .    .    .           .         .      .         .       .    .      occurs[v].clear(true);
          .    .    .           .         .      .         .       .    .      
          .    .    .           .         .      .         .       .    .      // Free watchers lists for this variable, if possible:
          .    .    .           .         .      .         .       .    .      watches_bin[ mkLit(v)].clear(true);
          .    .    .           .         .      .         .       .    .      watches_bin[~mkLit(v)].clear(true);
          .    .    .           .         .      .         .       .    .      watches[ mkLit(v)].clear(true);
          .    .    .           .         .      .         .       .    .      watches[~mkLit(v)].clear(true);
          .    .    .           .         .      .         .       .    .  
     60,596    0    0           0         0      0    15,149       0    0      return backwardSubsumptionCheck();
    788,024    0    0     689,521     3,231      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  bool SimpSolver::substitute(Var v, Lit x)
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .      assert(!frozen[v]);
          .    .    .           .         .      .         .       .    .      assert(!isEliminated(v));
          .    .    .           .         .      .         .       .    .      assert(value(v) == l_Undef);
          .    .    .           .         .      .         .       .    .  
-- line 579 ----------------------------------------
-- line 603 ----------------------------------------
          .    .    .           .         .      .         .       .    .  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  void SimpSolver::extendModel()
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .      int i, j;
          .    .    .           .         .      .         .       .    .      Lit x;
          .    .    .           .         .      .         .       .    .  
    278,700    1    1           1         1      1         0       0    0      for (i = elimclauses.size()-1; i > 0; i -= j){
  1,040,210    1    1     139,350    13,632 13,631         0       0    0          for (j = elimclauses[i--]; j > 1; j--, i--)
    285,534    0    0      38,163     2,231  2,231         0       0    0              if (modelValue(toLit(elimclauses[i])) != l_False)
          .    .    .           .         .      .         .       .    .                  goto next;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          x = toLit(elimclauses[i]);
     26,150    0    0           0         0      0    26,150   1,024    0          model[var(x)] = lbool(!sign(x));
          .    .    .           .         .      .         .       .    .      next:;
          .    .    .           .         .      .         .       .    .      }
          1    0    0           1         1      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  // Almost duplicate of Solver::removeSatisfied. Didn't want to make the base method 'virtual'.
          .    .    .           .         .      .         .       .    .  void SimpSolver::removeSatisfied()
          .    .    .           .         .      .         .       .    .  {
          .    .    .           .         .      .         .       .    .      int i, j;
          .    .    .           .         .      .         .       .    .      for (i = j = 0; i < clauses.size(); i++){
          .    .    .           .         .      .         .       .    .          const Clause& c = ca[clauses[i]];
          .    .    .           .         .      .         .       .    .          if (c.mark() == 0)
-- line 628 ----------------------------------------
-- line 632 ----------------------------------------
          .    .    .           .         .      .         .       .    .                  clauses[j++] = clauses[i];
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .      clauses.shrink(i - j);
          .    .    .           .         .      .         .       .    .  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  // The technique and code are by the courtesy of the GlueMiniSat team. Thank you!
          .    .    .           .         .      .         .       .    .  // It helps solving certain types of huge problems tremendously.
          .    .    .           .         .      .         .       .    .  bool SimpSolver::eliminate(bool turn_off_elim)
          9    1    1           0         0      0         7       1    0  {
          1    0    0           0         0      0         0       0    0      bool res = true;
          .    .    .           .         .      .         .       .    .      int iter = 0;
          .    .    .           .         .      .         .       .    .      int n_cls, n_cls_init, n_vars;
          .    .    .           .         .      .         .       .    .  
          3    0    0           1         0      0         0       0    0      if (nVars() == 0) goto cleanup; // User disabling preprocessing.
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Get an initial number of clauses (more accurately).
          3    1    1           1         0      0         0       0    0      if (trail.size() != 0) removeSatisfied();
          .    .    .           .         .      .         .       .    .      n_cls_init = nClauses();
          .    .    .           .         .      .         .       .    .  
          3    0    0           0         0      0         1       0    0      res = eliminate_(); // The first, usual variable elimination of MiniSat.
          2    0    0           0         0      0         0       0    0      if (!res) goto cleanup;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      n_cls  = nClauses();
          .    .    .           .         .      .         .       .    .      n_vars = nFreeVars();
          .    .    .           .         .      .         .       .    .  
          6    0    0           1         1      0         1       0    0      printf("c Reduced to %d vars, %d cls (grow=%d)\n", n_vars, n_cls, grow);
          .    .    .           .         .      .         .       .    .  
          9    1    1           1         0      0         0       0    0      if ((double)n_cls / n_vars >= 10 || n_vars < 10000){
          .    .    .           .         .      .         .       .    .          printf("c No iterative elimination performed. (vars=%d, c/v ratio=%.1f)\n", n_vars, (double)n_cls / n_vars);
          .    .    .           .         .      .         .       .    .          goto cleanup; }
          .    .    .           .         .      .         .       .    .  
          4    0    0           1         0      0         1       0    0      grow = grow ? grow * 2 : 8;
          6    0    0           1         0      0         2       0    0      for (; grow < 10000; grow *= 2){
          .    .    .           .         .      .         .       .    .          // Rebuild elimination variable heap.
    632,520    0    0           2         0      0         4       0    0          for (int i = 0; i < clauses.size(); i++){
    316,252    0    0     316,252         0      0         0       0    0              const Clause& c = ca[clauses[i]];
  4,518,204    0    0   2,100,976         0      0         0       0    0              for (int j = 0; j < c.size(); j++)
          .    .    .           .         .      .         .       .    .                  if (!elim_heap.inHeap(var(c[j])))
          .    .    .           .         .      .         .       .    .                      elim_heap.insert(var(c[j]));
          .    .    .           .         .      .         .       .    .                  else
          .    .    .           .         .      .         .       .    .                      elim_heap.update(var(c[j])); }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          int n_cls_last = nClauses();
          .    .    .           .         .      .         .       .    .          int n_vars_last = nFreeVars();
          .    .    .           .         .      .         .       .    .  
          6    2    1           0         0      0         2       0    0          res = eliminate_();
          8    2    2           0         0      0         0       0    0          if (!res || n_vars_last == nFreeVars()) break;
          .    .    .           .         .      .         .       .    .          iter++;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          int n_cls_now  = nClauses();
          .    .    .           .         .      .         .       .    .          int n_vars_now = nFreeVars();
          .    .    .           .         .      .         .       .    .  
         14    2    2           2         2      1         2       0    0          double cl_inc_rate  = (double)n_cls_now   / n_cls_last;
         12    0    0           0         0      0         2       0    0          double var_dec_rate = (double)n_vars_last / n_vars_now;
          .    .    .           .         .      .         .       .    .  
         12    0    0           2         2      0         4       0    0          printf("c Reduced to %d vars, %d cls (grow=%d)\n", n_vars_now, n_cls_now, grow);
         10    1    1           4         0      0         2       0    0          printf("c cl_inc_rate=%.3f, var_dec_rate=%.3f\n", cl_inc_rate, var_dec_rate);
          .    .    .           .         .      .         .       .    .  
          7    0    0           4         0      0         0       0    0          if (n_cls_now > n_cls_init || cl_inc_rate > var_dec_rate) break;
          .    .    .           .         .      .         .       .    .      }
          4    1    1           1         0      0         1       0    0      printf("c No. effective iterative eliminations: %d\n", iter);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  cleanup:
          .    .    .           .         .      .         .       .    .      touched  .clear(true);
          .    .    .           .         .      .         .       .    .      occurs   .clear(true);
          .    .    .           .         .      .         .       .    .      n_occ    .clear(true);
          .    .    .           .         .      .         .       .    .      elim_heap.clear(true);
          1    0    0           0         0      0         0       0    0      subsumption_queue.clear(true);
          .    .    .           .         .      .         .       .    .  
          1    0    0           0         0      0         1       1    0      use_simplification    = false;
          1    0    0           0         0      0         1       1    1      remove_satisfied      = true;
          1    0    0           0         0      0         1       1    0      ca.extra_clause_field = false;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Force full cleanup (this is safe and desirable since it only happens once):
          2    0    0           0         0      0         1       0    0      rebuildOrderHeap();
          3    0    0           2         2      0         1       0    0      garbageCollect();
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      return res;
     15,158    1    1           7         1      1         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  bool SimpSolver::eliminate_()
         24    1    1           0         0      0        18       2    0  {
          9    0    0           0         0      0         3       2    0      if (!simplify())
          .    .    .           .         .      .         .       .    .          return false;
          6    0    0           3         3      0         0       0    0      else if (!use_simplification)
          .    .    .           .         .      .         .       .    .          return true;
          .    .    .           .         .      .         .       .    .  
          9    0    0           3         0      0         3       1    0      int trail_size_last = trail.size();
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Main simplification loop:
          .    .    .           .         .      .         .       .    .      //
         80    6    3          27         8      0         7       0    0      while (n_touched > 0 || bwdsub_assigns < trail.size() || elim_heap.size() > 0){
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          gatherTouchedClauses();
          .    .    .           .         .      .         .       .    .          // printf("  ## (time = %6.2f s) BWD-SUB: queue = %d, trail = %d\n", cpuTime(), subsumption_queue.size(), trail.size() - bwdsub_assigns);
         38    0    0           4         0      0         0       0    0          if ((subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()) && 
         21    4    2           0         0      0         7       0    0              !backwardSubsumptionCheck(true)){
          .    .    .           .         .      .         .       .    .              ok = false; goto cleanup; }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          // Empty elim_heap and return immediately on user-interrupt:
         45    0    0          18         2      0         9       7    0          if (asynch_interrupt){
          .    .    .           .         .      .         .       .    .              assert(bwdsub_assigns == trail.size());
          .    .    .           .         .      .         .       .    .              assert(subsumption_queue.size() == 0);
          .    .    .           .         .      .         .       .    .              assert(n_touched == 0);
          .    .    .           .         .      .         .       .    .              elim_heap.clear();
          .    .    .           .         .      .         .       .    .              goto cleanup; }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          // printf("  ## (time = %6.2f s) ELIM: vars = %d\n", cpuTime(), elim_heap.size());
    492,524    0    0     196,997     3,632      0    98,503       0    0          for (int cnt = 0; !elim_heap.empty(); cnt++){
          .    .    .           .         .      .         .       .    .              Var elim = elim_heap.removeMin();
          .    .    .           .         .      .         .       .    .              
    197,006    2    2      98,503         0      0         0       0    0              if (asynch_interrupt) break;
          .    .    .           .         .      .         .       .    .  
    394,012    0    0     197,006   134,835    106         0       0    0              if (isEliminated(elim) || value(elim) != l_Undef) continue;
          .    .    .           .         .      .         .       .    .  
    197,006    0    0      98,503     1,552      0         0       0    0              if (verbosity >= 2 && cnt % 100 == 0)
          .    .    .           .         .      .         .       .    .                  printf("c elimination left: %10d\r", elim_heap.size());
          .    .    .           .         .      .         .       .    .  
    197,006    1    1      98,503         2      0         0       0    0              if (use_asymm){
          .    .    .           .         .      .         .       .    .                  // Temporarily freeze variable. Otherwise, it would immediately end up on the queue again:
          .    .    .           .         .      .         .       .    .                  bool was_frozen = frozen[elim];
          .    .    .           .         .      .         .       .    .                  frozen[elim] = true;
          .    .    .           .         .      .         .       .    .                  if (!asymmVar(elim)){
          .    .    .           .         .      .         .       .    .                      ok = false; goto cleanup; }
          .    .    .           .         .      .         .       .    .                  frozen[elim] = was_frozen; }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .              // At this point, the variable may have been set by assymetric branching, so check it
          .    .    .           .         .      .         .       .    .              // again. Also, don't eliminate frozen variables:
  1,182,036  362    1     492,515    69,288    103    98,503       0    0              if (use_elim && value(elim) == l_Undef && !frozen[elim] && !eliminateVar(elim)){
          .    .    .           .         .      .         .       .    .                  ok = false; goto cleanup; }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .              checkGarbage(simp_garbage_frac);
          .    .    .           .         .      .         .       .    .          }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .          assert(subsumption_queue.size() == 0);
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .   cleanup:
          .    .    .           .         .      .         .       .    .      // To get an accurate number of clauses.
          6    3    2           3         0      0         0       0    0      if (trail_size_last != trail.size())
          .    .    .           .         .      .         .       .    .          removeSatisfied();
          .    .    .           .         .      .         .       .    .      else{
          .    .    .           .         .      .         .       .    .          int i,j;
  1,323,036    3    2           3         3      0         0       0    0          for (i = j = 0; i < clauses.size(); i++)
  2,964,443    2    2   1,323,023   405,866  3,029         0       0    0              if (ca[clauses[i]].mark() == 0)
  3,013,858    0    0     502,310         2      0   502,310  30,938    0                  clauses[j++] = clauses[i];
          3    0    0           0         0      0         0       0    0          clauses.shrink(i - j);
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .      checkGarbage();
          .    .    .           .         .      .         .       .    .  
         18    0    0           6         3      0         0       0    0      if (verbosity >= 1 && elimclauses.size() > 0)
         12    0    0           3         3      2         3       0    0          printf("c |  Eliminated clauses:     %10.2f Mb                                      |\n", 
          9    0    0           0         0      0         0       0    0                 double(elimclauses.size() * sizeof(uint32_t)) / (1024*1024));
          .    .    .           .         .      .         .       .    .  
          3    0    0           3         0      0         0       0    0      return ok;
         24    0    0          21         6      1         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  //=================================================================================================
          .    .    .           .         .      .         .       .    .  // Garbage Collection methods:
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
         27    3    2           0         0      0        21       0    0  void SimpSolver::relocAll(ClauseAllocator& to)
          .    .    .           .         .      .         .       .    .  {
         18    7    5           9         9      3         0       0    0      if (!use_simplification) return;
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // All occurs lists:
          .    .    .           .         .      .         .       .    .      //
          .    .    .           .         .      .         .       .    .      occurs.cleanAll();
    197,136    4    3           3         0      0         9       3    0      for (int i = 0; i < nVars(); i++){
          .    .    .           .         .      .         .       .    .          vec<CRef>& cs = occurs[i];
  8,243,648    5    4   4,072,546    24,741    663    63,582       0    0          for (int j = 0; j < cs.size(); j++)
          .    .    .           .         .      .         .       .    .              ca.reloc(cs[j], to);
          .    .    .           .         .      .         .       .    .      }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Subsumption queue:
          .    .    .           .         .      .         .       .    .      //
         21    3    3           6         0      0         0       0    0      for (int i = 0; i < subsumption_queue.size(); i++)
          .    .    .           .         .      .         .       .    .          ca.reloc(subsumption_queue[i], to);
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .      // Temporary clause:
          .    .    .           .         .      .         .       .    .      //
          .    .    .           .         .      .         .       .    .      ca.reloc(bwdsub_tmpunit, to);
         24    0    0          21         0      0         0       0    0  }
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  
          .    .    .           .         .      .         .       .    .  void SimpSolver::garbageCollect()
         27    7    5           0         0      0         9       0    0  {
          .    .    .           .         .      .         .       .    .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
          .    .    .           .         .      .         .       .    .      // is not precise but should avoid some unnecessary reallocations for the new region:
         18    0    0          18         1      0         0       0    0      ClauseAllocator to(ca.size() - ca.wasted()); 
          .    .    .           .         .      .         .       .    .  
         18    0    0           9         2      0         9       0    0      to.extra_clause_field = ca.extra_clause_field; // NOTE: this is important to keep (or lose) the extra fields.
          .    .    .           .         .      .         .       .    .      relocAll(to);
         27    0    0           0         0      0         9       0    0      Solver::relocAll(to);
         18    0    0           9         9      1         0       0    0      if (verbosity >= 2)
          .    .    .           .         .      .         .       .    .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
          .    .    .           .         .      .         .       .    .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
          .    .    .           .         .      .         .       .    .      to.moveTo(ca);
         96   11   10          36         4      2        27       0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alg.h
--------------------------------------------------------------------------------
Ir         I1mr  ILmr Dr         D1mr    DLmr  Dw        D1mw DLmw 

-- line 30 ----------------------------------------
         .     .    .          .       .     .         .    .    .  
         .     .    .          .       .     .         .    .    .  //=================================================================================================
         .     .    .          .       .     .         .    .    .  // Removing and searching for elements:
         .     .    .          .       .     .         .    .    .  //
         .     .    .          .       .     .         .    .    .  
         .     .    .          .       .     .         .    .    .  template<class V, class T>
         .     .    .          .       .     .         .    .    .  static inline void remove(V& ts, const T& t)
         .     .    .          .       .     .         .    .    .  {
    42,249    22    3          0       0     0         0    0    0      int j = 0;
27,585,930   387   13  4,744,851 385,172 3,648         0    0    0      for (; j < ts.size() && ts[j] != t; j++);
         .     .    .          .       .     .         .    .    .      assert(j < ts.size());
10,410,558 2,043    6  2,845,855  92,375   185 1,399,953    0    0      for (; j < ts.size()-1; j++) ts[j] = ts[j+1];
         .     .    .          .       .     .         .    .    .      ts.pop();
         .     .    .          .       .     .         .    .    .  }
         .     .    .          .       .     .         .    .    .  
         .     .    .          .       .     .         .    .    .  
         .     .    .          .       .     .         .    .    .  template<class V, class T>
         .     .    .          .       .     .         .    .    .  static inline bool find(V& ts, const T& t)
         .     .    .          .       .     .         .    .    .  {
         .     .    .          .       .     .         .    .    .      int j = 0;
58,571,490     1    1 11,057,985 553,339     0         0    0    0      for (; j < ts.size() && ts[j] != t; j++);
         .     .    .          .       .     .         .    .    .      return j < ts.size();
         .     .    .          .       .     .         .    .    .  }
         .     .    .          .       .     .         .    .    .  
         .     .    .          .       .     .         .    .    .  
         .     .    .          .       .     .         .    .    .  //=================================================================================================
         .     .    .          .       .     .         .    .    .  // Copying vectors with support for nested vector types:
         .     .    .          .       .     .         .    .    .  //
         .     .    .          .       .     .         .    .    .  
-- line 58 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/8/cmath
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr         D1mr    DLmr Dw         D1mw    DLmw 

-- line 410 ----------------------------------------
         .    .    .          .       .    .          .       .    .  #endif
         .    .    .          .       .    .          .       .    .  
         .    .    .          .       .    .          .       .    .    template<typename _Tp, typename _Up>
         .    .    .          .       .    .          .       .    .      inline _GLIBCXX_CONSTEXPR
         .    .    .          .       .    .          .       .    .      typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
         .    .    .          .       .    .          .       .    .      pow(_Tp __x, _Up __y)
         .    .    .          .       .    .          .       .    .      {
         .    .    .          .       .    .          .       .    .        typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
92,756,849    5    3 13,454,763 120,985    1 38,749,656 135,382    0        return pow(__type(__x), __type(__y));
         .    .    .          .       .    .          .       .    .      }
         .    .    .          .       .    .          .       .    .  
         .    .    .          .       .    .          .       .    .    using ::sin;
         .    .    .          .       .    .          .       .    .  
         .    .    .          .       .    .          .       .    .  #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
         .    .    .          .       .    .          .       .    .    inline _GLIBCXX_CONSTEXPR float
         .    .    .          .       .    .          .       .    .    sin(float __x)
         .    .    .          .       .    .          .       .    .    { return __builtin_sinf(__x); }
-- line 426 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr       DLmr   Dw         D1mw  DLmw 

-- line 77 ----------------------------------------
          .    .    .           .          .      .          .     .    .  private:
          .    .    .           .          .      .          .     .    .      template<typename T>
          .    .    .           .          .      .          .     .    .      class MyQueue {
          .    .    .           .          .      .          .     .    .          int max_sz, q_sz;
          .    .    .           .          .      .          .     .    .          int ptr;
          .    .    .           .          .      .          .     .    .          int64_t sum;
          .    .    .           .          .      .          .     .    .          vec<T> q;
          .    .    .           .          .      .          .     .    .      public:
          4    1    1           0          0      0          3     0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
          .    .    .           .          .      .          .     .    .          inline bool   full () const { return q_sz == max_sz; }
          .    .    .           .          .      .          .     .    .  #ifdef INT_QUEUE_AVG
     14,924   50    1       3,731          0      0          0     0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
          .    .    .           .          .      .          .     .    .  #else
          .    .    .           .          .      .          .     .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
          .    .    .           .          .      .          .     .    .  #endif
        444   12    5           0          0      0        444    92    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
          .    .    .           .          .      .          .     .    .          void push(T e) {
     62,330    0    0      28,665          0      0      2,500     0    0              if (q_sz < max_sz) q_sz++;
     21,165    4    1       7,055      7,048      0          0     0    0              else sum -= q[ptr];
     28,665    6    1           0          0      0      9,555     0    0              sum += e;
     28,665    0    0           0          0      0     19,110 2,498    3              q[ptr++] = e;
     28,836    0    0      19,110          0      0        171     0    0              if (ptr == max_sz) ptr = 0;
          .    .    .           .          .      .          .     .    .          }
          .    .    .           .          .      .          .     .    .      };
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  public:
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .      // Constructor/Destructor:
          .    .    .           .          .      .          .     .    .      //
          .    .    .           .          .      .          .     .    .      Solver();
          .    .    .           .          .      .          .     .    .      virtual ~Solver();
         10    2    2           0          0      0          4     0    0      void print_size(std::ostream &os)
          .    .    .           .          .      .          .     .    .      {
          4    2    2           0          0      0          4     1    0          program_end_time=std::chrono::steady_clock::now();
          2    0    0           0          0      0          2     0    0          total_work_time=program_end_time-program_start_time;
          4    0    0           2          1      0          0     0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
          2    0    0           2          2      0          0     0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
          4    0    0           2          1      0          0     0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
          4    0    0           2          1      0          0     0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
          4    0    0           2          0      0          0     0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
          4    0    0           2          2      0          0     0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
          .    .    .           .          .      .          .     .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
          .    .    .           .          .      .          .     .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
          2    0    0           2          2      0          0     0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
          2    0    0           2          0      0          0     0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
          2    0    0           2          0      0          0     0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
          4    0    0           2          2      0          0     0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
          4    0    0           2          0      0          0     0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
          4    0    0           2          0      0          0     0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
          4    0    0           2          2      0          0     0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
          .    .    .           .          .      .          .     .    .          os << "total_Watchers: " << total_Watchers << "\n";
          .    .    .           .          .      .          .     .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
          .    .    .           .          .      .          .     .    .          os << "total_indexs: " << total_indexs << "\n";
          .    .    .           .          .      .          .     .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
          .    .    .           .          .      .          .     .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
          .    .    .           .          .      .          .     .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
          .    .    .           .          .      .          .     .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
          .    .    .           .          .      .          .     .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
          .    .    .           .          .      .          .     .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
          .    .    .           .          .      .          .     .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
          .    .    .           .          .      .          .     .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
          .    .    .           .          .      .          .     .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
          .    .    .           .          .      .          .     .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
          .    .    .           .          .      .          .     .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
          .    .    .           .          .      .          .     .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
          .    .    .           .          .      .          .     .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
          6    0    0           4          0      0          0     0    0      }
          .    .    .           .          .      .          .     .    .      using ull=unsigned long long;
          .    .    .           .          .      .          .     .    .      ull total_Watchers = 0;
          .    .    .           .          .      .          .     .    .      ull total_act_watchers = 0;
          .    .    .           .          .      .          .     .    .      ull total_indexs = 0;
          .    .    .           .          .      .          .     .    .      ull time_find_conflict = 0;
          .    .    .           .          .      .          .     .    .      ull total_find_conflict_length = 0;
          .    .    .           .          .      .          .     .    .      ull total_find_conflict_allsize = 0;
          .    .    .           .          .      .          .     .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
          .    .    .           .          .      .          .     .    .      {
          .    .    .           .          .      .          .     .    .          const ClauseAllocator& ca;
          .    .    .           .          .      .          .     .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
          .    .    .           .          .      .          .     .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
          .    .    .           .          .      .          .     .    .      };
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .      struct VarOrderLt {
          .    .    .           .          .      .          .     .    .          const vec<double>&  activity;
269,545,637  207   13 159,324,229 34,483,294 27,248    206,764     0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
          .    .    .           .          .      .          .     .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
          .    .    .           .          .      .          .     .    .      };
          .    .    .           .          .      .          .     .    .      
          .    .    .           .          .      .          .     .    .      struct ConflictData
          .    .    .           .          .      .          .     .    .  	{
          .    .    .           .          .      .          .     .    .  		ConflictData() :
          .    .    .           .          .      .          .     .    .  			nHighestLevel(-1),
          .    .    .           .          .      .          .     .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
          .    .    .           .          .      .          .     .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
          .    .    .           .          .      .          .     .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
          .    .    .           .          .      .          .     .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
          .    .    .           .          .      .          .     .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
          .    .    .           .          .      .          .     .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
          .    .    .           .          .      .          .     .    .      std::chrono::nanoseconds total_duration;
          .    .    .           .          .      .          .     .    .      CRef     propagate(){
          .    .    .           .          .      .          .     .    .  
  4,911,410  854   13           0          0      0  2,455,705     1    0          auto start_time=std::chrono::steady_clock::now();
  7,367,115    0    0           0          0      0  2,455,705     0    0          auto ref= propagate_();
  2,455,705    0    0           0          0      0  2,455,705     0    0          auto end_time=std::chrono::steady_clock::now();
          .    .    .           .          .      .          .     .    .          auto duration=end_time-start_time;
          .    .    .           .          .      .          .     .    .          total_duration+=duration;
          .    .    .           .          .      .          .     .    .          return ref;
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .      }
          .    .    .           .          .      .          .     .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
          .    .    .           .          .      .          .     .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
          .    .    .           .          .      .          .     .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
          .    .    .           .          .      .          .     .    .      
          .    .    .           .          .      .          .     .    .  public:
          .    .    .           .          .      .          .     .    .      int      level            (Var x) const;
          .    .    .           .          .      .          .     .    .  protected:
          .    .    .           .          .      .          .     .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
          .    .    .           .          .      .          .     .    .      bool     withinBudget     ()      const;
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .      template<class V> int computeLBD(const V& c) {
 10,001,996    8    4           0          0      0          0     0    0          int lbd = 0;
          .    .    .           .          .      .          .     .    .  
    683,595   11    6     618,727    131,241      2          0     0    0          counter++;
 80,000,531    0    0      65,434          0      0          0     0    0          for (int i = 0; i < c.size(); i++){
          .    .    .           .          .      .          .     .    .              int l = level(var(c[i]));
195,657,263    0    0  78,259,918  9,083,466    893          0     0    0              if (l != 0 && seen2[l] != counter){
 20,560,720    0    0           0          0      0 20,560,720     0    0                  seen2[l] = counter;
 28,851,069    0    0           0          0      0          0     0    0                  lbd++; } }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .          return lbd;
          .    .    .           .          .      .          .     .    .      }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  #ifdef BIN_DRUP
          .    .    .           .          .      .          .     .    .      static int buf_len;
          .    .    .           .          .      .          .     .    .      static unsigned char drup_buf[];
          .    .    .           .          .      .          .     .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
          .    .    .           .          .      .          .     .    .      }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .      template<class V>
          .    .    .           .          .      .          .     .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
          .    .    .           .          .      .          .     .    .          assert(op == 'a' || op == 'd');
          .    .    .           .          .      .          .     .    .          *buf_ptr++ = op; buf_len++;
          .    .    .           .          .      .          .     .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
          .    .    .           .          .      .          .     .    .          *buf_ptr++ = 0; buf_len++;
     12,687    8    4           0          0      0     12,687     0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
          .    .    .           .          .      .          .     .    .      }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
          .    .    .           .          .      .          .     .    .          *buf_ptr++ = 'a'; buf_len++;
          .    .    .           .          .      .          .     .    .          for (int i = 0; i < c.size(); i++)
          .    .    .           .          .      .          .     .    .              if (c[i] != l) byteDRUP(c[i]);
          .    .    .           .          .      .          .     .    .          *buf_ptr++ = 0; buf_len++;
          .    .    .           .          .      .          .     .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
          .    .    .           .          .      .          .     .    .      double    my_var_decay;
          .    .    .           .          .      .          .     .    .      bool   DISTANCE;
          .    .    .           .          .      .          .     .    .  };
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  //=================================================================================================
          .    .    .           .          .      .          .     .    .  // Implementation of inline methods:
          .    .    .           .          .      .          .     .    .  
 39,243,017    0    0  39,243,017  5,493,303  6,818          0     0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
210,400,515   21    6 180,523,774 55,157,713  1,791 28,592,123     0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  inline void Solver::insertVarOrder(Var x) {
          .    .    .           .          .      .          .     .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
103,759,086  457    2  34,586,362     45,003      0          0     0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
 10,470,390    1    1   6,980,260  2,826,805  1,136          0     0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  inline void Solver::varDecayActivity() {
     38,220    0    0      19,110         13      0      9,555     0    0      var_inc *= (1 / var_decay); }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  inline void Solver::varBumpActivity(Var v, double mult) {
  2,245,549    7    2   1,380,044    264,564      4    328,794     0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
          .    .    .           .          .      .          .     .    .          // Rescale:
         92    9    2           1          0      0          0     0    0          for (int i = 0; i < nVars(); i++)
    591,336    0    0     147,834     36,843    113    147,834     0    0              activity_VSIDS[i] *= 1e-100;
         18    0    0           9          9      0          9     0    0          var_inc *= 1e-100; }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .      // Update order_heap with respect to new activity:
    241,754    0    0           0          0      0          0     0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
          .    .    .           .          .      .          .     .    .  
    259,472  175    3     129,736      1,082      0     64,868     0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
          .    .    .           .          .      .          .     .    .  inline void Solver::claBumpActivity (Clause& c) {
  3,444,612  164    9   1,031,516    235,773     21    345,395    12    0      if ( (c.activity() += cla_inc) > 1e20 ) {
          .    .    .           .          .      .          .     .    .          // Rescale:
     66,038    1    1           3          0      0          0     0    0          for (int i = 0; i < learnts_local.size(); i++)
    154,070    1    0      22,010     20,141  2,376     22,010     0    0              ca[learnts_local[i]].activity() *= 1e-20;
      9,341    3    3       4,669          0      0          1     1    0          cla_inc *= 1e-20; } }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
          .    .    .           .          .      .          .     .    .  inline void Solver::checkGarbage(double gf){
    886,824    7    0     295,608         37      1          0     0    0      if (ca.wasted() > ca.size() * gf)
         27    3    2          16         16      5          5     3    0          garbageCollect(); }
          .    .    .           .          .      .          .     .    .  
          .    .    .           .          .      .          .     .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
          .    .    .           .          .      .          .     .    .  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
          .    .    .           .          .      .          .     .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
          .    .    .           .          .      .          .     .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
          .    .    .           .          .      .          .     .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
          .    .    .           .          .      .          .     .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
          .    .    .           .          .      .          .     .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
          .    .    .           .          .      .          .     .    .  inline bool     Solver::locked          (const Clause& c) const {
  1,591,229    4    4     397,841      4,774      0          0     0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
  1,054,790   10    9     361,220     35,810     74          0     0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
          .    .    .           .          .      .          .     .    .  }
  4,778,304    1    1   2,389,143          0      0          0     0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
          .    .    .           .          .      .          .     .    .  
    629,385    1    1     319,581          0      0    309,804     0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
 81,974,933   87    3  10,404,780  6,242,914      0          0     0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
  4,063,263    1    1   4,063,247      5,920      1          0     0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
238,048,962   11    7 238,048,962      1,069      0          0     0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
          .    .    .           .          .      .          .     .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
          .    .    .           .          .      .          .     .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
          .    .    .           .          .      .          .     .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
          7    0    0           4          0      0          1     0    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
          .    .    .           .          .      .          .     .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
    890,085    1    1     230,011        121      0          3     0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
         30    2    2          15         10      0          0     0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
          .    .    .           .          .      .          .     .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
          .    .    .           .          .      .          .     .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
          .    .    .           .          .      .          .     .    .  { 
    197,112    0    0      98,556        170      0          0     0    0      if      ( b && !decision[v]) dec_vars++;
     45,447    0    0      30,298     12,536     94          0     0    0      else if (!b &&  decision[v]) dec_vars--;
          .    .    .           .          .      .          .     .    .  
     48,001    0    0           0          0      0     48,001     0    0      decision[v] = b;
          .    .    .           .          .      .          .     .    .      if (b && !order_heap_CHB.inHeap(v)){
          .    .    .           .          .      .          .     .    .          order_heap_CHB.insert(v);
          .    .    .           .          .      .          .     .    .          order_heap_VSIDS.insert(v);
          .    .    .           .          .      .          .     .    .          order_heap_distance.insert(v);}
          .    .    .           .          .      .          .     .    .  }
          .    .    .           .          .      .          .     .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
          .    .    .           .          .      .          .     .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
          .    .    .           .          .      .          .     .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir            I1mr   ILmr Dr          D1mr       DLmr   Dw          D1mw       DLmw  

-- line 51 ----------------------------------------
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  //=================================================================================================
            .      .    .           .          .      .           .          .     .  // Options:
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  static const char* _cat = "CORE";
            .      .    .           .          .      .           .          .     .  
            4      0    0           0          0      0           1          0     0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
            4      0    0           0          0      0           1          0     0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
            4      0    0           0          0      0           1          0     0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
            4      1    1           0          0      0           1          0     0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
            4      0    0           0          0      0           1          0     0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
            4      0    0           0          0      0           1          0     0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
            4      0    0           0          0      0           1          0     0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
            4      0    0           0          0      0           1          0     0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
            4      0    0           0          0      0           1          0     0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
            4      1    1           0          0      0           1          0     0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
            4      0    0           0          0      0           1          0     0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
            4      1    1           0          0      0           1          0     0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
            4      1    1           0          0      0           1          0     0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
            4      1    1           0          0      0           1          0     0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
            4      1    1           0          0      0           1          0     0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
            .      .    .           .          .      .           .          .     .  
            4      1    1           0          0      0           1          0     0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
            1      1    1           0          0      0           1          0     0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
            4      0    0           0          0      0           1          0     0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
            .      .    .           .          .      .           .          .     .  
            4      1    1           0          0      0           1          0     0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  //VSIDS_props_limit
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  //=================================================================================================
            .      .    .           .          .      .           .          .     .  // Constructor/Destructor:
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            4      1    1           0          0      0           2          0     0  Solver::Solver() :
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Parameters (user settable):
            .      .    .           .          .      .           .          .     .      //
            .      .    .           .          .      .           .          .     .      drup_file        (NULL)
            .      .    .           .          .      .           .          .     .    , verbosity        (0)
            .      .    .           .          .      .           .          .     .    , step_size        (opt_step_size)
            .      .    .           .          .      .           .          .     .    , step_size_dec    (opt_step_size_dec)
            .      .    .           .          .      .           .          .     .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
            .      .    .           .          .      .           .          .     .    , garbage_frac     (opt_garbage_frac)
            .      .    .           .          .      .           .          .     .    , restart_first    (opt_restart_first)
            .      .    .           .          .      .           .          .     .    , restart_inc      (opt_restart_inc)
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .    , min_number_of_learnts_copies(opt_min_dupl_app)  
            .      .    .           .          .      .           .          .     .    , max_lbd_dup(opt_max_lbd_dup)
            .      .    .           .          .      .           .          .     .    , dupl_db_init_size(opt_dupl_db_init_size)
            3      1    1           1          0      0           1          0     0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .    // Parameters (the rest):
            .      .    .           .          .      .           .          .     .    //
            .      .    .           .          .      .           .          .     .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .    // Parameters (experimental):
            .      .    .           .          .      .           .          .     .    //
            .      .    .           .          .      .           .          .     .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
            .      .    .           .          .      .           .          .     .    //
            .      .    .           .          .      .           .          .     .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
            .      .    .           .          .      .           .          .     .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
            .      .    .           .          .      .           .          .     .    , chrono_backtrack(0), non_chrono_backtrack(0)
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .    , ok                 (true)
            .      .    .           .          .      .           .          .     .    , cla_inc            (1)
            .      .    .           .          .      .           .          .     .    , var_inc            (1)
            1      0    0           0          0      0           0          0     0    , watches_bin        (WatcherDeleted(ca))
            .      .    .           .          .      .           .          .     .    , watches            (WatcherDeleted(ca))
            .      .    .           .          .      .           .          .     .    , qhead              (0)
            .      .    .           .          .      .           .          .     .    , simpDB_assigns     (-1)
            .      .    .           .          .      .           .          .     .    , simpDB_props       (0)
            .      .    .           .          .      .           .          .     .    , order_heap_CHB     (VarOrderLt(activity_CHB))
            .      .    .           .          .      .           .          .     .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
            .      .    .           .          .      .           .          .     .    , progress_estimate  (0)
            .      .    .           .          .      .           .          .     .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
            .      .    .           .          .      .           .          .     .    // simplifyAll adjust occasion
            .      .    .           .          .      .           .          .     .    , curSimplify(1)
            .      .    .           .          .      .           .          .     .    , nbconfbeforesimplify(1000)
            .      .    .           .          .      .           .          .     .    , incSimplify(1000)
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .    , my_var_decay       (0.6)
            .      .    .           .          .      .           .          .     .    , DISTANCE           (true)
            .      .    .           .          .      .           .          .     .    , var_iLevel_inc     (1)
           94      8    8          25          2      2          63          1     0    , order_heap_distance(VarOrderLt(activity_distance))
            .      .    .           .          .      .           .          .     .  
            4      0    0           3          0      0           0          0     0  {}
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  Solver::~Solver()
            .      .    .           .          .      .           .          .     .  {
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  // simplify All
            .      .    .           .          .      .           .          .     .  //
            .      .    .           .          .      .           .          .     .  CRef Solver::simplePropagate()
    1,027,416      0    0           0          0      0     770,562        113     0  {
      128,427      0    0           0          0      0     128,427          0     0      CRef    confl = CRef_Undef;
      128,427      0    0           0          0      0     128,427          0     0      int     num_props = 0;
      256,854      0    0           0          0      0     128,427        596     0      watches.cleanAll();
      385,281      8    4     128,427          0      0     128,427          0     0      watches_bin.cleanAll();
    9,616,098      0    0   4,808,049          0      0           0          0     0      while (qhead < trail.size())
            .      .    .           .          .      .           .          .     .      {
   23,401,495      1    1   9,360,598     52,691      0   9,360,598          0     0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
            .      .    .           .          .      .           .          .     .          vec<Watcher>&  ws = watches[p];
            .      .    .           .          .      .           .          .     .          Watcher        *i, *j, *end;
    4,679,622      0    0   4,679,622          0      0           0          0     0          num_props++;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          // First, Propagate binary clauses
            .      .    .           .          .      .           .          .     .          vec<Watcher>&  wbin = watches_bin[p];
            .      .    .           .          .      .           .          .     .  
   24,775,538      0    0   4,680,299  4,619,513  2,445           0          0     0          for (int k = 0; k<wbin.size(); k++)
            .      .    .           .          .      .           .          .     .          {
            .      .    .           .          .      .           .          .     .  
    5,749,432      0    0   3,931,383  1,243,658  2,034           0          0     0              Lit imp = wbin[k].blocker;
            .      .    .           .          .      .           .          .     .  
    5,749,432      0    0           0          0      0           0          0     0              if (value(imp) == l_False)
            .      .    .           .          .      .           .          .     .              {
        1,354      0    0         677          0      0         677          0     0                  return wbin[k].cref;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
    5,748,078      6    4           0          0      0           0          0     0              if (value(imp) == l_Undef)
            .      .    .           .          .      .           .          .     .              {
    1,645,449      0    0   1,645,449          0      0           0          0     0                  simpleUncheckEnqueue(imp, wbin[k].cref);
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
  100,325,253      6    3  36,500,257  4,321,487  1,484   8,622,085          0     0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
            .      .    .           .          .      .           .          .     .          {
            .      .    .           .          .      .           .          .     .              // Try to avoid inspecting the clause:
   27,141,013      8    4  27,141,013  6,222,090  7,482           0          0     0              Lit blocker = i->blocker;
   54,282,026      0    0  27,141,013  3,128,477      0           0          0     0              if (value(blocker) == l_True)
            .      .    .           .          .      .           .          .     .              {
            .      .    .           .          .      .           .          .     .                  *j++ = *i++; continue;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Make sure the false literal is data[1]:
   23,846,108      0    0  11,923,054          0      0           0          0     0              CRef     cr = i->cref;
            .      .    .           .          .      .           .          .     .              Clause&  c = ca[cr];
            .      .    .           .          .      .           .          .     .              Lit      false_lit = ~p;
   35,769,162      0    0  11,923,054  9,495,969  3,325           0          0     0              if (c[0] == false_lit)
    8,432,028      0    0   2,810,676    130,054     85   5,621,352          0     0                  c[0] = c[1], c[1] = false_lit;
            .      .    .           .          .      .           .          .     .              assert(c[1] == false_lit);
            .      .    .           .          .      .           .          .     .              //  i++;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // If 0th watch is true, then clause is already satisfied.
            .      .    .           .          .      .           .          .     .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
            .      .    .           .          .      .           .          .     .              // why not simply do i->blocker=first in this case?
            .      .    .           .          .      .           .          .     .              Lit     first = c[0];
            .      .    .           .          .      .           .          .     .              //  Watcher w     = Watcher(cr, first);
   27,302,714      0    0   1,728,303    172,134      0           0          0     0              if (first != blocker && value(first) == l_True)
            .      .    .           .          .      .           .          .     .              {
      526,017      0    0           0          0      0     526,017          0     0                  i->blocker = first;
   62,975,904      0    0  15,743,976          0      0  15,743,976        558     0                  *j++ = *i++; continue;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Look for new watch:
            .      .    .           .          .      .           .          .     .              //if (incremental)
            .      .    .           .          .      .           .          .     .              //{ // ----------------- INCREMENTAL MODE
            .      .    .           .          .      .           .          .     .              //	int choosenPos = -1;
            .      .    .           .          .      .           .          .     .              //	for (int k = 2; k < c.size(); k++)
            .      .    .           .          .      .           .          .     .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
            .      .    .           .          .      .           .          .     .              //		Watcher w = Watcher(cr, first); i++;
            .      .    .           .          .      .           .          .     .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
            .      .    .           .          .      .           .          .     .              //		watches[~c[1]].push(w);
            .      .    .           .          .      .           .          .     .              //		goto NextClause;
            .      .    .           .          .      .           .          .     .              //	}
            .      .    .           .          .      .           .          .     .              //}
            .      .    .           .          .      .           .          .     .              else
            .      .    .           .          .      .           .          .     .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
   46,769,459      8    4           0          0      0           0          0     0                  for (int k = 2; k < c.size(); k++)
            .      .    .           .          .      .           .          .     .                  {
            .      .    .           .          .      .           .          .     .  
   64,047,210      0    0           0          0      0           0          0     0                      if (value(c[k]) != l_False)
            .      .    .           .          .      .           .          .     .                      {
            .      .    .           .          .      .           .          .     .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
            .      .    .           .          .      .           .          .     .                          // the blocker is first in the watcher. However,
            .      .    .           .          .      .           .          .     .                          // the blocker in the corresponding watcher in ~first is not c[1]
            .      .    .           .          .      .           .          .     .                          Watcher w = Watcher(cr, first); i++;
   33,203,600      0    0   8,300,900          0      0  16,601,800          0     0                          c[1] = c[k]; c[k] = false_lit;
            .      .    .           .          .      .           .          .     .                          watches[~c[1]].push(w);
    8,300,900      0    0           0          0      0           0          0     0                          goto NextClause;
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Did not find watch -- clause is unit under assignment:
    3,096,137      0    0           0          0      0   3,096,137          0     0              i->blocker = first;
   12,384,548      1    0   3,096,137          0      0   3,096,137         61     0              *j++ = *i++;
    6,192,274      8    4           0          0      0           0          0     0              if (value(first) == l_False)
            .      .    .           .          .      .           .          .     .              {
       64,661      1    1           0          0      0      11,403          0     0                  confl = cr;
       22,806      7    4      11,403          3      0      11,403          0     0                  qhead = trail.size();
            .      .    .           .          .      .           .          .     .                  // Copy the remaining watches:
      258,076      0    0      19,774          1      0           0          0     0                  while (i < end)
       97,861      0    0      97,861     10,747     99      97,861          0     0                      *j++ = *i++;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              else
            .      .    .           .          .      .           .          .     .              {
            .      .    .           .          .      .           .          .     .                  simpleUncheckEnqueue(first, cr);
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  NextClause:;
            .      .    .           .          .      .           .          .     .          }
    7,884,926      8    4           0          0      0           0          0     0          ws.shrink(i - j);
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
      255,500      0    0     255,500     17,874      0           0          0     0      s_propagations += num_props;
            .      .    .           .          .      .           .          .     .  
      127,750      0    0     127,750          0      0           0          0     0      return confl;
    7,715,677      9    4     898,989     17,984      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
            .      .    .           .          .      .           .          .     .      assert(value(p) == l_Undef);
    4,730,183      0    0           0          0      0   4,730,183          0     0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
    9,717,220      8    4   4,858,610        235      0   4,858,610  4,441,706   245      vardata[var(p)].reason = from;
    3,213,161      0    0   3,213,161          0      0           0          0     0      trail.push_(p);
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::cancelUntilTrailRecord()
            .      .    .           .          .      .           .          .     .  {
    9,811,525      0    0      37,722          0      0           0          0     0      for (int c = trail.size() - 1; c >= trailRecord; c--)
            .      .    .           .          .      .           .          .     .      {
       18,861      8    4      18,861          0      0           0          0     0          Var x = var(trail[c]);
    4,915,193      0    0      18,861         50      0   4,858,610  1,024,386     0          assigns[x] = l_Undef;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      }
       18,861      0    0           0          0      0      18,861        648     0      qhead = trailRecord;
       37,722      0    0           0          0      0           0          0     0      trail.shrink(trail.size() - trailRecord);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::litsEnqueue(int cutP, Clause& c)
            .      .    .           .          .      .           .          .     .  {
            .      .    .           .          .      .           .          .     .      for (int i = cutP; i < c.size(); i++)
            .      .    .           .          .      .           .          .     .      {
            .      .    .           .          .      .           .          .     .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  bool Solver::removed(CRef cr) {
            .      .    .           .          .      .           .          .     .      return ca[cr].mark() == 1;
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
      207,405      8    4           0          0      0     113,130          0     0  {
       18,855      0    0           0          0      0           0          0     0      int pathC = 0;
       18,855      0    0           0          0      0           0          0     0      Lit p = lit_Undef;
       56,565      0    0      18,855          0      0           0          0     0      int index = trail.size() - 1;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      do{
      798,520      8    4           0          0      0           0          0     0          if (confl != CRef_Undef){
            .      .    .           .          .      .           .          .     .              reason_clause.push(confl);
            .      .    .           .          .      .           .          .     .              Clause& c = ca[confl];
            .      .    .           .          .      .           .          .     .              // Special case for binary clauses
            .      .    .           .          .      .           .          .     .              // The first one has to be SAT
    1,215,086      8    4           0          0      0           0          0     0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                  assert(value(c[1]) == l_True);
            .      .    .           .          .      .           .          .     .                  Lit tmp = c[0];
       31,989      0    0      10,663        519      2      21,326          0     0                  c[0] = c[1], c[1] = tmp;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              // if True_confl==true, then choose p begin with the 1th index of c;
    2,618,174      0    0     536,368     14,031      0           0          0     0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
            .      .    .           .          .      .           .          .     .                  Lit q = c[j];
    1,529,890      0    0     764,945    149,126      4           0          0     0                  if (!seen[var(q)]){
      381,890      0    0           0          0      0     381,890          0     0                      seen[var(q)] = 1;
    1,145,670      0    0     381,890          0      0           0          0     0                      pathC++;
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          else if (confl == CRef_Undef){
            .      .    .           .          .      .           .          .     .              out_learnt.push(~p);
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
    1,317,514      8    4     380,977          1      0           0          0     0          if (pathC == 0) break;
            .      .    .           .          .      .           .          .     .          // Select next clause to look at:
   30,355,831      0    0  10,118,801  1,684,383      9           0          0     0          while (!seen[var(trail[index--])]);
            .      .    .           .          .      .           .          .     .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
            .      .    .           .          .      .           .          .     .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
      761,954      0    0     380,977         76      0           0          0     0          if (trailRecord > index + 1) break;
            .      .    .           .          .      .           .          .     .          p = trail[index + 1];
            .      .    .           .          .      .           .          .     .          confl = reason(var(p));
      380,405      0    0           0          0      0     380,405          0     0          seen[var(p)] = 0;
      380,405      0    0           0          0      0           0          0     0          pathC--;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      } while (pathC >= 0);
      188,550      8    4     131,985      1,787      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::simplifyLearnt(Clause& c)
      169,749     16    8           0          0      0     113,166          8     0  {
            .      .    .           .          .      .           .          .     .      ////
       18,861      0    0      18,861         16      0           0          0     0      original_length_record += c.size();
            .      .    .           .          .      .           .          .     .  
       37,722      0    0      18,861         14      0      18,861          0     0      trailRecord = trail.size();// record the start pointer
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      vec<Lit> falseLit;
            .      .    .           .          .      .           .          .     .      falseLit.clear();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
            .      .    .           .          .      .           .          .     .  
       24,160      7    3           0          0      0           0          0     0      bool True_confl = false;
            .      .    .           .          .      .           .          .     .      int beforeSize, afterSize;
            .      .    .           .          .      .           .          .     .      beforeSize = c.size();
            .      .    .           .          .      .           .          .     .      int i, j;
            .      .    .           .          .      .           .          .     .      CRef confl;
            .      .    .           .          .      .           .          .     .  
      490,713      8    4           0          0      0           0          0     0      for (i = 0, j = 0; i < c.size(); i++){
      289,408      0    0           0          0      0           0          0     0          if (value(c[i]) == l_Undef){
            .      .    .           .          .      .           .          .     .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
            .      .    .           .          .      .           .          .     .              simpleUncheckEnqueue(~c[i]);
      501,628      0    0     128,427          0      0     128,427        158     0              c[j++] = c[i];
      385,281      0    0           0          0      0     128,427          0     0              confl = simplePropagate();
      385,281      8    4     128,427     18,616      0           0          0     0              if (confl != CRef_Undef){
            .      .    .           .          .      .           .          .     .                  break;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          else{
       32,554      0    0           0          0      0           0          0     0              if (value(c[i]) == l_True){
            .      .    .           .          .      .           .          .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
       27,100      7    3       6,775          0      0       6,775         29     0                  c[j++] = c[i];
        6,775      3    2           0          0      0           0          0     0                  True_confl = true;
            .      .    .           .          .      .           .          .     .                  confl = reason(var(c[i]));
            .      .    .           .          .      .           .          .     .                  break;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              else{
            .      .    .           .          .      .           .          .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
            .      .    .           .          .      .           .          .     .                  falseLit.push(c[i]);
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .      c.shrink(c.size() - j);
            .      .    .           .          .      .           .          .     .      afterSize = c.size();
            .      .    .           .          .      .           .          .     .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      if (confl != CRef_Undef || True_confl == true){
       18,855      0    0           0          0      0           0          0     0          simp_learnt_clause.clear();
       18,855      0    0           0          0      0           0          0     0          simp_reason_clause.clear();
       37,710      0    0           0          0      0           0          0     0          if (True_confl == true){
            .      .    .           .          .      .           .          .     .              simp_learnt_clause.push(c.last());
            .      .    .           .          .      .           .          .     .          }
      131,985      5    2           0          0      0      18,855          0     0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
            .      .    .           .          .      .           .          .     .  
       56,565      0    0      18,855          0      0           0          0     0          if (simp_learnt_clause.size() < c.size()){
       65,968      8    4      27,322          0      0           0          0     0              for (i = 0; i < simp_learnt_clause.size(); i++){
       97,964      0    0      24,491         22      0      24,491        337     0                  c[i] = simp_learnt_clause[i];
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              c.shrink(c.size() - i);
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      cancelUntilTrailRecord();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      ////
       18,861      0    0      18,861        464      0           0          0     0      simplified_length_record += c.size();
            .      .    .           .          .      .           .          .     .  
      150,888      0    0     132,027     13,480      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
            .      .    .           .          .      .           .          .     .  {
            .      .    .           .          .      .           .          .     .      int beforeSize, afterSize;
            .      .    .           .          .      .           .          .     .      int learnts_x_size_before = learnts_x.size();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      int ci, cj, li, lj;
            .      .    .           .          .      .           .          .     .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
            .      .    .           .          .      .           .          .     .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      return true;
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  bool Solver::simplifyLearnt_core()
           88      0    0           0          0      0          48          0     0  {
            .      .    .           .          .      .           .          .     .      int beforeSize, afterSize;
            .      .    .           .          .      .           .          .     .      int learnts_core_size_before = learnts_core.size();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      int ci, cj, li, lj;
            .      .    .           .          .      .           .          .     .      bool sat, false_lit;
            .      .    .           .          .      .           .          .     .      unsigned int nblevels;
            .      .    .           .          .      .           .          .     .      ////
            .      .    .           .          .      .           .          .     .      //printf("learnts_x size : %d\n", learnts_x.size());
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      ////
            .      .    .           .          .      .           .          .     .      int nbSimplified = 0;
            .      .    .           .          .      .           .          .     .      int nbSimplifing = 0;
            .      .    .           .          .      .           .          .     .  
       54,686      8    4           8          0      0           0          0     0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
       81,984      8    4      54,656      1,744      0           0          0     0          CRef cr = learnts_core[ci];
            .      .    .           .          .      .           .          .     .          Clause& c = ca[cr];
            .      .    .           .          .      .           .          .     .  
       54,656      0    0           0          0      0           0          0     0          if (removed(cr)) continue;
       54,656      0    0      27,328      3,148    117           0          0     0          else if (c.simplified()){
       42,084      0    0           0          0      0      21,042          8     0              learnts_core[cj++] = learnts_core[ci];
            .      .    .           .          .      .           .          .     .              ////
       63,430      0    0      21,042          0      0           0          0     0              nbSimplified++;
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          else{
            .      .    .           .          .      .           .          .     .              int saved_size=c.size();
            .      .    .           .          .      .           .          .     .              //         if (drup_file){
            .      .    .           .          .      .           .          .     .              //                 add_oc.clear();
            .      .    .           .          .      .           .          .     .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
            .      .    .           .          .      .           .          .     .              ////
            .      .    .           .          .      .           .          .     .              nbSimplifing++;
        6,234      0    0           0          0      0           0          0     0              sat = false_lit = false;
       73,788      0    0           0          0      0           0          0     0              for (int i = 0; i < c.size(); i++){
       73,908      0    0           0          0      0           0          0     0                  if (value(c[i]) == l_True){
            .      .    .           .          .      .           .          .     .                      sat = true;
            .      .    .           .          .      .           .          .     .                      break;
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .                  else if (value(c[i]) == l_False){
       86,152      8    5           0          0      0       6,234         12     0                      false_lit = true;
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              if (sat){
          784      8    6         224          0      0         224          0     0                  removeClause(cr);
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              else{
       37,044      0    0           0          0      0      18,522          0     0                  detachClause(cr, true);
            .      .    .           .          .      .           .          .     .  
       24,696      8    4      12,348          0      0           0          0     0                  if (false_lit){
        2,369      0    0         234          0      0           0          0     0                      for (li = lj = 0; li < c.size(); li++){
        1,316      0    0           0          0      0           0          0     0                          if (value(c[li]) != l_False){
        1,314      0    0           0          0      0         438          0     0                              c[lj++] = c[li];
            .      .    .           .          .      .           .          .     .                          }
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                      c.shrink(li - lj);
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                  beforeSize = c.size();
            .      .    .           .          .      .           .          .     .                  assert(c.size() > 1);
            .      .    .           .          .      .           .          .     .                  // simplify a learnt clause c
       24,696      0    0           0          0      0      12,348          0     0                  simplifyLearnt(c);
            .      .    .           .          .      .           .          .     .                  assert(c.size() > 0);
            .      .    .           .          .      .           .          .     .                  afterSize = c.size();
            .      .    .           .          .      .           .          .     .                  
       28,568      0    0      18,522      7,256      0           0          0     0                  if(drup_file && saved_size !=c.size()){
            .      .    .           .          .      .           .          .     .  #ifdef BIN_DRUP
            .      .    .           .          .      .           .          .     .                      binDRUP('a', c , drup_file);
            .      .    .           .          .      .           .          .     .                      //                    binDRUP('d', add_oc, drup_file);
            .      .    .           .          .      .           .          .     .  #else
            .      .    .           .          .      .           .          .     .                      for (int i = 0; i < c.size(); i++)
            .      .    .           .          .      .           .          .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .           .          .      .           .          .     .                      fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
            .      .    .           .          .      .           .          .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
            .      .    .           .          .      .           .          .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
            .      .    .           .          .      .           .          .     .                      //                    fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
            .      .    .           .          .      .           .          .     .  
       12,348      0    0           0          0      0           0          0     0                  if (c.size() == 1){
            .      .    .           .          .      .           .          .     .                      // when unit clause occur, enqueue and propagate
          200      4    0          40          2      0          40          0     0                      uncheckedEnqueue(c[0]);
          120      0    0          40          0      0           0          0     0                      if (propagate() != CRef_Undef){
            .      .    .           .          .      .           .          .     .                          ok = false;
            .      .    .           .          .      .           .          .     .                          return false;
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                      // delete the clause memory in logic
            .      .    .           .          .      .           .          .     .                      c.mark(1);
            .      .    .           .          .      .           .          .     .                      ca.free(cr);
            .      .    .           .          .      .           .          .     .  //#ifdef BIN_DRUP
            .      .    .           .          .      .           .          .     .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
            .      .    .           .          .      .           .          .     .  //#else
            .      .    .           .          .      .           .          .     .  //                    fprintf(drup_file, "d ");
            .      .    .           .          .      .           .          .     .  //                    for (int i = 0; i < c.size(); i++)
            .      .    .           .          .      .           .          .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .           .          .      .           .          .     .  //                    fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  //#endif
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .                  else{
       18,402      0    0           0          0      0       6,134          0     0                      attachClause(cr);
       36,804      8    4      18,402      7,371      0       6,134      1,795     0                      learnts_core[cj++] = learnts_core[ci];
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                      nblevels = computeLBD(c);
       12,268      8    4           0          0      0           0          0     0                      if (nblevels < c.lbd()){
            .      .    .           .          .      .           .          .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
            .      .    .           .          .      .           .          .     .                          c.set_lbd(nblevels);
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                      c.setSimplified(true);
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            8      0    0           0          0      0           0          0     0      learnts_core.shrink(ci - cj);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
            .      .    .           .          .      .           .          .     .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
            .      .    .           .          .      .           .          .     .  
            8      1    1           0          0      0           0          0     0      return true;
            .      .    .           .          .      .           .          .     .  
           64      0    0          56          8      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
      360,108      2    2           0          0      0     240,072          0     0  int Solver::is_duplicate(std::vector<uint32_t>&c){
       80,024      0    0           0          0      0      80,024      5,277     0     auto time_point_0 = std::chrono::high_resolution_clock::now();
       40,012      0    0      40,012     18,532      1           0          0     0      dupl_db_size++;
      102,245    104    5      33,411          0      0           0          0     0      int res = 0;    
            .      .    .           .          .      .           .          .     .      
       80,024      0    0      80,024          0      0           0          0     0      int sz = c.size();
            .      .    .           .          .      .           .          .     .      std::vector<uint32_t> tmp(c);    
            .      .    .           .          .      .           .          .     .      sort(tmp.begin(),tmp.end());
            .      .    .           .          .      .           .          .     .      
       40,012 13,521    5           0          0      0      40,012          0     0      uint64_t hash = 0;    
            .      .    .           .          .      .           .          .     .      
    1,168,664    178    6           0          0      0      40,012          0     0      for (int i =0; i<sz; i++) {
    4,242,840      0    0     424,284          0      0           0          0     0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
            .      .    .           .          .      .           .          .     .      }    
            .      .    .           .          .      .           .          .     .      
       40,012      0    0           0          0      0      40,012          0     0      int32_t head = tmp[0];
            .      .    .           .          .      .           .          .     .      auto it0 = ht.find(head);
      182,307      0    0      40,005          0      0           0          0     0      if (it0 != ht.end()){
            .      .    .           .          .      .           .          .     .          auto it1=ht[head].find(sz);
       68,198      0    0           0          0      0           0          0     0          if (it1 != ht[head].end()){
       19,992      0    0           0          0      0      19,992          0     0              auto it2 = ht[head][sz].find(hash);
       59,976      0    0           0          0      0      19,992          0     0              if (it2 != ht[head][sz].end()){
       16,785      0    0       5,595        969     79       5,595          0     0                  it2->second++;
        5,595      0    0           0          0      0           0          0     0                  res = it2->second;            
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              else{
       14,397      0    0           0          0      0      14,397          0     0                  ht[head][sz][hash]=1;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          else{            
       28,214     10    1           0          0      0      14,107          0     0              ht[head][sz][hash]=1;
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }else{        
       40,330  2,793    5           0          0      0      40,330          0     0          ht[head][sz][hash]=1;
            .      .    .           .          .      .           .          .     .      } 
       40,012     45    3           0          0      0      40,012          0     0      auto time_point_1 = std::chrono::high_resolution_clock::now();
            .      .    .           .          .      .           .          .     .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
            .      .    .           .          .      .           .          .     .      return res;
      360,108      0    0     280,084          0      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  bool Solver::simplifyLearnt_tier2()
           88      8    4           0          0      0          48          0     0  {
            .      .    .           .          .      .           .          .     .      int beforeSize, afterSize;
            .      .    .           .          .      .           .          .     .      int learnts_tier2_size_before = learnts_tier2.size();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      int ci, cj, li, lj;
            .      .    .           .          .      .           .          .     .      bool sat, false_lit;
            .      .    .           .          .      .           .          .     .      unsigned int nblevels;
            .      .    .           .          .      .           .          .     .      ////
            .      .    .           .          .      .           .          .     .      //printf("learnts_x size : %d\n", learnts_x.size());
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      ////
            .      .    .           .          .      .           .          .     .      int nbSimplified = 0;
            .      .    .           .          .      .           .          .     .      int nbSimplifing = 0;
            .      .    .           .          .      .           .          .     .  
       61,718      8    3           8          8      0           0          0     0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
       92,541      0    0      61,694      1,957      0           0          0     0          CRef cr = learnts_tier2[ci];
            .      .    .           .          .      .           .          .     .          Clause& c = ca[cr];
            .      .    .           .          .      .           .          .     .  
       61,694      0    0           0          0      0           0          0     0          if (removed(cr)) continue;
       61,682      0    0      30,841      3,592      0           0          0     0          else if (c.simplified()){
       36,038      0    0           0          0      0      18,019         34     0              learnts_tier2[cj++] = learnts_tier2[ci];
            .      .    .           .          .      .           .          .     .              ////
       79,657      0    0      18,019          0      0           0          0     0              nbSimplified++;
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          else{
            .      .    .           .          .      .           .          .     .              int saved_size=c.size();
            .      .    .           .          .      .           .          .     .              //            if (drup_file){
            .      .    .           .          .      .           .          .     .              //                    add_oc.clear();
            .      .    .           .          .      .           .          .     .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
            .      .    .           .          .      .           .          .     .              ////
            .      .    .           .          .      .           .          .     .              nbSimplifing++;
       12,769      0    0           0          0      0           0          0     0              sat = false_lit = false;
      285,406      0    0           0          0      0           0          0     0              for (int i = 0; i < c.size(); i++){
      285,570      0    0           0          0      0           0          0     0                  if (value(c[i]) == l_True){
            .      .    .           .          .      .           .          .     .                      sat = true;
            .      .    .           .          .      .           .          .     .                      break;
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .                  else if (value(c[i]) == l_False){
      310,838      3    3           0          0      0      12,769          0     0                      false_lit = true;
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              if (sat){
          675      0    0         135          0      0         135          0     0                  removeClause(cr);
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              else{
       76,122      6    5           0          0      0      38,061          6     0                  detachClause(cr, true);
            .      .    .           .          .      .           .          .     .  
       50,748      0    0      25,374          0      0           0          0     0                  if (false_lit){
       19,683      6    4       1,438          0      0           0          0     0                      for (li = lj = 0; li < c.size(); li++){
       13,212      0    0           0          0      0           0          0     0                          if (value(c[li]) != l_False){
       15,759      0    0           0          0      0       5,253          0     0                              c[lj++] = c[li];
            .      .    .           .          .      .           .          .     .                          }
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                      c.shrink(li - lj);
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                  beforeSize = c.size();
            .      .    .           .          .      .           .          .     .                  assert(c.size() > 1);
            .      .    .           .          .      .           .          .     .                  // simplify a learnt clause c
       63,435      0    0           0          0      0      38,061          0     0                  simplifyLearnt(c);
            .      .    .           .          .      .           .          .     .                  assert(c.size() > 0);
            .      .    .           .          .      .           .          .     .                  afterSize = c.size();
            .      .    .           .          .      .           .          .     .                  
       50,748      8    4      25,374     20,030      0           0          0     0                  if(drup_file && saved_size!=c.size()){
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  #ifdef BIN_DRUP
            .      .    .           .          .      .           .          .     .                      binDRUP('a', c , drup_file);
            .      .    .           .          .      .           .          .     .                      //                    binDRUP('d', add_oc, drup_file);
            .      .    .           .          .      .           .          .     .  #else
            .      .    .           .          .      .           .          .     .                      for (int i = 0; i < c.size(); i++)
            .      .    .           .          .      .           .          .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .           .          .      .           .          .     .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
            .      .    .           .          .      .           .          .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
            .      .    .           .          .      .           .          .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
            .      .    .           .          .      .           .          .     .                      //                    fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
            .      .    .           .          .      .           .          .     .  
       25,374      0    0           0          0      0           0          0     0                  if (c.size() == 1){
            .      .    .           .          .      .           .          .     .                      // when unit clause occur, enqueue and propagate
          140      0    0          28          0      0          28          0     0                      uncheckedEnqueue(c[0]);
           84      0    0          28          7      0           0          0     0                      if (propagate() != CRef_Undef){
            .      .    .           .          .      .           .          .     .                          ok = false;
            .      .    .           .          .      .           .          .     .                          return false;
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                      // delete the clause memory in logic
            .      .    .           .          .      .           .          .     .                      c.mark(1);
            .      .    .           .          .      .           .          .     .                      ca.free(cr);
            .      .    .           .          .      .           .          .     .  //#ifdef BIN_DRUP
            .      .    .           .          .      .           .          .     .  //                    binDRUP('d', c, drup_file);
-- line 841 ----------------------------------------
-- line 845 ----------------------------------------
            .      .    .           .          .      .           .          .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .           .          .      .           .          .     .  //                    fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  //#endif
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .                  else{
            .      .    .           .          .      .           .          .     .                      
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                      nblevels = computeLBD(c);
       25,318      0    0           0          0      0           0          0     0                      if (nblevels < c.lbd()){
            .      .    .           .          .      .           .          .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
            .      .    .           .          .      .           .          .     .                          c.set_lbd(nblevels);
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                       //duplicate learnts 
            .      .    .           .          .      .           .          .     .                      int id = 0;                    
            .      .    .           .          .      .           .          .     .                      
            .      .    .           .          .      .           .          .     .                      std::vector<uint32_t> tmp;
      393,404      0    0     286,010          0      0           0          0     0                      for (int i = 0; i < c.size(); i++)                           
      207,552      0    0     103,776          0      0     103,776          0     0                          tmp.push_back(c[i].x);
       50,636      0    0           0          0      0      12,659          0     0                      id = is_duplicate(tmp);
            .      .    .           .          .      .           .          .     .                       
            .      .    .           .          .      .           .          .     .                                          
            .      .    .           .          .      .           .          .     .                      //duplicate learnts 
            .      .    .           .          .      .           .          .     .  
       50,636      0    0      12,659     10,398      0           0          0     0                      if (id < min_number_of_learnts_copies+2){
       37,968      0    0           0          0      0      12,656          0     0                          attachClause(cr);
       61,474      0    0      37,968     20,509      0      12,656      9,981     0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
       50,624      8    4      12,656          0      0           0          0     0                          if (id == min_number_of_learnts_copies+1){                            
            6      0    0           6          0      0           0          0     0                              duplicates_added_minimization++;                                  
            .      .    .           .          .      .           .          .     .                          }
       25,300      0    0      12,650     10,436      0           0          0     0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
            .      .    .           .          .      .           .          .     .                          //if (id == min_number_of_learnts_copies+1){
            .      .    .           .          .      .           .          .     .                              cj--;
            1      1    1           0          0      0           0          0     0                              learnts_core.push(cr);
            .      .    .           .          .      .           .          .     .                              c.mark(CORE);
            .      .    .           .          .      .           .          .     .                          }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                          c.setSimplified(true);
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            8      3    2           0          0      0           0          0     0      learnts_tier2.shrink(ci - cj);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
            .      .    .           .          .      .           .          .     .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
            .      .    .           .          .      .           .          .     .  
            8      0    0           0          0      0           0          0     0      return true;
            .      .    .           .          .      .           .          .     .  
           64      0    0          56          8      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  bool Solver::simplifyAll()
           40      2    2           0          0      0          24          0     0  {
            .      .    .           .          .      .           .          .     .      ////
           16      0    0           0          0      0           8          0     0      simplified_length_record = original_length_record = 0;
            .      .    .           .          .      .           .          .     .  
           32      0    0           8          3      0           0          0     0      if (!ok || propagate() != CRef_Undef)
            .      .    .           .          .      .           .          .     .          return ok = false;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      //// cleanLearnts(also can delete these code), here just for analyzing
            .      .    .           .          .      .           .          .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
            .      .    .           .          .      .           .          .     .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
            .      .    .           .          .      .           .          .     .      //local_learnts_dirty = tier2_learnts_dirty = false;
            .      .    .           .          .      .           .          .     .  
           32      0    0           0          0      0           8          0     0      if (!simplifyLearnt_core()) return ok = false;
           32      8    4           0          0      0           8          0     0      if (!simplifyLearnt_tier2()) return ok = false;
            .      .    .           .          .      .           .          .     .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      checkGarbage();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      ////
            .      .    .           .          .      .           .          .     .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
            .      .    .           .          .      .           .          .     .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      return true;
           40      0    0          32          0      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  //=================================================================================================
            .      .    .           .          .      .           .          .     .  // Minor methods:
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
            .      .    .           .          .      .           .          .     .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
            .      .    .           .          .      .           .          .     .  //
            .      .    .           .          .      .           .          .     .  Var Solver::newVar(bool sign, bool dvar)
      328,520      1    1           0          0      0     262,816          0     0  {
            .      .    .           .          .      .           .          .     .      int v = nVars();
            .      .    .           .          .      .           .          .     .      watches_bin.init(mkLit(v, false));
            .      .    .           .          .      .           .          .     .      watches_bin.init(mkLit(v, true ));
            .      .    .           .          .      .           .          .     .      watches  .init(mkLit(v, false));
            .      .    .           .          .      .           .          .     .      watches  .init(mkLit(v, true ));
           23      1    1           0          0      0           0          0     0      assigns  .push(l_Undef);
           23      1    1           0          0      0           0          0     0      vardata  .push(mkVarData(CRef_Undef, 0));
           23      0    0           0          0      0           0          0     0      activity_CHB  .push(0);
       98,602      0    0      32,852        540      0          23          0     0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
            .      .    .           .          .      .           .          .     .  
           23      1    1           0          0      0           0          0     0      picked.push(0);
           23      0    0           0          0      0           0          0     0      conflicted.push(0);
           23      0    0           0          0      0           0          0     0      almost_conflicted.push(0);
            .      .    .           .          .      .           .          .     .  #ifdef ANTI_EXPLORATION
           23      0    0           0          0      0           0          0     0      canceled.push(0);
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .  
           23      0    0           0          0      0           0          0     0      seen     .push(0);
           23      0    0           0          0      0           0          0     0      seen2    .push(0);
           23      0    0           0          0      0           0          0     0      polarity .push(sign);
           23      0    0           0          0      0           0          0     0      decision .push();
      164,260      1    1           0          0      0      65,704      1,058     0      trail    .capacity(v+1);
            .      .    .           .          .      .           .          .     .      setDecisionVar(v, dvar);
            .      .    .           .          .      .           .          .     .  
           23      0    0           0          0      0           0          0     0      activity_distance.push(0);
           23      1    1           0          0      0           0          0     0      var_iLevel.push(0);
           23      0    0           0          0      0           0          0     0      var_iLevel_tmp.push(0);
           23      0    0           0          0      0           0          0     0      pathCs.push(0);
            .      .    .           .          .      .           .          .     .      return v;
      295,668      0    0     229,964         27      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  bool Solver::addClause_(vec<Lit>& ps)
    2,416,806      2    1           0          0      0   2,071,548         84     0  {
            .      .    .           .          .      .           .          .     .      assert(decisionLevel() == 0);
    1,035,774      2    2     345,258          0      0           0          0     0      if (!ok) return false;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Check if clause is satisfied and remove false/duplicate literals:
            .      .    .           .          .      .           .          .     .      sort(ps);
            .      .    .           .          .      .           .          .     .      Lit p; int i, j;
            .      .    .           .          .      .           .          .     .  
      690,516      0    0     345,258        125      0           0          0     0      if (drup_file){
            .      .    .           .          .      .           .          .     .          add_oc.clear();
      345,258      4    1     345,258          0      0           0          0     0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
            .      .    .           .          .      .           .          .     .  
    4,671,189      0    0           0          0      0           0          0     0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
    8,015,487      0    0   1,326,891          0      0           0          0     0          if (value(ps[i]) == l_True || ps[i] == ~p)
            .      .    .           .          .      .           .          .     .              return true;
    5,307,564      5    3           0          0      0           0          0     0          else if (value(ps[i]) != l_False && ps[i] != p)
    3,980,673      0    0   1,326,891          0      0   1,326,891          0     0              ps[j++] = p = ps[i];
    2,762,064      0    0     345,258          0      0           0          0     0      ps.shrink(i - j);
            .      .    .           .          .      .           .          .     .  
      690,516      4    1           0          0      0           0          0     0      if (drup_file && i != j){
            .      .    .           .          .      .           .          .     .  #ifdef BIN_DRUP
            .      .    .           .          .      .           .          .     .          binDRUP('a', ps, drup_file);
      345,258      0    0     345,258          0      0           0          0     0          binDRUP('d', add_oc, drup_file);
            .      .    .           .          .      .           .          .     .  #else
            .      .    .           .          .      .           .          .     .          for (int i = 0; i < ps.size(); i++)
            .      .    .           .          .      .           .          .     .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
            .      .    .           .          .      .           .          .     .          fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          fprintf(drup_file, "d ");
            .      .    .           .          .      .           .          .     .          for (int i = 0; i < add_oc.size(); i++)
            .      .    .           .          .      .           .          .     .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
            .      .    .           .          .      .           .          .     .          fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .      
      690,516      0    0           0          0      0           0          0     0      if (ps.size() == 0)
            .      .    .           .          .      .           .          .     .          return ok = false;
      690,516      4    1           0          0      0           0          0     0      else if (ps.size() == 1){
            .      .    .           .          .      .           .          .     .          uncheckedEnqueue(ps[0]);
            .      .    .           .          .      .           .          .     .          return ok = (propagate() == CRef_Undef);
            .      .    .           .          .      .           .          .     .      }else{
      345,258      0    0           0          0      0     345,258          1     0          CRef cr = ca.alloc(ps, false);
            .      .    .           .          .      .           .          .     .          //auto ca_size=ca.size();
            .      .    .           .          .      .           .          .     .          //printf("ca size:%d\n",ca_size);
    1,035,774      0    0           0          0      0     345,258          0     0          clauses.push(cr);
    1,035,774      2    1     345,258          0      0     345,258          0     0          attachClause(cr);
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
      345,258      0    0           0          0      0           0          0     0      return true;
    3,797,838      0    0   2,416,806        108      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
    4,568,490      9    2           0          0      0   2,741,094          0     0  void Solver::attachClause(CRef cr) {
            .      .    .           .          .      .           .          .     .      const Clause& c = ca[cr];
            .      .    .           .          .      .           .          .     .      assert(c.size() > 1);
    1,771,407      0    0     456,849          5      0           0          0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
            .      .    .           .          .      .           .          .     .      ws[~c[0]].push(Watcher(cr, c[1]));
            .      .    .           .          .      .           .          .     .      ws[~c[1]].push(Watcher(cr, c[0]));
      997,297      0    0     540,448     70,570      2           0          0     0      if (c.learnt()) learnts_literals += c.size();
    4,028,042      1    0   3,571,193        281      0           0          0     0      else            clauses_literals += c.size(); }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
    1,905,732     31    5           0          0      0   1,270,488      3,429     0  void Solver::detachClause(CRef cr, bool strict) {
            .      .    .           .          .      .           .          .     .      const Clause& c = ca[cr];
            .      .    .           .          .      .           .          .     .      assert(c.size() > 1);
    1,270,488      0    0           0          0      0           0          0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
            .      .    .           .          .      .           .          .     .      
    1,270,488      0    0           0          0      0           0          0     0      if (strict){
            .      .    .           .          .      .           .          .     .          remove(ws[~c[0]], Watcher(cr, c[1]));
            .      .    .           .          .      .           .          .     .          remove(ws[~c[1]], Watcher(cr, c[0]));
            .      .    .           .          .      .           .          .     .      }else{
            .      .    .           .          .      .           .          .     .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
            .      .    .           .          .      .           .          .     .          ws.smudge(~c[0]);
            .      .    .           .          .      .           .          .     .          ws.smudge(~c[1]);
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
      689,283      7    1     371,661      7,303      1           0          0     0      if (c.learnt()) learnts_literals -= c.size();
    2,169,315      0    0   1,851,693      4,748      0           0          0     0      else            clauses_literals -= c.size(); }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
    2,166,152     81   11           0          0      0   1,083,076        520     0  void Solver::removeClause(CRef cr) {
            .      .    .           .          .      .           .          .     .      Clause& c = ca[cr];
            .      .    .           .          .      .           .          .     .  
      812,307      0    0     270,769        625      0           0          0     0      if (drup_file){
            .      .    .           .          .      .           .          .     .          if (c.mark() != 1){
            .      .    .           .          .      .           .          .     .  #ifdef BIN_DRUP
            .      .    .           .          .      .           .          .     .              binDRUP('d', c, drup_file);
            .      .    .           .          .      .           .          .     .  #else
            .      .    .           .          .      .           .          .     .              fprintf(drup_file, "d ");
            .      .    .           .          .      .           .          .     .              for (int i = 0; i < c.size(); i++)
            .      .    .           .          .      .           .          .     .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
            .      .    .           .          .      .           .          .     .              fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .          }else
            .      .    .           .          .      .           .          .     .              printf("c Bug. I don't expect this to happen.\n");
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
    1,083,076     38    6           0          0      0     270,769          0     0      detachClause(cr);
            .      .    .           .          .      .           .          .     .      // Don't leave pointers to free'd memory!
            .      .    .           .          .      .           .          .     .      if (locked(c)){
       15,164      0    0       1,818          0      0           0          0     0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
       11,528      0    0           0          0      0       5,764          0     0          vardata[var(implied)].reason = CRef_Undef; }
            .      .    .           .          .      .           .          .     .      c.mark(1);
            .      .    .           .          .      .           .          .     .      ca.free(cr);
    1,624,614      0    0   1,353,845         11      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  bool Solver::satisfied(const Clause& c) const {
   52,975,008     48   11           0          0      0           0          0     0      for (int i = 0; i < c.size(); i++)
   57,587,518      0    0  24,236,953    395,038      5           0          0     0          if (value(c[i]) == l_True)
            .      .    .           .          .      .           .          .     .              return true;
            .      .    .           .          .      .           .          .     .      return false; }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
            .      .    .           .          .      .           .          .     .  //
      596,151  1,803    7           0          0      0     397,434          1     0  void Solver::cancelUntil(int bLevel) {
            .      .    .           .          .      .           .          .     .  	
      266,550      9    2       1,371          1      0      66,239          1     0      if (decisionLevel() > bLevel){
            .      .    .           .          .      .           .          .     .  #ifdef PRINT_OUT
            .      .    .           .          .      .           .          .     .  		std::cout << "bt " << bLevel << "\n";
            .      .    .           .          .      .           .          .     .  #endif				
      132,478      0    0           0          0      0      66,239     28,702     0  		add_tmp.clear();
  153,125,031  6,170    5  30,770,732    117,189     19           0          0     0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
            .      .    .           .          .      .           .          .     .          {
            .      .    .           .          .      .           .          .     .              Var      x  = var(trail[c]);
            .      .    .           .          .      .           .          .     .  
   60,879,074      0    0  30,439,537 28,478,179  1,225           0          0     0  			if (level(x) <= bLevel)
            .      .    .           .          .      .           .          .     .  			{
            .      .    .           .          .      .           .          .     .  				add_tmp.push(trail[c]);
            .      .    .           .          .      .           .          .     .  			}
            .      .    .           .          .      .           .          .     .  			else
            .      .    .           .          .      .           .          .     .  			{
   59,910,724      0    0  29,955,362     29,791      0           0          0     0  				 if (!VSIDS){
   74,467,911      0    0  49,645,274        536      0           0          0     0  					uint32_t age = conflicts - picked[x];
   49,645,274      0    0  24,822,637 22,323,333  2,416           0          0     0  					if (age > 0){
  248,081,240    245    4  99,232,496 44,675,111  2,956           0          0     0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
   24,808,124      0    0  24,808,124 22,873,908  1,611           0          0     0  						double old_activity = activity_CHB[x];
  173,656,868     23    3  49,616,248     81,771      0  24,808,124          0     0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
            .      .    .           .          .      .           .          .     .  						if (order_heap_CHB.inHeap(x)){
  146,766,648    126    3           0          0      0  73,383,324         84     0  							if (activity_CHB[x] > old_activity)
            .      .    .           .          .      .           .          .     .  								order_heap_CHB.decrease(x);
            .      .    .           .          .      .           .          .     .  							else
            .      .    .           .          .      .           .          .     .  								order_heap_CHB.increase(x);
            .      .    .           .          .      .           .          .     .  						}
            .      .    .           .          .      .           .          .     .  					}
            .      .    .           .          .      .           .          .     .  #ifdef ANTI_EXPLORATION
   49,645,274      0    0  24,822,637     39,957      0  24,822,637 22,381,827 2,014  					canceled[x] = conflicts;
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .  				}
            .      .    .           .          .      .           .          .     .  				
   59,910,724    139    5  29,955,362     32,136      0  29,955,362 20,691,437   157  				assigns [x] = l_Undef;
            .      .    .           .          .      .           .          .     .  #ifdef PRINT_OUT
            .      .    .           .          .      .           .          .     .  				std::cout << "undo " << x << "\n";
            .      .    .           .          .      .           .          .     .  #endif				
   59,910,724      0    0  29,955,362          0      0           0          0     0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
   29,955,362      0    0  29,955,362          0      0           0          0     0  					polarity[x] = sign(trail[c]);
            .      .    .           .          .      .           .          .     .  				insertVarOrder(x);
            .      .    .           .          .      .           .          .     .  			}
            .      .    .           .          .      .           .          .     .          }
       66,239      0    0           0          0      0      66,239          0     0          qhead = trail_lim[bLevel];
      132,478      0    0           0          0      0           0          0     0          trail.shrink(trail.size() - trail_lim[bLevel]);
      198,717      0    0      66,239          0      0           0          0     0          trail_lim.shrink(trail_lim.size() - bLevel);
    1,167,067      1    1      66,239          0      0           0          0     0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
            .      .    .           .          .      .           .          .     .  		{
       21,153      0    0       7,051          0      0           0          0     0  			trail.push_(add_tmp[nLitId]);
            .      .    .           .          .      .           .          .     .  		}
            .      .    .           .          .      .           .          .     .  		
            .      .    .           .          .      .           .          .     .  		add_tmp.clear();
      529,912      0    0     463,673     57,404      0           0          0     0      } }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  //=================================================================================================
            .      .    .           .          .      .           .          .     .  // Major methods:
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  Lit Solver::pickBranchLit()
   19,113,152    340    4           0          0      0  14,334,864          0     0  {
            .      .    .           .          .      .           .          .     .      Var next = var_Undef;
            .      .    .           .          .      .           .          .     .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
    7,352,358    254    1   2,450,786     94,052      5           0          0     0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Random decision:
            .      .    .           .          .      .           .          .     .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
            .      .    .           .          .      .           .          .     .          next = order_heap[irand(random_seed,order_heap.size())];
            .      .    .           .          .      .           .          .     .          if (value(next) == l_Undef && decision[next])
            .      .    .           .          .      .           .          .     .              rnd_decisions++; }*/
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Activity based decision:
   33,092,979  1,740    4  14,157,345  4,614,665    413           0          0     0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    6,989,918      0    0           0          0      0           0          0     0          if (order_heap.empty())
            1      0    0           0          0      0           0          0     0              return lit_Undef;
            .      .    .           .          .      .           .          .     .          else{
            .      .    .           .          .      .           .          .     .  #ifdef ANTI_EXPLORATION
    6,989,916      0    0   3,494,958      1,450      1           0          0     0              if (!VSIDS){
            .      .    .           .          .      .           .          .     .                  Var v = order_heap_CHB[0];
    3,431,552      0    0   3,431,552      2,743      0           0          0     0                  uint32_t age = conflicts - canceled[v];
    4,648,436      0    0   2,213,375    754,291    505     110,843          3     0                  while (age > 0){
            .      .    .           .          .      .           .          .     .                      double decay = pow(0.95, age);
      995,198      0    0     497,599     11,543      1     497,599          0     0                      activity_CHB[v] *= decay;
            .      .    .           .          .      .           .          .     .                      if (order_heap_CHB.inHeap(v))
            .      .    .           .          .      .           .          .     .                          order_heap_CHB.increase(v);
    1,492,797      0    0     995,198          3      0     497,599          0     0                      canceled[v] = conflicts;
            .      .    .           .          .      .           .          .     .                      v = order_heap_CHB[0];
            .      .    .           .          .      .           .          .     .                      age = conflicts - canceled[v];
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .              next = order_heap.removeMin();
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .  
    9,556,572      0    0   4,778,286  2,161,594    113           0          0     0      return mkLit(next, polarity[next]);
   21,502,295      0    0  16,724,008     10,097      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
            .      .    .           .          .      .           .          .     .  {
            .      .    .           .          .      .           .          .     .  	ConflictData data;
            .      .    .           .          .      .           .          .     .  	Clause& conflCls = ca[cind];
            .      .    .           .          .      .           .          .     .  	data.nHighestLevel = level(var(conflCls[0]));
      254,910      0    0     127,455      1,440      0           0          0     0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
            .      .    .           .          .      .           .          .     .  	{
            .      .    .           .          .      .           .          .     .  		return data;
            .      .    .           .          .      .           .          .     .  	}
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  	int highestId = 0;
            .      .    .           .          .      .           .          .     .      data.bOnlyOneLitFromHighest = true;
            .      .    .           .          .      .           .          .     .  	// find the largest decision level in the clause
      111,930     22    6           0          0      0           0          0     0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
            .      .    .           .          .      .           .          .     .  	{
            .      .    .           .          .      .           .          .     .  		int nLevel = level(var(conflCls[nLitId]));
       77,101      0    0           0          0      0           0          0     0  		if (nLevel > data.nHighestLevel)
            .      .    .           .          .      .           .          .     .  		{
            .      .    .           .          .      .           .          .     .  			highestId = nLitId;
            .      .    .           .          .      .           .          .     .  			data.nHighestLevel = nLevel;
          857      0    0           0          0      0           0          0     0  			data.bOnlyOneLitFromHighest = true;
            .      .    .           .          .      .           .          .     .  		}
            .      .    .           .          .      .           .          .     .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
            .      .    .           .          .      .           .          .     .  		{
       72,816      0    0           0          0      0           0          0     0  			data.bOnlyOneLitFromHighest = false;
            .      .    .           .          .      .           .          .     .  		}
            .      .    .           .          .      .           .          .     .  	}
            .      .    .           .          .      .           .          .     .  
        9,350    479    5           0          0      0           0          0     0  	if (highestId != 0)
            .      .    .           .          .      .           .          .     .  	{
            .      .    .           .          .      .           .          .     .  		std::swap(conflCls[0], conflCls[highestId]);
        1,516      0    0           0          0      0           0          0     0  		if (highestId > 1)
            .      .    .           .          .      .           .          .     .  		{
        1,872      0    0           0          0      0           0          0     0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
            .      .    .           .          .      .           .          .     .  			//ws.smudge(~conflCls[highestId]);
            .      .    .           .          .      .           .          .     .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
            .      .    .           .          .      .           .          .     .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
            .      .    .           .          .      .           .          .     .  		}
            .      .    .           .          .      .           .          .     .  	}
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  	return data;
            .      .    .           .          .      .           .          .     .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
            .      .    .           .          .      .           .          .     .  |  
            .      .    .           .          .      .           .          .     .  |    Post-conditions:
            .      .    .           .          .      .           .          .     .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
            .      .    .           .          .      .           .          .     .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
            .      .    .           .          .      .           .          .     .  |        rest of literals. There may be others from the same level though.
            .      .    .           .          .      .           .          .     .  |  
            .      .    .           .          .      .           .          .     .  |________________________________________________________________________________________________@*/
            .      .    .           .          .      .           .          .     .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
      843,284     28    7           0          0      0     583,812          0     0  {
       64,868      0    0           0          0      0      64,868        336     0      int pathC = 0;
       64,868      0    0           0          0      0           0          0     0      Lit p     = lit_Undef;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Generate conflict clause:
            .      .    .           .          .      .           .          .     .      //
            .      .    .           .          .      .           .          .     .      out_learnt.push();      // (leave room for the asserting literal)
      129,736      0    0      64,868          0      0           0          0     0      int index   = trail.size() - 1;
       64,868      0    0      64,868          0      0           0          0     0      int nDecisionLevel = level(var(ca[confl][0]));
            .      .    .           .          .      .           .          .     .      assert(nDecisionLevel == level(var(ca[confl][0])));
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      do{
            .      .    .           .          .      .           .          .     .          assert(confl != CRef_Undef); // (otherwise should be UIP)
            .      .    .           .          .      .           .          .     .          Clause& c = ca[confl];
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
   11,521,280      0    0           0          0      0           0          0     0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
            .      .    .           .          .      .           .          .     .              assert(value(c[1]) == l_True);
            .      .    .           .          .      .           .          .     .              Lit tmp = c[0];
       64,686      0    0      21,562        792      7      43,124          0     0              c[0] = c[1], c[1] = tmp; }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          // Update LBD if improved.
    7,947,799      1    1     801,802         36      0           0          0     0          if (c.learnt() && c.mark() != CORE){
            .      .    .           .          .      .           .          .     .              int lbd = computeLBD(c);
      939,830      0    0           0          0      0           0          0     0              if (lbd < c.lbd()){
       73,450      0    0           0          0      0           0          0     0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
            .      .    .           .          .      .           .          .     .                  c.set_lbd(lbd);
       73,450      0    0      36,725     28,331      0           0          0     0                  if (lbd <= core_lbd_cut){
            2      0    0           0          0      0           1          0     0                      learnts_core.push(confl);
            .      .    .           .          .      .           .          .     .                      c.mark(CORE);
       82,291      0    0       5,163          0      0           0          0     0                  }else if (lbd <= 6 && c.mark() == LOCAL){
            .      .    .           .          .      .           .          .     .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
            .      .    .           .          .      .           .          .     .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
      458,996      1    1           0          0      0     132,196     60,232     2                      learnts_tier2.push(confl);
            .      .    .           .          .      .           .          .     .                      c.mark(TIER2); }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
      931,952      0    0     465,976     14,756      0           0          0     0              if (c.mark() == TIER2)
      688,300      8    4     172,075     44,790      0     172,075     17,147    11                  c.touched() = conflicts;
      590,262      0    0     295,131          0      0           0          0     0              else if (c.mark() == LOCAL)
            .      .    .           .          .      .           .          .     .                  claBumpActivity(c);
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .  
   98,827,251      6    3  38,965,217     12,048      0   2,667,930          1     0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
   36,297,287      0    0  36,297,287    828,660     25           0          0     0              Lit q = c[j];
            .      .    .           .          .      .           .          .     .  
  111,886,054      4    3  49,394,447 16,588,378    406           0          0     0              if (!seen[var(q)] && level(var(q)) > 0){
   26,145,420      0    0  13,072,710     23,858      0           0          0     0                  if (VSIDS){
            .      .    .           .          .      .           .          .     .                      varBumpActivity(var(q), .5);
           14      0    0           0          0      0           7          0     0                      add_tmp.push(q);
            .      .    .           .          .      .           .          .     .                  }else
   12,864,793      0    0  12,864,793 10,845,312  1,153           0          0     0                      conflicted[var(q)]++;
   13,072,710      0    0           0          0      0  13,072,710          2     0                  seen[var(q)] = 1;
   26,145,420      0    0  13,072,710          2      0           0          0     0                  if (level(var(q)) >= nDecisionLevel){
    5,335,860      0    0   5,335,860      5,083      0           0          0     0                      pathC++;
            .      .    .           .          .      .           .          .     .                  }else
            .      .    .           .          .      .           .          .     .                      out_learnt.push(q);
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          
            .      .    .           .          .      .           .          .     .          // Select next clause to look at:
            .      .    .           .          .      .           .          .     .  		do {
   99,820,935      0    0  40,461,960  8,031,737  1,065           0          0     0  			while (!seen[var(trail[index--])]);
            .      .    .           .          .      .           .          .     .  			p  = trail[index+1];
    5,352,970      1    0   2,676,485    440,879      0           0          0     0  		} while (level(var(p)) < nDecisionLevel);
            .      .    .           .          .      .           .          .     .  		
    5,335,860      0    0   2,667,930          0      0   2,667,930        125     0          confl = reason(var(p));
    2,667,930      0    0           0          0      0   2,667,930          0     0          seen[var(p)] = 0;
    5,335,860      0    0   5,335,860      1,143      0           0          0     0          pathC--;
            .      .    .           .          .      .           .          .     .  
   15,748,108      0    0   5,206,124     55,196      0           0          0     0      }while (pathC > 0);
       64,868      0    0      64,868        400      0           0          0     0      out_learnt[0] = ~p;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Simplify conflict clause:
            .      .    .           .          .      .           .          .     .      //
            .      .    .           .          .      .           .          .     .      int i, j;
      129,736      0    0           0          0      0      64,868          0     0      out_learnt.copyTo(analyze_toclear);
      194,604      0    0      64,868        273      0           0          0     0      if (ccmin_mode == 2){
       64,810    145    4           0          0      0           0          0     0          uint32_t abstract_level = 0;
   20,939,296    127    6           0          0      0           0          0     0          for (i = 1; i < out_learnt.size(); i++)
   10,534,400      0    0      64,810          0      0           0          0     0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
            .      .    .           .          .      .           .          .     .  
   73,481,560      6    3  31,149,530      6,886      0      64,810      6,409     0          for (i = j = 1; i < out_learnt.size(); i++)
   75,841,581      7    4  16,708,363  7,490,530      0   8,484,971          0     0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
   24,670,176      3    1   8,223,392        239      0   8,223,392     76,753     0                  out_learnt[j++] = out_learnt[i];
            .      .    .           .          .      .           .          .     .          
            .      .    .           .          .      .           .          .     .      }else if (ccmin_mode == 1){
            .      .    .           .          .      .           .          .     .          for (i = j = 1; i < out_learnt.size(); i++){
            .      .    .           .          .      .           .          .     .              Var x = var(out_learnt[i]);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              if (reason(x) == CRef_Undef)
            .      .    .           .          .      .           .          .     .                  out_learnt[j++] = out_learnt[i];
            .      .    .           .          .      .           .          .     .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
            .      .    .           .          .      .           .          .     .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
            .      .    .           .          .      .           .          .     .                          out_learnt[j++] = out_learnt[i];
            .      .    .           .          .      .           .          .     .                          break; }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }else
            .      .    .           .          .      .           .          .     .          i = j = out_learnt.size();
            .      .    .           .          .      .           .          .     .  
      129,736      0    0      64,868     62,587      2           0          0     0      max_literals += out_learnt.size();
      773,908      2    2     177,260          0      0           0          0     0      out_learnt.shrink(i - j);
       64,868     43    1      64,868          0      0           0          0     0      tot_literals += out_learnt.size();
            .      .    .           .          .      .           .          .     .  
      129,736      0    0      64,868     30,796      0      64,868     13,007     0      out_lbd = computeLBD(out_learnt);
      763,333  6,622   11     340,799     15,878      0           0          0     0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
      116,865  2,775    8      16,695          0      0      33,390          0     0          if (binResMinimize(out_learnt))
          849      0    0         283          0      0         283          0     0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Find correct backtrack level:
            .      .    .           .          .      .           .          .     .      //
      129,564      0    0           0          0      0           0          0     0      if (out_learnt.size() == 1)
          177      0    0          59          0      0          59          0     0          out_btlevel = 0;
            .      .    .           .          .      .           .          .     .      else{
      128,406      0    0           0          0      0           0          0     0          int max_i = 1;
            .      .    .           .          .      .           .          .     .          // Find the first literal assigned at the next-highest level:
   32,746,393      0    0           0          0      0           0          0     0          for (int i = 2; i < out_learnt.size(); i++)
   25,053,597      0    0   8,158,267    112,588      0           0          0     0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
            .      .    .           .          .      .           .          .     .                  max_i = i;
            .      .    .           .          .      .           .          .     .          // Swap-in this literal at index 1:
            .      .    .           .          .      .           .          .     .          Lit p             = out_learnt[max_i];
      129,618      6    1      64,809      1,883      0      64,809        883     0          out_learnt[max_i] = out_learnt[1];
       64,809      0    0           0          0      0      64,809          0     0          out_learnt[1]     = p;
      129,618      0    0      64,809      3,983      0      64,809      6,925     0          out_btlevel       = level(var(p));
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
      129,736    401    4      64,868     30,445      0           0          0     0      if (VSIDS){
      777,676  7,632    2     236,582      2,047      0           0          0     0          for (int i = 0; i < add_tmp.size(); i++){
            .      .    .           .          .      .           .          .     .              Var v = var(add_tmp[i]);
      623,751      0    0     207,917     24,087      0           0          0     0              if (level(v) >= out_btlevel - 1)
            .      .    .           .          .      .           .          .     .                  varBumpActivity(v, 1);
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          add_tmp.clear();
            .      .    .           .          .      .           .          .     .      }else{
      110,626      1    0      55,313      7,025      0      55,313     21,613     0          seen[var(p)] = true;
   25,166,794      0    0      55,313          0      0           0          0     0          for(int i = out_learnt.size() - 1; i >= 0; i--){
            .      .    .           .          .      .           .          .     .              Var v = var(out_learnt[i]);
            .      .    .           .          .      .           .          .     .              CRef rea = reason(v);
   16,372,234      0    0           0          0      0           0          0     0              if (rea != CRef_Undef){
            .      .    .           .          .      .           .          .     .                  const Clause& reaC = ca[rea];
  153,803,358      0    0           0          0      0           0          0     0                  for (int i = 0; i < reaC.size(); i++){
            .      .    .           .          .      .           .          .     .                      Lit l = reaC[i];
  128,727,522      0    0  64,363,761 10,571,173    161           0          0     0                      if (!seen[var(l)]){
   15,019,583      0    0           0          0      0  15,019,583          0     0                          seen[var(l)] = true;
   15,019,583      0    0  15,019,583 12,730,535  1,585           0          0     0                          almost_conflicted[var(l)]++;
            .      .    .           .          .      .           .          .     .                          analyze_toclear.push(l); } } } } }
            .      .    .           .          .      .           .          .     .  
  112,685,940    967    3  56,245,668         49      0  28,090,400  2,427,663     0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
      518,944      0    0     454,076     40,883      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  // Try further learnt clause minimization by means of binary clause resolution.
            .      .    .           .          .      .           .          .     .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
       50,450      0    0           0          0      0      40,360          0     0  {
            .      .    .           .          .      .           .          .     .      // Preparation: remember which false variables we have in 'out_learnt'.
       50,085      8    2      16,695          0      0      16,695          0     0      counter++;
      333,820      0    0      33,390          0      0           0          0     0      for (int i = 1; i < out_learnt.size(); i++)
      118,051      0    0      16,637          0      0     101,414     97,615 7,963          seen2[var(out_learnt[i])] = counter;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Get the list of binary clauses containing 'out_learnt[0]'.
            .      .    .           .          .      .           .          .     .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
            .      .    .           .          .      .           .          .     .  
       10,090      0    0           0          0      0           0          0     0      int to_remove = 0;
      127,556      1    0      16,695     11,971      0         283          0     0      for (int i = 0; i < ws.size(); i++){
       45,183      0    0      45,183      9,517      0           0          0     0          Lit the_other = ws[i].blocker;
            .      .    .           .          .      .           .          .     .          // Does 'the_other' appear negatively in 'out_learnt'?
      181,364      9    2      80,908     33,462  3,770           0          0     0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
          316      0    0           0          0      0           0          0     0              to_remove++;
          948      0    0           0          0      0         316          0     0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Shrink.
       30,270     10    1           0          0      0           0          0     0      if (to_remove > 0){
          283      0    0           0          0      0           0          0     0          int last = out_learnt.size() - 1;
       15,255    115    4         282          0      0           0          0     0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
        4,070      0    0       2,035          0      0           0          0     0              if (seen2[var(out_learnt[i])] != counter)
        1,145      0    0         458          0      0         229          0     0                  out_learnt[i--] = out_learnt[last--];
            .      .    .           .          .      .           .          .     .          out_learnt.shrink(to_remove);
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .      return to_remove != 0;
       57,055      1    1      57,055          0      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
            .      .    .           .          .      .           .          .     .  // visiting literals at levels that cannot be removed later.
            .      .    .           .          .      .           .          .     .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
   84,849,710  5,658    2           0          0      0  50,909,826     35,232     0  {
   16,969,942      0    0           0          0      0   8,484,971          0     0      analyze_stack.clear(); analyze_stack.push(p);
   25,454,913      0    0  16,969,942          0      0   8,484,971          0     0      int top = analyze_toclear.size();
   47,475,404      0    0           0          0      0           0          0     0      while (analyze_stack.size() > 0){
            .      .    .           .          .      .           .          .     .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
            .      .    .           .          .      .           .          .     .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          // Special handling for binary clauses like in 'analyze()'.
   56,317,930     14    4           0          0      0           0          0     0          if (c.size() == 2 && value(c[0]) == l_False){
            .      .    .           .          .      .           .          .     .              assert(value(c[1]) == l_True);
            .      .    .           .          .      .           .          .     .              Lit tmp = c[0];
       25,491      0    0       8,497        451      6      16,994          0     0              c[0] = c[1], c[1] = tmp; }
            .      .    .           .          .      .           .          .     .  
  149,891,576      0    0           0          0      0           0          0     0          for (int i = 1; i < c.size(); i++){
   66,295,708    105    6  66,295,708  4,879,314    297           0          0     0              Lit p  = c[i];
  253,975,312      0    0 132,591,416 12,289,996    353           0          0     0              if (!seen[var(p)] && level(var(p)) > 0){
   96,165,884      0    0  27,042,346          0      0           0          0     0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
   20,738,763      0    0           0          0      0  20,738,763          0     0                      seen[var(p)] = 1;
            .      .    .           .          .      .           .          .     .                      analyze_stack.push(p);
            7      0    0           0          0      0           0          0     0                      analyze_toclear.push(p);
            .      .    .           .          .      .           .          .     .                  }else{
   94,773,814    235    9  30,744,760        148      0           0          0     0                      for (int j = top; j < analyze_toclear.size(); j++)
   32,018,983      0    0  13,881,389          0      0  18,137,594      1,216     0                          seen[var(analyze_toclear[j])] = 0;
   12,607,166      7    1   6,303,583          0      0           0          0     0                      analyze_toclear.shrink(analyze_toclear.size() - top);
    6,303,583      0    0           0          0      0           0          0     0                      return false;
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
    4,362,776      0    0           0          0      0           0          0     0      return true;
   67,879,768      2    1  59,394,797        488      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  /*_________________________________________________________________________________________________
            .      .    .           .          .      .           .          .     .  |
            .      .    .           .          .      .           .          .     .  |  analyzeFinal : (p : Lit)  ->  [void]
            .      .    .           .          .      .           .          .     .  |  
            .      .    .           .          .      .           .          .     .  |  Description:
            .      .    .           .          .      .           .          .     .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      seen[var(p)] = 0;
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
  299,613,370      2    2           0          0      0 149,806,685          0     0  {
            .      .    .           .          .      .           .          .     .      assert(value(p) == l_Undef);
            .      .    .           .          .      .           .          .     .      Var x = var(p);
   59,922,674      0    0  29,961,337     27,924      2           0          0     0      if (!VSIDS){
   74,468,394      0    0  49,645,596     76,585      6  24,822,798 22,866,925 7,111          picked[x] = conflicts;
   49,645,596      0    0  24,822,798          0      0  24,822,798 22,922,196 6,118          conflicted[x] = 0;
   49,645,596      0    0  24,822,798          0      0  24,822,798 22,922,189 5,956          almost_conflicted[x] = 0;
            .      .    .           .          .      .           .          .     .  #ifdef ANTI_EXPLORATION
   24,822,798      0    0  24,822,798     30,288      2           0          0     0          uint32_t age = conflicts - canceled[var(p)];
   49,645,596      0    0  24,822,798 22,843,583  6,501           0          0     0          if (age > 0){
            .      .    .           .          .      .           .          .     .              double decay = pow(0.95, age);
   25,294,720      0    0  12,647,360 12,028,661  3,023  12,647,360          0     0              activity_CHB[var(p)] *= decay;
            .      .    .           .          .      .           .          .     .              if (order_heap_CHB.inHeap(var(p)))
   12,647,360      0    0           0          0      0           0          0     0                  order_heap_CHB.increase(var(p));
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
   29,961,337      1    1  29,961,337        148      2           0          0     0      assigns[x] = lbool(!sign(p));
   59,922,674      0    0           0          0      0  59,922,674 28,195,262 8,963      vardata[x] = mkVarData(from, level);
   29,961,337      1    1  29,961,337          0      0           0          0     0      trail.push_(p);
  209,729,359      0    0 179,768,022          0      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  unsigned number_watch_changed_total=0;
            .      .    .           .          .      .           .          .     .  unsigned number_clause_read_total=0;
            .      .    .           .          .      .           .          .     .  unsigned times_only_access_watch=0;
            .      .    .           .          .      .           .          .     .  /*_________________________________________________________________________________________________
            .      .    .           .          .      .           .          .     .  |
            .      .    .           .          .      .           .          .     .  |  propagate : [void]  ->  [Clause*]
            .      .    .           .          .      .           .          .     .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
            .      .    .           .          .      .           .          .     .  |  Description:
            .      .    .           .          .      .           .          .     .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
            .      .    .           .          .      .           .          .     .  |    otherwise CRef_Undef.
            .      .    .           .          .      .           .          .     .  |  
            .      .    .           .          .      .           .          .     .  |    Post-conditions:
            .      .    .           .          .      .           .          .     .  |      * the propagation queue is empty, even if there was a conflict.
            .      .    .           .          .      .           .          .     .  |________________________________________________________________________________________________@*/
            .      .    .           .          .      .           .          .     .  CRef Solver::propagate_()
   19,645,640      4    2           0          0      0  14,734,230          0     0  {
            .      .    .           .          .      .           .          .     .      //auto start_time=std::chrono::steady_clock::now();
    2,455,705      0    0           0          0      0   2,455,705          0     0      CRef    confl     = CRef_Undef;
    2,455,705      0    0           0          0      0   2,455,705         10     0      int     num_props = 0;
    4,911,410      0    0           0          0      0   2,455,705      8,208     0      watches.cleanAll();
    4,911,410      4    2           0          0      0   2,455,705          0     0      watches_bin.cleanAll();
            .      .    .           .          .      .           .          .     .      
  100,618,931      0    0  67,372,693     37,823      0           0          0     0      while (qhead < trail.size()){
  142,960,615      0    0  57,184,246    527,299      0  28,592,123          0     0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
            .      .    .           .          .      .           .          .     .          int currLevel = level(var(p));
            .      .    .           .          .      .           .          .     .          vec<Watcher>&  ws  = watches[p];
            .      .    .           .          .      .           .          .     .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          Watcher        *i, *j, *end;
   33,872,586      0    0  33,872,586     55,822      0           0          0     0          num_props++;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
            .      .    .           .          .      .           .          .     .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
  147,661,576      1    1  28,592,123 28,394,991 20,834           0          0     0          for (int k = 0; k < ws_bin.size(); k++){
   25,410,847      0    0  25,410,847  8,339,724 14,911           0          0     0              Lit the_other = ws_bin[k].blocker;
  226,806,817      0    0 154,494,888          0      0           0          0     0              if (value(the_other) == l_False){
        6,852      2    0       3,426          0      0       3,426          0     0                  confl = ws_bin[k].cref;
            .      .    .           .          .      .           .          .     .                  //auto end_time=std::chrono::steady_clock::now();
            .      .    .           .          .      .           .          .     .                  //auto duration=end_time-start_time;
            .      .    .           .          .      .           .          .     .  #ifdef LOOSE_PROP_STAT
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                  return confl;
            .      .    .           .          .      .           .          .     .  #else
            .      .    .           .          .      .           .          .     .                  goto ExitProp;
            .      .    .           .          .      .           .          .     .  #endif
   36,481,212      2    1           0          0      0           0          0     0              }else if(value(the_other) == l_Undef)
            .      .    .           .          .      .           .          .     .              {
   31,197,090      2    1  18,718,254          0      0   6,239,418      8,297     0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
            .      .    .           .          .      .           .          .     .  #ifdef  PRINT_OUT                
            .      .    .           .          .      .           .          .     .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
            .      .    .           .          .      .           .          .     .  #endif                
            .      .    .           .          .      .           .          .     .  			}
            .      .    .           .          .      .           .          .     .          }
   57,177,394      0    0  57,177,394 28,006,419 16,039           0          0     0          total_Watchers+=ws.size();
   28,588,697      0    0  28,588,697          0      0           0          0     0          total_indexs++;//number of rounds
            .      .    .           .          .      .           .          .     .          //int count=0;
   24,513,836      0    0           0          0      0           0          0     0          bool no_clause_access=true;
   24,513,836      0    0           0          0      0  24,513,836          0     0          bool no_implication_added=true;
   24,513,836      0    0           0          0      0  24,513,836          0     0          bool no_change_other_watch=true;
  580,709,439      3    3 235,214,756          0      0  28,588,697          0     0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
            .      .    .           .          .      .           .          .     .              // Try to avoid inspecting the clause:
            .      .    .           .          .      .           .          .     .              //count++;
  206,626,059      1    1 206,626,059 45,280,076 71,568           0          0     0              Lit blocker = i->blocker;
  413,252,118      0    0 206,626,059     76,561      4           0          0     0              total_access_watches++;
  413,252,118      0    0 206,626,059 31,737,717    502           0          0     0              if (value(blocker) == l_True){
            .      .    .           .          .      .           .          .     .                  
  606,646,804      0    0 151,661,701          0      0 151,661,701     22,453     0                  *j++ = *i++; continue; }//no clause accessed
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Make sure the false literal is data[1]:
   55,283,373      0    0      51,285          0      0           0          0     0              no_clause_access=false;
  164,893,074      1    1 109,928,716    145,496      6  54,964,358          0     0              total_clause_access_times++;
  109,928,716      0    0  54,964,358          0      0           0          0     0              CRef     cr        = i->cref;
            .      .    .           .          .      .           .          .     .              //std::cout<<"cr: "<<cr<<"\n";
            .      .    .           .          .      .           .          .     .              Clause&  c         = ca[cr];
            .      .    .           .          .      .           .          .     .              Lit      false_lit = ~p;
   54,964,358      0    0  54,964,358          0      0           0          0     0              total_clause_access_size+=2;
  164,893,074      0    0 109,928,716 49,469,142 29,207           0          0     0              if (c[0] == false_lit)
   40,951,912      0    0  20,475,956    571,860    798  20,475,956          0     0                  c[0] = c[1], c[1] = false_lit;
            .      .    .           .          .      .           .          .     .              assert(c[1] == false_lit);
            .      .    .           .          .      .           .          .     .              i++;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // If 0th watch is true, then clause is already satisfied.
            .      .    .           .          .      .           .          .     .              Lit     first = c[0];
            .      .    .           .          .      .           .          .     .              Watcher w     = Watcher(cr, first);
  122,405,320      0    0   6,238,302    815,287     11           0          0     0              if (first != blocker && value(first) == l_True){
    8,499,561      0    0           0          0      0   5,666,374     10,658     0                  *j++ = w; continue; }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Look for new watch:
1,194,670,296      1    1           0          0      0           0          0     0              for (int k = 2; k < c.size(); k++)
            .      .    .           .          .      .           .          .     .              {
1,970,640,338      0    0           0          0      0 394,270,059          0     0                  total_clause_access_size++;
  931,723,349      0    0  38,920,889          0      0           0          0     0                  if (value(c[k]) != l_False){
  123,202,964  1,528    0  61,601,482          0      0  61,601,482          0     0                      c[1] = c[k]; c[k] = false_lit;
   30,800,741      0    0  30,800,741          0      0           0          0     0                      total_change_other_watch++;
   30,800,741      0    0           0          0      0  30,800,741          0     0                      no_change_other_watch=false;
            .      .    .           .          .      .           .          .     .                      watches[~c[1]].push(w);
            .      .    .           .          .      .           .          .     .                      goto NextClause; }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Did not find watch -- clause is unit under assignment:
   64,053,880      0    0           0          0      0  42,660,860      2,129     0              *j++ = w;
   42,660,860      0    0           0          0      0           0          0     0              if (value(first) == l_False){
       62,590      0    0      62,590          0      0           0          0     0                  time_find_conflict++;
      375,540      0    0     250,360        902      0           0          0     0                  total_find_conflict_length+=i-(Watcher*)ws;
      125,180      0    0     125,180          0      0           0          0     0                  total_find_conflict_allsize+=ws.size();
            .      .    .           .          .      .           .          .     .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
       62,590      0    0           0          0      0      62,590          0     0                  confl = cr;
      125,180      0    0      62,590        335      0      62,590          0     0                  qhead = trail.size();
            .      .    .           .          .      .           .          .     .                  // Copy the remaining watches:
            .      .    .           .          .      .           .          .     .  
    2,049,012      1    1     113,875          0      0           0          0     0                  while (i < end)
      879,336      0    0     879,336    108,110    824     879,336      1,162     0                      *j++ = *i++;
            .      .    .           .          .      .           .          .     .              }else
            .      .    .           .          .      .           .          .     .              {//new implecate
   21,267,840      0    0           0          0      0  21,267,840          1     0                  no_implication_added=false;
   21,267,840      0    0  21,267,840          0      0           0          0     0                  total_push_new_implication++;
   63,803,520      0    0  42,535,680      9,734      0           0          0     0  				if (currLevel == decisionLevel())
            .      .    .           .          .      .           .          .     .  				{
   42,535,680      0    0           0          0      0           0          0     0  					uncheckedEnqueue(first, currLevel, cr);
            .      .    .           .          .      .           .          .     .  #ifdef PRINT_OUT					
            .      .    .           .          .      .           .          .     .  					std::cout << "i " << first << " l " << currLevel << "\n";
            .      .    .           .          .      .           .          .     .  #endif					
            .      .    .           .          .      .           .          .     .  				}
            .      .    .           .          .      .           .          .     .  				else
            .      .    .           .          .      .           .          .     .  				{
            .      .    .           .          .      .           .          .     .  					int nMaxLevel = currLevel;
      710,004      0    0           0          0      0           0          0     0  					int nMaxInd = 1;
            .      .    .           .          .      .           .          .     .  					// pass over all the literals in the clause and find the one with the biggest level
    3,487,504      0    0     355,002          0      0           0          0     0  					for (int nInd = 2; nInd < c.size(); ++nInd)
            .      .    .           .          .      .           .          .     .  					{
            .      .    .           .          .      .           .          .     .  						int nLevel = level(var(c[nInd]));
    2,117,028      0    0           0          0      0           0          0     0  						if (nLevel > nMaxLevel)
            .      .    .           .          .      .           .          .     .  						{
            .      .    .           .          .      .           .          .     .  							nMaxLevel = nLevel;
            .      .    .           .          .      .           .          .     .  							nMaxInd = nInd;
            .      .    .           .          .      .           .          .     .  						}
            .      .    .           .          .      .           .          .     .  					}
            .      .    .           .          .      .           .          .     .  
      710,004      2    1           0          0      0           0          0     0  					if (nMaxInd != 1)
            .      .    .           .          .      .           .          .     .  					{
            .      .    .           .          .      .           .          .     .  						std::swap(c[1], c[nMaxInd]);
            .      .    .           .          .      .           .          .     .  						*j--; // undo last watch
       22,579      0    0      22,579         24      0           0          0     0                          total_change_other_watch++;
       22,579      0    0           0          0      0      22,579          5     0                          no_change_other_watch=false;
            .      .    .           .          .      .           .          .     .  						watches[~c[1]].push(w);
            .      .    .           .          .      .           .          .     .  					}
            .      .    .           .          .      .           .          .     .  					
  106,694,202      0    0  21,267,840          0      0  21,267,840     23,409     0  					uncheckedEnqueue(first, nMaxLevel, cr);
            .      .    .           .          .      .           .          .     .  #ifdef PRINT_OUT					
            .      .    .           .          .      .           .          .     .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
            .      .    .           .          .      .           .          .     .  #endif	
            .      .    .           .          .      .           .          .     .  				}
            .      .    .           .          .      .           .          .     .  			}
            .      .    .           .          .      .           .          .     .  
       51,285     37    2           0          0      0           0          0     0  NextClause:;
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
  122,569,180      0    0  24,513,836          0      0           0          0     0          if(no_clause_access==true){
   13,136,501     12    3  13,136,501      9,797      1           0          0     0              total_no_clause_access++;
            .      .    .           .          .      .           .          .     .          }
   58,089,312      9    3  24,513,836          0      0           0          0     0          if(no_implication_added==true){
   19,979,973      1    1  15,905,112          1      0           0          0     0              total_no_implication_added++;
            .      .    .           .          .      .           .          .     .          }
   58,191,447      0    0  24,513,836          0      0           0          0     0          if(no_change_other_watch==true){
   23,304,808      9    3  23,304,808          3      0           0          0     0              total_no_change_other_watch++;
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          ws.shrink(i - j);
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  ExitProp:;
    4,904,558      4    2   4,904,558     19,437      0           0          0     0      propagations += num_props;
    2,452,279      0    0   2,452,279          0      0           0          0     0      simpDB_props -= num_props;
            .      .    .           .          .      .           .          .     .  
    2,452,279      0    0   2,452,279          0      0           0          0     0      return confl;
   32,855,922  1,895    1  17,189,935    118,262      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  /*_________________________________________________________________________________________________
            .      .    .           .          .      .           .          .     .  |
            .      .    .           .          .      .           .          .     .  |  reduceDB : ()  ->  [void]
            .      .    .           .          .      .           .          .     .  |  
            .      .    .           .          .      .           .          .     .  |  Description:
            .      .    .           .          .      .           .          .     .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
            .      .    .           .          .      .           .          .     .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
            .      .    .           .          .      .           .          .     .  |________________________________________________________________________________________________@*/
            .      .    .           .          .      .           .          .     .  struct reduceDB_lt { 
            .      .    .           .          .      .           .          .     .      ClauseAllocator& ca;
            .      .    .           .          .      .           .          .     .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    1,704,720      8    8   1,665,311    561,488     28           0          0     0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
            .      .    .           .          .      .           .          .     .  };
            .      .    .           .          .      .           .          .     .  void Solver::reduceDB()
           24      4    4           0          0      0          16          0     0  {
            .      .    .           .          .      .           .          .     .      int     i, j;
            .      .    .           .          .      .           .          .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
            .      .    .           .          .      .           .          .     .      //local_learnts_dirty = false;
            .      .    .           .          .      .           .          .     .  
            4      0    0           0          0      0           0          0     0      sort(learnts_local, reduceDB_lt(ca));
            .      .    .           .          .      .           .          .     .  
           20      0    0           4          4      0           0          0     0      int limit = learnts_local.size() / 2;
      137,880      4    4           0          0      0           0          0     0      for (i = j = 0; i < learnts_local.size(); i++){
      206,790      4    4     137,860      4,313      0           0          0     0          Clause& c = ca[learnts_local[i]];
      137,860      0    0      68,930     68,758     27           0          0     0          if (c.mark() == LOCAL)
      263,972      0    0      68,605          0      0           0          0     0              if (c.removable() && !locked(c) && i < limit)
      171,470      0    0      34,294          0      0      34,294          0     0                  removeClause(learnts_local[i]);
            .      .    .           .          .      .           .          .     .              else{
        5,069      0    0           0          0      0           0          0     0                  if (!c.removable()) limit++;
            .      .    .           .          .      .           .          .     .                  c.removable(true);
      172,205      0    0      34,311          0      0      34,311      2,167     0                  learnts_local[j++] = learnts_local[i]; }
            .      .    .           .          .      .           .          .     .      }
            4      0    0           0          0      0           0          0     0      learnts_local.shrink(i - j);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      checkGarbage();
           21      0    0          17          4      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  void Solver::reduceDB_Tier2()
           36      6    5           0          0      0          30          0     0  {
            .      .    .           .          .      .           .          .     .      int i, j;
       65,740      5    4           6          1      0           0          0     0      for (i = j = 0; i < learnts_tier2.size(); i++){
       82,647      6    5      55,098      1,727    182           0          0     0          Clause& c = ca[learnts_tier2[i]];
       55,098      0    0           0          0      0           0          0     0          if (c.mark() == TIER2)
      132,365      0    0      52,946     13,941    574           0          0     0              if (!locked(c) && c.touched() + 30000 < conflicts){
            .      .    .           .          .      .           .          .     .                  learnts_local.push(learnts_tier2[i]);
            .      .    .           .          .      .           .          .     .                  c.mark(LOCAL);
            .      .    .           .          .      .           .          .     .                  //c.removable(true);
            .      .    .           .          .      .           .          .     .                  c.activity() = 0;
            .      .    .           .          .      .           .          .     .                  claBumpActivity(c);
            .      .    .           .          .      .           .          .     .              }else
      111,230      0    0      22,246          0      0      22,246        525     0                  learnts_tier2[j++] = learnts_tier2[i];
            .      .    .           .          .      .           .          .     .      }
            6      0    0           0          0      0           0          0     0      learnts_tier2.shrink(i - j);
           36      0    0          36          6      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::removeSatisfied(vec<CRef>& cs)
          306      0    0           0          0      0         136          0     0  {
            .      .    .           .          .      .           .          .     .      int i, j;
   10,803,215     14    4   2,160,657         17      0           0          0     0      for (i = j = 0; i < cs.size(); i++){
    6,481,866      0    0   4,321,244    135,062 13,249           0          0     0          Clause& c = ca[cs[i]];
            .      .    .           .          .      .           .          .     .          if (satisfied(c))
      229,948     12    1           1          0      0      76,649        474     0              removeClause(cs[i]);
            .      .    .           .          .      .           .          .     .          else
    4,167,946      0    0           0          0      0   2,083,973     44,364     0              cs[j++] = cs[i];
            .      .    .           .          .      .           .          .     .      }
           34      0    0           0          0      0           0          0     0      cs.shrink(i - j);
          204      6    3         170         57      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
          216      0    0           0          0      0         180          0     0  {
            .      .    .           .          .      .           .          .     .      int i, j;
      344,480     17    3          36         18      0           0          0     0      for (i = j = 0; i < cs.size(); i++){
      507,993      0    0     338,662     10,614  2,201           0          0     0          Clause& c = ca[cs[i]];
      338,662      0    0           0          0      0           0          0     0          if (c.mark() == valid_mark)
            .      .    .           .          .      .           .          .     .              if (satisfied(c))
        1,516      6    0         379          0      0         379         37     0                  removeClause(cs[i]);
            .      .    .           .          .      .           .          .     .              else
      832,890      0    0     166,578          0      0     166,578      2,214     0                  cs[j++] = cs[i];
            .      .    .           .          .      .           .          .     .      }
           34      0    0           0          0      0           0          0     0      cs.shrink(i - j);
          216      6    4         216         68      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::rebuildOrderHeap()
          171      3    2           0          0      0         114          0     0  {
            .      .    .           .          .      .           .          .     .      vec<Var> vs;
    1,248,458      0    0          19          0      0          19          1     0      for (Var v = 0; v < nVars(); v++)
    3,199,764      0    0   1,599,882     19,448    750           0          0     0          if (decision[v] && value(v) == l_Undef)
            .      .    .           .          .      .           .          .     .              vs.push(v);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      order_heap_CHB  .build(vs);
            .      .    .           .          .      .           .          .     .      order_heap_VSIDS.build(vs);
            .      .    .           .          .      .           .          .     .      order_heap_distance.build(vs);
          152     19    5         133         37      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  /*_________________________________________________________________________________________________
            .      .    .           .          .      .           .          .     .  |
            .      .    .           .          .      .           .          .     .  |  simplify : [void]  ->  [bool]
            .      .    .           .          .      .           .          .     .  |  
            .      .    .           .          .      .           .          .     .  |  Description:
            .      .    .           .          .      .           .          .     .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
            .      .    .           .          .      .           .          .     .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
            .      .    .           .          .      .           .          .     .  |________________________________________________________________________________________________@*/
            .      .    .           .          .      .           .          .     .  bool Solver::simplify()
        1,482    102    3           0          0      0         988          0     0  {
            .      .    .           .          .      .           .          .     .      assert(decisionLevel() == 0);
            .      .    .           .          .      .           .          .     .  
        1,235      0    0         247         64      0           0          0     0      if (!ok || propagate() != CRef_Undef)
            .      .    .           .          .      .           .          .     .          return ok = false;
            .      .    .           .          .      .           .          .     .  
        1,071    163    6         659          0      0           0          0     0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
            .      .    .           .          .      .           .          .     .          return true;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Remove satisfied clauses:
           54      0    0           0          0      0          18          0     0      removeSatisfied(learnts_core); // Should clean core first.
           72      0    0           0          0      0          18          0     0      safeRemoveSatisfied(learnts_tier2, TIER2);
           72     18    5           0          0      0          18          0     0      safeRemoveSatisfied(learnts_local, LOCAL);
           36      0    0          18         18      0           0          0     0      if (remove_satisfied)        // Can be turned off.
           68     34    6           0          0      0          17          0     0          removeSatisfied(clauses);
            .      .    .           .          .      .           .          .     .      checkGarbage();
           36      1    1           0          0      0          18          0     0      rebuildOrderHeap();
            .      .    .           .          .      .           .          .     .  
           36      0    0          18         18      0          18          0     0      simpDB_assigns = nAssigns();
           54      0    0          36         18      0          18          0     0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
            .      .    .           .          .      .           .          .     .  
           18      0    0           0          0      0           0          0     0      return true;
        1,729      0    0       1,235          0      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  // pathCs[k] is the number of variables assigned at level k,
            .      .    .           .          .      .           .          .     .  // it is initialized to 0 at the begining and reset to 0 after the function execution
       76,440      6    1           0          0      0      57,330          0     0  bool Solver::collectFirstUIP(CRef confl){
       19,110      0    0           0          0      0       9,555          0     0      involved_lits.clear();
      613,816      9    1           0          0      0           0          0     0      int max_level=1;
            .      .    .           .          .      .           .          .     .      Clause& c=ca[confl]; int minLevel=decisionLevel();
      138,479      0    0       9,555          0      0           0          0     0      for(int i=0; i<c.size(); i++) {
            .      .    .           .          .      .           .          .     .          Var v=var(c[i]);
            .      .    .           .          .      .           .          .     .          //        assert(!seen[v]);
      135,246     58    1      45,082     15,330      0           0          0     0          if (level(v)>0) {
       85,340      0    0      42,670      7,654      1      42,670     34,523    10              seen[v]=1;
       94,895      0    0      52,225     16,971      1      42,670     41,657   532              var_iLevel_tmp[v]=1;
       42,670      0    0      42,670     23,055    125           0          0     0              pathCs[level(v)]++;
            .      .    .           .          .      .           .          .     .              if (minLevel>level(v)) {
            .      .    .           .          .      .           .          .     .                  minLevel=level(v);
            .      .    .           .          .      .           .          .     .                  assert(minLevel>0);
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              //    varBumpActivity(v);
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
       28,665      0    0      19,110      8,802      0           0          0     0      int limit=trail_lim[minLevel-1];
  205,724,420      0    0       9,555          0      0           0          0     0      for(int i=trail.size()-1; i>=limit; i--) {
  102,843,100     20    1 102,843,100  3,191,629      0           0          0     0          Lit p=trail[i]; Var v=var(p);
  102,843,100      0    0  51,421,550  6,613,265    483           0          0     0          if (seen[v]) {
            .      .    .           .          .      .           .          .     .              int currentDecLevel=level(v);
            .      .    .           .          .      .           .          .     .              //      if (currentDecLevel==decisionLevel())
            .      .    .           .          .      .           .          .     .              //      	varBumpActivity(v);
      408,793      0    0           0          0      0     408,793          0     0              seen[v]=0;
      817,586      0    0     408,793     67,989      0           0          0     0              if (--pathCs[currentDecLevel]!=0) {
            .      .    .           .          .      .           .          .     .                  Clause& rc=ca[reason(v)];
    1,160,747      7    1     834,729     54,850      0           0          0     0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
      556,486      0    0           0          0      0           0          0     0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
      683,780      0    0           0          0      0           0          0     0                  if (rc.size()==2 && value(rc[0])==l_False) {
            .      .    .           .          .      .           .          .     .                      // Special case for binary clauses
            .      .    .           .          .      .           .          .     .                      // The first one has to be SAT
            .      .    .           .          .      .           .          .     .                      assert(value(rc[1]) != l_False);
            .      .    .           .          .      .           .          .     .                      Lit tmp = rc[0];
       17,727      0    0       5,909        335      0      11,818          0     0                      rc[0] =  rc[1], rc[1] = tmp;
            .      .    .           .          .      .           .          .     .                  }
    1,919,730      0    0           0          0      0           0          0     0                  for (int j = 1; j < rc.size(); j++){
            .      .    .           .          .      .           .          .     .                      Lit q = rc[j]; Var v1=var(q);
    1,490,538      0    0           0          0      0           0          0     0                      if (level(v1) > 0) {
    1,292,276      0    0           0          0      0           0          0     0                          if (minLevel>level(v1)) {
       90,788      0    0      45,394     22,003      0           0          0     0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
            .      .    .           .          .      .           .          .     .                          }
    1,938,414      0    0   1,292,276    103,123     20           0          0     0                          if (seen[v1]) {
      560,030      0    0     280,015     35,467      0           0          0     0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
      307,578      0    0           0          0      0     153,789          0     0                                  var_iLevel_tmp[v1]=reasonVarLevel;
            .      .    .           .          .      .           .          .     .                          }
            .      .    .           .          .      .           .          .     .                          else {
      366,123      0    0           0          0      0     366,123    323,965 3,415                              var_iLevel_tmp[v1]=reasonVarLevel;
            .      .    .           .          .      .           .          .     .                              //   varBumpActivity(v1);
      366,123      0    0           0          0      0     366,123          0     0                              seen[v1] = 1;
    1,098,369      3    1     732,246     99,697    112           0          0     0                              pathCs[level(v1)]++;
            .      .    .           .          .      .           .          .     .                          }
            .      .    .           .          .      .           .          .     .                      }
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              involved_lits.push(p);
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
       28,665  1,501    1       9,555         35      0       9,555          0     0      double inc=var_iLevel_inc;
            .      .    .           .          .      .           .          .     .      vec<int> level_incs; level_incs.clear();
      496,485      0    0     187,128          0      0           0          0     0      for(int i=0;i<max_level;i++){
      206,238      4    1     103,119          0      0           0          0     0          level_incs.push(inc);
      309,357      0    0     206,238          0      0     103,119          0     0          inc = inc/my_var_decay;
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
      855,806      0    0     418,348          0      0           0          0     0      for(int i=0;i<involved_lits.size();i++){
        9,555      0    0       9,555          0      0           0          0     0          Var v =var(involved_lits[i]);
            .      .    .           .          .      .           .          .     .          //        double old_act=activity_distance[v];
            .      .    .           .          .      .           .          .     .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
    3,832,017  6,387    2   1,264,599    710,336      0     418,348          0     0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
            .      .    .           .          .      .           .          .     .  
      817,586      0    0           0          0      0           0          0     0          if(activity_distance[v]>1e100){
            .      .    .           .          .      .           .          .     .              for(int vv=0;vv<nVars();vv++)
       47,775    850    1      19,110     19,077      2      19,110          0     0                  activity_distance[vv] *= 1e-100;
            .      .    .           .          .      .           .          .     .              var_iLevel_inc*=1e-100;
       11,592     27    1           0          0      0           0          0     0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .          if (order_heap_distance.inHeap(v))
            .      .    .           .          .      .           .          .     .              order_heap_distance.decrease(v);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          //        var_iLevel_inc *= (1 / my_var_decay);
            .      .    .           .          .      .           .          .     .      }
       47,775    139    1      19,110          7      0       9,555          0     0      var_iLevel_inc=level_incs[level_incs.size()-1];
            .      .    .           .          .      .           .          .     .      return true;
       85,995      0    0      66,885      9,257      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  struct UIPOrderByILevel_Lt {
            .      .    .           .          .      .           .          .     .      Solver& solver;
            .      .    .           .          .      .           .          .     .      const vec<double>&  var_iLevel;
            .      .    .           .          .      .           .          .     .      bool operator () (Lit x, Lit y) const
            .      .    .           .          .      .           .          .     .      {
            .      .    .           .          .      .           .          .     .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
            .      .    .           .          .      .           .          .     .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
            .      .    .           .          .      .           .          .     .  |    Search for a model the specified number of conflicts. 
            .      .    .           .          .      .           .          .     .  |  
            .      .    .           .          .      .           .          .     .  |  Output:
            .      .    .           .          .      .           .          .     .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
            .      .    .           .          .      .           .          .     .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
            .      .    .           .          .      .           .          .     .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
            .      .    .           .          .      .           .          .     .  |________________________________________________________________________________________________@*/
            .      .    .           .          .      .           .          .     .  lbool Solver::search(int& nof_conflicts)
        2,453    227    6           0          0      0       1,561          8     0  {
            .      .    .           .          .      .           .          .     .      assert(ok);
            .      .    .           .          .      .           .          .     .      int         backtrack_level;
            .      .    .           .          .      .           .          .     .      int         lbd;
            .      .    .           .          .      .           .          .     .      vec<Lit>    learnt_clause;
            .      .    .           .          .      .           .          .     .      bool        cached = false;
          223      0    0         223         49      0           0          0     0      starts++;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // simplify
            .      .    .           .          .      .           .          .     .      //
          892      1    1         669        223      5           0          0     0      if (conflicts >= curSimplify * nbconfbeforesimplify){
            .      .    .           .          .      .           .          .     .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
            .      .    .           .          .      .           .          .     .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
            .      .    .           .          .      .           .          .     .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
            .      .    .           .          .      .           .          .     .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
            8      3    2           8          8      0           0          0     0          nbSimplifyAll++;
           24      8    4           0          0      0           8          0     0          if (!simplifyAll()){
            .      .    .           .          .      .           .          .     .              return l_False;
            .      .    .           .          .      .           .          .     .          }
           56      0    0          16          0      0           8          0     0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
           24      0    0           8          0      0           8          0     0          nbconfbeforesimplify += incSimplify;
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      for (;;){
            .      .    .           .          .      .           .          .     .          CRef confl = propagate();
            .      .    .           .          .      .           .          .     .  
    4,910,764      0    0           0          0      0           0          0     0          if (confl != CRef_Undef){
            .      .    .           .          .      .           .          .     .              // CONFLICT
      198,048      0    0      66,016        261      0           0          0     0              if (VSIDS){
       20,186      0    0      10,091      7,542      0           4          0     0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
            .      .    .           .          .      .           .          .     .              }else
      335,586    151    3     167,793     51,372      0      55,931          0     0                  if (step_size > min_step_size) step_size -= step_size_dec;
            .      .    .           .          .      .           .          .     .  
      264,064     54    6     132,032     60,145      0      66,016          0     0              conflicts++; nof_conflicts--;
            .      .    .           .          .      .           .          .     .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
            .      .    .           .          .      .           .          .     .              ConflictData data = FindConflictLevel(confl);
      132,032    120    5           0          0      0           0          0     0              if (data.nHighestLevel == 0) return l_False;
       16,404      0    0       7,054          2      0           0          0     0              if (data.bOnlyOneLitFromHighest)
            .      .    .           .          .      .           .          .     .              {
        1,148    166    0           0          0      0           0          0     0  				cancelUntil(data.nHighestLevel - 1);
            .      .    .           .          .      .           .          .     .  				continue;
            .      .    .           .          .      .           .          .     .  			}
            .      .    .           .          .      .           .          .     .  			
            .      .    .           .          .      .           .          .     .              learnt_clause.clear();
      129,736      0    0           0          0      0      64,868     52,111     0              if(conflicts>50000) DISTANCE=0;
            .      .    .           .          .      .           .          .     .              else DISTANCE=1;
      148,846      0    0           0          0      0           0          0     0              if(VSIDS && DISTANCE)
       38,220      6    1           0          0      0       9,555          0     0                  collectFirstUIP(confl);
            .      .    .           .          .      .           .          .     .  
      389,208     19    4           0          0      0      64,868          1     0              analyze(confl, learnt_clause, backtrack_level, lbd);
            .      .    .           .          .      .           .          .     .              // check chrono backtrack condition
      880,159     20    3     320,341     47,317      0           0          0     0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
            .      .    .           .          .      .           .          .     .              {
        6,155      0    0       6,155        402      0           0          0     0  				++chrono_backtrack;
        6,155      0    0           0          0      0           0          0     0  				cancelUntil(data.nHighestLevel -1);
            .      .    .           .          .      .           .          .     .  			}
            .      .    .           .          .      .           .          .     .  			else // default behavior
            .      .    .           .          .      .           .          .     .  			{
       58,713    589    1      58,713     29,449      0           0          0     0  				++non_chrono_backtrack;
            .      .    .           .          .      .           .          .     .  				cancelUntil(backtrack_level);
            .      .    .           .          .      .           .          .     .  			}
            .      .    .           .          .      .           .          .     .  
      194,604      0    0      64,868     55,400      0      64,868          0     0              lbd--;
      129,736      0    0      64,868          0      0           0          0     0              if (VSIDS){
        9,555      0    0           0          0      0       9,555          0     0                  cached = false;
       28,665    218    1      28,665      6,244      0           0          0     0                  conflicts_VSIDS++;
            .      .    .           .          .      .           .          .     .                  lbd_queue.push(lbd);
       76,440      0    0      28,665          0      0       9,555          0     0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
            .      .    .           .          .      .           .          .     .  
      194,604     12    4      64,868          0      0           0          0     0              if (learnt_clause.size() == 1){
          413      6    0         118         40      0          59          0     0                  uncheckedEnqueue(learnt_clause[0]);
            .      .    .           .          .      .           .          .     .              }else{
            .      .    .           .          .      .           .          .     .                  CRef cr = ca.alloc(learnt_clause, true);
       64,809      0    0      64,809          0      0           0          0     0                  ca[cr].set_lbd(lbd);
            .      .    .           .          .      .           .          .     .                  //duplicate learnts 
            .      .    .           .          .      .           .          .     .                  int  id = 0;
      129,618      0    0      64,809     63,965      3           0          0     0                  if (lbd <= max_lbd_dup){                        
            .      .    .           .          .      .           .          .     .                      std::vector<uint32_t> tmp;
    1,453,403      0    0     906,818          0      0      27,353          0     0                      for (int i = 0; i < learnt_clause.size(); i++)
      961,524     10    5     641,016          1      0     320,508          0     0                          tmp.push_back(learnt_clause[i].x);
       82,059      8    1      27,353          0      0      27,353          0     0                      id = is_duplicate(tmp);             
      136,765      0    0      27,353          0      0           0          0     0                      if (id == min_number_of_learnts_copies +1){
            .      .    .           .          .      .           .          .     .                          duplicates_added_conflicts++;                        
            .      .    .           .          .      .           .          .     .                      }                    
       54,706      0    0           0          0      0           0          0     0                      if (id == min_number_of_learnts_copies){
            .      .    .           .          .      .           .          .     .                          duplicates_added_tier2++;
            .      .    .           .          .      .           .          .     .                      }                                        
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .                  //duplicate learnts
            .      .    .           .          .      .           .          .     .  
      367,778      0    0     124,349     15,421      3           0          0     0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
           18      6    3           0          0      0           0          0     0                      learnts_core.push(cr);
            .      .    .           .          .      .           .          .     .                      ca[cr].mark(CORE);
      210,270  2,838    4           0          0      0           0          0     0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
           19      3    1           0          0      0           0          0     0                      learnts_tier2.push(cr);
            .      .    .           .          .      .           .          .     .                      ca[cr].mark(TIER2);
       55,780      0    0      13,945          5      0      13,945          2     0                      ca[cr].touched() = conflicts;
            .      .    .           .          .      .           .          .     .                  }else{
           23     21    3           0          0      0           0          0     0                      learnts_local.push(cr);
            .      .    .           .          .      .           .          .     .                      claBumpActivity(ca[cr]); }
      194,427  1,801    5           0          0      0      64,809          0     0                  attachClause(cr);
            .      .    .           .          .      .           .          .     .  
      388,854      0    0     194,427         40      0      64,809          0     0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
            .      .    .           .          .      .           .          .     .  #ifdef PRINT_OUT
            .      .    .           .          .      .           .          .     .                  std::cout << "new " << ca[cr] << "\n";
            .      .    .           .          .      .           .          .     .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
            .      .    .           .          .      .           .          .     .  #endif                
            .      .    .           .          .      .           .          .     .              }
      194,604      0    0      64,868      9,491      2           0          0     0              if (drup_file){
            .      .    .           .          .      .           .          .     .  #ifdef BIN_DRUP
            .      .    .           .          .      .           .          .     .                  binDRUP('a', learnt_clause, drup_file);
            .      .    .           .          .      .           .          .     .  #else
            .      .    .           .          .      .           .          .     .                  for (int i = 0; i < learnt_clause.size(); i++)
            .      .    .           .          .      .           .          .     .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
            .      .    .           .          .      .           .          .     .                  fprintf(drup_file, "0\n");
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
      194,604    291    3     129,736      8,634      2           0          0     0              if (VSIDS) varDecayActivity();
            .      .    .           .          .      .           .          .     .              claDecayActivity();
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              /*if (--learntsize_adjust_cnt == 0){
            .      .    .           .          .      .           .          .     .                  learntsize_adjust_confl *= learntsize_adjust_inc;
            .      .    .           .          .      .           .          .     .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
            .      .    .           .          .      .           .          .     .                  max_learnts             *= learntsize_inc;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
            .      .    .           .          .      .           .          .     .                             (int)conflicts,
            .      .    .           .          .      .           .          .     .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
            .      .    .           .          .      .           .          .     .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
            .      .    .           .          .      .           .          .     .              }*/
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .          }else{
            .      .    .           .          .      .           .          .     .              // NO CONFLICT
            .      .    .           .          .      .           .          .     .              bool restart = false;
    7,168,098      9    2   2,389,366      2,529      0           0          0     0              if (!VSIDS)
            .      .    .           .          .      .           .          .     .                  restart = nof_conflicts <= 0;
    2,567,224      1    1   1,283,612     12,439      0           0          0     0              else if (!cached){
       72,558      1    0      21,355      4,433      0       5,081          0     0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
            .      .    .           .          .      .           .          .     .                  cached = true;
            .      .    .           .          .      .           .          .     .              }
    3,317,262      0    0   1,105,754     85,120      3           0          0     0              if (restart /*|| !withinBudget()*/){
            .      .    .           .          .      .           .          .     .                  lbd_queue.clear();
            .      .    .           .          .      .           .          .     .                  cached = false;
            .      .    .           .          .      .           .          .     .                  // Reached bound on number of conflicts:
          666      0    0           0          0      0         444          0     0                  progress_estimate = progressEstimate();
            .      .    .           .          .      .           .          .     .                  cancelUntil(0);
          444      0    0           0          0      0           0          0     0                  return l_Undef; }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Simplify the set of problem clauses:
    7,172,094     33    5   2,389,144          0      0       3,925          0     0              if (decisionLevel() == 0 && !simplify())
            .      .    .           .          .      .           .          .     .                  return l_False;
            .      .    .           .          .      .           .          .     .  
    7,167,432     33    1   4,778,288      3,914      0           0          0     0              if (conflicts >= next_T2_reduce){
           12      0    0           0          0      0           6          0     0                  next_T2_reduce = conflicts + 10000;
           24      0    0           6          0      0           6          0     0                  reduceDB_Tier2(); }
    4,778,288     17    1   2,389,144          0      0           0          0     0              if (conflicts >= next_L_reduce){
            8      0    0           0          0      0           4          0     0                  next_L_reduce = conflicts + 15000;
            8      0    0           0          0      0           4          0     0                  reduceDB(); }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              Lit next = lit_Undef;
            .      .    .           .          .      .           .          .     .              /*while (decisionLevel() < assumptions.size()){
            .      .    .           .          .      .           .          .     .                  // Perform user provided assumption:
            .      .    .           .          .      .           .          .     .                  Lit p = assumptions[decisionLevel()];
            .      .    .           .          .      .           .          .     .                  if (value(p) == l_True){
            .      .    .           .          .      .           .          .     .                      // Dummy decision level:
            .      .    .           .          .      .           .          .     .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
            .      .    .           .          .      .           .          .     .                  }else{
            .      .    .           .          .      .           .          .     .                      next = p;
            .      .    .           .          .      .           .          .     .                      break;
            .      .    .           .          .      .           .          .     .                  }
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              if (next == lit_Undef)*/{
            .      .    .           .          .      .           .          .     .                  // New variable decision:
    2,389,144      0    0   2,389,144          4      1           0          0     0                  decisions++;
    7,167,432    335    4           0          0      0   2,389,144          0     0                  next = pickBranchLit();
            .      .    .           .          .      .           .          .     .  
    4,778,288      0    0           0          0      0           0          0     0                  if (next == lit_Undef)
            .      .    .           .          .      .           .          .     .                      // Model found:
            2      0    0           0          0      0           0          0     0                      return l_True;
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .              // Increase decision level and enqueue 'next'
            .      .    .           .          .      .           .          .     .              newDecisionLevel();
   14,334,858     10    1   2,389,143          0      0   2,389,143          0     0              uncheckedEnqueue(next, decisionLevel());
            .      .    .           .          .      .           .          .     .  #ifdef PRINT_OUT            
            .      .    .           .          .      .           .          .     .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
            .      .    .           .          .      .           .          .     .  #endif            
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
        2,007     38    3       1,561        446      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  double Solver::progressEstimate() const
        1,332      2    1           0          0      0       1,110          0     0  {
          444      0    0           0          0      0           0          0     0      double  progress = 0;
        1,110      0    0         444         44      0         222          0     0      double  F = 1.0 / nVars();
            .      .    .           .          .      .           .          .     .  
      930,522      2    1           0          0      0           0          0     0      for (int i = 0; i <= decisionLevel(); i++){
      929,190      0    0     619,164          0      0           0          0     0          int beg = i == 0 ? 0 : trail_lim[i - 1];
    1,238,994      0    0     619,386     19,554    229           0          0     0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
    1,859,490      8    4     310,026          0      0           0          0     0          progress += pow(F, i) * (end - beg);
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
          444      0    0           0          0      0           0          0     0      return progress / nVars();
        1,554      0    0       1,332          0      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  /*
            .      .    .           .          .      .           .          .     .    Finite subsequences of the Luby-sequence:
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .    0: 1
            .      .    .           .          .      .           .          .     .    1: 1 1 2
            .      .    .           .          .      .           .          .     .    2: 1 1 2 1 1 2 4
            .      .    .           .          .      .           .          .     .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .   */
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  static double luby(double y, int x){
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Find the finite subsequence that contains index 'x', and the
            .      .    .           .          .      .           .          .     .      // size of that subsequence:
            .      .    .           .          .      .           .          .     .      int size, seq;
        5,683      0    0           0          0      0           0          0     0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
            .      .    .           .          .      .           .          .     .  
        3,097      0    0           0          0      0           0          0     0      while (size-1 != x){
        1,614      0    0           0          0      0           0          0     0          size = (size-1)>>1;
          807      0    0           0          0      0           0          0     0          seq--;
        2,421      0    0           0          0      0           0          0     0          x = x % size;
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      return pow(y, seq);
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  static bool switch_mode = false;
            .      .    .           .          .      .           .          .     .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
            .      .    .           .          .      .           .          .     .  
-- line 2204 ----------------------------------------
-- line 2221 ----------------------------------------
            .      .    .           .          .      .           .          .     .      for (auto i=0;i<tmp.size();i++){
            .      .    .           .          .      .           .          .     .          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .      return removed_duplicates;
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  // NOTE: assumptions passed in member-variable 'assumptions'.
            .      .    .           .          .      .           .          .     .  lbool Solver::solve_()
            8      0    0           0          0      0           6          0     0  {
            .      .    .           .          .      .           .          .     .      //signal(SIGALRM, SIGALRM_switch);
            .      .    .           .          .      .           .          .     .      //alarm(2500);
            .      .    .           .          .      .           .          .     .  
            1      1    1           0          0      0           0          0     0      model.clear();
            .      .    .           .          .      .           .          .     .      conflict.clear();
            2      1    1           1          0      0           0          0     0      if (!ok) return l_False;
            .      .    .           .          .      .           .          .     .  
            1      1    1           1          1      1           0          0     0      solves++;
            .      .    .           .          .      .           .          .     .  
            5      0    0           2          0      0           1          0     0      max_learnts               = nClauses() * learntsize_factor;
            3      0    0           1          1      1           0          0     0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
            1      0    0           0          0      0           1          1     1      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
            .      .    .           .          .      .           .          .     .      lbool   status            = l_Undef;
            .      .    .           .          .      .           .          .     .  
            3      0    0           1          0      0           0          0     0      if (verbosity >= 1){
            2      0    0           0          0      0           1          0     0          printf("c ============================[ Search Statistics ]==============================\n");
            2      1    1           0          0      0           1          0     0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
            2      0    0           0          0      0           1          0     0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
            2      0    0           0          0      0           1          0     0          printf("c ===============================================================================\n");
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      add_tmp.clear();
            .      .    .           .          .      .           .          .     .  
            1      0    0           0          0      0           1          1     0      VSIDS = true;
            1      1    1           0          0      0           1          0     0      int init = 10000;
          250      0    0          50          0      0           0          0     0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
          200      4    0           0          0      0          50          0     0          status = search(init);
            1      0    0           0          0      0           1          0     0      VSIDS = false;
            .      .    .           .          .      .           .          .     .  
            3      1    1           0          0      0           2          1     0      duplicates_added_conflicts = 0;
            .      .    .           .          .      .           .          .     .      duplicates_added_minimization=0;
            .      .    .           .          .      .           .          .     .      duplicates_added_tier2 =0;    
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      dupl_db_size=0;
            1      0    0           1          1      0           0          0     0      size_t dupl_db_size_limit = dupl_db_init_size;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // Search:
            1      0    0           0          0      0           0          0     0      int curr_restarts = 0;
            1      0    0           0          0      0           0          0     0      uint64_t curr_props = 0;
            .      .    .           .          .      .           .          .     .      uint32_t removed_duplicates =0;
          346    173    4           0          0      0           0          0     0      while (status == l_Undef /*&& withinBudget()*/){
          346      1    1         173          1      0           0          0     0          if (dupl_db_size >= dupl_db_size_limit){    
            .      .    .           .          .      .           .          .     .              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
            .      .    .           .          .      .           .          .     .              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
            .      .    .           .          .      .           .          .     .              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
            .      .    .           .          .      .           .          .     .              printf("c Duptime: %i\n",duptime.count());
            .      .    .           .          .      .           .          .     .              printf("c Number of conflicts: %i\n",conflicts);
            .      .    .           .          .      .           .          .     .              printf("c Core size: %i\n",learnts_core.size());
            .      .    .           .          .      .           .          .     .              
            .      .    .           .          .      .           .          .     .              removed_duplicates = reduceduplicates();
            .      .    .           .          .      .           .          .     .              dupl_db_size_limit*=1.1;
            .      .    .           .          .      .           .          .     .              dupl_db_size -= removed_duplicates;
            .      .    .           .          .      .           .          .     .              printf("c removed duplicates %i\n",removed_duplicates);
            .      .    .           .          .      .           .          .     .          }   
        1,038     18    4         346        174      0           0          0     0          if (propagations - curr_props >  VSIDS_props_limit){
            .      .    .           .          .      .           .          .     .              curr_props = propagations;
            .      .    .           .          .      .           .          .     .              switch_mode = true;
            1      0    0           0          0      0           0          0     0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
            .      .    .           .          .      .           .          .     .          }     
          346      0    0         173          1      0           0          0     0          if (VSIDS){
            .      .    .           .          .      .           .          .     .              int weighted = INT32_MAX;
            .      .    .           .          .      .           .          .     .              status = search(weighted);
            .      .    .           .          .      .           .          .     .          }else{
        1,038    170    6         346          0      0         173          0     0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          173      0    0           0          0      0           0          0     0              curr_restarts++;
          865    172    5           0          0      0         173          0     0              status = search(nof_conflicts);
            .      .    .           .          .      .           .          .     .          }
          346    172    3         173        173      6           0          0     0          if (switch_mode){ 
            .      .    .           .          .      .           .          .     .              switch_mode = false;
            .      .    .           .          .      .           .          .     .              VSIDS = !VSIDS;
            .      .    .           .          .      .           .          .     .              if (VSIDS){
            .      .    .           .          .      .           .          .     .                  printf("c Switched to VSIDS.\n");
            .      .    .           .          .      .           .          .     .              }
            .      .    .           .          .      .           .          .     .              else{
            .      .    .           .          .      .           .          .     .                 printf("c Switched to LRB.\n");
            .      .    .           .          .      .           .          .     .              }
-- line 2305 ----------------------------------------
-- line 2309 ----------------------------------------
            .      .    .           .          .      .           .          .     .              conflicted.clear();
            .      .    .           .          .      .           .          .     .              almost_conflicted.clear();
            .      .    .           .          .      .           .          .     .  #ifdef ANTI_EXPLORATION
            .      .    .           .          .      .           .          .     .              canceled.clear();
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            3      1    1           1          1      0           0          0     0      if (verbosity >= 1)
            2      0    0           0          0      0           1          0     0          printf("c ===============================================================================\n");
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  #ifdef BIN_DRUP
            3      0    0           1          0      0           0          0     0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
            .      .    .           .          .      .           .          .     .  #endif
            .      .    .           .          .      .           .          .     .  
            2      1    1           0          0      0           0          0     0      if (status == l_True){
            .      .    .           .          .      .           .          .     .          // Extend & copy model:
            .      .    .           .          .      .           .          .     .          model.growTo(nVars());
        4,125      0    0       2,054        514     13       2,057        500     0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
            .      .    .           .          .      .           .          .     .      }else if (status == l_False && conflict.size() == 0)
            .      .    .           .          .      .           .          .     .          ok = false;
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      cancelUntil(0);
            1      0    0           0          0      0           0          0     0      return status;
            8      1    1           7          1      1           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  //=================================================================================================
            .      .    .           .          .      .           .          .     .  // Writing CNF to DIMACS:
            .      .    .           .          .      .           .          .     .  // 
            .      .    .           .          .      .           .          .     .  // FIXME: this needs to be rewritten completely.
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  static Var mapVar(Var x, vec<Var>& map, Var& max)
            .      .    .           .          .      .           .          .     .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
            .      .    .           .          .      .           .          .     .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
            .      .    .           .          .      .           .          .     .  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  //=================================================================================================
            .      .    .           .          .      .           .          .     .  // Garbage Collection methods:
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::relocAll(ClauseAllocator& to)
           90     10    8           0          0      0          72          0     0  {
            .      .    .           .          .      .           .          .     .      // All watchers:
            .      .    .           .          .      .           .          .     .      //
            .      .    .           .          .      .           .          .     .      // for (int i = 0; i < watches.size(); i++)
           18      0    0           0          0      0           9          0     0      watches.cleanAll();
           18      0    0           0          0      0           9          0     0      watches_bin.cleanAll();
    2,956,734     14   11   2,069,685        358      0     295,686          8     0      for (int v = 0; v < nVars(); v++)
    1,182,672      0    0     591,336          0      0           0          0     0          for (int s = 0; s < 2; s++){
            .      .    .           .          .      .           .          .     .              Lit p = mkLit(v, s);
            .      .    .           .          .      .           .          .     .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
            .      .    .           .          .      .           .          .     .              vec<Watcher>& ws = watches[p];
   12,953,750      6    5   5,327,864    147,843 35,168           0          0     0              for (int j = 0; j < ws.size(); j++)
            .      .    .           .          .      .           .          .     .                  ca.reloc(ws[j].cref, to);
            .      .    .           .          .      .           .          .     .              vec<Watcher>& ws_bin = watches_bin[p];
    5,967,823      8    5   2,393,796    148,101 40,921           0          0     0              for (int j = 0; j < ws_bin.size(); j++)
            .      .    .           .          .      .           .          .     .                  ca.reloc(ws_bin[j].cref, to);
            .      .    .           .          .      .           .          .     .          }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // All reasons:
            .      .    .           .          .      .           .          .     .      //
       85,578      0    0          27          0      0           0          0     0      for (int i = 0; i < trail.size(); i++){
            .      .    .           .          .      .           .          .     .          Var v = var(trail[i]);
            .      .    .           .          .      .           .          .     .  
      112,672      0    0      13,576     11,613     50           0          0     0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
       67,898      0    0      13,576          0      0      13,576          3     1              ca.reloc(vardata[v].reason, to);
            .      .    .           .          .      .           .          .     .      }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // All learnt:
            .      .    .           .          .      .           .          .     .      //
       36,169     12   10      18,078         16      3           0          0     0      for (int i = 0; i < learnts_core.size(); i++)
            .      .    .           .          .      .           .          .     .          ca.reloc(learnts_core[i], to);
       34,968     26   18      17,482         22      4           0          0     0      for (int i = 0; i < learnts_tier2.size(); i++)
            .      .    .           .          .      .           .          .     .          ca.reloc(learnts_tier2[i], to);
       69,358      9    6      34,663          5      0           0          0     0      for (int i = 0; i < learnts_local.size(); i++)
      103,935      0    0           0          0      0      34,645          0     0          ca.reloc(learnts_local[i], to);
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      // All original:
            .      .    .           .          .      .           .          .     .      //
            .      .    .           .          .      .           .          .     .      int i, j;
    2,538,713      9    5          36          5      0           0          0     0      for (i = j = 0; i < clauses.size(); i++)
    2,538,632      0    0           0          0      0           0          0     0          if (ca[clauses[i]].mark() != 1){
    3,807,966      8    7   1,269,316          5      0   1,269,316          0     0              ca.reloc(clauses[i], to);
   12,693,151      8    6   5,077,255          0      0   1,269,316          0     0              clauses[j++] = clauses[i]; }
            9      8    6           0          0      0           0          0     0      clauses.shrink(i - j);
           72      8    6          63          9      0           0          0     0  }
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .  void Solver::garbageCollect()
            .      .    .           .          .      .           .          .     .  {
            .      .    .           .          .      .           .          .     .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
            .      .    .           .          .      .           .          .     .      // is not precise but should avoid some unnecessary reallocations for the new region:
            .      .    .           .          .      .           .          .     .      ClauseAllocator to(ca.size() - ca.wasted());
            .      .    .           .          .      .           .          .     .  
            .      .    .           .          .      .           .          .     .      relocAll(to);
            .      .    .           .          .      .           .          .     .      if (verbosity >= 2)
            .      .    .           .          .      .           .          .     .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
            .      .    .           .          .      .           .          .     .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
            .      .    .           .          .      .           .          .     .      to.moveTo(ca);
          155     18   18          47          4      4          61          0     0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir          I1mr  ILmr Dr          D1mr      DLmr    Dw        D1mw DLmw 

-- line 40 ----------------------------------------
          .     .    .           .         .       .         .    .    .      void capacity(uint32_t min_cap);
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .   public:
          .     .    .           .         .       .         .    .    .      // TODO: make this a class for better type-checking?
          .     .    .           .         .       .         .    .    .      typedef uint32_t Ref;
          .     .    .           .         .       .         .    .    .      enum { Ref_Undef = UINT32_MAX };
          .     .    .           .         .       .         .    .    .      enum { Unit_Size = sizeof(uint32_t) };
          .     .    .           .         .       .         .    .    .  
         51     1    1           0         0       0        40    0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
          .     .    .           .         .       .         .    .    .      ~RegionAllocator()
          .     .    .           .         .       .         .    .    .      {
          .     .    .           .         .       .         .    .    .          if (memory != NULL)
          .     .    .           .         .       .         .    .    .              ::free(memory);
          .     .    .           .         .       .         .    .    .      }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .      uint32_t size      () const      { return sz; }
          .     .    .           .         .       .         .    .    .      uint32_t wasted    () const      { return wasted_; }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .      Ref      alloc     (int size); 
    812,607     0    0     270,837         0       0   270,837    0    0      void     free      (int size)    { wasted_ += size; }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
398,450,312   101   31 218,285,713 1,153,407 148,280   347,102    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
  1,551,930     0    0   1,551,930   275,975  27,317         0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
          .     .    .           .         .       .         .    .    .  
  5,312,274 6,790    3     410,068         0       0         0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     50,877     0    0           0         0       0         0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
          .     .    .           .         .       .         .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
          .     .    .           .         .       .         .    .    .          return  (Ref)(t - &memory[0]); }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .      void     moveTo(RegionAllocator& to) {
         36     0    0           9         0       0         9    0    0          if (to.memory != NULL) ::free(to.memory);
         18     0    0           9         0       0         9    0    0          to.memory = memory;
         18     0    0           9         0       0         9    0    0          to.sz = sz;
          .     .    .           .         .       .         .    .    .          to.cap = cap;
         18     0    0           9         0       0         9    0    0          to.wasted_ = wasted_;
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .          memory = NULL;
          .     .    .           .         .       .         .    .    .          sz = cap = wasted_ = 0;
          .     .    .           .         .       .         .    .    .      }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  };
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  template<class T>
        102    13    7           0         0       0        34    6    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
          .     .    .           .         .       .         .    .    .  {
  5,247,501     6    4   1,749,165         0       0         0    0    0      if (cap >= min_cap) return;
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .      uint32_t prev_cap = cap;
        601     0    0           0         0       0        19    0    0      while (cap < min_cap){
          .     .    .           .         .       .         .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
          .     .    .           .         .       .         .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
          .     .    .           .         .       .         .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
          .     .    .           .         .       .         .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
      1,746     0    0           0         0       0         0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
        291     0    0           0         0       0         0    0    0          cap += delta;
          .     .    .           .         .       .         .    .    .  
        582     0    0           0         0       0         0    0    0          if (cap <= prev_cap)
          .     .    .           .         .       .         .    .    .              throw OutOfMemoryException();
          .     .    .           .         .       .         .    .    .      }
          .     .    .           .         .       .         .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .      assert(cap > 0);
         40     5    3           0         0       0        19    9    2      memory = (T*)xrealloc(memory, sizeof(T)*cap);
         68     0    0          51         0       0         0    0    0  }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  template<class T>
          .     .    .           .         .       .         .    .    .  typename RegionAllocator<T>::Ref
  1,381,032     4    1           0         0       0 1,035,774    0    0  RegionAllocator<T>::alloc(int size)
          .     .    .           .         .       .         .    .    .  { 
          .     .    .           .         .       .         .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
          .     .    .           .         .       .         .    .    .      assert(size > 0);
  8,919,466     0    0   1,749,155    56,979       0 4,082,063    3    0      capacity(sz + size);
          .     .    .           .         .       .         .    .    .  
  4,276,501     0    0   2,742,979         0       0         0    0    0      uint32_t prev_sz = sz;
  1,749,155     4    1           0         0       0 1,749,155    0    0      sz += size;
          .     .    .           .         .       .         .    .    .      
          .     .    .           .         .       .         .    .    .      // Handle overflow:
  7,515,561    16   11   1,339,084         0       0         0    0    0      if (sz < prev_sz)
          2     1    1           1         1       1         0    0    0          throw OutOfMemoryException();
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .      return prev_sz;
  1,381,032     0    0   1,381,032         0       0         0    0    0  }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  //=================================================================================================
          .     .    .           .         .       .         .    .    .  }
          .     .    .           .         .       .         .    .    .  
          .     .    .           .         .       .         .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../utils/ParseUtils.h
--------------------------------------------------------------------------------
Ir         I1mr ILmr Dr        D1mr   DLmr   Dw        D1mw DLmw 

-- line 36 ----------------------------------------
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  class StreamBuffer {
         .    .    .         .      .      .         .    .    .      gzFile        in;
         .    .    .         .      .      .         .    .    .      unsigned char buf[buffer_size];
         .    .    .         .      .      .         .    .    .      int           pos;
         .    .    .         .      .      .         .    .    .      int           size;
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .      void assureLookahead() {
 7,593,710    1    1         0      0      0         0    0    0          if (pos >= size) {
         4    0    0         0      0      0         4    0    0              pos  = 0;
 5,303,914    2    2 2,727,569      0      0        10    0    0              size = gzread(in, buf, sizeof(buf)); } }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  public:
         2    0    0         0      0      0         2    1    1      explicit StreamBuffer(gzFile i) : in(i), pos(0), size(0) { assureLookahead(); }
         .    .    .         .      .      .         .    .    .  
25,112,485    4    4 5,133,553 54,648 14,995         0    0    0      int  operator *  () const { return (pos >= size) ? EOF : buf[pos]; }
 7,422,426    2    2         0      0      0 3,626,047    0    0      void operator ++ ()       { pos++; assureLookahead(); }
         .    .    .         .      .      .         .    .    .      int  position    () const { return pos; }
         .    .    .         .      .      .         .    .    .  };
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  //-------------------------------------------------------------------------------------------------
         .    .    .         .      .      .         .    .    .  // End-of-file detection functions for StreamBuffer and char*:
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  
-- line 60 ----------------------------------------
-- line 62 ----------------------------------------
         .    .    .         .      .      .         .    .    .  static inline bool isEof(const char*   in) { return *in == '\0'; }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  //-------------------------------------------------------------------------------------------------
         .    .    .         .      .      .         .    .    .  // Generic parse functions parametrized over the input-stream type.
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  template<class B>
         .    .    .         .      .      .         .    .    .  static void skipWhitespace(B& in) {
 8,133,512    0    0         0      0      0         0    0    0      while ((*in >= 9 && *in <= 13) || *in == 32)
         .    .    .         .      .      .         .    .    .          ++in; }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  template<class B>
         .    .    .         .      .      .         .    .    .  static void skipLine(B& in) {
         .    .    .         .      .      .         .    .    .      for (;;){
         .    .    .         .      .      .         .    .    .          if (isEof(in)) return;
       726    0    0       244      0      0         0    0    0          if (*in == '\n') { ++in; return; }
         .    .    .         .      .      .         .    .    .          ++in; } }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  template<class B>
 6,706,936    2    2 1,490,431     46      0 2,980,860    0    0  static int parseInt(B& in) {
   745,215    0    0         0      0      0         0    0    0      int     val = 0;
   421,627    0    0         0      0      0         0    0    0      bool    neg = false;
         .    .    .         .      .      .         .    .    .      skipWhitespace(in);
 2,137,606    1    1         0      0      0         0    0    0      if      (*in == '-') neg = true, ++in;
   843,254    0    0         0      0      0         0    0    0      else if (*in == '+') ++in;
 2,980,860    1    1   745,215  4,727  1,199         0    0    0      if (*in < '0' || *in > '9') fprintf(stderr, "PARSE ERROR! Unexpected char: %c\n", *in), exit(3);
10,418,337    0    0         0      0      0         0    0    0      while (*in >= '0' && *in <= '9')
 5,455,128    0    0         0      0      0         0    0    0          val = val*10 + (*in - '0'),
         .    .    .         .      .      .         .    .    .          ++in;
 8,197,365    1    1 3,726,075      0      0         0    0    0      return neg ? -val : val; }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  // String matching: in case of a match the input iterator will be advanced the corresponding
         .    .    .         .      .      .         .    .    .  // number of characters.
         .    .    .         .      .      .         .    .    .  template<class B>
         .    .    .         .      .      .         .    .    .  static bool match(B& in, const char* str) {
         .    .    .         .      .      .         .    .    .      int i;
         .    .    .         .      .      .         .    .    .      for (i = 0; str[i] != '\0'; i++)
        72    6    6        35      1      0         0    0    0          if (in[i] != str[i])
         .    .    .         .      .      .         .    .    .              return false;
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .      in += i;
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .      return true; 
         .    .    .         .      .      .         .    .    .  }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  // String matching: consumes characters eagerly, but does not require random access iterator.
         .    .    .         .      .      .         .    .    .  template<class B>
         .    .    .         .      .      .         .    .    .  static bool eagerMatch(B& in, const char* str) {
        25    1    1         9      1      1         0    0    0      for (; *str != '\0'; ++str, ++in)
        10    0    0         0      0      0         0    0    0          if (*str != *in)
         .    .    .         .      .      .         .    .    .              return false;
         .    .    .         .      .      .         .    .    .      return true; }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  //=================================================================================================
         .    .    .         .      .      .         .    .    .  }
         .    .    .         .      .      .         .    .    .  
         .    .    .         .      .      .         .    .    .  #endif
-- line 122 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir            I1mr  ILmr Dr          D1mr       DLmr    Dw          D1mw       DLmw    

-- line 54 ----------------------------------------
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  struct Lit {
            .     .    .           .          .       .           .          .       .      int     x;
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      // Use this as a constructor:
            .     .    .           .          .       .           .          .       .      friend Lit mkLit(Var var, bool sign );
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      bool operator == (Lit p) const { return x == p.x; }
   10,947,678     0    0   5,611,818  2,788,713     693           0          0       0      bool operator != (Lit p) const { return x != p.x; }
            .     .    .           .          .       .           .          .       .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
            .     .    .           .          .       .           .          .       .  };
            .     .    .           .          .       .           .          .       .  
    6,717,436     0    0           0          0       0      15,149          0       0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
  260,096,249    21   11  51,397,676      4,820      14  49,092,540     27,475       0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
            .     .    .           .          .       .           .          .       .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
1,207,473,074    20    6 119,955,850          0       0  60,045,126 20,984,978   2,430  inline  bool sign      (Lit p)              { return p.x & 1; }
3,043,666,049 7,070   30 267,343,005  6,884,687   2,384 208,337,776          0       0  inline  int  var       (Lit p)              { return p.x >> 1; }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  // Mapping Literals to and from compact integers suitable for array indexing:
            .     .    .           .          .       .           .          .       .  inline  int  toInt     (Var v)              { return v; } 
      192,481     1    1      27,334          0       0      27,336        817     343  inline  int  toInt     (Lit p)              { return p.x; } 
            .     .    .           .          .       .           .          .       .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
            .     .    .           .          .       .           .          .       .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
            .     .    .           .          .       .           .          .       .  const Lit lit_Error = { -1 };  // }
            .     .    .           .          .       .           .          .       .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
            .     .    .           .          .       .           .          .       .  #define l_Undef (lbool((uint8_t)2))
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  class lbool {
            .     .    .           .          .       .           .          .       .      uint8_t value;
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  public:
            .     .    .           .          .       .           .          .       .      explicit lbool(uint8_t v) : value(v) { }
            .     .    .           .          .       .           .          .       .  
        8,227     1    1           0          0       0       2,057        513     512      lbool()       : value(0) { }
            .     .    .           .          .       .           .          .       .      explicit lbool(bool x) : value(!x) { }
            .     .    .           .          .       .           .          .       .  
   58,841,705     1    1           0          0       0           0          0       0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
       98,556     0    0      65,704        514       0           0          0       0      bool  operator != (lbool b) const { return !(*this == b); }
  511,046,173     8    4 490,534,239 60,209,619   1,012           0          0       0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      lbool operator && (lbool b) const {
            .     .    .           .          .       .           .          .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
            .     .    .           .          .       .           .          .       .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
            .     .    .           .          .       .           .          .       .          return lbool(v); }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      lbool operator || (lbool b) const {
            .     .    .           .          .       .           .          .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
            .     .    .           .          .       .           .          .       .          unsigned simplified : 1;}                            header;
            .     .    .           .          .       .           .          .       .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      friend class ClauseAllocator;
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
            .     .    .           .          .       .           .          .       .      template<class V>
            .     .    .           .          .       .           .          .       .      Clause(const V& ps, bool use_extra, bool learnt) {
    6,802,194     0    0   1,684,346          0       0   1,749,155      3,794       1          header.mark      = 0;
    4,017,261     3    3   1,339,087     83,650  53,216           0          0       0          header.learnt    = learnt;
   10,451,335     2    2   2,029,605         14       0   1,684,346          0       0          header.has_extra = learnt | use_extra;
            .     .    .           .          .       .           .          .       .          header.reloced   = 0;
    2,159,221     0    0     410,067          8       2   1,749,154    102,468  45,812          header.size      = ps.size();
            .     .    .           .          .       .           .          .       .          header.lbd       = 0;
            .     .    .           .          .       .           .          .       .          header.removable = 1;
            .     .    .           .          .       .           .          .       .          //simplify
            .     .    .           .          .       .           .          .       .          //
    1,749,155     5    3   1,749,155    192,031 130,820           0          0       0          header.simplified = 0;
            .     .    .           .          .       .           .          .       .  
   64,482,202    31   24   1,736,961          0       0           0          0       0          for (int i = 0; i < ps.size(); i++)
   36,384,283    40    8  11,459,675  1,024,566  95,234  15,309,832  1,302,928 985,219              data[i].lit = ps[i];
            .     .    .           .          .       .           .          .       .  
    5,247,464    19   14   1,749,154          0       0           0          0       0          if (header.has_extra){
    1,964,296     0    0           0          0       0           0          0       0              if (header.learnt){
      269,154     1    1      69,763          0       0     134,577      8,613   5,815                  data[header.size].act = 0;
      269,159     0    0           0          0       0     134,577      8,300   5,596                  data[header.size+1].touched = 0;
            .     .    .           .          .       .           .          .       .              }else
            .     .    .           .          .       .           .          .       .                  calcAbstraction(); }
            .     .    .           .          .       .           .          .       .      }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  public:
            .     .    .           .          .       .           .          .       .      void calcAbstraction() {
            .     .    .           .          .       .           .          .       .          assert(header.has_extra);
      875,563     0    0           0          0       0           0          0       0          uint32_t abstraction = 0;
   16,434,736     8    6     507,686          0       0           0          0       0          for (int i = 0; i < size(); i++)
   24,936,731     5    4           0          0       0           1          0       0              abstraction |= 1 << (var(data[i].lit) & 31);
    3,230,064     0    0     502,310          0       0   1,377,876     57,967  57,965          data[header.size].abs = abstraction;  }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
  396,306,917    87   37 124,318,129 31,733,114  11,661  53,798,962          6       0      int          size        ()      const   { return header.size; }
      382,722    21    7     101,040      5,082       0     101,040        313       0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
            .     .    .           .          .       .           .          .       .      void         pop         ()              { shrink(1); }
    5,629,603     8    7     773,147         27       0           0          0       0      bool         learnt      ()      const   { return header.learnt; }
      471,182     0    0           0          0       0           0          0       0      bool         has_extra   ()      const   { return header.has_extra; }
   20,778,518    63   13   7,961,206  4,760,944  77,719     860,695          0       0      uint32_t     mark        ()      const   { return header.mark; }
   11,244,325    43   13   2,605,884        423       0   2,873,427          0       0      void         mark        (uint32_t m)    { header.mark = m; }
       13,550     0    0           0          0       0       6,775          0       0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
            .     .    .           .          .       .           .          .       .  
    5,922,817     0    0   5,922,817  2,562,143   9,291           0          0       0      bool         reloced     ()      const   { return header.reloced; }
            .     .    .           .          .       .           .          .       .      CRef         relocation  ()      const   { return data[0].rel; }
    5,356,348    15   11   1,339,087          0       0   2,678,174          0       0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
            .     .    .           .          .       .           .          .       .  
    1,472,231     0    0     488,699     13,222       0           0          0       0      int          lbd         ()      const   { return header.lbd; }
    1,260,262    16    7     245,402          0       0     176,312          0       0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
            .     .    .           .          .       .           .          .       .      bool         removable   ()      const   { return header.removable; }
      468,052     2    2     188,980          0       0      69,768          0       0      void         removable   (bool b)        { header.removable = b; }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
            .     .    .           .          .       .           .          .       .      //       subsumption operations to behave correctly.
  428,967,153    79   15 418,172,725 28,612,953 133,461           0          0       0      Lit&         operator [] (int i)         { return data[i].lit; }
   97,234,099   243   24  96,500,536  6,002,138 103,957           0          0       0      Lit          operator [] (int i) const   { return data[i].lit; }
            .     .    .           .          .       .           .          .       .      operator const Lit* (void) const         { return (Lit*)data; }
            .     .    .           .          .       .           .          .       .  
       83,713     0    0      83,713          0       0           0          0       0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
      196,002     0    0      67,605     12,655     362           0          0       0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
            .     .    .           .          .       .           .          .       .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      Lit          subsumes    (const Clause& other) const;
            .     .    .           .          .       .           .          .       .      void         strengthen  (Lit p);
            .     .    .           .          .       .           .          .       .      // simplify
            .     .    .           .          .       .           .          .       .      //
      538,224     0    0     164,460          0       0      69,768          0       0      void setSimplified(bool b) { header.simplified = b; }
            .     .    .           .          .       .           .          .       .      bool simplified() { return header.simplified; }
            .     .    .           .          .       .           .          .       .  };
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  //=================================================================================================
            .     .    .           .          .       .           .          .       .  // ClauseAllocator -- a simple class for allocating memory for clauses:
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
            .     .    .           .          .       .           .          .       .  class ClauseAllocator : public RegionAllocator<uint32_t>
            .     .    .           .          .       .           .          .       .  {
            .     .    .           .          .       .           .          .       .      static int clauseWord32Size(int size, int extras){
    3,359,151    14    7   1,609,992     70,812   3,454           0          0       0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
            .     .    .           .          .       .           .          .       .  public:
            .     .    .           .          .       .           .          .       .      bool extra_clause_field;
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
            1     0    0           0          0       0           1          0       0      ClauseAllocator() : extra_clause_field(false){}
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      void moveTo(ClauseAllocator& to){
           18     6    5           9          1       0           9          0       0          to.extra_clause_field = extra_clause_field;
            .     .    .           .          .       .           .          .       .          RegionAllocator<uint32_t>::moveTo(to); }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      template<class Lits>
            .     .    .           .          .       .           .          .       .      CRef alloc(const Lits& ps, bool learnt = false)
            .     .    .           .          .       .           .          .       .      {
            .     .    .           .          .       .           .          .       .          assert(sizeof(Lit)      == sizeof(uint32_t));
            .     .    .           .          .       .           .          .       .          assert(sizeof(float)    == sizeof(uint32_t));
    4,292,751    12    8   1,614,577        113       0           0          0       0          int extras = learnt ? 2 : (int)extra_clause_field;
            .     .    .           .          .       .           .          .       .  
      755,325     0    0           0          0       0     345,258          0       0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
            .     .    .           .          .       .           .          .       .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .          return cid;
            .     .    .           .          .       .           .          .       .      }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
   11,326,235     4    4   8,543,517      8,401       1   1,061,196          0       0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
      381,276     0    0     190,638          0       0           0          0       0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
    1,339,087     0    0   1,339,087          0       0           0          0       0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
            .     .    .           .          .       .           .          .       .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
            .     .    .           .          .       .           .          .       .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      void free(CRef cid)
            .     .    .           .          .       .           .          .       .      {
            .     .    .           .          .       .           .          .       .          Clause& c = operator[](cid);
    1,283,693     8    3           0          0       0           0          0       0          int extras = c.learnt() ? 2 : (int)c.has_extra();
            .     .    .           .          .       .           .          .       .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
            .     .    .           .          .       .           .          .       .      }
            .     .    .           .          .       .           .          .       .  
    9,222,759     8    7           0          0       0   7,905,222         11       2      void reloc(CRef& cr, ClauseAllocator& to)
            .     .    .           .          .       .           .          .       .      {
            .     .    .           .          .       .           .          .       .          Clause& c = operator[](cr);
            .     .    .           .          .       .           .          .       .          
   21,048,591     0    0   4,583,730    692,692   1,311   4,583,730          0       0          if (c.reloced()) { cr = c.relocation(); return; }
            .     .    .           .          .       .           .          .       .          
    1,339,090     0    0           3          0       0   1,339,087          0       0          cr = to.alloc(c, c.learnt());
            .     .    .           .          .       .           .          .       .          c.relocate(cr);
            .     .    .           .          .       .           .          .       .          
            .     .    .           .          .       .           .          .       .          // Copy extra data-fields:
            .     .    .           .          .       .           .          .       .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
            .     .    .           .          .       .           .          .       .          to[cr].mark(c.mark());
    2,678,174     1    1           0          0       0           0          0       0          if (to[cr].learnt()){
      279,072     0    0      69,768      3,965     156      69,768          0       0              to[cr].touched() = c.touched();
      279,067     0    0     139,536      3,934     187      69,768          0       0              to[cr].activity() = c.activity();
            .     .    .           .          .       .           .          .       .              to[cr].set_lbd(c.lbd());
            .     .    .           .          .       .           .          .       .              to[cr].removable(c.removable());
            .     .    .           .          .       .           .          .       .              // simplify
            .     .    .           .          .       .           .          .       .              //
            .     .    .           .          .       .           .          .       .              to[cr].setSimplified(c.simplified());
            .     .    .           .          .       .           .          .       .          }
    2,538,638    16   12           0          0       0           0          0       0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
   10,540,296     0    0   9,222,759          0       0           0          0       0      }
            .     .    .           .          .       .           .          .       .  };
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
            .     .    .           .          .       .           .          .       .  {
            .     .    .           .          .       .           .          .       .      for (int i = 0; i < cls.size(); ++i)
            .     .    .           .          .       .           .          .       .      {
            .     .    .           .          .       .           .          .       .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
            .     .    .           .          .       .           .          .       .  class OccLists
            .     .    .           .          .       .           .          .       .  {
            .     .    .           .          .       .           .          .       .      vec<Vec>  occs;
            .     .    .           .          .       .           .          .       .      vec<char> dirty;
            .     .    .           .          .       .           .          .       .      vec<Idx>  dirties;
            .     .    .           .          .       .           .          .       .      Deleted   deleted;
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  public:
            3     0    0           0          0       0           3          0       0      OccLists(const Deleted& d) : deleted(d) {}
            .     .    .           .          .       .           .          .       .      unsigned int size(){
            .     .    .           .          .       .           .          .       .          auto m_size=0;
           64     2    2           4          3       0           0          0       0          for(int i=0;i<occs.size();i++){
      722,812    14   14     262,820     65,708   7,251           0          0       0              m_size+=occs[i].size();
            .     .    .           .          .       .           .          .       .          }
            .     .    .           .          .       .           .          .       .          
            .     .    .           .          .       .           .          .       .          return m_size;
            .     .    .           .          .       .           .          .       .      }
      361,372     1    1           0          0       0      65,704          0       0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
            .     .    .           .          .       .           .          .       .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
   33,806,890     9    3  33,806,890     71,394       2           0          0       0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
    2,144,944     4    2   1,061,302    249,884   1,073      98,503          4       0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      void  cleanAll  ();
            .     .    .           .          .       .           .          .       .      void  clean     (const Idx& idx);
            .     .    .           .          .       .           .          .       .      void  smudge    (const Idx& idx){
    2,743,608     0    0   1,642,573    241,524   3,085           0          0       0          if (dirty[toInt(idx)] == 0){
      251,885    92    6           0          0       0     251,885          0       0              dirty[toInt(idx)] = 1;
           68     1    1           0          0       0           0          0       0              dirties.push(idx);
            .     .    .           .          .       .           .          .       .          }
            .     .    .           .          .       .           .          .       .      }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .      void  clear(bool free = true){
            .     .    .           .          .       .           .          .       .          occs   .clear(free);
            .     .    .           .          .       .           .          .       .          dirty  .clear(free);
            .     .    .           .          .       .           .          .       .          dirties.clear(free);
            .     .    .           .          .       .           .          .       .      }
            .     .    .           .          .       .           .          .       .  };
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  template<class Idx, class Vec, class Deleted>
          900     0    0           0          0       0         675          3       0  void OccLists<Idx,Vec,Deleted>::cleanAll()
            .     .    .           .          .       .           .          .       .  {
   21,276,716   181    7  10,336,570     11,749       0           0          0       0      for (int i = 0; i < dirties.size(); i++)
            .     .    .           .          .       .           .          .       .          // Dirties may contain duplicates so check here if a variable is already cleaned:
      755,655     0    0     503,770     60,237     581           0          0       0          if (dirty[toInt(dirties[i])])
            .     .    .           .          .       .           .          .       .              clean(dirties[i]);
            .     .    .           .          .       .           .          .       .      dirties.clear();
          900     0    0         900         38       0           0          0       0  }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  template<class Idx, class Vec, class Deleted>
            .     .    .           .          .       .           .          .       .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
            .     .    .           .          .       .           .          .       .  {
            .     .    .           .          .       .           .          .       .      Vec& vec = occs[toInt(idx)];
            .     .    .           .          .       .           .          .       .      int  i, j;
   14,832,093     6    2     486,579    157,837  10,966           0          0       0      for (i = j = 0; i < vec.size(); i++)
   21,465,463     0    0   6,090,373    237,657   4,538           0          0       0          if (!deleted(vec[i]))
   33,875,723     8    1   5,854,664          0       0   4,759,025        373       0              vec[j++] = vec[i];
      196,110    34    6           0          0       0           0          0       0      vec.shrink(i - j);
    1,107,112     3    3     503,770        255       0     283,778        131       0      dirty[toInt(idx)] = 0;
            .     .    .           .          .       .           .          .       .  }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  //=================================================================================================
            .     .    .           .          .       .           .          .       .  // CMap -- a class for mapping clauses to values:
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
            .     .    .           .          .       .           .          .       .  |       p          - The literal p can be deleted from 'other'
            .     .    .           .          .       .           .          .       .  |________________________________________________________________________________________________@*/
            .     .    .           .          .       .           .          .       .  inline Lit Clause::subsumes(const Clause& other) const
            .     .    .           .          .       .           .          .       .  {
            .     .    .           .          .       .           .          .       .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
            .     .    .           .          .       .           .          .       .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
            .     .    .           .          .       .           .          .       .      assert(!header.learnt);   assert(!other.header.learnt);
            .     .    .           .          .       .           .          .       .      assert(header.has_extra); assert(other.header.has_extra);
  277,711,416     0    0  92,570,472  3,195,563       0           0          0       0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
            .     .    .           .          .       .           .          .       .          return lit_Error;
            .     .    .           .          .       .           .          .       .  
    3,853,873     0    0           0          0       0           0          0       0      Lit        ret = lit_Undef;
            .     .    .           .          .       .           .          .       .      const Lit* c   = (const Lit*)(*this);
            .     .    .           .          .       .           .          .       .      const Lit* d   = (const Lit*)other;
            .     .    .           .          .       .           .          .       .  
   26,168,920     3    1   4,642,653          0       0           0          0       0      for (unsigned i = 0; i < header.size; i++) {
            .     .    .           .          .       .           .          .       .          // search for c[i] or ~c[i]
  136,207,764     2    2   3,853,873      1,568       0   3,853,873          0       0          for (unsigned j = 0; j < other.header.size; j++)
  148,880,370     0    0  34,367,701      3,343       0           0          0       0              if (c[i] == d[j])
            .     .    .           .          .       .           .          .       .                  goto ok;
   27,181,395     0    0           0          0       0           0          0       0              else if (ret == lit_Undef && c[i] == ~d[j]){
            .     .    .           .          .       .           .          .       .                  ret = c[i];
            .     .    .           .          .       .           .          .       .                  goto ok;
            .     .    .           .          .       .           .          .       .              }
            .     .    .           .          .       .           .          .       .  
            .     .    .           .          .       .           .          .       .          // did not find it
            .     .    .           .          .       .           .          .       .          return lit_Error;
            .     .    .           .          .       .           .          .       .  ok:;
            .     .    .           .          .       .           .          .       .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir          I1mr  ILmr Dr          D1mr       DLmr   Dw          D1mw       DLmw   

-- line 31 ----------------------------------------
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  template<class Comp>
          .     .    .           .          .      .           .          .      .  class Heap {
          .     .    .           .          .      .           .          .      .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
          .     .    .           .          .      .           .          .      .      vec<int> heap;     // Heap of integers
          .     .    .           .          .      .           .          .      .      vec<int> indices;  // Each integers position (index) in the Heap
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .      // Index "traversal" functions
 91,133,450     5    3           0          0      0           0          0      0      static inline int left  (int i) { return i*2+1; }
359,438,649    22    7 140,776,479 54,954,495 18,744           0          0      0      static inline int right (int i) { return (i+1)*2; }
 57,937,381    13    4   2,776,756          0      0           0          0      0      static inline int parent(int i) { return (i-1) >> 1; }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
  5,553,512     9    2           0          0      0   5,553,512      4,862      0      void percolateUp(int i)
          .     .    .           .          .      .           .          .      .      {
 18,698,420     0    0  13,351,975  2,264,414     18   2,569,689          0      0          int x  = heap[i];
          .     .    .           .          .      .           .          .      .          int p  = parent(i);
          .     .    .           .          .      .           .          .      .          
177,638,870    48   10  54,373,922 16,192,387  3,176     180,292          0      0          while (i != 0 && lt(x, heap[p])){
 18,987,771    18    3           0          0      0  18,987,771          0      0              heap[i]          = heap[p];
 18,987,771     0    0           0          0      0  18,987,771  8,022,738    826              indices[heap[p]] = i;
          .     .    .           .          .      .           .          .      .              i                = p;
 27,758,048     0    0           0          0      0           0          0      0              p                = parent(p);
          .     .    .           .          .      .           .          .      .          }
 10,575,219    16    6   2,055,637          0      0   8,519,582          0      0          heap   [i] = x;
 15,670,055     5    4   1,464,723          0      0   8,992,485          0      0          indices[x] = i;
 12,331,648     0    0   8,330,268          0      0           0          0      0      }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
241,168,123     0    0  34,452,589          0      0 206,715,534     26,357      0      void percolateDown(int i)
          .     .    .           .          .      .           .          .      .      {
120,660,329 1,043   20  77,566,010 29,565,840  1,292  42,695,358          0      0          int x = heap[i];
348,103,625 2,926   27  85,759,204        260      0           0          0      0          while (left(i) < heap.size()){
504,505,038    28    7  69,263,011  3,190,764    166           0          0      0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
167,754,396    39   13           0          0      0           0          0      0              if (!lt(heap[child], x)) break;
 47,731,122     0    0           0          0      0  47,731,122          0      0              heap[i]          = heap[child];
 48,094,125     0    0     363,003          0      0  47,731,122 15,218,456  1,778              indices[heap[i]] = i;
 41,801,936     0    0           0          0      0           0          0      0              i                = child;
          .     .    .           .          .      .           .          .      .          }
 83,620,723    45   12  41,821,925          0      0  41,798,798          0      0          heap   [i] = x;
 52,221,900     4    0   4,790,477          0      0  41,798,798     56,549      0          indices[x] = i;
241,675,233     0    0 241,168,123          0      0           0          0      0      }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .    public:
          .     .    .           .          .      .           .          .      .      Heap(const Comp& c) : lt(c) { }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .      int  size      ()          const { return heap.size(); }
  3,593,462     3    1   3,593,462     58,325      4           0          0      0      bool empty     ()          const { return heap.size() == 0; }
517,968,584 3,164   19 270,957,973 57,537,968 10,089           0          0      0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
  6,142,526     3    3   3,929,151     90,234      6           0          0      0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
 16,418,782     0    0  10,986,147         14      0   2,776,756          7      0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
181,420,815     1    1 112,515,636          0      0  34,452,589          0      0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .      // Safe variant of insert/decrease/increase:
          .     .    .           .          .      .           .          .      .      void update(int n)
          .     .    .           .          .      .           .          .      .      {
          .     .    .           .          .      .           .          .      .          if (!inHeap(n))
          .     .    .           .          .      .           .          .      .              insert(n);
          .     .    .           .          .      .           .          .      .          else {
          .     .    .           .          .      .           .          .      .              percolateUp(indices[n]);
  3,083,170     0    0   1,541,585          0      0           0          0      0              percolateDown(indices[n]); }
          .     .    .           .          .      .           .          .      .      }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .      void insert(int n)
          .     .    .           .          .      .           .          .      .      {
  3,687,189     4    3           0          0      0           0          0      0          indices.growTo(n+1, -1);
          .     .    .           .          .      .           .          .      .          assert(!inHeap(n));
          .     .    .           .          .      .           .          .      .  
  7,374,378     3    2   3,687,189          0      0   3,687,189          0      0          indices[n] = heap.size();
    477,697     4    3           2          0      0     318,401          0      0          heap.push(n);
  7,374,378     0    0   3,687,189         19      0           0          0      0          percolateUp(indices[n]); 
          .     .    .           .          .      .           .          .      .      }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .      int  removeMin()
          .     .    .           .          .      .           .          .      .      {
 10,780,383     1    1   7,186,922     68,456      3   3,593,461          3      0          int x            = heap[0];
  7,186,922     0    0   3,593,461    232,644     24   3,593,461          0      0          heap[0]          = heap.last();
  7,186,922    12    4   3,593,461          0      0   3,593,461  3,042,906    380          indices[heap[0]] = 0;
  3,593,461     1    1           0          0      0   3,593,461     88,159      3          indices[x]       = -1;
          .     .    .           .          .      .           .          .      .          heap.pop();
  7,186,922     0    0           0          0      0           0          0      0          if (heap.size() > 1) percolateDown(0);
          .     .    .           .          .      .           .          .      .          return x; 
          .     .    .           .          .      .           .          .      .      }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .      // Rebuild the heap from scratch, using the elements in 'ns':
          .     .    .           .          .      .           .          .      .      void build(const vec<int>& ns) {
  1,712,780    27   10     856,390         38      2           0          0      0          for (int i = 0; i < heap.size(); i++)
    856,447    18    5          57          0      0     856,276    304,392 13,108              indices[heap[i]] = -1;
         57     0    0           0          0      0           0          0      0          heap.clear();
          .     .    .           .          .      .           .          .      .  
  1,596,189    14    5     798,009         57      0           0          0      0          for (int i = 0; i < ns.size(); i++){
  1,595,904     0    0     797,952          0      0     797,952    111,431     18              indices[ns[i]] = i;
          .     .    .           .          .      .           .          .      .              heap.push(ns[i]); }
          .     .    .           .          .      .           .          .      .  
  2,793,316    54   15     399,018          0      0          57          0      0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
          .     .    .           .          .      .           .          .      .              percolateDown(i);
          .     .    .           .          .      .           .          .      .      }
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .      void clear(bool dealloc = false) 
          .     .    .           .          .      .           .          .      .      { 
          4     0    0           2          1      0           0          0      0          for (int i = 0; i < heap.size(); i++)
          .     .    .           .          .      .           .          .      .              indices[heap[i]] = -1;
          .     .    .           .          .      .           .          .      .          heap.clear(dealloc); 
          .     .    .           .          .      .           .          .      .      }
          .     .    .           .          .      .           .          .      .  };
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  
          .     .    .           .          .      .           .          .      .  //=================================================================================================
          .     .    .           .          .      .           .          .      .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
Ir             I1mr    ILmr  Dr            D1mr        DLmr      Dw            D1mw        DLmw      
--------------------------------------------------------------------------------
33,567,729,178 143,530 2,151 9,857,566,597 949,131,330 1,284,337 3,297,357,459 226,267,418 1,361,324  events annotated

