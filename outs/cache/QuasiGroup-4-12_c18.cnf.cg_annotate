--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/QuasiGroup-4-12_c18.cnf
Data file:        QuasiGroup-4-12_c18.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr      ILmr   Dr              D1mr           DLmr       Dw              D1mw          DLmw       
--------------------------------------------------------------------------------
1,095,616,111,866 1,396,787 35,380 338,937,099,618 21,297,323,917 23,172,827 124,891,574,227 5,294,049,050 37,930,288  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr              D1mr          DLmr      Dw             D1mw          DLmw        file:function
--------------------------------------------------------------------------------
490,733,719,064   6,787   114 154,740,798,868 9,759,201,333 4,663,583 55,091,023,749     3,389,403          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
203,644,816,644       9     3  46,121,659,533 2,050,565,407 1,312,345 22,169,242,911             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
104,012,856,835  29,987   168  22,963,656,212 2,132,859,313    79,775 13,261,858,076 2,521,956,844  5,288,060  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
 23,569,103,168 123,555 2,154   5,067,249,752    83,016,273     1,417  2,268,590,788    10,406,338         37  ???:__ieee754_pow_fma
 23,269,227,990  13,668   316   9,047,537,790 1,635,122,789     7,045  2,790,819,885   467,821,908        960  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
 22,184,770,907      12     4   9,491,725,353   486,636,447    14,106  6,751,302,074 1,543,356,541     54,004  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 18,545,345,739   9,093   104   7,760,651,038   988,705,072    12,662  5,187,412,842    27,661,010        593  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
 18,488,219,211  35,085   769   6,481,511,154   385,829,793    14,250  1,150,335,110    13,156,132        327  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 18,233,001,135       6     5  17,590,431,541   443,230,896         0    642,502,352             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
 16,929,432,146  14,437   211   5,566,292,202    66,704,637     4,740  2,135,942,968       943,894          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 13,511,177,596  59,195   151   3,821,575,445           648         0  2,456,731,517     4,922,408      3,250  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 12,365,272,350   4,386   319   3,123,195,926     6,472,807       106  1,159,109,266    24,074,438     46,251  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 11,591,068,078     429    24   5,995,305,033   443,469,176    15,204    508,260,467    10,809,211         39  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
 10,520,769,844       0     0   5,260,384,922        33,602         2              0             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
  9,912,531,618     286   251   2,491,425,380   399,404,498   193,684  1,031,683,159    12,590,274          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
  8,424,120,122   2,903   192   2,224,231,203   155,818,595    94,752     24,392,788       533,821          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  7,383,256,431  11,185   622   1,771,758,098    87,324,967    16,291    196,934,824     7,104,844         21  ???:__exp1_fma
  6,553,260,226   1,894   193   2,934,942,596   264,753,858    48,786    373,771,191            28          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  6,489,332,948     106    71   2,316,462,706   297,969,919    59,467              0             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  6,439,431,624      65    60   1,708,933,506    78,268,365    24,652              0             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
  5,663,795,428   1,464    68   2,300,522,344    11,389,575     5,985              0             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  4,969,586,814       7     7   1,721,750,713     3,425,163        43  1,526,085,388    49,177,110     10,404  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  4,827,803,380      39    31   1,220,008,356   176,563,596       421    899,575,579   202,609,845    318,204  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
  4,578,397,426       0     0   3,052,241,134    47,332,156     4,046    763,042,421   208,059,479      6,674  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  3,658,537,566   3,255    91   1,199,315,949       472,786         0     27,932,917     2,016,059      1,189  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
  3,556,217,699   8,674   214     987,461,773         4,480       142    592,416,378         7,749          0  ???:pow
  3,370,196,824   2,440    68   1,394,378,584   198,924,472    35,529    533,439,081    30,107,891      2,214  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
  3,052,170,776       0     0     763,042,694             0         0    763,042,694        50,356         43  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  2,347,983,900       0     0   1,369,657,275   161,594,320     4,605    195,665,325             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  2,255,410,707     100    58     437,617,792    59,381,637    11,428    232,102,346    38,068,090      4,460  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
  2,053,670,362      25    14     631,323,582   151,555,361     1,390    389,988,428    44,597,884        819  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
  1,796,827,534     630    92     845,443,621   109,149,697     2,029              0             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  1,780,707,517     746   733     440,668,320    53,488,062 5,223,452    252,930,592    13,648,925  8,625,405  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
  1,737,791,442       0     0               0             0         0              0             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  1,680,819,011       0     0   1,110,508,100   262,434,971     4,939              0             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  1,369,657,275       0     0     195,665,325     3,356,239        14    586,995,975     3,959,180          0  /usr/include/c++/8/cmath:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  1,316,403,666      12    12     209,933,671       353,682         0     10,992,454             0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc:Minisat::SimpSolver::eliminateVar(int)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/8/cmath
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr          D1mr      DLmr Dw          D1mw      DLmw 

-- line 410 ----------------------------------------
            .    .    .           .         .    .           .         .    .  #endif
            .    .    .           .         .    .           .         .    .  
            .    .    .           .         .    .           .         .    .    template<typename _Tp, typename _Up>
            .    .    .           .         .    .           .         .    .      inline _GLIBCXX_CONSTEXPR
            .    .    .           .         .    .           .         .    .      typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
            .    .    .           .         .    .           .         .    .      pow(_Tp __x, _Up __y)
            .    .    .           .         .    .           .         .    .      {
            .    .    .           .         .    .           .         .    .        typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
1,379,426,453   10    9 197,470,872 3,395,692   14 588,802,776 3,959,180    0        return pow(__type(__x), __type(__y));
            .    .    .           .         .    .           .         .    .      }
            .    .    .           .         .    .           .         .    .  
            .    .    .           .         .    .           .         .    .    using ::sin;
            .    .    .           .         .    .           .         .    .  
            .    .    .           .         .    .           .         .    .  #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
            .    .    .           .         .    .           .         .    .    inline _GLIBCXX_CONSTEXPR float
            .    .    .           .         .    .           .         .    .    sin(float __x)
            .    .    .           .         .    .           .         .    .    { return __builtin_sinf(__x); }
-- line 426 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr             D1mr          DLmr      Dw             D1mw        DLmw   

-- line 51 ----------------------------------------
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  //=================================================================================================
             .      .    .              .             .         .              .           .      .  // Options:
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  static const char* _cat = "CORE";
             .      .    .              .             .         .              .           .      .  
             4      0    0              0             0         0              1           0      0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
             4      0    0              0             0         0              1           0      0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
             4      0    0              0             0         0              1           0      0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
             4      1    1              0             0         0              1           0      0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
             4      0    0              0             0         0              1           0      0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
             4      0    0              0             0         0              1           0      0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
             4      0    0              0             0         0              1           0      0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
             4      0    0              0             0         0              1           0      0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
             4      0    0              0             0         0              1           0      0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
             4      1    1              0             0         0              1           0      0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
             4      0    0              0             0         0              1           0      0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
             4      1    1              0             0         0              1           0      0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
             4      1    1              0             0         0              1           0      0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
             4      1    1              0             0         0              1           0      0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
             4      1    1              0             0         0              1           0      0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
             .      .    .              .             .         .              .           .      .  
             4      1    1              0             0         0              1           0      0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
             1      1    1              0             0         0              1           0      0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
             4      0    0              0             0         0              1           0      0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
             .      .    .              .             .         .              .           .      .  
             4      1    1              0             0         0              1           0      0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  //VSIDS_props_limit
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  //=================================================================================================
             .      .    .              .             .         .              .           .      .  // Constructor/Destructor:
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             4      1    1              0             0         0              2           0      0  Solver::Solver() :
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Parameters (user settable):
             .      .    .              .             .         .              .           .      .      //
             .      .    .              .             .         .              .           .      .      drup_file        (NULL)
             .      .    .              .             .         .              .           .      .    , verbosity        (0)
             .      .    .              .             .         .              .           .      .    , step_size        (opt_step_size)
             .      .    .              .             .         .              .           .      .    , step_size_dec    (opt_step_size_dec)
             .      .    .              .             .         .              .           .      .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
             .      .    .              .             .         .              .           .      .    , garbage_frac     (opt_garbage_frac)
             .      .    .              .             .         .              .           .      .    , restart_first    (opt_restart_first)
             .      .    .              .             .         .              .           .      .    , restart_inc      (opt_restart_inc)
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .    , min_number_of_learnts_copies(opt_min_dupl_app)  
             .      .    .              .             .         .              .           .      .    , max_lbd_dup(opt_max_lbd_dup)
             .      .    .              .             .         .              .           .      .    , dupl_db_init_size(opt_dupl_db_init_size)
             3      1    1              1             0         0              1           0      0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .    // Parameters (the rest):
             .      .    .              .             .         .              .           .      .    //
             .      .    .              .             .         .              .           .      .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .    // Parameters (experimental):
             .      .    .              .             .         .              .           .      .    //
             .      .    .              .             .         .              .           .      .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
             .      .    .              .             .         .              .           .      .    //
             .      .    .              .             .         .              .           .      .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
             .      .    .              .             .         .              .           .      .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
             .      .    .              .             .         .              .           .      .    , chrono_backtrack(0), non_chrono_backtrack(0)
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .    , ok                 (true)
             .      .    .              .             .         .              .           .      .    , cla_inc            (1)
             .      .    .              .             .         .              .           .      .    , var_inc            (1)
             1      0    0              0             0         0              0           0      0    , watches_bin        (WatcherDeleted(ca))
             .      .    .              .             .         .              .           .      .    , watches            (WatcherDeleted(ca))
             .      .    .              .             .         .              .           .      .    , qhead              (0)
             .      .    .              .             .         .              .           .      .    , simpDB_assigns     (-1)
             .      .    .              .             .         .              .           .      .    , simpDB_props       (0)
             .      .    .              .             .         .              .           .      .    , order_heap_CHB     (VarOrderLt(activity_CHB))
             .      .    .              .             .         .              .           .      .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
             .      .    .              .             .         .              .           .      .    , progress_estimate  (0)
             .      .    .              .             .         .              .           .      .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
             .      .    .              .             .         .              .           .      .    // simplifyAll adjust occasion
             .      .    .              .             .         .              .           .      .    , curSimplify(1)
             .      .    .              .             .         .              .           .      .    , nbconfbeforesimplify(1000)
             .      .    .              .             .         .              .           .      .    , incSimplify(1000)
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .    , my_var_decay       (0.6)
             .      .    .              .             .         .              .           .      .    , DISTANCE           (true)
             .      .    .              .             .         .              .           .      .    , var_iLevel_inc     (1)
            94      8    8             25             2         2             63           1      0    , order_heap_distance(VarOrderLt(activity_distance))
             .      .    .              .             .         .              .           .      .  
             4      0    0              3             0         0              0           0      0  {}
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  Solver::~Solver()
             .      .    .              .             .         .              .           .      .  {
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  // simplify All
             .      .    .              .             .         .              .           .      .  //
             .      .    .              .             .         .              .           .      .  CRef Solver::simplePropagate()
     6,040,928      2    2              0             0         0      4,530,696          67      0  {
       755,116      0    0              0             0         0        755,116           0      0      CRef    confl = CRef_Undef;
       755,116      0    0              0             0         0        755,116           0      0      int     num_props = 0;
     1,510,232      0    0              0             0         0        755,116         111      0      watches.cleanAll();
     2,265,348     34   30        755,116             0         0        755,116           0      0      watches_bin.cleanAll();
    32,339,400      0    0     16,169,700             0         0              0           0      0      while (qhead < trail.size())
             .      .    .              .             .         .              .           .      .      {
    77,096,310      1    1     30,838,524       422,408         0     30,838,524           0      0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .      .    .              .             .         .              .           .      .          vec<Watcher>&  ws = watches[p];
             .      .    .              .             .         .              .           .      .          Watcher        *i, *j, *end;
    15,414,584      1    1     15,414,584             0         0              0           0      0          num_props++;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          // First, Propagate binary clauses
             .      .    .              .             .         .              .           .      .          vec<Watcher>&  wbin = watches_bin[p];
             .      .    .              .             .         .              .           .      .  
   126,908,473      0    0     15,419,262    14,917,363       746              0           0      0          for (int k = 0; k<wbin.size(); k++)
             .      .    .              .             .         .              .           .      .          {
             .      .    .              .             .         .              .           .      .  
    45,813,422      0    0     28,880,549     7,848,656    22,846              0           0      0              Lit imp = wbin[k].blocker;
             .      .    .              .             .         .              .           .      .  
    45,813,422      0    0              0             0         0              0           0      0              if (value(imp) == l_False)
             .      .    .              .             .         .              .           .      .              {
         9,356      0    0          4,678             0         0          4,678           0      0                  return wbin[k].cref;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
    45,804,066      8    8              0             0         0              0           0      0              if (value(imp) == l_Undef)
             .      .    .              .             .         .              .           .      .              {
    10,337,648      0    0     10,337,648             0         0              0           0      0                  simpleUncheckEnqueue(imp, wbin[k].cref);
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
   894,706,745     34   30    401,549,591    11,924,193        92     30,008,602           0      0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
             .      .    .              .             .         .              .           .      .          {
             .      .    .              .             .         .              .           .      .              // Try to avoid inspecting the clause:
   370,720,423     34   29    370,720,423    56,296,081    72,286              0           0      0              Lit blocker = i->blocker;
   741,440,846      0    0    370,720,423    19,769,642         0              0           0      0              if (value(blocker) == l_True)
             .      .    .              .             .         .              .           .      .              {
             .      .    .              .             .         .              .           .      .                  *j++ = *i++; continue;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Make sure the false literal is data[1]:
   617,034,438      0    0    308,517,219             0         0              0           0      0              CRef     cr = i->cref;
             .      .    .              .             .         .              .           .      .              Clause&  c = ca[cr];
             .      .    .              .             .         .              .           .      .              Lit      false_lit = ~p;
   925,551,657      0    0    308,517,219   277,090,241    93,927              0           0      0              if (c[0] == false_lit)
   377,519,937      0    0    125,839,979     6,690,046     3,613    251,679,958           0      0                  c[0] = c[1], c[1] = false_lit;
             .      .    .              .             .         .              .           .      .              assert(c[1] == false_lit);
             .      .    .              .             .         .              .           .      .              //  i++;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // If 0th watch is true, then clause is already satisfied.
             .      .    .              .             .         .              .           .      .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
             .      .    .              .             .         .              .           .      .              // why not simply do i->blocker=first in this case?
             .      .    .              .             .         .              .           .      .              Lit     first = c[0];
             .      .    .              .             .         .              .           .      .              //  Watcher w     = Watcher(cr, first);
   791,872,858      0    0     87,419,210     3,796,216         0              0           0      0              if (first != blocker && value(first) == l_True)
             .      .    .              .             .         .              .           .      .              {
    18,888,288      0    0              0             0         0     18,888,288           0      0                  i->blocker = first;
   324,365,968      0    0     81,091,492             0         0     81,091,492      21,147      0                  *j++ = *i++; continue;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Look for new watch:
             .      .    .              .             .         .              .           .      .              //if (incremental)
             .      .    .              .             .         .              .           .      .              //{ // ----------------- INCREMENTAL MODE
             .      .    .              .             .         .              .           .      .              //	int choosenPos = -1;
             .      .    .              .             .         .              .           .      .              //	for (int k = 2; k < c.size(); k++)
             .      .    .              .             .         .              .           .      .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
             .      .    .              .             .         .              .           .      .              //		Watcher w = Watcher(cr, first); i++;
             .      .    .              .             .         .              .           .      .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
             .      .    .              .             .         .              .           .      .              //		watches[~c[1]].push(w);
             .      .    .              .             .         .              .           .      .              //		goto NextClause;
             .      .    .              .             .         .              .           .      .              //	}
             .      .    .              .             .         .              .           .      .              //}
             .      .    .              .             .         .              .           .      .              else
             .      .    .              .             .         .              .           .      .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
   900,555,207     34   30              0             0         0              0           0      0                  for (int k = 2; k < c.size(); k++)
             .      .    .              .             .         .              .           .      .                  {
             .      .    .              .             .         .              .           .      .  
 1,758,253,967      0    0              0             0         0              0           0      0                      if (value(c[k]) != l_False)
             .      .    .              .             .         .              .           .      .                      {
             .      .    .              .             .         .              .           .      .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
             .      .    .              .             .         .              .           .      .                          // the blocker is first in the watcher. However,
             .      .    .              .             .         .              .           .      .                          // the blocker in the corresponding watcher in ~first is not c[1]
             .      .    .              .             .         .              .           .      .                          Watcher w = Watcher(cr, first); i++;
 1,137,268,444      0    0    284,317,111             0         0    568,634,222           0      0                          c[1] = c[k]; c[k] = false_lit;
             .      .    .              .             .         .              .           .      .                          watches[~c[1]].push(w);
   284,317,111      0    0              0             0         0              0           0      0                          goto NextClause;
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Did not find watch -- clause is unit under assignment:
     5,311,820      0    0              0             0         0      5,311,820           0      0              i->blocker = first;
    21,247,280      0    0      5,311,820             0         0      5,311,820       2,278      0              *j++ = *i++;
    10,623,640     34   30              0             0         0              0           0      0              if (value(first) == l_False)
             .      .    .              .             .         .              .           .      .              {
       288,419      0    0              0             0         0         47,312           0      0                  confl = cr;
        94,624     32   27         47,312            47         0         47,312           0      0                  qhead = trail.size();
             .      .    .              .             .         .              .           .      .                  // Copy the remaining watches:
     2,394,084      3    2         86,071            23         0              0           0      0                  while (i < end)
     1,063,659      0    0      1,063,659       127,815       174      1,063,659         125      0                      *j++ = *i++;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              else
             .      .    .              .             .         .              .           .      .              {
             .      .    .              .             .         .              .           .      .                  simpleUncheckEnqueue(first, cr);
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  NextClause:;
             .      .    .              .             .         .              .           .      .          }
    29,188,036     33   29              0             0         0              0           0      0          ws.shrink(i - j);
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
     1,500,876      0    0      1,500,876       255,358         0              0           0      0      s_propagations += num_props;
             .      .    .              .             .         .              .           .      .  
       750,438      0    0        750,438             0         0              0           0      0      return confl;
   234,638,456     36   32      5,285,812       257,782         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
             .      .    .              .             .         .              .           .      .      assert(value(p) == l_Undef);
    15,602,156      0    0              0             0         0     15,602,156           0      0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
    32,714,544     34   29     16,357,272         8,627         0     16,357,272  13,238,403      0      vardata[var(p)].reason = from;
     6,019,624      0    0      6,019,624             0         0              0           0      0      trail.push_(p);
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::cancelUntilTrailRecord()
             .      .    .              .             .         .              .           .      .  {
    33,263,789      0    0        219,698             0         0              0           0      0      for (int c = trail.size() - 1; c >= trailRecord; c--)
             .      .    .              .             .         .              .           .      .      {
       109,849     34   29        109,849             0         0              0           0      0          Var x = var(trail[c]);
    16,686,819      0    0        109,849             0         0     16,357,272   1,237,746      0          assigns[x] = l_Undef;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      }
       109,849      0    0              0             0         0        109,849           0      0      qhead = trailRecord;
       219,698      0    0              0             0         0              0           0      0      trail.shrink(trail.size() - trailRecord);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::litsEnqueue(int cutP, Clause& c)
             .      .    .              .             .         .              .           .      .  {
             .      .    .              .             .         .              .           .      .      for (int i = cutP; i < c.size(); i++)
             .      .    .              .             .         .              .           .      .      {
             .      .    .              .             .         .              .           .      .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  bool Solver::removed(CRef cr) {
             .      .    .              .             .         .              .           .      .      return ca[cr].mark() == 1;
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
     1,205,138     31   28              0             0         0        657,348           0      0  {
       109,558      0    0              0             0         0              0           0      0      int pathC = 0;
       109,558      0    0              0             0         0              0           0      0      Lit p = lit_Undef;
       328,674      0    0        109,558             0         0              0           0      0      int index = trail.size() - 1;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      do{
     4,661,984     34   29              0             0         0              0           0      0          if (confl != CRef_Undef){
             .      .    .              .             .         .              .           .      .              reason_clause.push(confl);
             .      .    .              .             .         .              .           .      .              Clause& c = ca[confl];
             .      .    .              .             .         .              .           .      .              // Special case for binary clauses
             .      .    .              .             .         .              .           .      .              // The first one has to be SAT
     7,664,336     34   30              0             0         0              0           0      0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                  assert(value(c[1]) == l_True);
             .      .    .              .             .         .              .           .      .                  Lit tmp = c[0];
       818,448      0    0        272,816        12,845       103        545,632           0      0                  c[0] = c[1], c[1] = tmp;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              // if True_confl==true, then choose p begin with the 1th index of c;
    13,889,783      0    0      3,116,251       106,626         0              0           0      0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
             .      .    .              .             .         .              .           .      .                  Lit q = c[j];
     7,573,634      0    0      3,786,817       691,566         0              0           0      0                  if (!seen[var(q)]){
     2,221,438      0    0              0             0         0      2,221,438           0      0                      seen[var(q)] = 1;
     6,664,314      0    0      2,221,438             0         0              0           0      0                      pathC++;
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          else if (confl == CRef_Undef){
             .      .    .              .             .         .              .           .      .              out_learnt.push(~p);
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
     7,694,588     34   29      2,221,438             0         0              0           0      0          if (pathC == 0) break;
             .      .    .              .             .         .              .           .      .          // Select next clause to look at:
   104,634,680      0    0     34,878,228     4,079,819         0              0           0      0          while (!seen[var(trail[index--])]);
             .      .    .              .             .         .              .           .      .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
             .      .    .              .             .         .              .           .      .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
     4,442,876      0    0      2,221,438             0         0              0           0      0          if (trailRecord > index + 1) break;
             .      .    .              .             .         .              .           .      .          p = trail[index + 1];
             .      .    .              .             .         .              .           .      .          confl = reason(var(p));
     2,221,434      0    0              0             0         0      2,221,434           0      0          seen[var(p)] = 0;
     2,221,434      0    0              0             0         0              0           0      0          pathC--;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      } while (pathC >= 0);
     1,095,580     34   30        766,906            64         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::simplifyLearnt(Clause& c)
       988,641     68   60              0             0         0        659,094          34      0  {
             .      .    .              .             .         .              .           .      .      ////
       109,849      0    0        109,849            82         0              0           0      0      original_length_record += c.size();
             .      .    .              .             .         .              .           .      .  
       219,698      0    0        109,849            65         0        109,849           0      0      trailRecord = trail.size();// record the start pointer
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      vec<Lit> falseLit;
             .      .    .              .             .         .              .           .      .      falseLit.clear();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
             .      .    .              .             .         .              .           .      .  
       103,980     30   25              0             0         0              0           0      0      bool True_confl = false;
             .      .    .              .             .         .              .           .      .      int beforeSize, afterSize;
             .      .    .              .             .         .              .           .      .      beforeSize = c.size();
             .      .    .              .             .         .              .           .      .      int i, j;
             .      .    .              .             .         .              .           .      .      CRef confl;
             .      .    .              .             .         .              .           .      .  
     2,947,305     34   29              0             0         0              0           0      0      for (i = 0, j = 0; i < c.size(); i++){
     1,744,590      0    0              0             0         0              0           0      0          if (value(c[i]) == l_Undef){
             .      .    .              .             .         .              .           .      .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
             .      .    .              .             .         .              .           .      .              simpleUncheckEnqueue(~c[i]);
     2,968,474      0    0        755,116             0         0        755,116          30      0              c[j++] = c[i];
     2,265,348      0    0              0             0         0        755,116           0      0              confl = simplePropagate();
     2,265,348     34   29        755,116       253,449         0              0           0      0              if (confl != CRef_Undef){
             .      .    .              .             .         .              .           .      .                  break;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          else{
       234,358      0    0              0             0         0              0           0      0              if (value(c[i]) == l_True){
             .      .    .              .             .         .              .           .      .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
       230,272     32   27         57,568             0         0         57,568          42      0                  c[j++] = c[i];
        57,568     19   18              0             0         0              0           0      0                  True_confl = true;
             .      .    .              .             .         .              .           .      .                  confl = reason(var(c[i]));
             .      .    .              .             .         .              .           .      .                  break;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              else{
             .      .    .              .             .         .              .           .      .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
             .      .    .              .             .         .              .           .      .                  falseLit.push(c[i]);
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .      c.shrink(c.size() - j);
             .      .    .              .             .         .              .           .      .      afterSize = c.size();
             .      .    .              .             .         .              .           .      .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      if (confl != CRef_Undef || True_confl == true){
       109,558      0    0              0             0         0              0           0      0          simp_learnt_clause.clear();
       109,558      0    0              0             0         0              0           0      0          simp_reason_clause.clear();
       219,116      0    0              0             0         0              0           0      0          if (True_confl == true){
             .      .    .              .             .         .              .           .      .              simp_learnt_clause.push(c.last());
             .      .    .              .             .         .              .           .      .          }
       766,906     15   11              0             0         0        109,558           0      0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
             .      .    .              .             .         .              .           .      .  
       328,674      0    0        109,558             0         0              0           0      0          if (simp_learnt_clause.size() < c.size()){
       298,890     34   30        120,499             0         0              0           0      0              for (i = 0; i < simp_learnt_clause.size(); i++){
       424,104      0    0        106,026             0         0        106,026         129      0                  c[i] = simp_learnt_clause[i];
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              c.shrink(c.size() - i);
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      cancelUntilTrailRecord();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      ////
       109,849      0    0        109,849             0         0              0           0      0      simplified_length_record += c.size();
             .      .    .              .             .         .              .           .      .  
       878,792      0    0        768,943       106,719         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
             .      .    .              .             .         .              .           .      .  {
             .      .    .              .             .         .              .           .      .      int beforeSize, afterSize;
             .      .    .              .             .         .              .           .      .      int learnts_x_size_before = learnts_x.size();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      int ci, cj, li, lj;
             .      .    .              .             .         .              .           .      .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .      .    .              .             .         .              .           .      .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      return true;
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  bool Solver::simplifyLearnt_core()
           374      0    0              0             0         0            204           0      0  {
             .      .    .              .             .         .              .           .      .      int beforeSize, afterSize;
             .      .    .              .             .         .              .           .      .      int learnts_core_size_before = learnts_core.size();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      int ci, cj, li, lj;
             .      .    .              .             .         .              .           .      .      bool sat, false_lit;
             .      .    .              .             .         .              .           .      .      unsigned int nblevels;
             .      .    .              .             .         .              .           .      .      ////
             .      .    .              .             .         .              .           .      .      //printf("learnts_x size : %d\n", learnts_x.size());
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      ////
             .      .    .              .             .         .              .           .      .      int nbSimplified = 0;
             .      .    .              .             .         .              .           .      .      int nbSimplifing = 0;
             .      .    .              .             .         .              .           .      .  
     2,271,488     34   29             34             0         0              0           0      0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     3,407,040     34   29      2,271,360        71,013    22,322              0           0      0          CRef cr = learnts_core[ci];
             .      .    .              .             .         .              .           .      .          Clause& c = ca[cr];
             .      .    .              .             .         .              .           .      .  
     2,271,360      0    0              0             0         0              0           0      0          if (removed(cr)) continue;
     2,271,360      0    0      1,135,680       138,567     7,335              0           0      0          else if (c.simplified()){
     2,213,968      0    0              0             0         0      1,106,984           0      0              learnts_core[cj++] = learnts_core[ci];
             .      .    .              .             .         .              .           .      .              ////
     3,320,960      0    0      1,106,984             0         0              0           0      0              nbSimplified++;
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          else{
             .      .    .              .             .         .              .           .      .              int saved_size=c.size();
             .      .    .              .             .         .              .           .      .              //         if (drup_file){
             .      .    .              .             .         .              .           .      .              //                 add_oc.clear();
             .      .    .              .             .         .              .           .      .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .      .    .              .             .         .              .           .      .              ////
             .      .    .              .             .         .              .           .      .              nbSimplifing++;
        28,696      0    0              0             0         0              0           0      0              sat = false_lit = false;
       358,602      0    0              0             0         0              0           0      0              for (int i = 0; i < c.size(); i++){
       358,604      0    0              0             0         0              0           0      0                  if (value(c[i]) == l_True){
             .      .    .              .             .         .              .           .      .                      sat = true;
             .      .    .              .             .         .              .           .      .                      break;
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .                  else if (value(c[i]) == l_False){
       415,994     34   29              0             0         0         28,696          32      0                      false_lit = true;
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              if (sat){
             7      1    0              2             0         0              2           0      0                  removeClause(cr);
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              else{
       172,170      0    0              0             0         0         86,085           0      0                  detachClause(cr, true);
             .      .    .              .             .         .              .           .      .  
       114,780     34   29         57,390             0         0              0           0      0                  if (false_lit){
             .      .    .              .             .         .              .           .      .                      for (li = lj = 0; li < c.size(); li++){
             .      .    .              .             .         .              .           .      .                          if (value(c[li]) != l_False){
             .      .    .              .             .         .              .           .      .                              c[lj++] = c[li];
             .      .    .              .             .         .              .           .      .                          }
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                      c.shrink(li - lj);
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                  beforeSize = c.size();
             .      .    .              .             .         .              .           .      .                  assert(c.size() > 1);
             .      .    .              .             .         .              .           .      .                  // simplify a learnt clause c
       114,780      0    0              0             0         0         57,390           0      0                  simplifyLearnt(c);
             .      .    .              .             .         .              .           .      .                  assert(c.size() > 0);
             .      .    .              .             .         .              .           .      .                  afterSize = c.size();
             .      .    .              .             .         .              .           .      .                  
       140,738      0    0         86,085        53,790         0              0           0      0                  if(drup_file && saved_size !=c.size()){
             .      .    .              .             .         .              .           .      .  #ifdef BIN_DRUP
             .      .    .              .             .         .              .           .      .                      binDRUP('a', c , drup_file);
             .      .    .              .             .         .              .           .      .                      //                    binDRUP('d', add_oc, drup_file);
             .      .    .              .             .         .              .           .      .  #else
             .      .    .              .             .         .              .           .      .                      for (int i = 0; i < c.size(); i++)
             .      .    .              .             .         .              .           .      .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .              .             .         .              .           .      .                      fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
             .      .    .              .             .         .              .           .      .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .      .    .              .             .         .              .           .      .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .      .    .              .             .         .              .           .      .                      //                    fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .      .    .              .             .         .              .           .      .  
        57,390      0    0              0             0         0              0           0      0                  if (c.size() == 1){
             .      .    .              .             .         .              .           .      .                      // when unit clause occur, enqueue and propagate
            15      2    2              3             0         0              3           0      0                      uncheckedEnqueue(c[0]);
             9      0    0              3             0         0              0           0      0                      if (propagate() != CRef_Undef){
             .      .    .              .             .         .              .           .      .                          ok = false;
             .      .    .              .             .         .              .           .      .                          return false;
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                      // delete the clause memory in logic
             .      .    .              .             .         .              .           .      .                      c.mark(1);
             .      .    .              .             .         .              .           .      .                      ca.free(cr);
             .      .    .              .             .         .              .           .      .  //#ifdef BIN_DRUP
             .      .    .              .             .         .              .           .      .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
             .      .    .              .             .         .              .           .      .  //#else
             .      .    .              .             .         .              .           .      .  //                    fprintf(drup_file, "d ");
             .      .    .              .             .         .              .           .      .  //                    for (int i = 0; i < c.size(); i++)
             .      .    .              .             .         .              .           .      .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .              .             .         .              .           .      .  //                    fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  //#endif
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .                  else{
        86,076      0    0              0             0         0         28,692           0      0                      attachClause(cr);
       172,152     32   30         86,076        54,017         0         28,692         186      0                      learnts_core[cj++] = learnts_core[ci];
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                      nblevels = computeLBD(c);
        57,384     34   30              0             0         0              0           0      0                      if (nblevels < c.lbd()){
             .      .    .              .             .         .              .           .      .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .      .    .              .             .         .              .           .      .                          c.set_lbd(nblevels);
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                      c.setSimplified(true);
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
            34      0    0              0             0         0              0           0      0      learnts_core.shrink(ci - cj);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .      .    .              .             .         .              .           .      .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
             .      .    .              .             .         .              .           .      .  
            34     32   28              0             0         0              0           0      0      return true;
             .      .    .              .             .         .              .           .      .  
           272      0    0            238            34         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
     2,537,190      2    2              0             0         0      1,691,460           0      0  int Solver::is_duplicate(std::vector<uint32_t>&c){
       563,820      0    0              0             0         0        563,820      14,219      0     auto time_point_0 = std::chrono::high_resolution_clock::now();
       281,910      0    0        281,910       220,924        59              0           0      0      dupl_db_size++;
       738,523    993   34        226,799             0         0              0           0      0      int res = 0;    
             .      .    .              .             .         .              .           .      .      
       563,820      0    0        563,820             0         0              0           0      0      int sz = c.size();
             .      .    .              .             .         .              .           .      .      std::vector<uint32_t> tmp(c);    
             .      .    .              .             .         .              .           .      .      sort(tmp.begin(),tmp.end());
             .      .    .              .             .         .              .           .      .      
       281,910 47,478   62              0             0         0        281,910           0      0      uint64_t hash = 0;    
             .      .    .              .             .         .              .           .      .      
     8,801,828  6,950  108              0             0         0        281,910           0      0      for (int i =0; i<sz; i++) {
    32,732,740      0    0      3,273,274             0         0              0           0      0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
             .      .    .              .             .         .              .           .      .      }    
             .      .    .              .             .         .              .           .      .      
       281,910      0    0              0             0         0        281,910           0      0      int32_t head = tmp[0];
             .      .    .              .             .         .              .           .      .      auto it0 = ht.find(head);
     1,388,910      0    0        281,904             0         0              0           0      0      if (it0 != ht.end()){
             .      .    .              .             .         .              .           .      .          auto it1=ht[head].find(sz);
       550,068      0    0              0             0         0              0           0      0          if (it1 != ht[head].end()){
       218,442      0    0              0             0         0        218,442           0      0              auto it2 = ht[head][sz].find(hash);
       655,326      0    0              0             0         0        218,442           0      0              if (it2 != ht[head][sz].end()){
        78,144      0    0         26,048         5,756     3,457         26,048           0      0                  it2->second++;
        26,048      0    0              0             0         0              0           0      0                  res = it2->second;            
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              else{
       192,394      0    0              0             0         0        192,394           0      0                  ht[head][sz][hash]=1;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          else{            
       113,184      3    1              0             0         0         56,592           0      0              ht[head][sz][hash]=1;
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }else{        
       262,738  4,400   98              0             0         0        262,738           0      0          ht[head][sz][hash]=1;
             .      .    .              .             .         .              .           .      .      } 
       281,910     49    8              0             0         0        281,910           0      0      auto time_point_1 = std::chrono::high_resolution_clock::now();
             .      .    .              .             .         .              .           .      .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
             .      .    .              .             .         .              .           .      .      return res;
     2,537,190      0    0      1,973,370             0         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  bool Solver::simplifyLearnt_tier2()
           374     34   29              0             0         0            204           0      0  {
             .      .    .              .             .         .              .           .      .      int beforeSize, afterSize;
             .      .    .              .             .         .              .           .      .      int learnts_tier2_size_before = learnts_tier2.size();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      int ci, cj, li, lj;
             .      .    .              .             .         .              .           .      .      bool sat, false_lit;
             .      .    .              .             .         .              .           .      .      unsigned int nblevels;
             .      .    .              .             .         .              .           .      .      ////
             .      .    .              .             .         .              .           .      .      //printf("learnts_x size : %d\n", learnts_x.size());
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      ////
             .      .    .              .             .         .              .           .      .      int nbSimplified = 0;
             .      .    .              .             .         .              .           .      .      int nbSimplifing = 0;
             .      .    .              .             .         .              .           .      .  
       376,048     34   22             34            34         0              0           0      0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
       563,919      0    0        375,946        11,789     1,644              0           0      0          CRef cr = learnts_tier2[ci];
             .      .    .              .             .         .              .           .      .          Clause& c = ca[cr];
             .      .    .              .             .         .              .           .      .  
       375,946      0    0              0             0         0              0           0      0          if (removed(cr)) continue;
       375,946      0    0        187,973        23,013         0              0           0      0          else if (c.simplified()){
       213,638      0    0              0             0         0        106,819         467      0              learnts_tier2[cj++] = learnts_tier2[ci];
             .      .    .              .             .         .              .           .      .              ////
       482,763      0    0        106,819             0         0              0           0      0              nbSimplified++;
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          else{
             .      .    .              .             .         .              .           .      .              int saved_size=c.size();
             .      .    .              .             .         .              .           .      .              //            if (drup_file){
             .      .    .              .             .         .              .           .      .              //                    add_oc.clear();
             .      .    .              .             .         .              .           .      .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
             .      .    .              .             .         .              .           .      .              ////
             .      .    .              .             .         .              .           .      .              nbSimplifing++;
        81,154      0    0              0             0         0              0           0      0              sat = false_lit = false;
     1,874,632      0    0              0             0         0              0           0      0              for (int i = 0; i < c.size(); i++){
     1,874,632      0    0              0             0         0              0           0      0                  if (value(c[i]) == l_True){
             .      .    .              .             .         .              .           .      .                      sat = true;
             .      .    .              .             .         .              .           .      .                      break;
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .                  else if (value(c[i]) == l_False){
     2,036,940      9    7              0             0         0         81,154           0      0                      false_lit = true;
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              if (sat){
             .      .    .              .             .         .              .           .      .                  removeClause(cr);
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              else{
       486,924     29   26              0             0         0        243,462          32      0                  detachClause(cr, true);
             .      .    .              .             .         .              .           .      .  
       324,616      0    0        162,308             0         0              0           0      0                  if (false_lit){
           175      3    3             10             0         0              0           0      0                      for (li = lj = 0; li < c.size(); li++){
           130      0    0              0             0         0              0           0      0                          if (value(c[li]) != l_False){
           180      0    0              0             0         0             60           0      0                              c[lj++] = c[li];
             .      .    .              .             .         .              .           .      .                          }
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                      c.shrink(li - lj);
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                  beforeSize = c.size();
             .      .    .              .             .         .              .           .      .                  assert(c.size() > 1);
             .      .    .              .             .         .              .           .      .                  // simplify a learnt clause c
       405,770      0    0              0             0         0        243,462           0      0                  simplifyLearnt(c);
             .      .    .              .             .         .              .           .      .                  assert(c.size() > 0);
             .      .    .              .             .         .              .           .      .                  afterSize = c.size();
             .      .    .              .             .         .              .           .      .                  
       324,616     32   29        162,308       159,804         0              0           0      0                  if(drup_file && saved_size!=c.size()){
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  #ifdef BIN_DRUP
             .      .    .              .             .         .              .           .      .                      binDRUP('a', c , drup_file);
             .      .    .              .             .         .              .           .      .                      //                    binDRUP('d', add_oc, drup_file);
             .      .    .              .             .         .              .           .      .  #else
             .      .    .              .             .         .              .           .      .                      for (int i = 0; i < c.size(); i++)
             .      .    .              .             .         .              .           .      .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .              .             .         .              .           .      .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
             .      .    .              .             .         .              .           .      .                      //                    for (int i = 0; i < add_oc.size(); i++)
             .      .    .              .             .         .              .           .      .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .      .    .              .             .         .              .           .      .                      //                    fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
             .      .    .              .             .         .              .           .      .  
       162,308      0    0              0             0         0              0           0      0                  if (c.size() == 1){
             .      .    .              .             .         .              .           .      .                      // when unit clause occur, enqueue and propagate
             5      0    0              1             0         0              1           0      0                      uncheckedEnqueue(c[0]);
             3      0    0              1             0         0              0           0      0                      if (propagate() != CRef_Undef){
             .      .    .              .             .         .              .           .      .                          ok = false;
             .      .    .              .             .         .              .           .      .                          return false;
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                      // delete the clause memory in logic
             .      .    .              .             .         .              .           .      .                      c.mark(1);
             .      .    .              .             .         .              .           .      .                      ca.free(cr);
             .      .    .              .             .         .              .           .      .  //#ifdef BIN_DRUP
             .      .    .              .             .         .              .           .      .  //                    binDRUP('d', c, drup_file);
-- line 841 ----------------------------------------
-- line 845 ----------------------------------------
             .      .    .              .             .         .              .           .      .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .              .             .         .              .           .      .  //                    fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  //#endif
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .                  else{
             .      .    .              .             .         .              .           .      .                      
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                      nblevels = computeLBD(c);
       162,306      0    0              0             0         0              0           0      0                      if (nblevels < c.lbd()){
             .      .    .              .             .         .              .           .      .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
             .      .    .              .             .         .              .           .      .                          c.set_lbd(nblevels);
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                       //duplicate learnts 
             .      .    .              .             .         .              .           .      .                      int id = 0;                    
             .      .    .              .             .         .              .           .      .                      
             .      .    .              .             .         .              .           .      .                      std::vector<uint32_t> tmp;
     2,518,691      0    0      1,833,432             0         0              0           0      0                      for (int i = 0; i < c.size(); i++)                           
     1,330,492      0    0        665,246             0         0        665,246           0      0                          tmp.push_back(c[i].x);
       324,612      0    0              0             0         0         81,153           0      0                      id = is_duplicate(tmp);
             .      .    .              .             .         .              .           .      .                       
             .      .    .              .             .         .              .           .      .                                          
             .      .    .              .             .         .              .           .      .                      //duplicate learnts 
             .      .    .              .             .         .              .           .      .  
       324,612      2    2         81,153        80,224         0              0           0      0                      if (id < min_number_of_learnts_copies+2){
       243,429     11   11              0             0         0         81,143           0      0                          attachClause(cr);
       396,405      0    0        243,429       160,143         0         81,143      76,975      0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
       324,572     34   30         81,143             0         0              0           0      0                          if (id == min_number_of_learnts_copies+1){                            
           151      0    0            151             0         0              0           0      0                              duplicates_added_minimization++;                                  
             .      .    .              .             .         .              .           .      .                          }
       161,984      0    0         80,992        80,049         0              0           0      0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
             .      .    .              .             .         .              .           .      .                          //if (id == min_number_of_learnts_copies+1){
             .      .    .              .             .         .              .           .      .                              cj--;
             2      2    1              0             0         0              0           0      0                              learnts_core.push(cr);
             .      .    .              .             .         .              .           .      .                              c.mark(CORE);
             .      .    .              .             .         .              .           .      .                          }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                          c.setSimplified(true);
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
            34     30   27              0             0         0              0           0      0      learnts_tier2.shrink(ci - cj);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
             .      .    .              .             .         .              .           .      .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
             .      .    .              .             .         .              .           .      .  
            34      0    0              0             0         0              0           0      0      return true;
             .      .    .              .             .         .              .           .      .  
           272      0    0            238            34         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  bool Solver::simplifyAll()
           170     10    8              0             0         0            102           0      0  {
             .      .    .              .             .         .              .           .      .      ////
            68      0    0              0             0         0             34           0      0      simplified_length_record = original_length_record = 0;
             .      .    .              .             .         .              .           .      .  
           136      0    0             34            20         0              0           0      0      if (!ok || propagate() != CRef_Undef)
             .      .    .              .             .         .              .           .      .          return ok = false;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      //// cleanLearnts(also can delete these code), here just for analyzing
             .      .    .              .             .         .              .           .      .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .      .    .              .             .         .              .           .      .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
             .      .    .              .             .         .              .           .      .      //local_learnts_dirty = tier2_learnts_dirty = false;
             .      .    .              .             .         .              .           .      .  
           136      0    0              0             0         0             34           0      0      if (!simplifyLearnt_core()) return ok = false;
           136     34   30              0             0         0             34           0      0      if (!simplifyLearnt_tier2()) return ok = false;
             .      .    .              .             .         .              .           .      .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      checkGarbage();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      ////
             .      .    .              .             .         .              .           .      .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
             .      .    .              .             .         .              .           .      .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      return true;
           170      0    0            136             0         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  //=================================================================================================
             .      .    .              .             .         .              .           .      .  // Minor methods:
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
             .      .    .              .             .         .              .           .      .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
             .      .    .              .             .         .              .           .      .  //
             .      .    .              .             .         .              .           .      .  Var Solver::newVar(bool sign, bool dvar)
        52,440      1    1              0             0         0         41,952           0      0  {
             .      .    .              .             .         .              .           .      .      int v = nVars();
             .      .    .              .             .         .              .           .      .      watches_bin.init(mkLit(v, false));
             .      .    .              .             .         .              .           .      .      watches_bin.init(mkLit(v, true ));
             .      .    .              .             .         .              .           .      .      watches  .init(mkLit(v, false));
             .      .    .              .             .         .              .           .      .      watches  .init(mkLit(v, true ));
            19      1    1              0             0         0              0           0      0      assigns  .push(l_Undef);
            19      1    1              0             0         0              0           0      0      vardata  .push(mkVarData(CRef_Undef, 0));
            19      0    0              0             0         0              0           0      0      activity_CHB  .push(0);
        15,770      0    0          5,244            94         0             19           0      0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
             .      .    .              .             .         .              .           .      .  
            19      1    1              0             0         0              0           0      0      picked.push(0);
            19      0    0              0             0         0              0           0      0      conflicted.push(0);
            19      0    0              0             0         0              0           0      0      almost_conflicted.push(0);
             .      .    .              .             .         .              .           .      .  #ifdef ANTI_EXPLORATION
            19      0    0              0             0         0              0           0      0      canceled.push(0);
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .  
            19      0    0              0             0         0              0           0      0      seen     .push(0);
            19      0    0              0             0         0              0           0      0      seen2    .push(0);
            19      0    0              0             0         0              0           0      0      polarity .push(sign);
            19      0    0              0             0         0              0           0      0      decision .push();
        26,220      1    1              0             0         0         10,488         166      0      trail    .capacity(v+1);
             .      .    .              .             .         .              .           .      .      setDecisionVar(v, dvar);
             .      .    .              .             .         .              .           .      .  
            19      0    0              0             0         0              0           0      0      activity_distance.push(0);
            19      1    1              0             0         0              0           0      0      var_iLevel.push(0);
            19      0    0              0             0         0              0           0      0      var_iLevel_tmp.push(0);
            19      0    0              0             0         0              0           0      0      pathCs.push(0);
             .      .    .              .             .         .              .           .      .      return v;
        47,196      0    0         36,708            17         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  bool Solver::addClause_(vec<Lit>& ps)
       883,974      2    1              0             0         0        757,692           2      0  {
             .      .    .              .             .         .              .           .      .      assert(decisionLevel() == 0);
       378,846      2    1        126,282             0         0              0           0      0      if (!ok) return false;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Check if clause is satisfied and remove false/duplicate literals:
             .      .    .              .             .         .              .           .      .      sort(ps);
             .      .    .              .             .         .              .           .      .      Lit p; int i, j;
             .      .    .              .             .         .              .           .      .  
       252,564      0    0        126,282            27         0              0           0      0      if (drup_file){
             .      .    .              .             .         .              .           .      .          add_oc.clear();
       126,282      2    1        126,282             0         0              0           0      0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
             .      .    .              .             .         .              .           .      .  
     2,608,458      0    0              0             0         0              0           0      0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
     4,447,407      0    0        793,037             0         0              0           0      0          if (value(ps[i]) == l_True || ps[i] == ~p)
             .      .    .              .             .         .              .           .      .              return true;
     3,139,872      4    2              0             0         0              0           0      0          else if (value(ps[i]) != l_False && ps[i] != p)
     2,353,914      0    0        784,638             0         0        784,638           0      0              ps[j++] = p = ps[i];
       948,344      0    0        118,543             0         0              0           0      0      ps.shrink(i - j);
             .      .    .              .             .         .              .           .      .  
       237,086      2    1              0             0         0              0           0      0      if (drup_file && i != j){
             .      .    .              .             .         .              .           .      .  #ifdef BIN_DRUP
             .      .    .              .             .         .              .           .      .          binDRUP('a', ps, drup_file);
       118,543      0    0        118,543             0         0              0           0      0          binDRUP('d', add_oc, drup_file);
             .      .    .              .             .         .              .           .      .  #else
             .      .    .              .             .         .              .           .      .          for (int i = 0; i < ps.size(); i++)
             .      .    .              .             .         .              .           .      .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
             .      .    .              .             .         .              .           .      .          fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          fprintf(drup_file, "d ");
             .      .    .              .             .         .              .           .      .          for (int i = 0; i < add_oc.size(); i++)
             .      .    .              .             .         .              .           .      .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
             .      .    .              .             .         .              .           .      .          fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .      
       237,086      0    0              0             0         0              0           0      0      if (ps.size() == 0)
             .      .    .              .             .         .              .           .      .          return ok = false;
       237,086      2    1              0             0         0              0           0      0      else if (ps.size() == 1){
         1,584      0    0            528             0         0            264           0      0          uncheckedEnqueue(ps[0]);
         1,056      0    0              0             0         0            264           0      0          return ok = (propagate() == CRef_Undef);
             .      .    .              .             .         .              .           .      .      }else{
       118,279      0    0              0             0         0        118,279           0      0          CRef cr = ca.alloc(ps, false);
             .      .    .              .             .         .              .           .      .          //auto ca_size=ca.size();
             .      .    .              .             .         .              .           .      .          //printf("ca size:%d\n",ca_size);
       354,837      0    0              0             0         0        118,279           0      0          clauses.push(cr);
       354,837      2    1        118,279             0         0        118,279           0      0          attachClause(cr);
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
       118,279      0    0              0             0         0              0           0      0      return true;
     1,389,102      0    0        883,974            10         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
    16,421,260      9    1              0             0         0      9,852,756           0      0  void Solver::attachClause(CRef cr) {
             .      .    .              .             .         .              .           .      .      const Clause& c = ca[cr];
             .      .    .              .             .         .              .           .      .      assert(c.size() > 1);
     6,533,883      0    0      1,642,126             6         0              0           0      0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .      .    .              .             .         .              .           .      .      ws[~c[0]].push(Watcher(cr, c[1]));
             .      .    .              .             .         .              .           .      .      ws[~c[1]].push(Watcher(cr, c[0]));
     4,687,123      0    0      3,044,997     1,171,478        43              0           0      0      if (c.learnt()) learnts_literals += c.size();
    13,376,263      1    0     11,734,137            56         0              0           0      0      else            clauses_literals += c.size(); }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
     8,683,458    123   89              0             0         0      5,788,972       1,215      0  void Solver::detachClause(CRef cr, bool strict) {
             .      .    .              .             .         .              .           .      .      const Clause& c = ca[cr];
             .      .    .              .             .         .              .           .      .      assert(c.size() > 1);
     5,788,972      0    0              0             0         0              0           0      0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
             .      .    .              .             .         .              .           .      .      
     5,788,972      0    0              0             0         0              0           0      0      if (strict){
             .      .    .              .             .         .              .           .      .          remove(ws[~c[0]], Watcher(cr, c[1]));
             .      .    .              .             .         .              .           .      .          remove(ws[~c[1]], Watcher(cr, c[0]));
             .      .    .              .             .         .              .           .      .      }else{
             .      .    .              .             .         .              .           .      .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
             .      .    .              .             .         .              .           .      .          ws.smudge(~c[0]);
             .      .    .              .             .         .              .           .      .          ws.smudge(~c[1]);
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
     4,213,802      8    3      2,766,559           180         0              0           0      0      if (c.learnt()) learnts_literals -= c.size();
     8,811,385      0    0      7,364,142         1,319         0              0           0      0      else            clauses_literals -= c.size(); }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
     9,731,344    181  150              0             0         0      4,865,672          10      0  void Solver::removeClause(CRef cr) {
             .      .    .              .             .         .              .           .      .      Clause& c = ca[cr];
             .      .    .              .             .         .              .           .      .  
     3,649,254      0    0      1,216,418           123         0              0           0      0      if (drup_file){
             .      .    .              .             .         .              .           .      .          if (c.mark() != 1){
             .      .    .              .             .         .              .           .      .  #ifdef BIN_DRUP
             .      .    .              .             .         .              .           .      .              binDRUP('d', c, drup_file);
             .      .    .              .             .         .              .           .      .  #else
             .      .    .              .             .         .              .           .      .              fprintf(drup_file, "d ");
             .      .    .              .             .         .              .           .      .              for (int i = 0; i < c.size(); i++)
             .      .    .              .             .         .              .           .      .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
             .      .    .              .             .         .              .           .      .              fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .          }else
             .      .    .              .             .         .              .           .      .              printf("c Bug. I don't expect this to happen.\n");
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
     4,865,672     91   84              0             0         0      1,216,418           0      0      detachClause(cr);
             .      .    .              .             .         .              .           .      .      // Don't leave pointers to free'd memory!
             .      .    .              .             .         .              .           .      .      if (locked(c)){
             .      .    .              .             .         .              .           .      .          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
             .      .    .              .             .         .              .           .      .          vardata[var(implied)].reason = CRef_Undef; }
             .      .    .              .             .         .              .           .      .      c.mark(1);
             .      .    .              .             .         .              .           .      .      ca.free(cr);
     7,298,508      0    0      6,082,090             1         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  bool Solver::satisfied(const Clause& c) const {
    11,190,256     12    5              0             0         0              0           0      0      for (int i = 0; i < c.size(); i++)
    12,647,580      0    0      4,867,946         5,305         0              0           0      0          if (value(c[i]) == l_True)
         1,765      1    1              0             0         0              0           0      0              return true;
       457,199      0    0        229,482             0         0              0           0      0      return false; }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
             .      .    .              .             .         .              .           .      .  //
    11,702,952  4,316  117              0             0         0      7,801,968           0      0  void Solver::cancelUntil(int bLevel) {
             .      .    .              .             .         .              .           .      .  	
     5,215,673      8    2          7,292             0         0      1,300,328           0      0      if (decisionLevel() > bLevel){
             .      .    .              .             .         .              .           .      .  #ifdef PRINT_OUT
             .      .    .              .             .         .              .           .      .  		std::cout << "bt " << bLevel << "\n";
             .      .    .              .             .         .              .           .      .  #endif				
     2,600,656      0    0              0             0         0      1,300,328     250,515      0  		add_tmp.clear();
 3,833,773,947  7,157   77    769,615,511     2,333,722        87              0           0      0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
             .      .    .              .             .         .              .           .      .          {
             .      .    .              .             .         .              .           .      .              Var      x  = var(trail[c]);
             .      .    .              .             .         .              .           .      .  
 1,526,227,742      0    0    763,113,871   527,571,506     2,259              0           0      0  			if (level(x) <= bLevel)
             .      .    .              .             .         .              .           .      .  			{
             .      .    .              .             .         .              .           .      .  				add_tmp.push(trail[c]);
             .      .    .              .             .         .              .           .      .  			}
             .      .    .              .             .         .              .           .      .  			else
             .      .    .              .             .         .              .           .      .  			{
 1,526,084,842      0    0    763,042,421       249,891         0              0           0      0  				 if (!VSIDS){
 1,214,337,084      0    0    809,558,056         8,716         0              0           0      0  					uint32_t age = conflicts - picked[x];
   809,558,056      0    0    404,779,028   269,474,776     1,007              0           0      0  					if (age > 0){
 4,045,453,060  1,078   35  1,618,181,224   538,328,727       882              0           0      0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
   404,545,306      0    0    404,545,306   294,249,701     2,810              0           0      0  						double old_activity = activity_CHB[x];
 2,831,817,142     22   14    809,090,612       926,487         0    404,545,306           0      0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
             .      .    .              .             .         .              .           .      .  						if (order_heap_CHB.inHeap(x)){
 2,416,101,012    378   18              0             0         0  1,208,050,506         452      0  							if (activity_CHB[x] > old_activity)
             .      .    .              .             .         .              .           .      .  								order_heap_CHB.decrease(x);
             .      .    .              .             .         .              .           .      .  							else
             .      .    .              .             .         .              .           .      .  								order_heap_CHB.increase(x);
             .      .    .              .             .         .              .           .      .  						}
             .      .    .              .             .         .              .           .      .  					}
             .      .    .              .             .         .              .           .      .  #ifdef ANTI_EXPLORATION
   809,558,056      0    0    404,779,028       495,554         0    404,779,028 269,327,538    947  					canceled[x] = conflicts;
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .  				}
             .      .    .              .             .         .              .           .      .  				
 1,526,084,842    716   54    763,042,421       474,969         0    763,042,421 198,243,403     13  				assigns [x] = l_Undef;
             .      .    .              .             .         .              .           .      .  #ifdef PRINT_OUT
             .      .    .              .             .         .              .           .      .  				std::cout << "undo " << x << "\n";
             .      .    .              .             .         .              .           .      .  #endif				
 1,526,084,842      0    0    763,042,421             0         0              0           0      0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
   763,042,421      0    0    763,042,421             0         0              0           0      0  					polarity[x] = sign(trail[c]);
             .      .    .              .             .         .              .           .      .  				insertVarOrder(x);
             .      .    .              .             .         .              .           .      .  			}
             .      .    .              .             .         .              .           .      .          }
     1,300,328      0    0              0             0         0      1,300,328           0      0          qhead = trail_lim[bLevel];
     2,600,656      0    0              0             0         0              0           0      0          trail.shrink(trail.size() - trail_lim[bLevel]);
     3,900,984      0    0      1,300,328             0         0              0           0      0          trail_lim.shrink(trail_lim.size() - bLevel);
     4,043,884      1    1      1,300,328             0         0              0           0      0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
             .      .    .              .             .         .              .           .      .  		{
         7,554      0    0          2,518             0         0              0           0      0  			trail.push_(add_tmp[nLitId]);
             .      .    .              .             .         .              .           .      .  		}
             .      .    .              .             .         .              .           .      .  		
             .      .    .              .             .         .              .           .      .  		add_tmp.clear();
    10,402,624      0    0      9,102,296     1,008,740         0              0           0      0      } }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  //=================================================================================================
             .      .    .              .             .         .              .           .      .  // Major methods:
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  Lit Solver::pickBranchLit()
    25,074,584    366    9              0             0         0     18,805,938           0      0  {
             .      .    .              .             .         .              .           .      .      Var next = var_Undef;
             .      .    .              .             .         .              .           .      .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
    19,834,145  1,878  103      5,499,289     1,425,630        80              0           0      0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Random decision:
             .      .    .              .             .         .              .           .      .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
             .      .    .              .             .         .              .           .      .          next = order_heap[irand(random_seed,order_heap.size())];
             .      .    .              .             .         .              .           .      .          if (value(next) == l_Undef && decision[next])
             .      .    .              .             .         .              .           .      .              rnd_decisions++; }*/
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Activity based decision:
    55,004,475    704    3     24,367,914     4,466,004     1,550              0           0      0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    14,964,950      0    0              0             0         0              0           0      0          if (order_heap.empty())
             1      0    0              0             0         0              0           0      0              return lit_Undef;
             .      .    .              .             .         .              .           .      .          else{
             .      .    .              .             .         .              .           .      .  #ifdef ANTI_EXPLORATION
    14,964,948      0    0      7,482,474           616         1              0           0      0              if (!VSIDS){
             .      .    .              .             .         .              .           .      .                  Var v = order_heap_CHB[0];
     4,165,536      0    0      4,165,536        21,057         0              0           0      0                  uint32_t age = conflicts - canceled[v];
     7,591,168      0    0      3,354,382     2,473,699     1,726        441,202           1      0                  while (age > 0){
             .      .    .              .             .         .              .           .      .                      double decay = pow(0.95, age);
     2,543,228      0    0      1,271,614        60,401         5      1,271,614           0      0                      activity_CHB[v] *= decay;
             .      .    .              .             .         .              .           .      .                      if (order_heap_CHB.inHeap(v))
             .      .    .              .             .         .              .           .      .                          order_heap_CHB.increase(v);
     3,814,842      0    0      2,543,228             0         0      1,271,614           0      0                      canceled[v] = conflicts;
             .      .    .              .             .         .              .           .      .                      v = order_heap_CHB[0];
             .      .    .              .             .         .              .           .      .                      age = conflicts - canceled[v];
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .              next = order_heap.removeMin();
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .  
    12,537,288      0    0      6,268,644     2,638,634       146              0           0      0      return mkLit(next, polarity[next]);
    28,208,906      0    0     21,940,261        12,382         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
             .      .    .              .             .         .              .           .      .  {
             .      .    .              .             .         .              .           .      .  	ConflictData data;
             .      .    .              .             .         .              .           .      .  	Clause& conflCls = ca[cind];
             .      .    .              .             .         .              .           .      .  	data.nHighestLevel = level(var(conflCls[0]));
     5,170,654      0    0      2,585,327       110,478         0              0           0      0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
             .      .    .              .             .         .              .           .      .  	{
             .      .    .              .             .         .              .           .      .  		return data;
             .      .    .              .             .         .              .           .      .  	}
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  	int highestId = 0;
             .      .    .              .             .         .              .           .      .      data.bOnlyOneLitFromHighest = true;
             .      .    .              .             .         .              .           .      .  	// find the largest decision level in the clause
        18,568      7    4              0             0         0              0           0      0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
             .      .    .              .             .         .              .           .      .  	{
             .      .    .              .             .         .              .           .      .  		int nLevel = level(var(conflCls[nLitId]));
         9,531      0    0              0             0         0              0           0      0  		if (nLevel > data.nHighestLevel)
             .      .    .              .             .         .              .           .      .  		{
             .      .    .              .             .         .              .           .      .  			highestId = nLitId;
             .      .    .              .             .         .              .           .      .  			data.nHighestLevel = nLevel;
           185      0    0              0             0         0              0           0      0  			data.bOnlyOneLitFromHighest = true;
             .      .    .              .             .         .              .           .      .  		}
             .      .    .              .             .         .              .           .      .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
             .      .    .              .             .         .              .           .      .  		{
         8,606      0    0              0             0         0              0           0      0  			data.bOnlyOneLitFromHighest = false;
             .      .    .              .             .         .              .           .      .  		}
             .      .    .              .             .         .              .           .      .  	}
             .      .    .              .             .         .              .           .      .  
         2,398     57    4              0             0         0              0           0      0  	if (highestId != 0)
             .      .    .              .             .         .              .           .      .  	{
             .      .    .              .             .         .              .           .      .  		std::swap(conflCls[0], conflCls[highestId]);
           348      0    0              0             0         0              0           0      0  		if (highestId > 1)
             .      .    .              .             .         .              .           .      .  		{
           472      0    0              0             0         0              0           0      0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
             .      .    .              .             .         .              .           .      .  			//ws.smudge(~conflCls[highestId]);
             .      .    .              .             .         .              .           .      .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
             .      .    .              .             .         .              .           .      .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
             .      .    .              .             .         .              .           .      .  		}
             .      .    .              .             .         .              .           .      .  	}
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  	return data;
             .      .    .              .             .         .              .           .      .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
             .      .    .              .             .         .              .           .      .  |  
             .      .    .              .             .         .              .           .      .  |    Post-conditions:
             .      .    .              .             .         .              .           .      .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
             .      .    .              .             .         .              .           .      .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
             .      .    .              .             .         .              .           .      .  |        rest of literals. There may be others from the same level though.
             .      .    .              .             .         .              .           .      .  |  
             .      .    .              .             .         .              .           .      .  |________________________________________________________________________________________________@*/
             .      .    .              .             .         .              .           .      .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
    16,809,468     76   39              0             0         0     11,637,324           0      0  {
     1,293,036      0    0              0             0         0      1,293,036       4,604      0      int pathC = 0;
     1,293,036      0    0              0             0         0              0           0      0      Lit p     = lit_Undef;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Generate conflict clause:
             .      .    .              .             .         .              .           .      .      //
             .      .    .              .             .         .              .           .      .      out_learnt.push();      // (leave room for the asserting literal)
     2,586,072      0    0      1,293,036             0         0              0           0      0      int index   = trail.size() - 1;
     1,293,036      0    0      1,293,036             0         0              0           0      0      int nDecisionLevel = level(var(ca[confl][0]));
             .      .    .              .             .         .              .           .      .      assert(nDecisionLevel == level(var(ca[confl][0])));
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      do{
             .      .    .              .             .         .              .           .      .          assert(confl != CRef_Undef); // (otherwise should be UIP)
             .      .    .              .             .         .              .           .      .          Clause& c = ca[confl];
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
   265,377,826      0    0              0             0         0              0           0      0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
             .      .    .              .             .         .              .           .      .              assert(value(c[1]) == l_True);
             .      .    .              .             .         .              .           .      .              Lit tmp = c[0];
    11,693,553      0    0      3,897,851       229,062     1,368      7,795,702           0      0              c[0] = c[1], c[1] = tmp; }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          // Update LBD if improved.
   201,964,972      1    1     45,465,774             0         0              0           0      0          if (c.learnt() && c.mark() != CORE){
             .      .    .              .             .         .              .           .      .              int lbd = computeLBD(c);
    14,178,302      0    0              0             0         0              0           0      0              if (lbd < c.lbd()){
       857,058      0    0              0             0         0              0           0      0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
             .      .    .              .             .         .              .           .      .                  c.set_lbd(lbd);
       857,058      0    0        428,529       348,639         9              0           0      0                  if (lbd <= core_lbd_cut){
             6      1    1              0             0         0              3           0      0                      learnts_core.push(confl);
             .      .    .              .             .         .              .           .      .                      c.mark(CORE);
     1,057,285      0    0        104,678             0         0              0           0      0                  }else if (lbd <= 6 && c.mark() == LOCAL){
             .      .    .              .             .         .              .           .      .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
             .      .    .              .             .         .              .           .      .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     9,235,872      4    2              0             0         0      2,678,382   1,252,590     52                      learnts_tier2.push(confl);
             .      .    .              .             .         .              .           .      .                      c.mark(TIER2); }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
    14,018,340      0    0      7,009,170             5         0              0           0      0              if (c.mark() == TIER2)
    13,360,768     34   29      3,340,192       349,282         0      3,340,192     411,196    275                  c.touched() = conflicts;
     7,430,266      0    0      3,715,133             0         0              0           0      0              else if (c.mark() == LOCAL)
             .      .    .              .             .         .              .           .      .                  claBumpActivity(c);
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .  
 1,315,850,556     11    7    442,449,132         1,523         0     55,026,366          28      0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
   387,422,766      0    0    387,422,766    11,546,044     2,606              0           0      0              Lit q = c[j];
             .      .    .              .             .         .              .           .      .  
 1,504,046,562      1    1    630,489,776    87,999,462     1,985              0           0      0              if (!seen[var(q)] && level(var(q)) > 0){
   486,134,020      0    0    243,067,010         2,496         0              0           0      0                  if (VSIDS){
             .      .    .              .             .         .              .           .      .                      varBumpActivity(var(q), .5);
            18      0    0              0             0         0              9           0      0                      add_tmp.push(q);
             .      .    .              .             .         .              .           .      .                  }else
   128,436,408      0    0    128,436,408    55,373,998       725              0           0      0                      conflicted[var(q)]++;
   243,067,010      0    0              0             0         0    243,067,010          71      0                  seen[var(q)] = 1;
   486,134,020      0    0    243,067,010            71         0              0           0      0                  if (level(var(q)) >= nDecisionLevel){
   110,052,732      0    0    110,052,732            94         0              0           0      0                      pathC++;
             .      .    .              .             .         .              .           .      .                  }else
             .      .    .              .             .         .              .           .      .                      out_learnt.push(q);
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          
             .      .    .              .             .         .              .           .      .          // Select next clause to look at:
             .      .    .              .             .         .              .           .      .  		do {
 3,627,440,072      0    0  1,461,981,302   116,823,384     6,872              0           0      0  			while (!seen[var(trail[index--])]);
             .      .    .              .             .         .              .           .      .  			p  = trail[index+1];
   110,054,968      2    1     55,027,484     3,749,926         0              0           0      0  		} while (level(var(p)) < nDecisionLevel);
             .      .    .              .             .         .              .           .      .  		
   110,052,732      0    0     55,026,366             0         0     55,026,366           0      0          confl = reason(var(p));
    55,026,366      0    0              0             0         0     55,026,366           0      0          seen[var(p)] = 0;
   110,052,732      0    0    110,052,732             6         0              0           0      0          pathC--;
             .      .    .              .             .         .              .           .      .  
   324,986,052      0    0    107,466,660       212,405         3              0           0      0      }while (pathC > 0);
     1,293,036      0    0      1,293,036            78         0              0           0      0      out_learnt[0] = ~p;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Simplify conflict clause:
             .      .    .              .             .         .              .           .      .      //
             .      .    .              .             .         .              .           .      .      int i, j;
     2,586,072      0    0              0             0         0      1,293,036           0      0      out_learnt.copyTo(analyze_toclear);
     3,879,108      0    0      1,293,036            72         0              0           0      0      if (ccmin_mode == 2){
     1,293,036    597   79              0             0         0              0           0      0          uint32_t abstract_level = 0;
   378,667,360    492   54              0             0         0              0           0      0          for (i = 1; i < out_learnt.size(); i++)
   190,626,716      0    0      1,293,036             0         0              0           0      0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
             .      .    .              .             .         .              .           .      .  
 1,329,214,868     18    7    562,828,896         1,460         0      1,293,036       2,674      0          for (i = j = 1; i < out_learnt.size(); i++)
 1,501,555,369     34   27    318,544,172    36,589,305         0    172,893,405           0      0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
   436,952,301      3    1    145,650,767           775         0    145,650,767     307,585      0                  out_learnt[j++] = out_learnt[i];
             .      .    .              .             .         .              .           .      .          
             .      .    .              .             .         .              .           .      .      }else if (ccmin_mode == 1){
             .      .    .              .             .         .              .           .      .          for (i = j = 1; i < out_learnt.size(); i++){
             .      .    .              .             .         .              .           .      .              Var x = var(out_learnt[i]);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              if (reason(x) == CRef_Undef)
             .      .    .              .             .         .              .           .      .                  out_learnt[j++] = out_learnt[i];
             .      .    .              .             .         .              .           .      .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
             .      .    .              .             .         .              .           .      .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
             .      .    .              .             .         .              .           .      .                          out_learnt[j++] = out_learnt[i];
             .      .    .              .             .         .              .           .      .                          break; }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }else
             .      .    .              .             .         .              .           .      .          i = j = out_learnt.size();
             .      .    .              .             .         .              .           .      .  
     2,586,072      0    0      1,293,036     1,282,213        57              0           0      0      max_literals += out_learnt.size();
   156,741,024      1    1     38,861,997             0         0              0           0      0      out_learnt.shrink(i - j);
     1,293,036    158   19      1,293,036             0         0              0           0      0      tot_literals += out_learnt.size();
             .      .    .              .             .         .              .           .      .  
     2,586,072      0    0      1,293,036       499,532         0      1,293,036         308      0      out_lbd = computeLBD(out_learnt);
    14,399,166  8,490  167      6,523,770           357         0              0           0      0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
       410,130 11,662  129         58,590             0         0        117,180           0      0          if (binResMinimize(out_learnt))
        44,700      0    0         14,900             0         0         14,900           0      0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Find correct backtrack level:
             .      .    .              .             .         .              .           .      .      //
     2,586,072      0    0              0             0         0              0           0      0      if (out_learnt.size() == 1)
             .      .    .              .             .         .              .           .      .          out_btlevel = 0;
             .      .    .              .             .         .              .           .      .      else{
     2,581,166      0    0              0             0         0              0           0      0          int max_i = 1;
             .      .    .              .             .         .              .           .      .          // Find the first literal assigned at the next-highest level:
   579,468,849      0    0              0             0         0              0           0      0          for (int i = 2; i < out_learnt.size(); i++)
   445,098,516      0    0    144,331,840         3,470         0              0           0      0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
             .      .    .              .             .         .              .           .      .                  max_i = i;
             .      .    .              .             .         .              .           .      .          // Swap-in this literal at index 1:
             .      .    .              .             .         .              .           .      .          Lit p             = out_learnt[max_i];
     2,586,072    163    0      1,293,036             2         0      1,293,036          16      0          out_learnt[max_i] = out_learnt[1];
     1,293,036      0    0              0             0         0      1,293,036           0      0          out_learnt[1]     = p;
     2,586,072      0    0      1,293,036             5         0      1,293,036          31      0          out_btlevel       = level(var(p));
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
     2,586,072  2,477   84      1,293,036       610,340         0              0           0      0      if (VSIDS){
   431,895,132  9,095   81    116,750,192       436,744         0              0           0      0          for (int i = 0; i < add_tmp.size(); i++){
             .      .    .              .             .         .              .           .      .              Var v = var(add_tmp[i]);
   343,891,806      0    0    114,630,602    16,381,113         0              0           0      0              if (level(v) >= out_btlevel - 1)
             .      .    .              .             .         .              .           .      .                  varBumpActivity(v, 1);
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          add_tmp.clear();
             .      .    .              .             .         .              .           .      .      }else{
     1,173,012      0    0        586,506           129         0        586,506      20,371      0          seen[var(p)] = true;
   205,994,856      0    0        586,506             0         0              0           0      0          for(int i = out_learnt.size() - 1; i >= 0; i--){
             .      .    .              .             .         .              .           .      .              Var v = var(out_learnt[i]);
             .      .    .              .             .         .              .           .      .              CRef rea = reason(v);
   133,028,860      0    0              0             0         0              0           0      0              if (rea != CRef_Undef){
             .      .    .              .             .         .              .           .      .                  const Clause& reaC = ca[rea];
   792,301,134      0    0              0             0         0              0           0      0                  for (int i = 0; i < reaC.size(); i++){
             .      .    .              .             .         .              .           .      .                      Lit l = reaC[i];
   561,861,354      0    0    280,930,677     5,306,285        19              0           0      0                      if (!seen[var(l)]){
    88,703,410      0    0              0             0         0     88,703,410           0      0                          seen[var(l)] = true;
    88,703,410      0    0     88,703,410    47,040,865       606              0           0      0                          almost_conflicted[var(l)]++;
             .      .    .              .             .         .              .           .      .                          analyze_toclear.push(l); } } } } }
             .      .    .              .             .         .              .           .      .  
 1,205,345,060  1,765   39    600,732,976       141,620         0    299,719,970  11,156,658      0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
    10,344,288      0    0      9,051,252       899,031         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  // Try further learnt clause minimization by means of binary clause resolution.
             .      .    .              .             .         .              .           .      .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
       266,600      0    0              0             0         0        213,280           0      0  {
             .      .    .              .             .         .              .           .      .      // Preparation: remember which false variables we have in 'out_learnt'.
       175,770     11    8         58,590             0         0         58,590           0      0      counter++;
     1,187,162      0    0        117,180             0         0              0           0      0      for (int i = 1; i < out_learnt.size(); i++)
       421,771      0    0         58,590             0         0        363,181     333,825 14,934          seen2[var(out_learnt[i])] = counter;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Get the list of binary clauses containing 'out_learnt[0]'.
             .      .    .              .             .         .              .           .      .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
             .      .    .              .             .         .              .           .      .  
        53,320      0    0              0             0         0              0           0      0      int to_remove = 0;
     2,693,446      0    0         58,590        40,324         0         14,900           0      0      for (int i = 0; i < ws.size(); i++){
     1,294,096      0    0      1,294,096       148,205         0              0           0      0          Lit the_other = ws[i].blocker;
             .      .    .              .             .         .              .           .      .          // Does 'the_other' appear negatively in 'out_learnt'?
     5,228,166     17   11      2,586,654       909,667    36,097              0           0      0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
        25,891      0    0              0             0         0              0           0      0              to_remove++;
        77,673      0    0              0             0         0         25,891           0      0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Shrink.
       159,960      6    3              0             0         0              0           0      0      if (to_remove > 0){
        14,900      0    0              0             0         0              0           0      0          int last = out_learnt.size() - 1;
       695,883    304   62         14,900             0         0              0           0      0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
       187,758      0    0         93,879             0         0              0           0      0              if (seen2[var(out_learnt[i])] != counter)
        84,450      0    0         33,780             0         0         16,890           0      0                  out_learnt[i--] = out_learnt[last--];
             .      .    .              .             .         .              .           .      .          out_learnt.shrink(to_remove);
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .      return to_remove != 0;
       271,870      4    3        271,870             0         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
             .      .    .              .             .         .              .           .      .  // visiting literals at levels that cannot be removed later.
             .      .    .              .             .         .              .           .      .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
 1,728,934,050 12,636    4              0             0         0  1,037,360,430     942,361      0  {
   345,786,810      0    0              0             0         0    172,893,405           0      0      analyze_stack.clear(); analyze_stack.push(p);
   518,680,215      0    0    345,786,810             0         0    172,893,405           0      0      int top = analyze_toclear.size();
   745,791,280      0    0              0             0         0              0           0      0      while (analyze_stack.size() > 0){
             .      .    .              .             .         .              .           .      .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
             .      .    .              .             .         .              .           .      .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          // Special handling for binary clauses like in 'analyze()'.
 1,060,639,870     42   31              0             0         0              0           0      0          if (c.size() == 2 && value(c[0]) == l_False){
             .      .    .              .             .         .              .           .      .              assert(value(c[1]) == l_True);
             .      .    .              .             .         .              .           .      .              Lit tmp = c[0];
     8,414,922      0    0      2,804,974       168,873       984      5,609,948           0      0              c[0] = c[1], c[1] = tmp; }
             .      .    .              .             .         .              .           .      .  
 1,630,578,422      0    0              0             0         0              0           0      0          for (int i = 1; i < c.size(); i++){
   815,101,148    221   49    815,101,148    42,577,457     3,490              0           0      0              Lit p  = c[i];
 3,475,179,160      0    0  1,630,202,296    23,956,913       266              0           0      0              if (!seen[var(p)] && level(var(p)) > 0){
 1,808,366,224      0    0    514,937,858             0         0              0           0      0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
   384,434,330      0    0              0             0         0    384,434,330           0      0                      seen[var(p)] = 1;
             .      .    .              .             .         .              .           .      .                      analyze_stack.push(p);
             5      0    0              0             0         0              0           0      0                      analyze_toclear.push(p);
             .      .    .              .             .         .              .           .      .                  }else{
 1,892,393,435  1,527  125    623,758,506           443         0              0           0      0                      for (int j = top; j < analyze_toclear.size(); j++)
   655,694,697      0    0    292,943,247             0         0    362,751,450       1,533      0                          seen[var(analyze_toclear[j])] = 0;
   261,007,056      8    2    130,503,528             0         0              0           0      0                      analyze_toclear.shrink(analyze_toclear.size() - top);
   130,503,528      0    0              0             0         0              0           0      0                      return false;
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
    84,779,754      0    0              0             0         0              0           0      0      return true;
 1,383,147,240      3    0  1,210,253,835           951         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  /*_________________________________________________________________________________________________
             .      .    .              .             .         .              .           .      .  |
             .      .    .              .             .         .              .           .      .  |  analyzeFinal : (p : Lit)  ->  [void]
             .      .    .              .             .         .              .           .      .  |  
             .      .    .              .             .         .              .           .      .  |  Description:
             .      .    .              .             .         .              .           .      .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      seen[var(p)] = 0;
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 7,630,426,940      6    2              0             0         0  3,815,213,470           0      0  {
             .      .    .              .             .         .              .           .      .      assert(value(p) == l_Undef);
             .      .    .              .             .         .              .           .      .      Var x = var(p);
 1,526,085,388      0    0    763,042,694     2,141,319        43              0           0      0      if (!VSIDS){
 1,214,337,891      0    0    809,558,594     2,149,564        50    404,779,297 311,126,457 11,736          picked[x] = conflicts;
   809,558,594      0    0    404,779,297             0         0    404,779,297 311,263,392  9,788          conflicted[x] = 0;
   809,558,594      2    1    404,779,297             0         0    404,779,297 312,222,517  8,932          almost_conflicted[x] = 0;
             .      .    .              .             .         .              .           .      .  #ifdef ANTI_EXPLORATION
   404,779,297      0    0    404,779,297     1,110,682        12              0           0      0          uint32_t age = conflicts - canceled[var(p)];
   809,558,594      0    0    404,779,297   310,263,969     9,368              0           0      0          if (age > 0){
             .      .    .              .             .         .              .           .      .              double decay = pow(0.95, age);
   391,330,650      0    0    195,665,325   170,970,842     4,590    195,665,325           0      0              activity_CHB[var(p)] *= decay;
             .      .    .              .             .         .              .           .      .              if (order_heap_CHB.inHeap(var(p)))
   195,665,325      0    0              0             0         0              0           0      0                  order_heap_CHB.increase(var(p));
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
   763,042,694      1    0    763,042,694            71        43              0           0      0      assigns[x] = lbool(!sign(p));
 1,526,085,388      0    0              0             0         0  1,526,085,388 608,744,175 23,548      vardata[x] = mkVarData(from, level);
   763,042,694      3    1    763,042,694             0         0              0           0      0      trail.push_(p);
 5,341,298,858      0    0  4,578,256,164             0         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  unsigned number_watch_changed_total=0;
             .      .    .              .             .         .              .           .      .  unsigned number_clause_read_total=0;
             .      .    .              .             .         .              .           .      .  unsigned times_only_access_watch=0;
             .      .    .              .             .         .              .           .      .  /*_________________________________________________________________________________________________
             .      .    .              .             .         .              .           .      .  |
             .      .    .              .             .         .              .           .      .  |  propagate : [void]  ->  [Clause*]
             .      .    .              .             .         .              .           .      .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
             .      .    .              .             .         .              .           .      .  |  Description:
             .      .    .              .             .         .              .           .      .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
             .      .    .              .             .         .              .           .      .  |    otherwise CRef_Undef.
             .      .    .              .             .         .              .           .      .  |  
             .      .    .              .             .         .              .           .      .  |    Post-conditions:
             .      .    .              .             .         .              .           .      .  |      * the propagation queue is empty, even if there was a conflict.
             .      .    .              .             .         .              .           .      .  |________________________________________________________________________________________________@*/
             .      .    .              .             .         .              .           .      .  CRef Solver::propagate_()
    35,536,216      3    1              0             0         0     26,652,162           0      0  {
             .      .    .              .             .         .              .           .      .      //auto start_time=std::chrono::steady_clock::now();
     4,442,027      0    0              0             0         0      4,442,027           0      0      CRef    confl     = CRef_Undef;
     4,442,027      0    0              0             0         0      4,442,027           5      0      int     num_props = 0;
     8,884,054      0    0              0             0         0      4,442,027     523,636      0      watches.cleanAll();
     8,884,054      3    1              0             0         0      4,442,027           0      0      watches_bin.cleanAll();
             .      .    .              .             .         .              .           .      .      
 2,317,708,608      1    1  1,669,236,786       572,456         0              0           0      0      while (qhead < trail.size()){
 3,212,511,760      0    0  1,285,004,704    29,292,979         0    642,502,352           0      0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
             .      .    .              .             .         .              .           .      .          int currLevel = level(var(p));
             .      .    .              .             .         .              .           .      .          vec<Watcher>&  ws  = watches[p];
             .      .    .              .             .         .              .           .      .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          Watcher        *i, *j, *end;
 1,018,188,277      0    0  1,018,188,277       911,825         0              0           0      0          num_props++;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
             .      .    .              .             .         .              .           .      .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
 7,249,460,636      3    1    642,502,352   625,697,448   129,050              0           0      0          for (int k = 0; k < ws_bin.size(); k++){
 2,017,467,624      0    0  2,017,467,624   510,575,940   595,311              0           0      0              Lit the_other = ws_bin[k].blocker;
16,803,401,004      0    0 11,674,938,215             0         0              0           0      0              if (value(the_other) == l_False){
       675,794      2    0        337,897             0         0        337,897           0      0                  confl = ws_bin[k].cref;
             .      .    .              .             .         .              .           .      .                  //auto end_time=std::chrono::steady_clock::now();
             .      .    .              .             .         .              .           .      .                  //auto duration=end_time-start_time;
             .      .    .              .             .         .              .           .      .  #ifdef LOOSE_PROP_STAT
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                  return confl;
             .      .    .              .             .         .              .           .      .  #else
             .      .    .              .             .         .              .           .      .                  goto ExitProp;
             .      .    .              .             .         .              .           .      .  #endif
 3,305,161,750      2    1              0             0         0              0           0      0              }else if(value(the_other) == l_Undef)
             .      .    .              .             .         .              .           .      .              {
 1,678,879,210      3    0  1,007,327,526             0         0    335,775,842     897,581      0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
             .      .    .              .             .         .              .           .      .  #ifdef  PRINT_OUT                
             .      .    .              .             .         .              .           .      .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
             .      .    .              .             .         .              .           .      .  #endif                
             .      .    .              .             .         .              .           .      .  			}
             .      .    .              .             .         .              .           .      .          }
 1,284,328,910      0    0  1,284,328,910   576,401,870    42,499              0           0      0          total_Watchers+=ws.size();
   642,164,455      0    0    642,164,455             0         0              0           0      0          total_indexs++;//number of rounds
             .      .    .              .             .         .              .           .      .          //int count=0;
   616,814,308      0    0              0             0         0              0           0      0          bool no_clause_access=true;
   616,814,308      0    0              0             0         0    616,814,308           0      0          bool no_implication_added=true;
   616,814,308      0    0              0             0         0    616,814,308           0      0          bool no_change_other_watch=true;
36,438,189,093      9    3 16,947,440,710             0         0    642,164,455           0      0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
             .      .    .              .             .         .              .           .      .              // Try to avoid inspecting the clause:
             .      .    .              .             .         .              .           .      .              //count++;
16,305,276,255      3    1 16,305,276,255 2,535,977,286 2,276,968              0           0      0              Lit blocker = i->blocker;
32,610,552,510      0    0 16,305,276,255     1,220,640       101              0           0      0              total_access_watches++;
32,610,552,510      0    0 16,305,276,255   545,760,098     3,656              0           0      0              if (value(blocker) == l_True){
             .      .    .              .             .         .              .           .      .                  
44,179,565,332      0    0 11,044,891,333             0         0 11,044,891,333     165,389      0                  *j++ = *i++; continue; }//no clause accessed
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Make sure the false literal is data[1]:
 5,265,763,029      0    0        884,549             0         0              0           0      0              no_clause_access=false;
15,781,154,766      3    1 10,520,769,844     2,451,193       150  5,260,384,922           0      0              total_clause_access_times++;
10,520,769,844      0    0  5,260,384,922             0         0              0           0      0              CRef     cr        = i->cref;
             .      .    .              .             .         .              .           .      .              //std::cout<<"cr: "<<cr<<"\n";
             .      .    .              .             .         .              .           .      .              Clause&  c         = ca[cr];
             .      .    .              .             .         .              .           .      .              Lit      false_lit = ~p;
 5,260,384,922      0    0  5,260,384,922             0         0              0           0      0              total_clause_access_size+=2;
15,781,154,766      0    0 10,520,769,844 4,788,389,484 1,565,519              0           0      0              if (c[0] == false_lit)
 7,665,822,596      0    0  3,832,911,298   105,497,907    44,159  3,832,911,298           0      0                  c[0] = c[1], c[1] = false_lit;
             .      .    .              .             .         .              .           .      .              assert(c[1] == false_lit);
             .      .    .              .             .         .              .           .      .              i++;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // If 0th watch is true, then clause is already satisfied.
             .      .    .              .             .         .              .           .      .              Lit     first = c[0];
             .      .    .              .             .         .              .           .      .              Watcher w     = Watcher(cr, first);
13,078,249,530      0    0  1,278,739,843    29,848,974        88              0           0      0              if (first != blocker && value(first) == l_True){
 1,890,140,646      0    0              0             0         0  1,260,093,764      67,506      0                  *j++ = w; continue; }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Look for new watch:
46,009,880,927      1    1              0             0         0              0           0      0              for (int k = 2; k < c.size(); k++)
             .      .    .              .             .         .              .           .      .              {
79,860,021,758      0    0              0             0         0 16,456,278,406           0      0                  total_clause_access_size++;
45,040,643,854      0    0  2,867,410,962             0         0              0           0      0                  if (value(c[k]) != l_False){
16,826,173,828  4,781    8  8,413,086,914             0         0  8,413,086,914           0      0                      c[1] = c[k]; c[k] = false_lit;
 4,206,543,457      0    0  4,206,543,457             0         0              0           0      0                      total_change_other_watch++;
 4,206,543,457      0    0              0             0         0  4,206,543,457           0      0                      no_change_other_watch=false;
             .      .    .              .             .         .              .           .      .                      watches[~c[1]].push(w);
             .      .    .              .             .         .              .           .      .                      goto NextClause; }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Did not find watch -- clause is unit under assignment:
 1,272,339,111      0    0              0             0         0    847,589,166       4,000      0              *j++ = w;
   847,589,166      0    0              0             0         0              0           0      0              if (value(first) == l_False){
       955,362      0    0        955,362             0         0              0           0      0                  time_find_conflict++;
     5,732,172      0    0      3,821,448         1,980         0              0           0      0                  total_find_conflict_length+=i-(Watcher*)ws;
     1,910,724      0    0      1,910,724             0         0              0           0      0                  total_find_conflict_allsize+=ws.size();
             .      .    .              .             .         .              .           .      .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
       955,362      0    0              0             0         0        955,362           0      0                  confl = cr;
     1,910,724      0    0        955,362           556         0        955,362           0      0                  qhead = trail.size();
             .      .    .              .             .         .              .           .      .                  // Copy the remaining watches:
             .      .    .              .             .         .              .           .      .  
    50,280,156      3    3      1,839,911             0         0              0           0      0                  while (i < end)
    22,822,486      0    0     22,822,486     2,841,596     6,054     22,822,486       2,049      0                      *j++ = *i++;
             .      .    .              .             .         .              .           .      .              }else
             .      .    .              .             .         .              .           .      .              {//new implecate
   422,839,221      0    0              0             0         0    422,839,221           0      0                  no_implication_added=false;
   422,839,221      0    0    422,839,221             0         0              0           0      0                  total_push_new_implication++;
 1,268,517,663      0    0    845,678,442        41,097         0              0           0      0  				if (currLevel == decisionLevel())
             .      .    .              .             .         .              .           .      .  				{
   845,678,442      0    0              0             0         0              0           0      0  					uncheckedEnqueue(first, currLevel, cr);
             .      .    .              .             .         .              .           .      .  #ifdef PRINT_OUT					
             .      .    .              .             .         .              .           .      .  					std::cout << "i " << first << " l " << currLevel << "\n";
             .      .    .              .             .         .              .           .      .  #endif					
             .      .    .              .             .         .              .           .      .  				}
             .      .    .              .             .         .              .           .      .  				else
             .      .    .              .             .         .              .           .      .  				{
             .      .    .              .             .         .              .           .      .  					int nMaxLevel = currLevel;
        67,242      0    0              0             0         0              0           0      0  					int nMaxInd = 1;
             .      .    .              .             .         .              .           .      .  					// pass over all the literals in the clause and find the one with the biggest level
       301,164      0    0         33,621             0         0              0           0      0  					for (int nInd = 2; nInd < c.size(); ++nInd)
             .      .    .              .             .         .              .           .      .  					{
             .      .    .              .             .         .              .           .      .  						int nLevel = level(var(c[nInd]));
       175,472      0    0              0             0         0              0           0      0  						if (nLevel > nMaxLevel)
             .      .    .              .             .         .              .           .      .  						{
             .      .    .              .             .         .              .           .      .  							nMaxLevel = nLevel;
             .      .    .              .             .         .              .           .      .  							nMaxInd = nInd;
             .      .    .              .             .         .              .           .      .  						}
             .      .    .              .             .         .              .           .      .  					}
             .      .    .              .             .         .              .           .      .  
        67,242      3    2              0             0         0              0           0      0  					if (nMaxInd != 1)
             .      .    .              .             .         .              .           .      .  					{
             .      .    .              .             .         .              .           .      .  						std::swap(c[1], c[nMaxInd]);
             .      .    .              .             .         .              .           .      .  						*j--; // undo last watch
         3,405      0    0          3,405             0         0              0           0      0                          total_change_other_watch++;
         3,405      0    0              0             0         0          3,405           0      0                          no_change_other_watch=false;
             .      .    .              .             .         .              .           .      .  						watches[~c[1]].push(w);
             .      .    .              .             .         .              .           .      .  					}
             .      .    .              .             .         .              .           .      .  					
 2,114,229,726      0    0    422,839,221             0         0    422,839,221   1,729,237      0  					uncheckedEnqueue(first, nMaxLevel, cr);
             .      .    .              .             .         .              .           .      .  #ifdef PRINT_OUT					
             .      .    .              .             .         .              .           .      .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
             .      .    .              .             .         .              .           .      .  #endif	
             .      .    .              .             .         .              .           .      .  				}
             .      .    .              .             .         .              .           .      .  			}
             .      .    .              .             .         .              .           .      .  
       884,549     28   15              0             0         0              0           0      0  NextClause:;
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
 3,084,071,540      0    0    616,814,308             0         0              0           0      0          if(no_clause_access==true){
   156,971,000    138   42    156,971,000         6,984         0              0           0      0              total_no_clause_access++;
             .      .    .              .             .         .              .           .      .          }
 1,365,249,469     41   20    616,814,308             0         0              0           0      0          if(no_implication_added==true){
   409,840,437      2    0    384,490,290             2         0              0           0      0              total_no_implication_added++;
             .      .    .              .             .         .              .           .      .          }
 1,376,501,746      0    0    616,814,308             0         0              0           0      0          if(no_change_other_watch==true){
   266,140,633     12    6    266,140,633             0         0              0           0      0              total_no_change_other_watch++;
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          ws.shrink(i - j);
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  ExitProp:;
     8,208,260      3    1      8,208,260     1,275,830        28              0           0      0      propagations += num_props;
     4,104,130      0    0      4,104,130             0         0              0           0      0      simpDB_props -= num_props;
             .      .    .              .             .         .              .           .      .  
     4,104,130      0    0      4,104,130             0         0              0           0      0      return confl;
 1,798,463,294  1,743    6     31,094,189     2,435,188         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  /*_________________________________________________________________________________________________
             .      .    .              .             .         .              .           .      .  |
             .      .    .              .             .         .              .           .      .  |  reduceDB : ()  ->  [void]
             .      .    .              .             .         .              .           .      .  |  
             .      .    .              .             .         .              .           .      .  |  Description:
             .      .    .              .             .         .              .           .      .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
             .      .    .              .             .         .              .           .      .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
             .      .    .              .             .         .              .           .      .  |________________________________________________________________________________________________@*/
             .      .    .              .             .         .              .           .      .  struct reduceDB_lt { 
             .      .    .              .             .         .              .           .      .      ClauseAllocator& ca;
             .      .    .              .             .         .              .           .      .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    63,876,628    172  168     62,535,137    22,527,741    54,410              0           0      0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
             .      .    .              .             .         .              .           .      .  };
             .      .    .              .             .         .              .           .      .  void Solver::reduceDB()
           516     85   83              0             0         0            344           0      0  {
             .      .    .              .             .         .              .           .      .      int     i, j;
             .      .    .              .             .         .              .           .      .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
             .      .    .              .             .         .              .           .      .      //local_learnts_dirty = false;
             .      .    .              .             .         .              .           .      .  
            86      0    0              0             0         0              0           0      0      sort(learnts_local, reduceDB_lt(ca));
             .      .    .              .             .         .              .           .      .  
           430      0    0             86            86         0              0           0      0      int limit = learnts_local.size() / 2;
     4,939,700     86   85              0             0         0              0           0      0      for (i = j = 0; i < learnts_local.size(); i++){
     7,408,905     86   85      4,939,270       154,397         0              0           0      0          Clause& c = ca[learnts_local[i]];
     4,939,270      0    0      2,469,635     2,466,049       898              0           0      0          if (c.mark() == LOCAL)
     9,225,408      0    0      2,416,492             0         0              0           0      0              if (c.removable() && !locked(c) && i < limit)
     6,047,330      0    0      1,209,466             1         0      1,209,466           0      0                  removeClause(learnts_local[i]);
             .      .    .              .             .         .              .           .      .              else{
       219,314      0    0              0             0         0              0           0      0                  if (!c.removable()) limit++;
             .      .    .              .             .         .              .           .      .                  c.removable(true);
     6,141,416      0    0      1,207,026             0         0      1,207,026      75,610      0                  learnts_local[j++] = learnts_local[i]; }
             .      .    .              .             .         .              .           .      .      }
            86      0    0              0             0         0              0           0      0      learnts_local.shrink(i - j);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      checkGarbage();
           431      0    0            345            86         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  void Solver::reduceDB_Tier2()
           774    115   97              0             0         0            645           0      0  {
             .      .    .              .             .         .              .           .      .      int i, j;
     1,671,418     87   69            129            66         0              0           0      0      for (i = j = 0; i < learnts_tier2.size(); i++){
     2,230,251    113   94      1,486,834        46,583     5,678              0           0      0          Clause& c = ca[learnts_tier2[i]];
     1,486,834      0    0              0             0         0              0           0      0          if (c.mark() == TIER2)
     3,572,595     79   61      1,429,038       492,050     7,971              0           0      0              if (!locked(c) && c.touched() + 30000 < conflicts){
             .      .    .              .             .         .              .           .      .                  learnts_local.push(learnts_tier2[i]);
             .      .    .              .             .         .              .           .      .                  c.mark(LOCAL);
             .      .    .              .             .         .              .           .      .                  //c.removable(true);
             .      .    .              .             .         .              .           .      .                  c.activity() = 0;
             .      .    .              .             .         .              .           .      .                  claBumpActivity(c);
             .      .    .              .             .         .              .           .      .              }else
     3,257,560      0    0        651,512             0         0        651,512      18,185      0                  learnts_tier2[j++] = learnts_tier2[i];
             .      .    .              .             .         .              .           .      .      }
           129      0    0              0             0         0              0           0      0      learnts_tier2.shrink(i - j);
           774      0    0            774           129         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::removeSatisfied(vec<CRef>& cs)
            72      0    0              0             0         0             32           0      0  {
             .      .    .              .             .         .              .           .      .      int i, j;
     2,356,792      5    2        471,362             5         0              0           0      0      for (i = j = 0; i < cs.size(); i++){
     1,414,059      0    0        942,706        29,464         0              0           0      0          Clause& c = ca[cs[i]];
             .      .    .              .             .         .              .           .      .          if (satisfied(c))
            85      1    1              1             0         0             28           9      0              removeClause(cs[i]);
             .      .    .              .             .         .              .           .      .          else
       942,650      0    0              0             0         0        471,325           0      0              cs[j++] = cs[i];
             .      .    .              .             .         .              .           .      .      }
             8      0    0              0             0         0              0           0      0      cs.shrink(i - j);
            48      4    1             40            16         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
            60      0    0              0             0         0             50           0      0  {
             .      .    .              .             .         .              .           .      .      int i, j;
        59,502      4    2             10             5         0              0           0      0      for (i = j = 0; i < cs.size(); i++){
        86,778      0    0         57,852         1,816         0              0           0      0          Clause& c = ca[cs[i]];
        57,852      0    0              0             0         0              0           0      0          if (c.mark() == valid_mark)
             .      .    .              .             .         .              .           .      .              if (satisfied(c))
             .      .    .              .             .         .              .           .      .                  removeClause(cs[i]);
             .      .    .              .             .         .              .           .      .              else
       140,700      0    0         28,140             0         0         28,140          12      0                  cs[j++] = cs[i];
             .      .    .              .             .         .              .           .      .      }
             8      0    0              0             0         0              0           0      0      cs.shrink(i - j);
            60      6    3             60            16         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::rebuildOrderHeap()
            54      3    2              0             0         0             36           0      0  {
             .      .    .              .             .         .              .           .      .      vec<Var> vs;
        62,958      0    0              6             0         0              6           0      0      for (Var v = 0; v < nVars(); v++)
       187,654      0    0         93,827           907         0              0           0      0          if (decision[v] && value(v) == l_Undef)
             .      .    .              .             .         .              .           .      .              vs.push(v);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      order_heap_CHB  .build(vs);
             .      .    .              .             .         .              .           .      .      order_heap_VSIDS.build(vs);
             .      .    .              .             .         .              .           .      .      order_heap_distance.build(vs);
            48      6    2             42            11         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  /*_________________________________________________________________________________________________
             .      .    .              .             .         .              .           .      .  |
             .      .    .              .             .         .              .           .      .  |  simplify : [void]  ->  [bool]
             .      .    .              .             .         .              .           .      .  |  
             .      .    .              .             .         .              .           .      .  |  Description:
             .      .    .              .             .         .              .           .      .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
             .      .    .              .             .         .              .           .      .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
             .      .    .              .             .         .              .           .      .  |________________________________________________________________________________________________@*/
             .      .    .              .             .         .              .           .      .  bool Solver::simplify()
        42,420  1,863   44              0             0         0         28,280           0      0  {
             .      .    .              .             .         .              .           .      .      assert(decisionLevel() == 0);
             .      .    .              .             .         .              .           .      .  
        35,350      0    0          7,070         5,820         7              0           0      0      if (!ok || propagate() != CRef_Undef)
             .      .    .              .             .         .              .           .      .          return ok = false;
             .      .    .              .             .         .              .           .      .  
        21,228    176   88         14,149             0         0              0           0      0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
             .      .    .              .             .         .              .           .      .          return true;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Remove satisfied clauses:
            15      0    0              0             0         0              5           0      0      removeSatisfied(learnts_core); // Should clean core first.
            20      0    0              0             0         0              5           0      0      safeRemoveSatisfied(learnts_tier2, TIER2);
            20      5    2              0             0         0              5           0      0      safeRemoveSatisfied(learnts_local, LOCAL);
            10      0    0              5             5         0              0           0      0      if (remove_satisfied)        // Can be turned off.
            16      8    3              0             0         0              4           0      0          removeSatisfied(clauses);
             .      .    .              .             .         .              .           .      .      checkGarbage();
            10      1    1              0             0         0              5           0      0      rebuildOrderHeap();
             .      .    .              .             .         .              .           .      .  
            10      0    0              5             5         0              5           0      0      simpDB_assigns = nAssigns();
            15      0    0             10             5         0              5           0      0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
             .      .    .              .             .         .              .           .      .  
             5      0    0              0             0         0              0           0      0      return true;
        49,490      0    0         35,350             0         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  // pathCs[k] is the number of variables assigned at level k,
             .      .    .              .             .         .              .           .      .  // it is initialized to 0 at the begining and reset to 0 after the function execution
        79,120      5    1              0             0         0         59,340           0      0  bool Solver::collectFirstUIP(CRef confl){
        19,780      0    0              0             0         0          9,890           0      0      involved_lits.clear();
       388,008      7    1              0             0         0              0           0      0      int max_level=1;
             .      .    .              .             .         .              .           .      .      Clause& c=ca[confl]; int minLevel=decisionLevel();
       129,673      0    0          9,890             0         0              0           0      0      for(int i=0; i<c.size(); i++) {
             .      .    .              .             .         .              .           .      .          Var v=var(c[i]);
             .      .    .              .             .         .              .           .      .          //        assert(!seen[v]);
       120,333     33    1         40,111         9,950         0              0           0      0          if (level(v)>0) {
        80,220      0    0         40,110         8,003         0         40,110      23,555      0              seen[v]=1;
        90,110      0    0         50,000        17,615         0         40,110      35,886      0              var_iLevel_tmp[v]=1;
        40,110      0    0         40,110        21,024         0              0           0      0              pathCs[level(v)]++;
             .      .    .              .             .         .              .           .      .              if (minLevel>level(v)) {
             .      .    .              .             .         .              .           .      .                  minLevel=level(v);
             .      .    .              .             .         .              .           .      .                  assert(minLevel>0);
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              //    varBumpActivity(v);
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
        29,670      0    0         19,780         8,723         0              0           0      0      int limit=trail_lim[minLevel-1];
    52,304,584      0    0          9,890             0         0              0           0      0      for(int i=trail.size()-1; i>=limit; i--) {
    26,132,512     77    1     26,132,512       792,255         0              0           0      0          Lit p=trail[i]; Var v=var(p);
    26,132,512      0    0     13,066,256       728,010         0              0           0      0          if (seen[v]) {
             .      .    .              .             .         .              .           .      .              int currentDecLevel=level(v);
             .      .    .              .             .         .              .           .      .              //      if (currentDecLevel==decisionLevel())
             .      .    .              .             .         .              .           .      .              //      	varBumpActivity(v);
       261,122      0    0              0             0         0        261,122           0      0              seen[v]=0;
       522,244      0    0        261,122         1,470         0              0           0      0              if (--pathCs[currentDecLevel]!=0) {
             .      .    .              .             .         .              .           .      .                  Clause& rc=ca[reason(v)];
       706,786      6    1        493,002           942         0              0           0      0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
       328,668      0    0              0             0         0              0           0      0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
       460,540      0    0              0             0         0              0           0      0                  if (rc.size()==2 && value(rc[0])==l_False) {
             .      .    .              .             .         .              .           .      .                      // Special case for binary clauses
             .      .    .              .             .         .              .           .      .                      // The first one has to be SAT
             .      .    .              .             .         .              .           .      .                      assert(value(rc[1]) != l_False);
             .      .    .              .             .         .              .           .      .                      Lit tmp = rc[0];
        34,140      0    0         11,380           567         0         22,760           0      0                      rc[0] =  rc[1], rc[1] = tmp;
             .      .    .              .             .         .              .           .      .                  }
       997,494      0    0              0             0         0              0           0      0                  for (int j = 1; j < rc.size(); j++){
             .      .    .              .             .         .              .           .      .                      Lit q = rc[j]; Var v1=var(q);
       800,698      0    0              0             0         0              0           0      0                      if (level(v1) > 0) {
       800,514      0    0              0             0         0              0           0      0                          if (minLevel>level(v1)) {
        66,876      0    0         33,438        15,404         0              0           0      0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
             .      .    .              .             .         .              .           .      .                          }
     1,200,771      0    0        800,514        33,688         0              0           0      0                          if (seen[v1]) {
       358,490      0    0        179,245           755         0              0           0      0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
       177,586      0    0              0             0         0         88,793           0      0                                  var_iLevel_tmp[v1]=reasonVarLevel;
             .      .    .              .             .         .              .           .      .                          }
             .      .    .              .             .         .              .           .      .                          else {
       221,012      0    0              0             0         0        221,012     155,404      0                              var_iLevel_tmp[v1]=reasonVarLevel;
             .      .    .              .             .         .              .           .      .                              //   varBumpActivity(v1);
       221,012      0    0              0             0         0        221,012           0      0                              seen[v1] = 1;
       663,036      5    1        442,024        52,573         0              0           0      0                              pathCs[level(v1)]++;
             .      .    .              .             .         .              .           .      .                          }
             .      .    .              .             .         .              .           .      .                      }
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              involved_lits.push(p);
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
        29,670  1,693    1          9,890             0         0          9,890           0      0      double inc=var_iLevel_inc;
             .      .    .              .             .         .              .           .      .      vec<int> level_incs; level_incs.clear();
       343,450      0    0        125,512             0         0              0           0      0      for(int i=0;i<max_level;i++){
       145,292      4    1         72,646             0         0              0           0      0          level_incs.push(inc);
       217,938      0    0        145,292             0         0         72,646           0      0          inc = inc/my_var_decay;
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
       561,804      0    0        271,012             0         0              0           0      0      for(int i=0;i<involved_lits.size();i++){
         9,890      0    0          9,890             0         0              0           0      0          Var v =var(involved_lits[i]);
             .      .    .              .             .         .              .           .      .          //        double old_act=activity_distance[v];
             .      .    .              .             .         .              .           .      .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
     2,508,338  6,800    2        822,926       244,100         0        271,012           0      0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
             .      .    .              .             .         .              .           .      .  
       522,244      0    0              0             0         0              0           0      0          if(activity_distance[v]>1e100){
             .      .    .              .             .         .              .           .      .              for(int vv=0;vv<nVars();vv++)
        49,450  1,349    1         19,780        18,864         0         19,780           0      0                  activity_distance[vv] *= 1e-100;
             .      .    .              .             .         .              .           .      .              var_iLevel_inc*=1e-100;
        25,161     12    1              0             0         0              0           0      0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .          if (order_heap_distance.inHeap(v))
             .      .    .              .             .         .              .           .      .              order_heap_distance.decrease(v);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          //        var_iLevel_inc *= (1 / my_var_decay);
             .      .    .              .             .         .              .           .      .      }
        49,450    657    1         19,780             0         0          9,890           0      0      var_iLevel_inc=level_incs[level_incs.size()-1];
             .      .    .              .             .         .              .           .      .      return true;
        89,010      0    0         69,230         2,042         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  struct UIPOrderByILevel_Lt {
             .      .    .              .             .         .              .           .      .      Solver& solver;
             .      .    .              .             .         .              .           .      .      const vec<double>&  var_iLevel;
             .      .    .              .             .         .              .           .      .      bool operator () (Lit x, Lit y) const
             .      .    .              .             .         .              .           .      .      {
             .      .    .              .             .         .              .           .      .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
             .      .    .              .             .         .              .           .      .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
             .      .    .              .             .         .              .           .      .  |    Search for a model the specified number of conflicts. 
             .      .    .              .             .         .              .           .      .  |  
             .      .    .              .             .         .              .           .      .  |  Output:
             .      .    .              .             .         .              .           .      .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
             .      .    .              .             .         .              .           .      .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
             .      .    .              .             .         .              .           .      .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
             .      .    .              .             .         .              .           .      .  |________________________________________________________________________________________________@*/
             .      .    .              .             .         .              .           .      .  lbool Solver::search(int& nof_conflicts)
        77,759  6,229  125              0             0         0         49,483          34      0  {
             .      .    .              .             .         .              .           .      .      assert(ok);
             .      .    .              .             .         .              .           .      .      int         backtrack_level;
             .      .    .              .             .         .              .           .      .      int         lbd;
             .      .    .              .             .         .              .           .      .      vec<Lit>    learnt_clause;
             .      .    .              .             .         .              .           .      .      bool        cached = false;
         7,069      0    0          7,069            44         0              0           0      0      starts++;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // simplify
             .      .    .              .             .         .              .           .      .      //
        28,276      1    1         21,207         7,069       104              0           0      0      if (conflicts >= curSimplify * nbconfbeforesimplify){
             .      .    .              .             .         .              .           .      .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
             .      .    .              .             .         .              .           .      .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
             .      .    .              .             .         .              .           .      .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
             .      .    .              .             .         .              .           .      .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
            34     25   23             34            34         0              0           0      0          nbSimplifyAll++;
           102     34   29              0             0         0             34           0      0          if (!simplifyAll()){
             .      .    .              .             .         .              .           .      .              return l_False;
             .      .    .              .             .         .              .           .      .          }
           238      0    0             68             1         0             34           0      0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
           102      0    0             34             0         0             34           0      0          nbconfbeforesimplify += incSimplify;
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      for (;;){
             .      .    .              .             .         .              .           .      .          CRef confl = propagate();
             .      .    .              .             .         .              .           .      .  
     8,869,300      0    0              0             0         0              0           0      0          if (confl != CRef_Undef){
             .      .    .              .             .         .              .           .      .              // CONFLICT
     3,879,777      0    0      1,293,259         3,853         0              0           0      0              if (VSIDS){
     1,413,610      0    0        706,790       678,532         0             30           0      0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
             .      .    .              .             .         .              .           .      .              }else
     2,779,551     21   10      1,513,033       576,744         0        340,001           0      0                  if (step_size > min_step_size) step_size -= step_size_dec;
             .      .    .              .             .         .              .           .      .  
     5,173,036    152   62      2,586,518     1,443,373        66      1,293,259           0      0              conflicts++; nof_conflicts--;
             .      .    .              .             .         .              .           .      .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
             .      .    .              .             .         .              .           .      .              ConflictData data = FindConflictLevel(confl);
     2,586,518     37    2              0             0         0              0           0      0              if (data.nHighestLevel == 0) return l_False;
         4,350      0    0          1,952             0         0              0           0      0              if (data.bOnlyOneLitFromHighest)
             .      .    .              .             .         .              .           .      .              {
           223     51    0              0             0         0              0           0      0  				cancelUntil(data.nHighestLevel - 1);
             .      .    .              .             .         .              .           .      .  				continue;
             .      .    .              .             .         .              .           .      .  			}
             .      .    .              .             .         .              .           .      .  			
             .      .    .              .             .         .              .           .      .              learnt_clause.clear();
     2,586,072      0    0              0             0         0      1,293,036   1,233,549     18              if(conflicts>50000) DISTANCE=0;
             .      .    .              .             .         .              .           .      .              else DISTANCE=1;
     3,999,132      0    0              0             0         0              0           0      0              if(VSIDS && DISTANCE)
        39,560      5    1              0             0         0          9,890           0      0                  collectFirstUIP(confl);
             .      .    .              .             .         .              .           .      .  
     7,758,216     49   36              0             0         0      1,293,036           0      0              analyze(confl, learnt_clause, backtrack_level, lbd);
             .      .    .              .             .         .              .           .      .              // check chrono backtrack condition
    18,074,511     35   29      6,461,181       888,263         0              0           0      0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
             .      .    .              .             .         .              .           .      .              {
         1,735      0    0          1,735             3         0              0           0      0  				++chrono_backtrack;
         1,735      0    0              0             0         0              0           0      0  				cancelUntil(data.nHighestLevel -1);
             .      .    .              .             .         .              .           .      .  			}
             .      .    .              .             .         .              .           .      .  			else // default behavior
             .      .    .              .             .         .              .           .      .  			{
     1,291,301  1,350   67      1,291,301       388,628         0              0           0      0  				++non_chrono_backtrack;
             .      .    .              .             .         .              .           .      .  				cancelUntil(backtrack_level);
             .      .    .              .             .         .              .           .      .  			}
             .      .    .              .             .         .              .           .      .  
     3,879,108      0    0      1,293,036       984,821         0      1,293,036           0      0              lbd--;
     2,586,072      0    0      1,293,036             0         0              0           0      0              if (VSIDS){
       706,530     66   29              0             0         0        706,530           0      0                  cached = false;
     2,119,590    782   73      2,119,590     1,164,388        23              0           0      0                  conflicts_VSIDS++;
             .      .    .              .             .         .              .           .      .                  lbd_queue.push(lbd);
     5,652,240      0    0      2,119,590             0         0        706,530           0      0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
             .      .    .              .             .         .              .           .      .  
     3,879,108     37   30      1,293,036             0         0              0           0      0              if (learnt_clause.size() == 1){
             .      .    .              .             .         .              .           .      .                  uncheckedEnqueue(learnt_clause[0]);
             .      .    .              .             .         .              .           .      .              }else{
             .      .    .              .             .         .              .           .      .                  CRef cr = ca.alloc(learnt_clause, true);
     1,293,036      0    0      1,293,036             0         0              0           0      0                  ca[cr].set_lbd(lbd);
             .      .    .              .             .         .              .           .      .                  //duplicate learnts 
             .      .    .              .             .         .              .           .      .                  int  id = 0;
     2,586,072      0    0      1,293,036     1,287,447        78              0           0      0                  if (lbd <= max_lbd_dup){                        
             .      .    .              .             .         .              .           .      .                      std::vector<uint32_t> tmp;
    11,675,987      0    0      7,422,570             0         0        200,757           0      0                      for (int i = 0; i < learnt_clause.size(); i++)
     7,824,084      8    5      5,216,056             0         0      2,608,028           0      0                          tmp.push_back(learnt_clause[i].x);
       602,271      6    2        200,757             0         0        200,757           0      0                      id = is_duplicate(tmp);             
     1,003,785      0    0        200,757             0         0              0           0      0                      if (id == min_number_of_learnts_copies +1){
             1      0    0              1             0         0              0           0      0                          duplicates_added_conflicts++;                        
             .      .    .              .             .         .              .           .      .                      }                    
       401,514      0    0              0             0         0              0           0      0                      if (id == min_number_of_learnts_copies){
           161      0    0            161             0         0              0           0      0                          duplicates_added_tier2++;
             .      .    .              .             .         .              .           .      .                      }                                        
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .                  //duplicate learnts
             .      .    .              .             .         .              .           .      .  
     7,684,384      0    0      2,567,614       545,907        55              0           0      0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
            20      6    4              0             0         0              0           0      0                      learnts_core.push(cr);
             .      .    .              .             .         .              .           .      .                      ca[cr].mark(CORE);
     4,980,890  2,616   52              0             0         0              0           0      0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
            19      2    1              0             0         0              0           0      0                      learnts_tier2.push(cr);
             .      .    .              .             .         .              .           .      .                      ca[cr].mark(TIER2);
       235,172      0    0         58,793             4         0         58,793           3      0                      ca[cr].touched() = conflicts;
             .      .    .              .             .         .              .           .      .                  }else{
            23     23    2              0             0         0              0           0      0                      learnts_local.push(cr);
             .      .    .              .             .         .              .           .      .                      claBumpActivity(ca[cr]); }
     3,879,108  2,786   83              0             0         0      1,293,036           0      0                  attachClause(cr);
             .      .    .              .             .         .              .           .      .  
     7,758,216      0    0      3,879,108            29         0      1,293,036           0      0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
             .      .    .              .             .         .              .           .      .  #ifdef PRINT_OUT
             .      .    .              .             .         .              .           .      .                  std::cout << "new " << ca[cr] << "\n";
             .      .    .              .             .         .              .           .      .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
             .      .    .              .             .         .              .           .      .  #endif                
             .      .    .              .             .         .              .           .      .              }
     3,879,108      0    0      1,293,036       634,573        43              0           0      0              if (drup_file){
             .      .    .              .             .         .              .           .      .  #ifdef BIN_DRUP
             .      .    .              .             .         .              .           .      .                  binDRUP('a', learnt_clause, drup_file);
             .      .    .              .             .         .              .           .      .  #else
             .      .    .              .             .         .              .           .      .                  for (int i = 0; i < learnt_clause.size(); i++)
             .      .    .              .             .         .              .           .      .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
             .      .    .              .             .         .              .           .      .                  fprintf(drup_file, "0\n");
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
     3,879,108  2,013   59      2,586,072       701,030        68              0           0      0              if (VSIDS) varDecayActivity();
             .      .    .              .             .         .              .           .      .              claDecayActivity();
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              /*if (--learntsize_adjust_cnt == 0){
             .      .    .              .             .         .              .           .      .                  learntsize_adjust_confl *= learntsize_adjust_inc;
             .      .    .              .             .         .              .           .      .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
             .      .    .              .             .         .              .           .      .                  max_learnts             *= learntsize_inc;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
             .      .    .              .             .         .              .           .      .                             (int)conflicts,
             .      .    .              .             .         .              .           .      .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
             .      .    .              .             .         .              .           .      .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
             .      .    .              .             .         .              .           .      .              }*/
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .          }else{
             .      .    .              .             .         .              .           .      .              // NO CONFLICT
             .      .    .              .             .         .              .           .      .              bool restart = false;
     9,424,173     35   22      3,141,391        51,884         0              0           0      0              if (!VSIDS)
             .      .    .              .             .         .              .           .      .                  restart = nof_conflicts <= 0;
     4,581,762      1    1      2,290,881       739,846        13              0           0      0              else if (!cached){
     4,528,138      3    3      1,400,561       466,694        12        376,465           0      0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
             .      .    .              .             .         .              .           .      .                  cached = true;
             .      .    .              .             .         .              .           .      .              }
     2,551,530      0    0        850,510       591,688        15              0           0      0              if (restart /*|| !withinBudget()*/){
             .      .    .              .             .         .              .           .      .                  lbd_queue.clear();
             .      .    .              .             .         .              .           .      .                  cached = false;
             .      .    .              .             .         .              .           .      .                  // Reached bound on number of conflicts:
        21,204      0    0              0             0         0         14,136           0      0                  progress_estimate = progressEstimate();
             .      .    .              .             .         .              .           .      .                  cancelUntil(0);
        14,136      0    0              0             0         0              0           0      0                  return l_Undef; }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Simplify the set of problem clauses:
     9,641,307     81   38      3,134,323             0         0        217,131           0      0              if (decisionLevel() == 0 && !simplify())
             .      .    .              .             .         .              .           .      .                  return l_False;
             .      .    .              .             .         .              .           .      .  
     9,402,969     13    2      6,268,646         7,274         0              0           0      0              if (conflicts >= next_T2_reduce){
           258      0    0              0             0         0            129           0      0                  next_T2_reduce = conflicts + 10000;
           516      0    0            129             0         0            129           0      0                  reduceDB_Tier2(); }
     6,268,646     21    9      3,134,323             0         0              0           0      0              if (conflicts >= next_L_reduce){
           172      0    0              0             0         0             86           0      0                  next_L_reduce = conflicts + 15000;
           172      0    0              0             0         0             86           0      0                  reduceDB(); }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              Lit next = lit_Undef;
             .      .    .              .             .         .              .           .      .              /*while (decisionLevel() < assumptions.size()){
             .      .    .              .             .         .              .           .      .                  // Perform user provided assumption:
             .      .    .              .             .         .              .           .      .                  Lit p = assumptions[decisionLevel()];
             .      .    .              .             .         .              .           .      .                  if (value(p) == l_True){
             .      .    .              .             .         .              .           .      .                      // Dummy decision level:
             .      .    .              .             .         .              .           .      .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
             .      .    .              .             .         .              .           .      .                  }else{
             .      .    .              .             .         .              .           .      .                      next = p;
             .      .    .              .             .         .              .           .      .                      break;
             .      .    .              .             .         .              .           .      .                  }
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              if (next == lit_Undef)*/{
             .      .    .              .             .         .              .           .      .                  // New variable decision:
     3,134,323      0    0      3,134,323            86        31              0           0      0                  decisions++;
     9,402,969  1,438   56              0             0         0      3,134,323           0      0                  next = pickBranchLit();
             .      .    .              .             .         .              .           .      .  
     6,268,646      0    0              0             0         0              0           0      0                  if (next == lit_Undef)
             .      .    .              .             .         .              .           .      .                      // Model found:
             2      0    0              0             0         0              0           0      0                      return l_True;
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .              // Increase decision level and enqueue 'next'
             .      .    .              .             .         .              .           .      .              newDecisionLevel();
    18,805,932     39   32      3,134,322             0         0      3,134,322           0      0              uncheckedEnqueue(next, decisionLevel());
             .      .    .              .             .         .              .           .      .  #ifdef PRINT_OUT            
             .      .    .              .             .         .              .           .      .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
             .      .    .              .             .         .              .           .      .  #endif            
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
        63,621     42   21         49,483        14,138         6              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  double Solver::progressEstimate() const
        42,408      3    2              0             0         0         35,340           0      0  {
        14,136      0    0              0             0         0              0           0      0      double  progress = 0;
        35,340      0    0         14,136         4,644         0          7,068           0      0      double  F = 1.0 / nVars();
             .      .    .              .             .         .              .           .      .  
     1,637,139      3    3              0             0         0              0           0      0      for (int i = 0; i <= decisionLevel(); i++){
     1,594,731      0    0      1,053,730             0         0              0           0      0          int beg = i == 0 ? 0 : trail_lim[i - 1];
     2,128,664      0    0      1,060,798        35,501       200              0           0      0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
     3,224,802     29   26        541,001             0         0              0           0      0          progress += pow(F, i) * (end - beg);
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
        14,136      0    0              0             0         0              0           0      0      return progress / nVars();
        49,476      0    0         42,408             0         0              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  /*
             .      .    .              .             .         .              .           .      .    Finite subsequences of the Luby-sequence:
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .    0: 1
             .      .    .              .             .         .              .           .      .    1: 1 1 2
             .      .    .              .             .         .              .           .      .    2: 1 1 2 1 1 2 4
             .      .    .              .             .         .              .           .      .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .   */
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  static double luby(double y, int x){
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Find the finite subsequence that contains index 'x', and the
             .      .    .              .             .         .              .           .      .      // size of that subsequence:
             .      .    .              .             .         .              .           .      .      int size, seq;
        58,788      0    0              0             0         0              0           0      0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
             .      .    .              .             .         .              .           .      .  
        32,843      4    4              0             0         0              0           0      0      while (size-1 != x){
        18,566      0    0              0             0         0              0           0      0          size = (size-1)>>1;
         9,283      0    0              0             0         0              0           0      0          seq--;
        27,849      0    0              0             0         0              0           0      0          x = x % size;
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      return pow(y, seq);
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  static bool switch_mode = false;
             .      .    .              .             .         .              .           .      .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
             .      .    .              .             .         .              .           .      .  
-- line 2204 ----------------------------------------
-- line 2221 ----------------------------------------
             .      .    .              .             .         .              .           .      .      for (auto i=0;i<tmp.size();i++){
             .      .    .              .             .         .              .           .      .          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .      return removed_duplicates;
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  // NOTE: assumptions passed in member-variable 'assumptions'.
             .      .    .              .             .         .              .           .      .  lbool Solver::solve_()
             8      0    0              0             0         0              6           0      0  {
             .      .    .              .             .         .              .           .      .      //signal(SIGALRM, SIGALRM_switch);
             .      .    .              .             .         .              .           .      .      //alarm(2500);
             .      .    .              .             .         .              .           .      .  
             1      1    1              0             0         0              0           0      0      model.clear();
             .      .    .              .             .         .              .           .      .      conflict.clear();
             2      1    1              1             0         0              0           0      0      if (!ok) return l_False;
             .      .    .              .             .         .              .           .      .  
             1      1    1              1             1         0              0           0      0      solves++;
             .      .    .              .             .         .              .           .      .  
             5      0    0              2             0         0              1           0      0      max_learnts               = nClauses() * learntsize_factor;
             3      0    0              1             1         0              0           0      0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
             1      0    0              0             0         0              1           1      0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
             .      .    .              .             .         .              .           .      .      lbool   status            = l_Undef;
             .      .    .              .             .         .              .           .      .  
             3      0    0              1             0         0              0           0      0      if (verbosity >= 1){
             2      0    0              0             0         0              1           0      0          printf("c ============================[ Search Statistics ]==============================\n");
             2      1    1              0             0         0              1           0      0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
             2      0    0              0             0         0              1           0      0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
             2      0    0              0             0         0              1           0      0          printf("c ===============================================================================\n");
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      add_tmp.clear();
             .      .    .              .             .         .              .           .      .  
             1      0    0              0             0         0              1           1      0      VSIDS = true;
             1      1    1              0             0         0              1           0      0      int init = 10000;
           225      0    0             45             0         0              0           0      0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
           180      3    0              0             0         0             45           0      0          status = search(init);
             1      0    0              0             0         0              1           0      0      VSIDS = false;
             .      .    .              .             .         .              .           .      .  
             3      1    1              0             0         0              2           1      0      duplicates_added_conflicts = 0;
             .      .    .              .             .         .              .           .      .      duplicates_added_minimization=0;
             .      .    .              .             .         .              .           .      .      duplicates_added_tier2 =0;    
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      dupl_db_size=0;
             1      0    0              1             1         0              0           0      0      size_t dupl_db_size_limit = dupl_db_init_size;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // Search:
             1      0    0              0             0         0              0           0      0      int curr_restarts = 0;
             1      0    0              0             0         0              0           0      0      uint64_t curr_props = 0;
             .      .    .              .             .         .              .           .      .      uint32_t removed_duplicates =0;
        14,048  3,658   95              0             0         0              0           0      0      while (status == l_Undef /*&& withinBudget()*/){
        14,048      1    1          7,024         5,765         6              0           0      0          if (dupl_db_size >= dupl_db_size_limit){    
             .      .    .              .             .         .              .           .      .              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             .      .    .              .             .         .              .           .      .              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             .      .    .              .             .         .              .           .      .              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             .      .    .              .             .         .              .           .      .              printf("c Duptime: %i\n",duptime.count());
             .      .    .              .             .         .              .           .      .              printf("c Number of conflicts: %i\n",conflicts);
             .      .    .              .             .         .              .           .      .              printf("c Core size: %i\n",learnts_core.size());
             .      .    .              .             .         .              .           .      .              
             .      .    .              .             .         .              .           .      .              removed_duplicates = reduceduplicates();
             .      .    .              .             .         .              .           .      .              dupl_db_size_limit*=1.1;
             .      .    .              .             .         .              .           .      .              dupl_db_size -= removed_duplicates;
             .      .    .              .             .         .              .           .      .              printf("c removed duplicates %i\n",removed_duplicates);
             .      .    .              .             .         .              .           .      .          }   
        42,144     85   76         14,048        12,794         0              0           0      0          if (propagations - curr_props >  VSIDS_props_limit){
            10      0    0              0             0         0              0           0      0              curr_props = propagations;
            10      0    0              0             0         0             10           0      0              switch_mode = true;
            51      0    0              0             0         0             10           0      0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
             .      .    .              .             .         .              .           .      .          }     
        14,048      0    0          7,024             0         0              0           0      0          if (VSIDS){
         5,770      0    0              0             0         0          5,770           0      0              int weighted = INT32_MAX;
        23,080  5,769   58              0             0         0          5,770           0      0              status = search(weighted);
             .      .    .              .             .         .              .           .      .          }else{
         7,524  1,006   43          2,508             0         0          1,254           0      0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
         1,254      0    0              0             0         0              0           0      0              curr_restarts++;
         6,270  1,235   33              0             0         0          1,254           0      0              status = search(nof_conflicts);
             .      .    .              .             .         .              .           .      .          }
        14,048  1,235   32          7,024         7,024        93              0           0      0          if (switch_mode){ 
            10      0    0              0             0         0             10           0      0              switch_mode = false;
             .      .    .              .             .         .              .           .      .              VSIDS = !VSIDS;
            20      0    0             10             0         0              0           0      0              if (VSIDS){
            10      5    5              0             0         0              5           0      0                  printf("c Switched to VSIDS.\n");
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              else{
            15      5    5              0             0         0              5           0      0                 printf("c Switched to LRB.\n");
             .      .    .              .             .         .              .           .      .              }
             .      .    .              .             .         .              .           .      .              //            reduceduplicates();            
            20      5    5             10            10        10             10           0      0              fflush(stdout);
             .      .    .              .             .         .              .           .      .              picked.clear();
             .      .    .              .             .         .              .           .      .              conflicted.clear();
             .      .    .              .             .         .              .           .      .              almost_conflicted.clear();
             .      .    .              .             .         .              .           .      .  #ifdef ANTI_EXPLORATION
             .      .    .              .             .         .              .           .      .              canceled.clear();
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             3      1    1              1             1         0              0           0      0      if (verbosity >= 1)
             2      0    0              0             0         0              1           0      0          printf("c ===============================================================================\n");
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  #ifdef BIN_DRUP
             3      0    0              1             0         0              0           0      0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
             .      .    .              .             .         .              .           .      .  #endif
             .      .    .              .             .         .              .           .      .  
             2      1    1              0             0         0              0           0      0      if (status == l_True){
             .      .    .              .             .         .              .           .      .          // Extend & copy model:
             .      .    .              .             .         .              .           .      .          model.growTo(nVars());
           705      1    1            328            39         0            339           0      0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
             .      .    .              .             .         .              .           .      .      }else if (status == l_False && conflict.size() == 0)
             .      .    .              .             .         .              .           .      .          ok = false;
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      cancelUntil(0);
             1      0    0              0             0         0              0           0      0      return status;
             8      1    1              7             1         1              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  //=================================================================================================
             .      .    .              .             .         .              .           .      .  // Writing CNF to DIMACS:
             .      .    .              .             .         .              .           .      .  // 
             .      .    .              .             .         .              .           .      .  // FIXME: this needs to be rewritten completely.
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  static Var mapVar(Var x, vec<Var>& map, Var& max)
             .      .    .              .             .         .              .           .      .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
             .      .    .              .             .         .              .           .      .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
             .      .    .              .             .         .              .           .      .  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  //=================================================================================================
             .      .    .              .             .         .              .           .      .  // Garbage Collection methods:
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::relocAll(ClauseAllocator& to)
           860     65   63              0             0         0            688           0      0  {
             .      .    .              .             .         .              .           .      .      // All watchers:
             .      .    .              .             .         .              .           .      .      //
             .      .    .              .             .         .              .           .      .      // for (int i = 0; i < watches.size(); i++)
           172      0    0              0             0         0             86           0      0      watches.cleanAll();
           172      0    0              0             0         0             86           0      0      watches_bin.cleanAll();
     4,510,356      8    8      3,156,974        16,574         1        451,156          86      0      for (int v = 0; v < nVars(); v++)
     1,803,936      0    0        901,968             0         0              0           0      0          for (int s = 0; s < 2; s++){
             .      .    .              .             .         .              .           .      .              Lit p = mkLit(v, s);
             .      .    .              .             .         .              .           .      .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
             .      .    .              .             .         .              .           .      .              vec<Watcher>& ws = watches[p];
   101,196,718     56   55     51,462,284       225,492    20,761              0           0      0              for (int j = 0; j < ws.size(); j++)
             .      .    .              .             .         .              .           .      .                  ca.reloc(ws[j].cref, to);
             .      .    .              .             .         .              .           .      .              vec<Watcher>& ws_bin = watches_bin[p];
    27,337,583      6    6     12,906,996       232,031    24,581              0           0      0              for (int j = 0; j < ws_bin.size(); j++)
             .      .    .              .             .         .              .           .      .                  ca.reloc(ws_bin[j].cref, to);
             .      .    .              .             .         .              .           .      .          }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // All reasons:
             .      .    .              .             .         .              .           .      .      //
       393,472      0    0            258             0         0              0           0      0      for (int i = 0; i < trail.size(); i++){
             .      .    .              .             .         .              .           .      .          Var v = var(trail[i]);
             .      .    .              .             .         .              .           .      .  
       730,124      0    0        168,584       144,979       645              0           0      0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
       843,092      0    0        168,584             0         0        168,584           0      0              ca.reloc(vardata[v].reason, to);
             .      .    .              .             .         .              .           .      .      }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // All learnt:
             .      .    .              .             .         .              .           .      .      //
     7,897,119     86   86      3,948,516           169        65              0           0      0      for (int i = 0; i < learnts_core.size(); i++)
             .      .    .              .             .         .              .           .      .          ca.reloc(learnts_core[i], to);
       954,355    258  254        477,177           341        82              0           0      0      for (int i = 0; i < learnts_tier2.size(); i++)
             .      .    .              .             .         .              .           .      .          ca.reloc(learnts_tier2[i], to);
     2,407,843     86   84      1,203,750            85         0              0           0      0      for (int i = 0; i < learnts_local.size(); i++)
     3,610,734      0    0              0             0         0      1,203,578           0      0          ca.reloc(learnts_local[i], to);
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      // All original:
             .      .    .              .             .         .              .           .      .      //
             .      .    .              .             .         .              .           .      .      int i, j;
    19,149,344     86   83            344            85         0              0           0      0      for (i = j = 0; i < clauses.size(); i++)
    19,148,570      0    0              0             0         0              0           0      0          if (ca[clauses[i]].mark() != 1){
    28,723,027     86   83      9,574,285            85         0      9,574,285           1      0              ca.reloc(clauses[i], to);
    95,742,764     67   65     38,297,054             0         0      9,574,285           0      0              clauses[j++] = clauses[i]; }
            86     86   83              0             0         0              0           0      0      clauses.shrink(i - j);
           688     86   84            602            86        15              0           0      0  }
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .  void Solver::garbageCollect()
             .      .    .              .             .         .              .           .      .  {
             .      .    .              .             .         .              .           .      .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
             .      .    .              .             .         .              .           .      .      // is not precise but should avoid some unnecessary reallocations for the new region:
             .      .    .              .             .         .              .           .      .      ClauseAllocator to(ca.size() - ca.wasted());
             .      .    .              .             .         .              .           .      .  
             .      .    .              .             .         .              .           .      .      relocAll(to);
             .      .    .              .             .         .              .           .      .      if (verbosity >= 2)
             .      .    .              .             .         .              .           .      .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
             .      .    .              .             .         .              .           .      .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
             .      .    .              .             .         .              .           .      .      to.moveTo(ca);
           155     18   18             47             4         4             61           0      0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr          DLmr      Dw             D1mw        DLmw       

-- line 54 ----------------------------------------
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  struct Lit {
              .     .    .              .             .         .              .           .          .      int     x;
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      // Use this as a constructor:
              .     .    .              .             .         .              .           .          .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      bool operator == (Lit p) const { return x == p.x; }
    221,705,413     0    0    111,652,681    56,309,714    84,519              0           0          0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .             .         .              .           .          .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .             .         .              .           .          .  };
              .     .    .              .             .         .              .           .          .  
        785,085     1    1              0             0         0            113           0          0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 12,730,956,597    28   24  4,800,887,374        75,062     2,617  1,234,921,652     533,821          0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .             .         .              .           .          .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
 62,184,856,985    13   12  3,052,925,073             0         0  1,526,840,231 208,109,835      6,717  inline  bool sign      (Lit p)              { return p.x & 1; }
106,404,846,546 9,714  250  3,810,551,180    91,858,607    12,358 16,305,302,145           0          0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .             .         .              .           .          .  inline  int  toInt     (Var v)              { return v; } 
          4,894     0    0              8             0         0              8           0          0  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .             .         .              .           .          .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .             .         .              .           .          .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .             .         .              .           .          .  const Lit lit_Error = { -1 };  // }
              .     .    .              .             .         .              .           .          .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .     .    .              .             .         .              .           .          .  #define l_Undef (lbool((uint8_t)2))
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  class lbool {
              .     .    .              .             .         .              .           .          .      uint8_t value;
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  public:
              .     .    .              .             .         .              .           .          .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .             .         .              .           .          .  
          1,331     1    1              0             0         0            339          81          0      lbool()       : value(0) { }
              .     .    .              .             .         .              .           .          .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .             .         .              .           .          .  
    578,433,986     1    1              0             0         0              0           0          0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
         15,732     0    0         10,488            83         0              0           0          0      bool  operator != (lbool b) const { return !(*this == b); }
 21,379,663,812    34   29 21,057,319,805   407,207,161     2,770              0           0          0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      lbool operator && (lbool b) const {
              .     .    .              .             .         .              .           .          .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .             .         .              .           .          .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .             .         .              .           .          .          return lbool(v); }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      lbool operator || (lbool b) const {
              .     .    .              .             .         .              .           .          .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .             .         .              .           .          .          unsigned simplified : 1;}                            header;
              .     .    .              .             .         .              .           .          .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      friend class ClauseAllocator;
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .             .         .              .           .          .      template<class V>
              .     .    .              .             .         .              .           .          .      Clause(const V& ps, bool use_extra, bool learnt) {
     62,527,581     0    0     15,308,636             0         0     16,601,672      79,293          1          header.mark      = 0;
     45,571,068     0    0     15,190,356       949,819   472,086              0           0          0          header.learnt    = learnt;
     91,970,096     3    3     15,426,916             0         0     15,308,636           0          0          header.has_extra = learnt | use_extra;
              .     .    .              .             .         .              .           .          .          header.reloced   = 0;
     18,012,986     0    0      1,411,315            57        43     16,601,671   1,291,243    172,331          header.size      = ps.size();
              .     .    .              .             .         .              .           .          .          header.lbd       = 0;
              .     .    .              .             .         .              .           .          .          header.removable = 1;
              .     .    .              .             .         .              .           .          .          //simplify
              .     .    .              .             .         .              .           .          .          //
     16,601,672     5    4     16,601,672     1,985,045 1,029,076              0           0          0          header.simplified = 0;
              .     .    .              .             .         .              .           .          .  
    801,624,139   134  133      2,187,917             0         0              0           0          0          for (int i = 0; i < ps.size(); i++)
    560,451,549   149  115    192,582,643    20,846,455 3,419,412    220,174,392  22,178,081 17,319,242              data[i].lit = ps[i];
              .     .    .              .             .         .              .           .          .  
     49,805,015    40   40     16,601,671             0         0              0           0          0          if (header.has_extra){
     14,054,772    19   19              0             0         0              0           0          0              if (header.learnt){
     13,818,214     1    1      5,616,067             0         0      6,909,107     431,503    268,256                  data[header.size].act = 0;
     13,818,219     1    1              0             0         0      6,909,107     432,891    270,034                  data[header.size+1].touched = 0;
              .     .    .              .             .         .              .           .          .              }else
              .     .    .              .             .         .              .           .          .                  calcAbstraction(); }
              .     .    .              .             .         .              .           .          .      }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  public:
              .     .    .              .             .         .              .           .          .      void calcAbstraction() {
              .     .    .              .             .         .              .           .          .          assert(header.has_extra);
        239,798     0    0              0             0         0              0           0          0          uint32_t abstraction = 0;
      4,266,819     2    1         24,047             0         0              0           0          0          for (int i = 0; i < size(); i++)
      7,166,114     2    1              0             0         0              1           0          0              abstraction |= 1 << (var(data[i].lit) & 31);
        357,808     0    0              0             0         0        239,529       7,763      7,763          data[header.size].abs = abstraction;  }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
 11,899,207,145   147  131  5,433,159,673   827,373,551   195,908  4,645,585,783          32          0      int          size        ()      const   { return header.size; }
      1,866,543    21   17        490,616        39,751         4        490,616         642          0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .             .         .              .           .          .      void         pop         ()              { shrink(1); }
     62,694,283     3    3      1,216,422             0         0              0           0          0      bool         learnt      ()      const   { return header.learnt; }
         13,902     0    0              0             0         0              0           0          0      bool         has_extra   ()      const   { return header.has_extra; }
    130,209,824    97   87     27,267,103    23,153,401   222,773     22,625,068           0          0      uint32_t     mark        ()      const   { return header.mark; }
     67,346,056   123  115     16,853,233        25,287         0     16,766,336           0          0      void         mark        (uint32_t m)    { header.mark = m; }
        115,136     0    0              0             0         0         57,568           0          0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .             .         .              .           .          .  
     45,752,242     0    0     45,752,242    27,372,355   140,919              0           0          0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .             .         .              .           .          .      CRef         relocation  ()      const   { return data[0].rel; }
     60,761,424    16   16     15,190,356             0         0     30,380,712           0          0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .             .         .              .           .          .  
     21,625,197     0    0      7,198,835           719         0              0           0          0      int          lbd         ()      const   { return header.lbd; }
     47,649,547   108   87     12,982,433             0         0      7,368,011           0          0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .             .         .              .           .          .      bool         removable   ()      const   { return header.removable; }
     35,272,534     3    3     12,808,250             0         0      5,616,071           0          0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .             .         .              .           .          .      //       subsumption operations to behave correctly.
 17,207,321,302   176  106 17,075,418,178 1,237,300,395 1,208,995              0           0          0      Lit&         operator [] (int i)         { return data[i].lit; }
    339,855,051   596  191    320,809,140    16,498,504   147,841              0           0          0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .             .         .              .           .          .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .             .         .              .           .          .  
      5,674,864     0    0      5,674,864             0         0              0           0          0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
      5,782,322     0    0      1,800,340       431,660     8,314              0           0          0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .             .         .              .           .          .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .             .         .              .           .          .      void         strengthen  (Lit p);
              .     .    .              .             .         .              .           .          .      // simplify
              .     .    .              .             .         .              .           .          .      //
     39,589,551     0    0     11,370,669             0         0      5,616,071           0          0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .             .         .              .           .          .      bool simplified() { return header.simplified; }
              .     .    .              .             .         .              .           .          .  };
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  //=================================================================================================
              .     .    .              .             .         .              .           .          .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .             .         .              .           .          .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .             .         .              .           .          .  {
              .     .    .              .             .         .              .           .          .      static int clauseWord32Size(int size, int extras){
     33,008,457     3    2     16,406,782       834,463    58,882              0           0          0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .             .         .              .           .          .  public:
              .     .    .              .             .         .              .           .          .      bool extra_clause_field;
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0             0         0              1           0          0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      void moveTo(ClauseAllocator& to){
            172    56   55             86             1         0             86           0          0          to.extra_clause_field = extra_clause_field;
              .     .    .              .             .         .              .           .          .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      template<class Lits>
              .     .    .              .             .         .              .           .          .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .             .         .              .           .          .      {
              .     .    .              .             .         .              .           .          .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .             .         .              .           .          .          assert(sizeof(float)    == sizeof(uint32_t));
     40,073,276   120  117      9,692,564            58         2              0           0          0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .             .         .              .           .          .  
      1,529,594     0    0              0             0         0        118,279           0          0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .             .         .              .           .          .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .          return cid;
              .     .    .              .             .         .              .           .          .      }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
     96,094,656    86   85     91,153,882        31,327         0        115,832           0          0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
         36,944     1    1         18,472             6         0              0           0          0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     15,190,356     0    0     15,190,356             0         0              0           0          0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .         .              .           .          .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .         .              .           .          .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      void free(CRef cid)
              .     .    .              .             .         .              .           .          .      {
              .     .    .              .             .         .              .           .          .          Clause& c = operator[](cid);
      3,663,168     4    2              0             0         0              0           0          0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .             .         .              .           .          .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .             .         .              .           .          .      }
              .     .    .              .             .         .              .           .          .  
     76,625,129    86   78              0             0         0     65,678,682         168         20      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .             .         .              .           .          .      {
              .     .    .              .             .         .              .           .          .          Clause& c = operator[](cr);
              .     .    .              .             .         .              .           .          .          
    157,053,347     0    0     30,561,886     5,019,708     9,341     30,561,886           0          0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .             .         .              .           .          .          
     15,190,356     0    0              0             0         0     15,190,356           0          0          cr = to.alloc(c, c.learnt());
              .     .    .              .             .         .              .           .          .          c.relocate(cr);
              .     .    .              .             .         .              .           .          .          
              .     .    .              .             .         .              .           .          .          // Copy extra data-fields:
              .     .    .              .             .         .              .           .          .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .             .         .              .           .          .          to[cr].mark(c.mark());
     30,380,712     2    2              0             0         0              0           0          0          if (to[cr].learnt()){
     22,464,284     0    0      5,616,071       294,761     9,014      5,616,071           0          0              to[cr].touched() = c.touched();
     22,464,280     0    0     11,232,142       294,118     9,181      5,616,071           0          0              to[cr].activity() = c.activity();
              .     .    .              .             .         .              .           .          .              to[cr].set_lbd(c.lbd());
              .     .    .              .             .         .              .           .          .              to[cr].removable(c.removable());
              .     .    .              .             .         .              .           .          .              // simplify
              .     .    .              .             .         .              .           .          .              //
              .     .    .              .             .         .              .           .          .              to[cr].setSimplified(c.simplified());
              .     .    .              .             .         .              .           .          .          }
     19,148,570   172  168              0             0         0              0           0          0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     87,571,576     0    0     76,625,129             0         0              0           0          0      }
              .     .    .              .             .         .              .           .          .  };
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .             .         .              .           .          .  {
              .     .    .              .             .         .              .           .          .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .             .         .              .           .          .      {
              .     .    .              .             .         .              .           .          .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .             .         .              .           .          .  class OccLists
              .     .    .              .             .         .              .           .          .  {
              .     .    .              .             .         .              .           .          .      vec<Vec>  occs;
              .     .    .              .             .         .              .           .          .      vec<char> dirty;
              .     .    .              .             .         .              .           .          .      vec<Idx>  dirties;
              .     .    .              .             .         .              .           .          .      Deleted   deleted;
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  public:
              3     0    0              0             0         0              3           0          0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .             .         .              .           .          .      unsigned int size(){
              .     .    .              .             .         .              .           .          .          auto m_size=0;
             64     2    2              4             3         0              0           0          0          for(int i=0;i<occs.size();i++){
        115,436    14   14         41,956        10,490        11              0           0          0              m_size+=occs[i].size();
              .     .    .              .             .         .              .           .          .          }
              .     .    .              .             .         .              .           .          .          
              .     .    .              .             .         .              .           .          .          return m_size;
              .     .    .              .             .         .              .           .          .      }
         57,684     1    1              0             0         0         10,488           0          0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .             .         .              .           .          .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
    659,794,909    30   17    659,794,909     1,249,983        43              0           0          0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
        524,835     1    1        262,608       182,225         0          4,975           1          0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      void  cleanAll  ();
              .     .    .              .             .         .              .           .          .      void  clean     (const Idx& idx);
              .     .    .              .             .         .              .           .          .      void  smudge    (const Idx& idx){
      7,350,288     0    0      4,891,562       165,112    12,990              0           0          0          if (dirty[toInt(idx)] == 0){
        309,084    91   84              0             0         0        309,084           0          0              dirty[toInt(idx)] = 1;
             55     1    1              0             0         0              0           0          0              dirties.push(idx);
              .     .    .              .             .         .              .           .          .          }
              .     .    .              .             .         .              .           .          .      }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .      void  clear(bool free = true){
              .     .    .              .             .         .              .           .          .          occs   .clear(free);
              .     .    .              .             .         .              .           .          .          dirty  .clear(free);
              .     .    .              .             .         .              .           .          .          dirties.clear(free);
              .     .    .              .             .         .              .           .          .      }
              .     .    .              .             .         .              .           .          .  };
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  template<class Idx, class Vec, class Deleted>
            424     0    0              0             0         0            318           4          0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .             .         .              .           .          .  {
     42,177,542 1,093   20     20,788,916        26,975         0              0           0          0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .             .         .              .           .          .          // Dirties may contain duplicates so check here if a variable is already cleaned:
        899,406     0    0        599,604       261,841         0              0           0          0          if (dirty[toInt(dirties[i])])
              .     .    .              .             .         .              .           .          .              clean(dirties[i]);
              .     .    .              .             .         .              .           .          .      dirties.clear();
            424     0    0            424           181         0              0           0          0  }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  template<class Idx, class Vec, class Deleted>
              .     .    .              .             .         .              .           .          .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .             .         .              .           .          .  {
              .     .    .              .             .         .              .           .          .      Vec& vec = occs[toInt(idx)];
              .     .    .              .             .         .              .           .          .      int  i, j;
     50,654,981     2    2      1,200,536       299,509       425              0           0          0      for (i = j = 0; i < vec.size(); i++)
     32,840,151     0    0      1,222,104        63,989         0              0           0          0          if (!deleted(vec[i]))
     89,804,146     2    2     24,889,592             8         0     12,891,382       4,665          0              vec[j++] = vec[i];
        308,952    91   84              0             0         0              0           0          0      vec.shrink(i - j);
      1,245,388     0    0        618,076         2,360         0        310,624       1,351          0      dirty[toInt(idx)] = 0;
              .     .    .              .             .         .              .           .          .  }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  //=================================================================================================
              .     .    .              .             .         .              .           .          .  // CMap -- a class for mapping clauses to values:
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .             .         .              .           .          .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .             .         .              .           .          .  |________________________________________________________________________________________________@*/
              .     .    .              .             .         .              .           .          .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .             .         .              .           .          .  {
              .     .    .              .             .         .              .           .          .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .             .         .              .           .          .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .             .         .              .           .          .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .             .         .              .           .          .      assert(header.has_extra); assert(other.header.has_extra);
    254,424,528     0    0     84,808,176    13,898,755         0              0           0          0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .             .         .              .           .          .          return lit_Error;
              .     .    .              .             .         .              .           .          .  
      1,379,774     0    0              0             0         0              0           0          0      Lit        ret = lit_Undef;
              .     .    .              .             .         .              .           .          .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .             .         .              .           .          .      const Lit* d   = (const Lit*)other;
              .     .    .              .             .         .              .           .          .  
     10,556,610     1    1      2,012,221             0         0              0           0          0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .             .         .              .           .          .          // search for c[i] or ~c[i]
     76,999,960     2    2      1,379,774             0         0      1,379,774          11          0          for (unsigned j = 0; j < other.header.size; j++)
     71,353,829     0    0     16,638,089             0         0              0           0          0              if (c[i] == d[j])
              .     .    .              .             .         .              .           .          .                  goto ok;
     16,431,470     0    0              0             0         0              0           0          0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .             .         .              .           .          .                  ret = c[i];
              .     .    .              .             .         .              .           .          .                  goto ok;
              .     .    .              .             .         .              .           .          .              }
              .     .    .              .             .         .              .           .          .  
              .     .    .              .             .         .              .           .          .          // did not find it
              .     .    .              .             .         .              .           .          .          return lit_Error;
              .     .    .              .             .         .              .           .          .  ok:;
              .     .    .              .             .         .              .           .          .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr            D1mr      DLmr      Dw         D1mw DLmw 

-- line 40 ----------------------------------------
             .     .    .             .         .         .          .    .    .      void capacity(uint32_t min_cap);
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .   public:
             .     .    .             .         .         .          .    .    .      // TODO: make this a class for better type-checking?
             .     .    .             .         .         .          .    .    .      typedef uint32_t Ref;
             .     .    .             .         .         .          .    .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .             .         .         .          .    .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .             .         .         .          .    .    .  
           436     1    1             0         0         0        348    0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .             .         .         .          .    .    .      ~RegionAllocator()
             .     .    .             .         .         .          .    .    .      {
             .     .    .             .         .         .          .    .    .          if (memory != NULL)
             .     .    .             .         .         .          .    .    .              ::free(memory);
             .     .    .             .         .         .          .    .    .      }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .      uint32_t size      () const      { return sz; }
             .     .    .             .         .         .          .    .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .      Ref      alloc     (int size); 
     3,649,271     0    0     1,216,422         0         0  1,216,422    0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
12,721,016,409   308  246 6,465,383,386 6,086,870 1,474,767    187,973    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    14,430,831     0    0    14,430,831 2,047,228    86,418          0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .             .         .         .          .    .    .  
    51,098,052 7,214   28     1,411,316         0         0          0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     1,968,580     0    0             0         0         0          0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .             .         .         .          .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .             .         .         .          .    .    .          return  (Ref)(t - &memory[0]); }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .      void     moveTo(RegionAllocator& to) {
           344     0    0            86         0         0         86    0    0          if (to.memory != NULL) ::free(to.memory);
           172     0    0            86         0         0         86    0    0          to.memory = memory;
           172     0    0            86         0         0         86    0    0          to.sz = sz;
             .     .    .             .         .         .          .    .    .          to.cap = cap;
           172     0    0            86         0         0         86    0    0          to.wasted_ = wasted_;
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .          memory = NULL;
             .     .    .             .         .         .          .    .    .          sz = cap = wasted_ = 0;
             .     .    .             .         .         .          .    .    .      }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  };
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  template<class T>
           912    44   39             0         0         0        304   85    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .             .         .         .          .    .    .  {
    49,805,280     4    0    16,601,759         0         0          0    0    0      if (cap >= min_cap) return;
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .      uint32_t prev_cap = cap;
         5,457     0    0             0         0         0        153    0    0      while (cap < min_cap){
             .     .    .             .         .         .          .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .             .         .         .          .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .             .         .         .          .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .             .         .         .          .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        15,912     0    0             0         0         0          0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         2,652     0    0             0         0         0          0    0    0          cap += delta;
             .     .    .             .         .         .          .    .    .  
         5,304     0    0             0         0         0          0    0    0          if (cap <= prev_cap)
             .     .    .             .         .         .          .    .    .              throw OutOfMemoryException();
             .     .    .             .         .         .          .    .    .      }
             .     .    .             .         .         .          .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .      assert(cap > 0);
           307     2    1             0         0         0        153   57   43      memory = (T*)xrealloc(memory, sizeof(T)*cap);
           608     0    0           456         0         0          0    0    0  }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  template<class T>
             .     .    .             .         .         .          .    .    .  typename RegionAllocator<T>::Ref
       473,116     2    1             0         0         0    354,837    0    0  RegionAllocator<T>::alloc(int size)
             .     .    .             .         .         .          .    .    .  { 
             .     .    .             .         .         .          .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .             .         .         .          .    .    .      assert(size > 0);
    95,257,806     0    0    16,601,672 1,141,669        44 46,864,101   17    1      capacity(sz + size);
             .     .    .             .         .         .          .    .    .  
    50,743,211     0    0    31,673,745         0         0          0    0    0      uint32_t prev_sz = sz;
    16,601,672     2    1             0         0         0 16,601,672    0    0      sz += size;
             .     .    .             .         .         .          .    .    .      
             .     .    .             .         .         .          .    .    .      // Handle overflow:
    78,774,411   119  117    15,190,356         0         0          0    0    0      if (sz < prev_sz)
             2     1    1             1         1         0          0    0    0          throw OutOfMemoryException();
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .      return prev_sz;
       473,116     0    0       473,116         0         0          0    0    0  }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  //=================================================================================================
             .     .    .             .         .         .          .    .    .  }
             .     .    .             .         .         .          .    .    .  
             .     .    .             .         .         .          .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/SimpSolver.cc
--------------------------------------------------------------------------------
Ir          I1mr ILmr Dr          D1mr       DLmr Dw         D1mw   DLmw 

-- line 33 ----------------------------------------
          .    .    .           .          .    .          .      .    .  using namespace Minisat;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  //=================================================================================================
          .    .    .           .          .    .          .      .    .  // Options:
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  static const char* _cat = "SIMP";
          .    .    .           .          .    .          .      .    .  
          4    1    1           0          0    0          1      0    0  static BoolOption   opt_use_asymm        (_cat, "asymm",        "Shrink clauses by asymmetric branching.", false);
          4    0    0           0          0    0          1      0    0  static BoolOption   opt_use_rcheck       (_cat, "rcheck",       "Check if a clause is already implied. (costly)", false);
          4    0    0           0          0    0          1      0    0  static BoolOption   opt_use_elim         (_cat, "elim",         "Perform variable elimination.", true);
          4    1    1           0          0    0          1      0    0  static IntOption    opt_grow             (_cat, "grow",         "Allow a variable elimination step to grow by a number of clauses.", 0);
          4    0    0           0          0    0          1      0    0  static IntOption    opt_clause_lim       (_cat, "cl-lim",       "Variables are not eliminated if it produces a resolvent with a length above this limit. -1 means no limit", 20,   IntRange(-1, INT32_MAX));
          4    0    0           0          0    0          1      0    0  static IntOption    opt_subsumption_lim  (_cat, "sub-lim",      "Do not check if subsumption against a clause larger than this. -1 means no limit.", 1000, IntRange(-1, INT32_MAX));
          4    0    0           0          0    0          1      0    0  static DoubleOption opt_simp_garbage_frac(_cat, "simp-gc-frac", "The fraction of wasted memory allowed before a garbage collection is triggered during simplification.",  0.5, DoubleRange(0, false, HUGE_VAL, false));
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  //=================================================================================================
          .    .    .           .          .    .          .      .    .  // Constructor/Destructor:
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          4    1    1           0          0    0          3      0    0  SimpSolver::SimpSolver() :
          .    .    .           .          .    .          .      .    .      parsing            (false)
          .    .    .           .          .    .          .      .    .    , grow               (opt_grow)
          .    .    .           .          .    .          .      .    .    , clause_lim         (opt_clause_lim)
          .    .    .           .          .    .          .      .    .    , subsumption_lim    (opt_subsumption_lim)
          .    .    .           .          .    .          .      .    .    , simp_garbage_frac  (opt_simp_garbage_frac)
          .    .    .           .          .    .          .      .    .    , use_asymm          (opt_use_asymm)
          .    .    .           .          .    .          .      .    .    , use_rcheck         (opt_use_rcheck)
          .    .    .           .          .    .          .      .    .    , use_elim           (opt_use_elim)
          .    .    .           .          .    .          .      .    .    , merges             (0)
          .    .    .           .          .    .          .      .    .    , asymm_lits         (0)
          .    .    .           .          .    .          .      .    .    , eliminated_vars    (0)
          .    .    .           .          .    .          .      .    .    , elimorder          (1)
          .    .    .           .          .    .          .      .    .    , use_simplification (true)
          1    0    0           0          0    0          0      0    0    , occurs             (ClauseDeleted(ca))
          .    .    .           .          .    .          .      .    .    , elim_heap          (ElimLt(n_occ))
          .    .    .           .          .    .          .      .    .    , bwdsub_assigns     (0)
         22    2    2           8          1    1         13      1    0    , n_touched          (0)
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .      vec<Lit> dummy(1,lit_Undef);
          1    0    0           0          0    0          1      0    0      ca.extra_clause_field = true; // NOTE: must happen before allocating the dummy clause below.
          1    1    1           0          0    0          1      0    0      bwdsub_tmpunit        = ca.alloc(dummy);
          1    0    0           0          0    0          1      0    0      remove_satisfied      = false;
          3    0    0           3          0    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  SimpSolver::~SimpSolver()
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
     31,464    2    2           0          0    0     26,220      0    0  Var SimpSolver::newVar(bool sign, bool dvar) {
     20,976    0    0           0          0    0      5,244      0    0      Var v = Solver::newVar(sign, dvar);
          .    .    .           .          .    .          .      .    .  
         19    0    0           0          0    0          0      0    0      frozen    .push((char)false);
         19    0    0           0          0    0          0      0    0      eliminated.push((char)false);
          .    .    .           .          .    .          .      .    .  
     10,488    0    0       5,244         22    0          0      0    0      if (use_simplification){
     10,488    1    1           0          0    0          0      0    0          n_occ     .push(0);
          .    .    .           .          .    .          .      .    .          n_occ     .push(0);
          .    .    .           .          .    .          .      .    .          occurs    .init(v);
         19    0    0           0          0    0          0      0    0          touched   .push(0);
          .    .    .           .          .    .          .      .    .          elim_heap .insert(v);
          .    .    .           .          .    .          .      .    .      }
     36,708    0    0      31,464         18    0          0      0    0      return v; }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  lbool SimpSolver::solve_(bool do_simp, bool turn_off_simp)
          8    1    1           0          0    0          6      0    0  {
          .    .    .           .          .    .          .      .    .      vec<Var> extra_frozen;
          .    .    .           .          .    .          .      .    .      lbool    result = l_True;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      do_simp &= use_simplification;
          .    .    .           .          .    .          .      .    .  
          4    0    0           1          1    0          1      0    0      if (do_simp){
          .    .    .           .          .    .          .      .    .          // Assumptions must be temporarily frozen to run variable elimination:
          .    .    .           .          .    .          .      .    .          for (int i = 0; i < assumptions.size(); i++){
          .    .    .           .          .    .          .      .    .              Var v = var(assumptions[i]);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .              // If an assumption has been eliminated, remember it.
          .    .    .           .          .    .          .      .    .              assert(!isEliminated(v));
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .              if (!frozen[v]){
-- line 117 ----------------------------------------
-- line 119 ----------------------------------------
          .    .    .           .          .    .          .      .    .                  setFrozen(v, true);
          .    .    .           .          .    .          .      .    .                  extra_frozen.push(v);
          .    .    .           .          .    .          .      .    .              } }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          result = lbool(eliminate(turn_off_simp));
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      if (result == l_True)
          3    2    2           0          0    0          2      1    1          result = Solver::solve_();
          .    .    .           .          .    .          .      .    .      else if (verbosity >= 1)
          .    .    .           .          .    .          .      .    .          printf("c ===============================================================================\n");
          .    .    .           .          .    .          .      .    .  
          2    0    0           0          0    0          0      0    0      if (result == l_True)
          2    0    0           0          0    0          1      0    0          extendModel();
          .    .    .           .          .    .          .      .    .  
          2    0    0           1          0    0          0      0    0      if (do_simp)
          .    .    .           .          .    .          .      .    .          // Unfreeze the assumptions that were frozen:
          .    .    .           .          .    .          .      .    .          for (int i = 0; i < extra_frozen.size(); i++)
          .    .    .           .          .    .          .      .    .              setFrozen(extra_frozen[i], false);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      return result;
          9    0    0           8          1    1          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  bool SimpSolver::addClause_(vec<Lit>& ps)
  1,136,538    6    2           0          0    0    757,692      0    0  {
          .    .    .           .          .    .          .      .    .  #ifndef NDEBUG
          .    .    .           .          .    .          .      .    .      for (int i = 0; i < ps.size(); i++)
          .    .    .           .          .    .          .      .    .          assert(!isEliminated(var(ps[i])));
          .    .    .           .          .    .          .      .    .  #endif
          .    .    .           .          .    .          .      .    .  
    126,282    0    0     126,282         18    0          0      0    0      int nclauses = clauses.size();
          .    .    .           .          .    .          .      .    .  
    252,564    0    0     126,282         19    0          0      0    0      if (use_rcheck && implied(ps))
    126,282    0    0           0          0    0          0      0    0          return true;
          .    .    .           .          .    .          .      .    .  
    631,410    0    0           0          0    0    126,282      0    0      if (!Solver::addClause_(ps))
          .    .    .           .          .    .          .      .    .          return false;
          .    .    .           .          .    .          .      .    .  
    253,023    2    1     126,435          9    0          0      0    0      if (!parsing && drup_file) {
          .    .    .           .          .    .          .      .    .  #ifdef BIN_DRUP
          .    .    .           .          .    .          .      .    .          binDRUP('a', ps, drup_file);
          .    .    .           .          .    .          .      .    .  #else
          .    .    .           .          .    .          .      .    .          for (int i = 0; i < ps.size(); i++)
          .    .    .           .          .    .          .      .    .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
          .    .    .           .          .    .          .      .    .          fprintf(drup_file, "0\n");
          .    .    .           .          .    .          .      .    .  #endif
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
    631,410    2    1     252,564         15    0          0      0    0      if (use_simplification && clauses.size() == nclauses + 1){
    473,116    2    1     236,558          5    0    118,279      0    0          CRef          cr = clauses.last();
          .    .    .           .          .    .          .      .    .          const Clause& c  = ca[cr];
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          // NOTE: the clause is added to the queue immediately and then
          .    .    .           .          .    .          .      .    .          // again during 'gatherTouchedClauses()'. If nothing happens
          .    .    .           .          .    .          .      .    .          // in between, it will only be checked once. Otherwise, it may
          .    .    .           .          .    .          .      .    .          // be checked twice unnecessarily. This is an unfortunate
          .    .    .           .          .    .          .      .    .          // consequence of how backward subsumption is used to mimic
          .    .    .           .          .    .          .      .    .          // forward subsumption.
          .    .    .           .          .    .          .      .    .          subsumption_queue.insert(cr);
  2,262,878    1    0     894,881         10    0          0      0    0          for (int i = 0; i < c.size(); i++){
          .    .    .           .          .    .          .      .    .              occurs[var(c[i])].push(cr);
    776,602    0    0     776,602    111,737    0          0      0    0              n_occ[toInt(c[i])]++;
  1,553,204    0    0     776,602          2    0    776,602 48,003    0              touched[var(c[i])] = 1;
    776,602    2    1     776,602         21    0          0      0    0              n_touched++;
          .    .    .           .          .    .          .      .    .              if (elim_heap.inHeap(var(c[i])))
          .    .    .           .          .    .          .      .    .                  elim_heap.increase(var(c[i]));
          .    .    .           .          .    .          .      .    .          }
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      return true;
  1,010,256    0    0     883,974         34    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  void SimpSolver::removeClause(CRef cr)
     62,307    1    1           0          0    0     48,461    285    0  {
          .    .    .           .          .    .          .      .    .      const Clause& c = ca[cr];
          .    .    .           .          .    .          .      .    .  
     13,846    0    0       6,923         15    0          0      0    0      if (use_simplification)
    131,252    0    0      58,703          6    0          0      0    0          for (int i = 0; i < c.size(); i++){
     25,890    0    0      25,890     12,217    0          0      0    0              n_occ[toInt(c[i])]--;
          .    .    .           .          .    .          .      .    .              updateElimHeap(var(c[i]));
          .    .    .           .          .    .          .      .    .              occurs.smudge(var(c[i]));
          .    .    .           .          .    .          .      .    .          }
          .    .    .           .          .    .          .      .    .  
     20,769    0    0       6,923          0    0          0      0    0      Solver::removeClause(cr);
     48,461    0    0      41,538          3    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  bool SimpSolver::strengthenClause(CRef cr, Lit l)
  1,209,810    1    1           0          0    0    725,886      0    0  {
          .    .    .           .          .    .          .      .    .      Clause& c = ca[cr];
          .    .    .           .          .    .          .      .    .      assert(decisionLevel() == 0);
          .    .    .           .          .    .          .      .    .      assert(use_simplification);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // FIX: this is too inefficient but would be nice to have (properly implemented)
          .    .    .           .          .    .          .      .    .      // if (!find(subsumption_queue, &c))
          .    .    .           .          .    .          .      .    .      subsumption_queue.insert(cr);
          .    .    .           .          .    .          .      .    .  
    362,943    0    0     120,981        288    0          0      0    0      if (drup_file){
          .    .    .           .          .    .          .      .    .  #ifdef BIN_DRUP
          .    .    .           .          .    .          .      .    .          binDRUP_strengthen(c, l, drup_file);
          .    .    .           .          .    .          .      .    .  #else
          .    .    .           .          .    .          .      .    .          for (int i = 0; i < c.size(); i++)
          .    .    .           .          .    .          .      .    .              if (c[i] != l) fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
          .    .    .           .          .    .          .      .    .          fprintf(drup_file, "0\n");
          .    .    .           .          .    .          .      .    .  #endif
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
    241,962    1    1     120,981          0    0          0      0    0      if (c.size() == 2){
         15    0    0           0          0    0          5      0    0          removeClause(cr);
          .    .    .           .          .    .          .      .    .          c.strengthen(l);
          .    .    .           .          .    .          .      .    .      }else{
          .    .    .           .          .    .          .      .    .          if (drup_file){
          .    .    .           .          .    .          .      .    .  #ifdef BIN_DRUP
          .    .    .           .          .    .          .      .    .              binDRUP('d', c, drup_file);
          .    .    .           .          .    .          .      .    .  #else
          .    .    .           .          .    .          .      .    .              fprintf(drup_file, "d ");
          .    .    .           .          .    .          .      .    .              for (int i = 0; i < c.size(); i++)
          .    .    .           .          .    .          .      .    .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
          .    .    .           .          .    .          .      .    .              fprintf(drup_file, "0\n");
          .    .    .           .          .    .          .      .    .  #endif
          .    .    .           .          .    .          .      .    .          }
          .    .    .           .          .    .          .      .    .  
    483,904    2    2           0          0    0    120,976    816    0          detachClause(cr, true);
          .    .    .           .          .    .          .      .    .          c.strengthen(l);
    362,928    1    1           0          0    0    120,976      0    0          attachClause(cr);
          .    .    .           .          .    .          .      .    .          remove(occurs[var(l)], cr);
    120,976    0    0     120,976     17,065    0          0      0    0          n_occ[toInt(l)]--;
          .    .    .           .          .    .          .      .    .          updateElimHeap(var(l));
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
    362,958    2    2           0          0    0          0      0    0      return c.size() == 1 ? enqueue(c[0]) && propagate() == CRef_Undef : true;
    967,848    0    0     846,867          3    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  // Returns FALSE if clause is always satisfied ('out_clause' should not be used).
          .    .    .           .          .    .          .      .    .  bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, vec<Lit>& out_clause)
      1,870    1    1           0          0    0      1,020      0    0  {
        170    1    1         170          0    0          0      0    0      merges++;
          .    .    .           .          .    .          .      .    .      out_clause.clear();
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      bool  ps_smallest = _ps.size() < _qs.size();
      1,397    0    0           0          0    0          0      0    0      const Clause& ps  =  ps_smallest ? _qs : _ps;
          .    .    .           .          .    .          .      .    .      const Clause& qs  =  ps_smallest ? _ps : _qs;
          .    .    .           .          .    .          .      .    .  
      1,256    0    0           0          0    0          0      0    0      for (int i = 0; i < qs.size(); i++){
        780    0    0           0          0    0          0      0    0          if (var(qs[i]) != v){
      1,772    1    1           0          0    0          0      0    0              for (int j = 0; j < ps.size(); j++)
      2,230    0    0           0          0    0          0      0    0                  if (var(ps[j]) == var(qs[i]))
         34    0    0           0          0    0          0      0    0                      if (ps[j] == ~qs[i])
         17    0    0           0          0    0          0      0    0                          return false;
          .    .    .           .          .    .          .      .    .                      else
          .    .    .           .          .    .          .      .    .                          goto next;
          .    .    .           .          .    .          .      .    .              out_clause.push(qs[i]);
          .    .    .           .          .    .          .      .    .          }
          .    .    .           .          .    .          .      .    .          next:;
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
      1,546    1    1           0          0    0          0      0    0      for (int i = 0; i < ps.size(); i++)
        934    0    0           0          0    0          0      0    0          if (var(ps[i]) != v)
          .    .    .           .          .    .          .      .    .              out_clause.push(ps[i]);
          .    .    .           .          .    .          .      .    .  
        153    0    0           0          0    0          0      0    0      return true;
      1,360    0    0       1,190          0    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  // Returns FALSE if clause is always satisfied.
          .    .    .           .          .    .          .      .    .  bool SimpSolver::merge(const Clause& _ps, const Clause& _qs, Var v, int& size)
          .    .    .           .          .    .          .      .    .  {
 32,797,284    0    0  10,932,428          0    0 10,932,428      0    0      merges++;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      bool  ps_smallest = _ps.size() < _qs.size();
 76,458,028    1    1           0          0    0          0      0    0      const Clause& ps  =  ps_smallest ? _qs : _ps;
          .    .    .           .          .    .          .      .    .      const Clause& qs  =  ps_smallest ? _ps : _qs;
          .    .    .           .          .    .          .      .    .      const Lit*  __ps  = (const Lit*)ps;
          .    .    .           .          .    .          .      .    .      const Lit*  __qs  = (const Lit*)qs;
          .    .    .           .          .    .          .      .    .  
 10,932,428    0    0           0          0    0          0      0    0      size = ps.size()-1;
          .    .    .           .          .    .          .      .    .  
146,107,550    0    0           0          0    0          0      0    0      for (int i = 0; i < qs.size(); i++){
102,466,578    1    1  34,155,526    223,525    0          0      0    0          if (var(__qs[i]) != v){
318,749,280    0    0           0          0    0          0      0    0              for (int j = 0; j < ps.size(); j++)
500,390,324    0    0 148,570,726    126,296    0          0      0    0                  if (var(__ps[j]) == var(__qs[i]))
 50,668,899    0    0           0          0    0          0      0    0                      if (__ps[j] == ~__qs[i])
          .    .    .           .          .    .          .      .    .                          return false;
          .    .    .           .          .    .          .      .    .                      else
          .    .    .           .          .    .          .      .    .                          goto next;
 21,607,828    0    0           0          0    0          0      0    0              size++;
          .    .    .           .          .    .          .      .    .          }
          .    .    .           .          .    .          .      .    .          next:;
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      return true;
          .    .    .           .          .    .          .      .    .  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
         16    1    1           0          0    0         12      0    0  void SimpSolver::gatherTouchedClauses()
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .      if (n_touched == 0) return;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      int i,j;
    236,256    1    1           0          0    0          0      0    0      for (i = j = 0; i < subsumption_queue.size(); i++)
    236,252    0    0           0          0    0          0      0    0          if (ca[subsumption_queue[i]].mark() == 0)
          .    .    .           .          .    .          .      .    .              ca[subsumption_queue[i]].mark(2);
          .    .    .           .          .    .          .      .    .  
     20,994    0    0           6          3    0          0      0    0      for (i = 0; i < touched.size(); i++)
     31,464    0    0      20,976        166    0          0      0    0          if (touched[i]){
          .    .    .           .          .    .          .      .    .              const vec<CRef>& cs = occurs.lookup(i);
  2,377,664    0    0      10,464        780    0          0      0    0              for (j = 0; j < cs.size(); j++)
  3,928,280    0    0   1,571,312    702,096    0          0      0    0                  if (ca[cs[j]].mark() == 0){
          .    .    .           .          .    .          .      .    .                      subsumption_queue.insert(cs[j]);
          .    .    .           .          .    .          .      .    .                      ca[cs[j]].mark(2);
          .    .    .           .          .    .          .      .    .                  }
     21,424    2    2      10,712        760    0      5,356    695    0              touched[i] = 0;
          .    .    .           .          .    .          .      .    .          }
          .    .    .           .          .    .          .      .    .  
    263,286    2    2           0          0    0          0      0    0      for (i = 0; i < subsumption_queue.size(); i++)
    258,140    0    0           0          0    0          0      0    0          if (ca[subsumption_queue[i]].mark() == 2)
          .    .    .           .          .    .          .      .    .              ca[subsumption_queue[i]].mark(0);
          .    .    .           .          .    .          .      .    .  
          2    1    1           0          0    0          2      2    0      n_touched = 0;
         16    0    0          14          2    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  bool SimpSolver::implied(const vec<Lit>& c)
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .      assert(decisionLevel() == 0);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      trail_lim.push(trail.size());
          .    .    .           .          .    .          .      .    .      for (int i = 0; i < c.size(); i++)
-- line 350 ----------------------------------------
-- line 359 ----------------------------------------
          .    .    .           .          .    .          .      .    .      bool result = propagate() != CRef_Undef;
          .    .    .           .          .    .          .      .    .      cancelUntil(0);
          .    .    .           .          .    .          .      .    .      return result;
          .    .    .           .          .    .          .      .    .  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  // Backward subsumption + backward subsumption resolution
          .    .    .           .          .    .          .      .    .  bool SimpSolver::backwardSubsumptionCheck(bool verbose)
      1,035    1    1           0          0    0        805      3    0  {
    247,266    0    0     247,036     15,547    0        115      0    0      int cnt = 0;
        115    1    1           0          0    0        115      0    0      int subsumed = 0;
        115    0    0           0          0    0        115      0    0      int deleted_literals = 0;
          .    .    .           .          .    .          .      .    .      assert(decisionLevel() == 0);
          .    .    .           .          .    .          .      .    .  
    502,328    1    1         768          8    0          0      0    0      while (subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()){
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          // Empty subsumption queue and return immediately on user-interrupt:
  2,002,439    1    1   1,001,354     17,193    0          0      0    0          if (asynch_interrupt){
          .    .    .           .          .    .          .      .    .              subsumption_queue.clear();
          .    .    .           .          .    .          .      .    .              bwdsub_assigns = trail.size();
          .    .    .           .          .    .          .      .    .              break; }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          // Check top-level assignments by creating a dummy clause and placing it in the queue:
        807    0    0         269          0    0          0      0    0          if (subsumption_queue.size() == 0 && bwdsub_assigns < trail.size()){
      1,076    1    1         538         18    0        269      0    0              Lit l = trail[bwdsub_assigns++];
        807    0    0         269          0    0        269      0    0              ca[bwdsub_tmpunit][0] = l;
          .    .    .           .          .    .          .      .    .              ca[bwdsub_tmpunit].calcAbstraction();
          .    .    .           .          .    .          .      .    .              subsumption_queue.insert(bwdsub_tmpunit); }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          CRef    cr = subsumption_queue.peek(); subsumption_queue.pop();
          .    .    .           .          .    .          .      .    .          Clause& c  = ca[cr];
          .    .    .           .          .    .          .      .    .  
  2,380,808    2    2     250,473     97,118    0          0      0    0          if (c.mark()) continue;
          .    .    .           .          .    .          .      .    .  
    987,378    0    0     493,689     28,773    0          0      0    0          if (verbose && verbosity >= 2 && cnt++ % 1000 == 0)
          .    .    .           .          .    .          .      .    .              printf("c subsumption left: %10d (%10d subsumed, %10d deleted literals)\r", subsumption_queue.size(), subsumed, deleted_literals);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          assert(c.size() > 1 || value(c[0]) == l_True);    // Unit-clauses should have been propagated before this point.
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          // Find best variable to scan:
          .    .    .           .          .    .          .      .    .          Var best = var(c[0]);
  4,255,676    0    0           0          0    0          0      0    0          for (int i = 1; i < c.size(); i++)
  4,437,799    0    0   1,387,613    450,338    0          0      0    0              if (occurs[var(c[i])].size() < occurs[best].size())
          .    .    .           .          .    .          .      .    .                  best = var(c[i]);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          // Search all candidates:
          .    .    .           .          .    .          .      .    .          vec<CRef>& _cs = occurs.lookup(best);
    246,921    0    0     246,921          0    0          0      0    0          CRef*       cs = (CRef*)_cs;
          .    .    .           .          .    .          .      .    .  
 70,850,369    1    1           0          0    0    246,789      0    0          for (int j = 0; j < _cs.size(); j++)
 69,862,949    0    0  34,808,080         10    0    246,789    263    0              if (c.mark())
          .    .    .           .          .    .          .      .    .                  break;
451,025,128    1    1 138,739,016 34,152,006    0          0      0    0              else if (!ca[cs[j]].mark() &&  cs[j] != cr && (subsumption_lim == -1 || ca[cs[j]].size() < subsumption_lim)){
          .    .    .           .          .    .          .      .    .                  Lit l = c.subsumes(ca[cs[j]]);
          .    .    .           .          .    .          .      .    .  
    251,822    0    0           0          0    0          0      0    0                  if (l == lit_Undef)
     34,510    0    0      14,790         22    0      4,930    291    0                      subsumed++, removeClause(cs[j]);
    241,962    0    0           0          0    0          0      0    0                  else if (l != lit_Error){
    120,981    0    0     120,981          0    0          0      0    0                      deleted_literals++;
          .    .    .           .          .    .          .      .    .  
    483,924    0    0           0          0    0    120,981    819    0                      if (!strengthenClause(cs[j], ~l))
          .    .    .           .          .    .          .      .    .                          return false;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .                      // Did current candidate get deleted from cs? Then check candidate at index j again:
          .    .    .           .          .    .          .      .    .                      if (var(l) == best)
          .    .    .           .          .    .          .      .    .                          j--;
          .    .    .           .          .    .          .      .    .                  }
          .    .    .           .          .    .          .      .    .              }
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
        115    0    0           0          0    0          0      0    0      return true;
        920    1    1         805          2    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  bool SimpSolver::asymm(Var v, CRef cr)
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .      Clause& c = ca[cr];
          .    .    .           .          .    .          .      .    .      assert(decisionLevel() == 0);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      if (c.mark() || satisfied(c)) return true;
-- line 438 ----------------------------------------
-- line 478 ----------------------------------------
          .    .    .           .          .    .          .      .    .  static void mkElimClause(vec<uint32_t>& elimclauses, Lit x)
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .      elimclauses.push(toInt(x));
          .    .    .           .          .    .          .      .    .      elimclauses.push(1);
          .    .    .           .          .    .          .      .    .  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  static void mkElimClause(vec<uint32_t>& elimclauses, Var v, Clause& c)
        136    1    1           0          0    0        102      0    0  {
         17    0    0          17          0    0          0      0    0      int first = elimclauses.size();
         84    0    0          50          0    0          0      0    0      int v_pos = -1;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Copy clause to elimclauses-vector. Remember position where the
          .    .    .           .          .    .          .      .    .      // variable 'v' occurs:
        238    0    0          34          0    0          0      0    0      for (int i = 0; i < c.size(); i++){
        102    1    1          51          0    0          0      0    0          elimclauses.push(toInt(c[i]));
          .    .    .           .          .    .          .      .    .          if (var(c[i]) == v)
          .    .    .           .          .    .          .      .    .              v_pos = i + first;
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .      assert(v_pos != -1);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Swap the first literal with the 'v' literal, so that the literal
          .    .    .           .          .    .          .      .    .      // containing 'v' will occur first in the clause:
         17    0    0          17          0    0          0      0    0      uint32_t tmp = elimclauses[v_pos];
         34    0    0          17          0    0         17      0    0      elimclauses[v_pos] = elimclauses[first];
         17    0    0           0          0    0         17      0    0      elimclauses[first] = tmp;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Store the length of the clause last:
          .    .    .           .          .    .          .      .    .      elimclauses.push(c.size());
        136    0    0         119          0    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  bool SimpSolver::eliminateVar(Var v)
     49,750    1    1           0          0    0     29,850      0    0  {
          .    .    .           .          .    .          .      .    .      assert(!frozen[v]);
          .    .    .           .          .    .          .      .    .      assert(!isEliminated(v));
          .    .    .           .          .    .          .      .    .      assert(value(v) == l_Undef);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Split the occurrences into positive and negative:
          .    .    .           .          .    .          .      .    .      //
          .    .    .           .          .    .          .      .    .      const vec<CRef>& cls = occurs.lookup(v);
          .    .    .           .          .    .          .      .    .      vec<CRef>        pos, neg;
  1,909,777    1    1   1,269,868      2,886    0          0      0    0      for (int i = 0; i < cls.size(); i++)
    629,959    0    0           0          0    0          0      0    0          (find(ca[cls[i]], mkLit(v)) ? pos : neg).push(cls[i]);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Check wether the increase in number of clauses stays within the allowed ('grow'). Moreover, no
          .    .    .           .          .    .          .      .    .      // clause must exceed the limit on the maximal clause size (if it is set):
          .    .    .           .          .    .          .      .    .      //
      4,879    0    0           0          0    0      4,879      0    0      int cnt         = 0;
          .    .    .           .          .    .          .      .    .      int clause_size = 0;
          .    .    .           .          .    .          .      .    .  
    125,696    0    0      62,836          0    0          0      0    0      for (int i = 0; i < pos.size(); i++)
 43,950,845    0    0  11,096,469          0    0      9,758      0    0          for (int j = 0; j < neg.size(); j++)
  2,563,399    1    1   1,274,381          0    0     14,637      0    0              if (merge(ca[pos[i]], ca[neg[j]], v, clause_size) && 
  6,943,365    1    1   2,534,142          9    0          0      0    0                  (++cnt > cls.size() + grow || (clause_lim != -1 && clause_size > clause_lim)))
          .    .    .           .          .    .          .      .    .                  return true;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Delete and store old clauses:
        339    1    1         226          0    0        113      0    0      eliminated[v] = true;
          .    .    .           .          .    .          .      .    .      setDecisionVar(v, false);
        113    0    0         113          0    0          0      0    0      eliminated_vars++;
          .    .    .           .          .    .          .      .    .  
        565    1    1         226          0    0          0      0    0      if (pos.size() > neg.size()){
        121    0    0           2          0    0          0      0    0          for (int i = 0; i < neg.size(); i++)
         10    0    0           2          0    0          2      0    0              mkElimClause(elimclauses, v, ca[neg[i]]);
          .    .    .           .          .    .          .      .    .          mkElimClause(elimclauses, mkLit(v));
          .    .    .           .          .    .          .      .    .      }else{
        252    1    1          15          0    0          0      0    0          for (int i = 0; i < pos.size(); i++)
         75    0    0          15          0    0         15      0    0              mkElimClause(elimclauses, v, ca[pos[i]]);
          .    .    .           .          .    .          .      .    .          mkElimClause(elimclauses, ~mkLit(v));
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Produce clauses in cross product:
        113    1    1           0          0    0          0      0    0      vec<Lit>& resolvent = add_tmp;
        475    0    0         130          1    0          0      0    0      for (int i = 0; i < pos.size(); i++)
        782    0    0         170          0    0          0      0    0          for (int j = 0; j < neg.size(); j++)
      2,351    1    1         453          0    0        436      0    0              if (merge(ca[pos[i]], ca[neg[j]], v, resolvent) && !addClause_(resolvent))
          .    .    .           .          .    .          .      .    .                  return false;
          .    .    .           .          .    .          .      .    .  
      1,011    1    1         449          1    0          0      0    0      for (int i = 0; i < cls.size(); i++)
      1,338    0    0         669          1    0        223      0    0          removeClause(cls[i]); 
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Free occurs list for this variable:
          .    .    .           .          .    .          .      .    .      occurs[v].clear(true);
          .    .    .           .          .    .          .      .    .      
          .    .    .           .          .    .          .      .    .      // Free watchers lists for this variable, if possible:
          .    .    .           .          .    .          .      .    .      watches_bin[ mkLit(v)].clear(true);
          .    .    .           .          .    .          .      .    .      watches_bin[~mkLit(v)].clear(true);
          .    .    .           .          .    .          .      .    .      watches[ mkLit(v)].clear(true);
          .    .    .           .          .    .          .      .    .      watches[~mkLit(v)].clear(true);
          .    .    .           .          .    .          .      .    .  
        452    0    0           0          0    0        113      0    0      return backwardSubsumptionCheck();
     39,800    0    0      34,825        963    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  bool SimpSolver::substitute(Var v, Lit x)
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .      assert(!frozen[v]);
          .    .    .           .          .    .          .      .    .      assert(!isEliminated(v));
          .    .    .           .          .    .          .      .    .      assert(value(v) == l_Undef);
          .    .    .           .          .    .          .      .    .  
-- line 579 ----------------------------------------
-- line 603 ----------------------------------------
          .    .    .           .          .    .          .      .    .  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  void SimpSolver::extendModel()
          .    .    .           .          .    .          .      .    .  {
          .    .    .           .          .    .          .      .    .      int i, j;
          .    .    .           .          .    .          .      .    .      Lit x;
          .    .    .           .          .    .          .      .    .  
        524    1    1           1          1    1          0      0    0      for (i = elimclauses.size()-1; i > 0; i -= j){
      1,456    1    1         262         18   17          0      0    0          for (j = elimclauses[i--]; j > 1; j--, i--)
        136    0    0          17          2    2          0      0    0              if (modelValue(toLit(elimclauses[i])) != l_False)
          .    .    .           .          .    .          .      .    .                  goto next;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          x = toLit(elimclauses[i]);
        113    0    0           0          0    0        113     15    0          model[var(x)] = lbool(!sign(x));
          .    .    .           .          .    .          .      .    .      next:;
          .    .    .           .          .    .          .      .    .      }
          1    0    0           1          0    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  // Almost duplicate of Solver::removeSatisfied. Didn't want to make the base method 'virtual'.
          .    .    .           .          .    .          .      .    .  void SimpSolver::removeSatisfied()
     13,864    1    1           0          0    0          8      0    0  {
          .    .    .           .          .    .          .      .    .      int i, j;
    469,286    1    1           2          1    0          0      0    0      for (i = j = 0; i < clauses.size(); i++){
    469,280    0    0     234,640          0    0          0      0    0          const Clause& c = ca[clauses[i]];
    469,280    0    0     234,640     39,634    0          0      0    0          if (c.mark() == 0)
    917,928    0    0           0          0    0    229,482      0    0              if (satisfied(c))
    238,307    2    1     233,012          1    0      1,765      0    0                  removeClause(clauses[i]);
          .    .    .           .          .    .          .      .    .              else
  1,366,302    0    0     455,434          0    0    227,717  8,488    0                  clauses[j++] = clauses[i];
          .    .    .           .          .    .          .      .    .      }
          2    0    0           0          0    0          0      0    0      clauses.shrink(i - j);
         12    1    0          10          1    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  // The technique and code are by the courtesy of the GlueMiniSat team. Thank you!
          .    .    .           .          .    .          .      .    .  // It helps solving certain types of huge problems tremendously.
          .    .    .           .          .    .          .      .    .  bool SimpSolver::eliminate(bool turn_off_elim)
          8    1    1           0          0    0          6      0    0  {
          1    0    0           0          0    0          0      0    0      bool res = true;
          .    .    .           .          .    .          .      .    .      int iter = 0;
          .    .    .           .          .    .          .      .    .      int n_cls, n_cls_init, n_vars;
          .    .    .           .          .    .          .      .    .  
          3    0    0           1          0    0          0      0    0      if (nVars() == 0) goto cleanup; // User disabling preprocessing.
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Get an initial number of clauses (more accurately).
          5    2    2           1          0    0          1      0    0      if (trail.size() != 0) removeSatisfied();
          .    .    .           .          .    .          .      .    .      n_cls_init = nClauses();
          .    .    .           .          .    .          .      .    .  
          3    0    0           0          0    0          1      0    0      res = eliminate_(); // The first, usual variable elimination of MiniSat.
          2    0    0           0          0    0          0      0    0      if (!res) goto cleanup;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      n_cls  = nClauses();
          .    .    .           .          .    .          .      .    .      n_vars = nFreeVars();
          .    .    .           .          .    .          .      .    .  
          6    0    0           1          1    0          1      0    0      printf("c Reduced to %d vars, %d cls (grow=%d)\n", n_vars, n_cls, grow);
          .    .    .           .          .    .          .      .    .  
          7    1    1           1          0    0          0      0    0      if ((double)n_cls / n_vars >= 10 || n_vars < 10000){
          4    1    1           0          0    0          1      0    0          printf("c No iterative elimination performed. (vars=%d, c/v ratio=%.1f)\n", n_vars, (double)n_cls / n_vars);
          1    0    0           0          0    0          0      0    0          goto cleanup; }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      grow = grow ? grow * 2 : 8;
          .    .    .           .          .    .          .      .    .      for (; grow < 10000; grow *= 2){
          .    .    .           .          .    .          .      .    .          // Rebuild elimination variable heap.
          .    .    .           .          .    .          .      .    .          for (int i = 0; i < clauses.size(); i++){
          .    .    .           .          .    .          .      .    .              const Clause& c = ca[clauses[i]];
          .    .    .           .          .    .          .      .    .              for (int j = 0; j < c.size(); j++)
          .    .    .           .          .    .          .      .    .                  if (!elim_heap.inHeap(var(c[j])))
-- line 669 ----------------------------------------
-- line 691 ----------------------------------------
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .      printf("c No. effective iterative eliminations: %d\n", iter);
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  cleanup:
          .    .    .           .          .    .          .      .    .      touched  .clear(true);
          .    .    .           .          .    .          .      .    .      occurs   .clear(true);
          .    .    .           .          .    .          .      .    .      n_occ    .clear(true);
          .    .    .           .          .    .          .      .    .      elim_heap.clear(true);
          1    0    0           0          0    0          0      0    0      subsumption_queue.clear(true);
          .    .    .           .          .    .          .      .    .  
          1    0    0           0          0    0          1      0    0      use_simplification    = false;
          1    0    0           0          0    0          1      1    0      remove_satisfied      = true;
          1    0    0           0          0    0          1      1    0      ca.extra_clause_field = false;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Force full cleanup (this is safe and desirable since it only happens once):
          2    0    0           0          0    0          1      0    0      rebuildOrderHeap();
          3    0    0           2          2    0          1      0    0      garbageCollect();
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      return res;
        130    1    0           7          1    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  bool SimpSolver::eliminate_()
          8    1    1           0          0    0          6      0    0  {
          3    0    0           0          0    0          1      1    0      if (!simplify())
          .    .    .           .          .    .          .      .    .          return false;
          2    0    0           1          1    0          0      0    0      else if (!use_simplification)
          .    .    .           .          .    .          .      .    .          return true;
          .    .    .           .          .    .          .      .    .  
          3    0    0           1          0    0          1      1    0      int trail_size_last = trail.size();
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Main simplification loop:
          .    .    .           .          .    .          .      .    .      //
         19    2    2           6          2    0          2      0    0      while (n_touched > 0 || bwdsub_assigns < trail.size() || elim_heap.size() > 0){
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          gatherTouchedClauses();
          .    .    .           .          .    .          .      .    .          // printf("  ## (time = %6.2f s) BWD-SUB: queue = %d, trail = %d\n", cpuTime(), subsumption_queue.size(), trail.size() - bwdsub_assigns);
          8    0    0           0          0    0          0      0    0          if ((subsumption_queue.size() > 0 || bwdsub_assigns < trail.size()) && 
          6    1    1           0          0    0          2      0    0              !backwardSubsumptionCheck(true)){
          .    .    .           .          .    .          .      .    .              ok = false; goto cleanup; }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          // Empty elim_heap and return immediately on user-interrupt:
         10    0    0           4          0    0          2      2    0          if (asynch_interrupt){
          .    .    .           .          .    .          .      .    .              assert(bwdsub_assigns == trail.size());
          .    .    .           .          .    .          .      .    .              assert(subsumption_queue.size() == 0);
          .    .    .           .          .    .          .      .    .              assert(n_touched == 0);
          .    .    .           .          .    .          .      .    .              elim_heap.clear();
          .    .    .           .          .    .          .      .    .              goto cleanup; }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          // printf("  ## (time = %6.2f s) ELIM: vars = %d\n", cpuTime(), elim_heap.size());
     26,225    0    0      10,487      2,017    0      5,245      0    0          for (int cnt = 0; !elim_heap.empty(); cnt++){
          .    .    .           .          .    .          .      .    .              Var elim = elim_heap.removeMin();
          .    .    .           .          .    .          .      .    .              
     10,488    1    1       5,244          0    0          0      0    0              if (asynch_interrupt) break;
          .    .    .           .          .    .          .      .    .  
     20,976    0    0      10,488      5,291    0          0      0    0              if (isEliminated(elim) || value(elim) != l_Undef) continue;
          .    .    .           .          .    .          .      .    .  
      9,950    0    0       4,975        952    0          0      0    0              if (verbosity >= 2 && cnt % 100 == 0)
          .    .    .           .          .    .          .      .    .                  printf("c elimination left: %10d\r", elim_heap.size());
          .    .    .           .          .    .          .      .    .  
      9,950    1    1       4,975          1    0          0      0    0              if (use_asymm){
          .    .    .           .          .    .          .      .    .                  // Temporarily freeze variable. Otherwise, it would immediately end up on the queue again:
          .    .    .           .          .    .          .      .    .                  bool was_frozen = frozen[elim];
          .    .    .           .          .    .          .      .    .                  frozen[elim] = true;
          .    .    .           .          .    .          .      .    .                  if (!asymmVar(elim)){
          .    .    .           .          .    .          .      .    .                      ok = false; goto cleanup; }
          .    .    .           .          .    .          .      .    .                  frozen[elim] = was_frozen; }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .              // At this point, the variable may have been set by assymetric branching, so check it
          .    .    .           .          .    .          .      .    .              // again. Also, don't eliminate frozen variables:
     59,700    0    0      24,875      2,625    0      4,975      2    0              if (use_elim && value(elim) == l_Undef && !frozen[elim] && !eliminateVar(elim)){
          .    .    .           .          .    .          .      .    .                  ok = false; goto cleanup; }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .              checkGarbage(simp_garbage_frac);
          .    .    .           .          .    .          .      .    .          }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .          assert(subsumption_queue.size() == 0);
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .   cleanup:
          .    .    .           .          .    .          .      .    .      // To get an accurate number of clauses.
          2    1    1           1          0    0          0      0    0      if (trail_size_last != trail.size())
          2    0    0           0          0    0          1      0    0          removeSatisfied();
          .    .    .           .          .    .          .      .    .      else{
          .    .    .           .          .    .          .      .    .          int i,j;
          .    .    .           .          .    .          .      .    .          for (i = j = 0; i < clauses.size(); i++)
          .    .    .           .          .    .          .      .    .              if (ca[clauses[i]].mark() == 0)
          .    .    .           .          .    .          .      .    .                  clauses[j++] = clauses[i];
          .    .    .           .          .    .          .      .    .          clauses.shrink(i - j);
          .    .    .           .          .    .          .      .    .      }
          .    .    .           .          .    .          .      .    .      checkGarbage();
          .    .    .           .          .    .          .      .    .  
          6    1    1           2          2    0          0      0    0      if (verbosity >= 1 && elimclauses.size() > 0)
          4    0    0           1          1    0          1      0    0          printf("c |  Eliminated clauses:     %10.2f Mb                                      |\n", 
          3    0    0           0          0    0          0      0    0                 double(elimclauses.size() * sizeof(uint32_t)) / (1024*1024));
          .    .    .           .          .    .          .      .    .  
          1    0    0           1          0    0          0      0    0      return ok;
          8    0    0           7          2    0          0      0    0  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  //=================================================================================================
          .    .    .           .          .    .          .      .    .  // Garbage Collection methods:
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  void SimpSolver::relocAll(ClauseAllocator& to)
          .    .    .           .          .    .          .      .    .  {
        172   85   85          86         86   85          0      0    0      if (!use_simplification) return;
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // All occurs lists:
          .    .    .           .          .    .          .      .    .      //
          .    .    .           .          .    .          .      .    .      occurs.cleanAll();
          .    .    .           .          .    .          .      .    .      for (int i = 0; i < nVars(); i++){
          .    .    .           .          .    .          .      .    .          vec<CRef>& cs = occurs[i];
          .    .    .           .          .    .          .      .    .          for (int j = 0; j < cs.size(); j++)
          .    .    .           .          .    .          .      .    .              ca.reloc(cs[j], to);
-- line 804 ----------------------------------------
-- line 811 ----------------------------------------
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .      // Temporary clause:
          .    .    .           .          .    .          .      .    .      //
          .    .    .           .          .    .          .      .    .      ca.reloc(bwdsub_tmpunit, to);
          .    .    .           .          .    .          .      .    .  }
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  
          .    .    .           .          .    .          .      .    .  void SimpSolver::garbageCollect()
        258   86   86           0          0    0         86      0    0  {
          .    .    .           .          .    .          .      .    .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
          .    .    .           .          .    .          .      .    .      // is not precise but should avoid some unnecessary reallocations for the new region:
        172    0    0         172          1    0          0      0    0      ClauseAllocator to(ca.size() - ca.wasted()); 
          .    .    .           .          .    .          .      .    .  
        172    0    0          86          0    0         86      0    0      to.extra_clause_field = ca.extra_clause_field; // NOTE: this is important to keep (or lose) the extra fields.
          .    .    .           .          .    .          .      .    .      relocAll(to);
        258    0    0           0          0    0         86      0    0      Solver::relocAll(to);
        172    0    0          86         86   21          0      0    0      if (verbosity >= 2)
          .    .    .           .          .    .          .      .    .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n", 
          .    .    .           .          .    .          .      .    .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
          .    .    .           .          .    .          .      .    .      to.moveTo(ca);
        315   92   90         190          2    2         24      0    0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr             D1mr          DLmr   Dw             D1mw          DLmw      

-- line 40 ----------------------------------------
             .      .    .              .             .      .              .             .         .      int sz;
             .      .    .              .             .      .              .             .         .      int cap;
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .      // Don't allow copying (error prone):
             .      .    .              .             .      .              .             .         .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
             .      .    .              .             .      .              .             .         .               vec        (vec<T>& other) { assert(0); }
             .      .    .              .             .      .              .             .         .               
             .      .    .              .             .      .              .             .         .      // Helpers for calculating next capacity:
     2,835,374      8    6              0             0      0              0             0         0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
             .      .    .              .             .      .              .             .         .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .      .    .              .             .      .              .             .         .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  public:
             .      .    .              .             .      .              .             .         .      // Constructors:
       378,528     26   24              2             0      0        352,304         7,053     4,579      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
            58      0    0              0             0      0             58             0         0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
             .      .    .              .             .      .              .             .         .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
             .      .    .              .             .      .              .             .         .     ~vec()                                                          { clear(true); }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .      // Pointer to first element:
             .      .    .              .             .      .              .             .         .      operator T*       (void)           { return data; }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .      // Size operations:
             .      .    .              .             .      .              .             .         .      int      size     (void) const     { return sz; }
 1,774,141,229    311   58     41,676,798       198,854      0     73,868,773             8         0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
             .      .    .              .             .      .              .             .         .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
             .      .    .              .             .      .              .             .         .      int      capacity (void) const     { return cap; }
             .      .    .              .             .      .              .             .         .      void     capacity (int min_cap);
             .      .    .              .             .      .              .             .         .      void     growTo   (int size);
             .      .    .              .             .      .              .             .         .      void     growTo   (int size, const T& pad);
             .      .    .              .             .      .              .             .         .      void     clear    (bool dealloc = false);
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .      // Stack interface:
     5,242,679  2,217   24      2,615,961         2,050      0      1,307,193           109         0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
59,718,370,012 37,401  665 22,638,048,782 2,311,340,976 80,529 16,185,083,459 2,760,465,254 5,777,728      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
 3,133,630,720      0    0    789,880,514         2,157      0  1,558,942,832    50,289,642    10,404      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
   684,288,249     18    3      7,487,718             0      0    338,576,225             0         0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
             .      .    .              .             .      .              .             .         .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
             .      .    .              .             .      .              .             .         .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
             .      .    .              .             .      .              .             .         .      // happen given the way capacities are calculated (below). Essentially, all capacities are
             .      .    .              .             .      .              .             .         .      // even, but INT_MAX is odd.
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .      const T& last  (void) const        { return data[sz-1]; }
   330,624,042      0    0              0             0      0              0             0         0      T&       last  (void)              { return data[sz-1]; }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .      // Vector interface:
42,499,098,231  2,581  166    516,285,619            15      0      8,237,547             4         0      const T& operator [] (int index) const { return data[index]; }
35,032,721,700    589  424  9,627,158,426     6,682,120    666    843,059,361       371,417         0      T&       operator [] (int index)       { return data[index]; }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .      // Duplicatation (preferred instead):
 1,145,053,332     28   26    382,546,468     4,789,501      0    189,333,680             0         0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
       299,498      1    0        299,414             9      0             56             0         0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
             .      .    .              .             .      .              .             .         .  };
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  template<class T>
       708,732      0    0              0             0      0        354,366             0         0  void vec<T>::capacity(int min_cap) {
     5,177,658     41   18      1,725,886             7      0              0             0         0      if (cap >= min_cap) return;
     2,481,007     10    6              0             0      0              2             0         0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     4,607,433     81   23        354,445            18      0      1,063,273         1,285         0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
             .      .    .              .             .      .              .             .         .          throw OutOfMemoryException();
     2,059,276      2    2      2,059,276             3      0              0             0         0   }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  template<class T>
             .      .    .              .             .      .              .             .         .  void vec<T>::growTo(int size, const T& pad) {
    22,555,923      6    6      7,513,397           205      0              0             0         0      if (sz >= size) return;
       104,880      4    4         10,488             0      0         47,196             0         0      capacity(size);
       592,574      7    7         94,393             1      0         47,197           635         0      for (int i = sz; i < size; i++) data[i] = pad;
    10,995,156      7    6         11,590             0      0         47,196             0         0      sz = size; }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  template<class T>
       104,880      1    1              0             0      0         41,952             0         0  void vec<T>::growTo(int size) {
     2,711,991      1    1         36,711            70      0         20,976             0         0      if (sz >= size) return;
     5,182,724    584   74              0             0      0      2,591,348             0         0      capacity(size);
    18,522,424     36   16      5,224,648             0      0      2,586,103             0         0      for (int i = sz; i < size; i++) new (&data[i]) T();
     3,989,351      0    0      1,356,049            19      0      1,319,288             8         0      sz = size; }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  template<class T>
             .      .    .              .             .      .              .             .         .  void vec<T>::clear(bool dealloc) {
   553,789,829 62,101  323    177,263,017     1,381,750     22          4,879             0         0      if (data != NULL){
        10,493      0    0              1             0      0              0             0         0          for (int i = 0; i < sz; i++) data[i].~T();
 1,208,140,899      8    4     10,394,352             0      0    189,529,050           101         0          sz = 0;
       100,685      5    5         25,011             0      0         70,541            11         0          if (dealloc) free(data), data = NULL, cap = 0; } }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  //=================================================================================================
             .      .    .              .             .      .              .             .         .  }
             .      .    .              .             .      .              .             .         .  
             .      .    .              .             .      .              .             .         .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr            D1mr        DLmr   Dw            D1mw       DLmw  

-- line 31 ----------------------------------------
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  template<class Comp>
             .     .    .             .           .      .             .          .     .  class Heap {
             .     .    .             .           .      .             .          .     .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
             .     .    .             .           .      .             .          .     .      vec<int> heap;     // Heap of integers
             .     .    .             .           .      .             .          .     .      vec<int> indices;  // Each integers position (index) in the Heap
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .      // Index "traversal" functions
   699,848,406     5    3             0           0      0             0          0     0      static inline int left  (int i) { return i*2+1; }
 1,961,709,963    14    9   784,316,089 553,666,379 18,817             0          0     0      static inline int right (int i) { return (i+1)*2; }
   714,523,414    11    7    61,035,757           0      0             0          0     0      static inline int parent(int i) { return (i-1) >> 1; }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
   122,071,514    12    9             0           0      0   122,071,514      8,524     0      void percolateUp(int i)
             .     .    .             .           .      .             .          .     .      {
   543,822,221     0    0   306,253,765  59,641,834 12,837   176,532,699          0     0          int x  = heap[i];
             .     .    .             .           .      .             .          .     .          int p  = parent(i);
             .     .    .             .           .      .             .          .     .          
 2,368,346,002    32   13   862,750,908 251,981,789 21,121    39,204,003          0     0          while (i != 0 && lt(x, heap[p])){
   169,863,955    38   20             0           0      0   169,863,955          0     0              heap[i]          = heap[p];
   169,863,955     0    0             0           0      0   169,863,955 85,527,224 3,072              indices[heap[p]] = i;
             .     .    .             .           .      .             .          .     .              i                = p;
   169,747,586     0    0             0           0      0             0          0     0              p                = parent(p);
             .     .    .             .           .      .             .          .     .          }
   245,218,008    11    4    88,339,671           0      0   156,878,337          0     0          heap   [i] = x;
   252,973,666     2    2    88,244,362           0      0   156,904,004          0     0          indices[x] = i;
   259,418,597     0    0   183,107,271           0      0             0          0     0      }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
 3,982,202,392     0    0   568,886,056           0      0 3,413,316,336    133,800     0      void percolateDown(int i)
             .     .    .             .           .      .             .          .     .      {
 1,728,247,210 3,220   62 1,148,275,207 458,280,536  4,878   579,928,083          0     0          int x = heap[i];
 2,555,045,536 5,904   51   693,111,210         141      0             0          0     0          while (left(i) < heap.size()){
 2,624,370,146     5    3   391,170,030  32,574,277    813             0          0     0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
 1,093,793,748    18    8             0           0      0             0          0     0              if (!lt(heap[child], x)) break;
   121,147,891     0    0             0           0      0   121,147,891          0     0              heap[i]          = heap[child];
   121,181,266     0    0        33,375           0      0   121,147,891 58,861,642 4,463              indices[heap[i]] = i;
    87,319,289     0    0             0           0      0             0          0     0              i                = child;
             .     .    .             .           .      .             .          .     .          }
 1,157,346,074    23   13   578,733,525           0      0   578,612,549          0     0          heap   [i] = x;
   596,360,446     2    0     8,841,926           0      0   578,612,549      2,759     0          indices[x] = i;
 3,989,683,488     0    0 3,982,202,392           0      0             0          0     0      }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .    public:
             .     .    .             .           .      .             .          .     .      Heap(const Comp& c) : lt(c) { }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .      int  size      ()          const { return heap.size(); }
     7,487,719     1    1     7,487,719     917,668     70             0          0     0      bool empty     ()          const { return heap.size() == 0; }
11,007,510,942 4,140   72 5,699,977,926 644,833,015 22,775             0          0     0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
     8,791,532    11    9     5,437,150     572,508     27             0          0     0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
   303,068,570     0    0   212,570,042         219      0    61,035,757        151     0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
 3,021,985,687     7    7 1,884,213,574           0      0   568,886,056          0     0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .      // Safe variant of insert/decrease/increase:
             .     .    .             .           .      .             .          .     .      void update(int n)
             .     .    .             .           .      .             .          .     .      {
             .     .    .             .           .      .             .          .     .          if (!inHeap(n))
             .     .    .             .           .      .             .          .     .              insert(n);
             .     .    .             .           .      .             .          .     .          else {
             .     .    .             .           .      .             .          .     .              percolateUp(indices[n]);
       293,286     0    0       146,643           0      0             0          0     0              percolateDown(indices[n]); }
             .     .    .             .           .      .             .          .     .      }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .      void insert(int n)
             .     .    .             .           .      .             .          .     .      {
     7,502,909     2    2             0           0      0             0          0     0          indices.growTo(n+1, -1);
             .     .    .             .           .      .             .          .     .          assert(!inHeap(n));
             .     .    .             .           .      .             .          .     .  
    15,005,818     1    1     7,502,909           0      0     7,502,909          0     0          indices[n] = heap.size();
        20,845     1    1             0           0      0        13,846          0     0          heap.push(n);
    15,005,818     0    0     7,502,909           5      0             0          0     0          percolateUp(indices[n]); 
             .     .    .             .           .      .             .          .     .      }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .      int  removeMin()
             .     .    .             .           .      .             .          .     .      {
    22,463,154     1    1    14,975,436     807,408     50     7,487,718        126     0          int x            = heap[0];
    14,975,436     0    0     7,487,718   1,480,689    114     7,487,718          0     0          heap[0]          = heap.last();
    14,975,436    26   20     7,487,718           0      0     7,487,718  5,503,991   518          indices[heap[0]] = 0;
     7,487,718     1    1             0           0      0     7,487,718  1,269,821    72          indices[x]       = -1;
             .     .    .             .           .      .             .          .     .          heap.pop();
    14,975,436     0    0             0           0      0             0          0     0          if (heap.size() > 1) percolateDown(0);
             .     .    .             .           .      .             .          .     .          return x; 
             .     .    .             .           .      .             .          .     .      }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .      // Rebuild the heap from scratch, using the elements in 'ns':
             .     .    .             .           .      .             .          .     .      void build(const vec<int>& ns) {
       176,992    14    5        88,496          12      0             0          0     0          for (int i = 0; i < heap.size(); i++)
        88,514     6    2            18           0      0        88,460      5,895   652              indices[heap[i]] = -1;
            18     0    0             0           0      0             0          0     0          heap.clear();
             .     .    .             .           .      .             .          .     .  
       175,776     6    2        87,861          18      0             0          0     0          for (int i = 0; i < ns.size(); i++){
       175,686     0    0        87,843           0      0        87,843      4,558     0              indices[ns[i]] = i;
             .     .    .             .           .      .             .          .     .              heap.push(ns[i]); }
             .     .    .             .           .      .             .          .     .  
       307,626    18    6        43,938           0      0            18          0     0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
             .     .    .             .           .      .             .          .     .              percolateDown(i);
             .     .    .             .           .      .             .          .     .      }
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .      void clear(bool dealloc = false) 
             .     .    .             .           .      .             .          .     .      { 
             4     0    0             2           1      0             0          0     0          for (int i = 0; i < heap.size(); i++)
             .     .    .             .           .      .             .          .     .              indices[heap[i]] = -1;
             .     .    .             .           .      .             .          .     .          heap.clear(dealloc); 
             .     .    .             .           .      .             .          .     .      }
             .     .    .             .           .      .             .          .     .  };
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  
             .     .    .             .           .      .             .          .     .  //=================================================================================================
             .     .    .             .           .      .             .          .     .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr        DLmr   Dw          D1mw    DLmw 

-- line 77 ----------------------------------------
             .     .    .              .           .      .           .       .    .  private:
             .     .    .              .           .      .           .       .    .      template<typename T>
             .     .    .              .           .      .           .       .    .      class MyQueue {
             .     .    .              .           .      .           .       .    .          int max_sz, q_sz;
             .     .    .              .           .      .           .       .    .          int ptr;
             .     .    .              .           .      .           .       .    .          int64_t sum;
             .     .    .              .           .      .           .       .    .          vec<T> q;
             .     .    .              .           .      .           .       .    .      public:
             4     1    1              0           0      0           3       0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .     .    .              .           .      .           .       .    .          inline bool   full () const { return q_sz == max_sz; }
             .     .    .              .           .      .           .       .    .  #ifdef INT_QUEUE_AVG
       863,508    57   10        215,877           0      0           0       0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .     .    .              .           .      .           .       .    .  #else
             .     .    .              .           .      .           .       .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .     .    .              .           .      .           .       .    .  #endif
        14,136    21   15              0           0      0      14,136   1,038    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .     .    .              .           .      .           .       .    .          void push(T e) {
     4,820,680     0    0      2,119,590           0      0     290,750       0    0              if (q_sz < max_sz) q_sz++;
     1,247,340     9    6        415,780     414,456    135           0       0    0              else sum -= q[ptr];
     2,119,590    28   19              0           0      0     706,530       0    0              sum += e;
     2,119,590     0    0              0           0      0   1,413,060 289,034   86              q[ptr++] = e;
     2,132,305     0    0      1,413,060           0      0      12,715       0    0              if (ptr == max_sz) ptr = 0;
             .     .    .              .           .      .           .       .    .          }
             .     .    .              .           .      .           .       .    .      };
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  public:
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      // Constructor/Destructor:
             .     .    .              .           .      .           .       .    .      //
             .     .    .              .           .      .           .       .    .      Solver();
             .     .    .              .           .      .           .       .    .      virtual ~Solver();
            10     2    2              0           0      0           4       0    0      void print_size(std::ostream &os)
             .     .    .              .           .      .           .       .    .      {
             4     2    2              0           0      0           4       1    0          program_end_time=std::chrono::steady_clock::now();
             2     0    0              0           0      0           2       0    0          total_work_time=program_end_time-program_start_time;
             4     0    0              2           1      0           0       0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2     0    0              2           1      0           0       0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4     0    0              2           1      0           0       0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .     .    .              .           .      .           .       .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .     .    .              .           .      .           .       .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2     0    0              2           2      0           0       0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2     0    0              2           0      0           0       0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2     0    0              2           0      0           0       0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4     0    0              2           2      0           0       0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4     0    0              2           0      0           0       0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4     0    0              2           2      0           0       0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_Watchers: " << total_Watchers << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_indexs: " << total_indexs << "\n";
             .     .    .              .           .      .           .       .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .     .    .              .           .      .           .       .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .     .    .              .           .      .           .       .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .     .    .              .           .      .           .       .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6     0    0              4           0      0           0       0    0      }
             .     .    .              .           .      .           .       .    .      using ull=unsigned long long;
             .     .    .              .           .      .           .       .    .      ull total_Watchers = 0;
             .     .    .              .           .      .           .       .    .      ull total_act_watchers = 0;
             .     .    .              .           .      .           .       .    .      ull total_indexs = 0;
             .     .    .              .           .      .           .       .    .      ull time_find_conflict = 0;
             .     .    .              .           .      .           .       .    .      ull total_find_conflict_length = 0;
             .     .    .              .           .      .           .       .    .      ull total_find_conflict_allsize = 0;
             .     .    .              .           .      .           .       .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .              .           .      .           .       .    .      {
             .     .    .              .           .      .           .       .    .          const ClauseAllocator& ca;
             .     .    .              .           .      .           .       .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .     .    .              .           .      .           .       .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .     .    .              .           .      .           .       .    .      };
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      struct VarOrderLt {
             .     .    .              .           .      .           .       .    .          const vec<double>&  activity;
 2,497,745,994 1,166   51  1,695,923,295 307,939,632 13,751  87,733,827       0    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .     .    .              .           .      .           .       .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .     .    .              .           .      .           .       .    .      };
             .     .    .              .           .      .           .       .    .      
             .     .    .              .           .      .           .       .    .      struct ConflictData
             .     .    .              .           .      .           .       .    .  	{
             .     .    .              .           .      .           .       .    .  		ConflictData() :
             .     .    .              .           .      .           .       .    .  			nHighestLevel(-1),
             .     .    .              .           .      .           .       .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .     .    .              .           .      .           .       .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .     .    .              .           .      .           .       .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .     .    .              .           .      .           .       .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .     .    .              .           .      .           .       .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .     .    .              .           .      .           .       .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .     .    .              .           .      .           .       .    .      std::chrono::nanoseconds total_duration;
             .     .    .              .           .      .           .       .    .      CRef     propagate(){
             .     .    .              .           .      .           .       .    .  
     8,884,054 7,701  136              0           0      0   4,442,027       1    0          auto start_time=std::chrono::steady_clock::now();
    13,326,081     0    0              0           0      0   4,442,027       0    0          auto ref= propagate_();
     4,442,027     1    1              0           0      0   4,442,027       0    0          auto end_time=std::chrono::steady_clock::now();
             .     .    .              .           .      .           .       .    .          auto duration=end_time-start_time;
             .     .    .              .           .      .           .       .    .          total_duration+=duration;
             .     .    .              .           .      .           .       .    .          return ref;
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .     .    .              .           .      .           .       .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .     .    .              .           .      .           .       .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .     .    .              .           .      .           .       .    .      
             .     .    .              .           .      .           .       .    .  public:
             .     .    .              .           .      .           .       .    .      int      level            (Var x) const;
             .     .    .              .           .      .           .       .    .  protected:
             .     .    .              .           .      .           .       .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .     .    .              .           .      .           .       .    .      bool     withinBudget     ()      const;
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      template<class V> int computeLBD(const V& c) {
   172,851,300    34   29              0           0      0           0       0    0          int lbd = 0;
             .     .    .              .           .      .           .       .    .  
    11,093,004    36   32      9,799,968   2,396,072     93           0       0    0          counter++;
   837,977,372     0    0      1,322,836           0      0           0       0    0          for (int i = 0; i < c.size(); i++){
             .     .    .              .           .      .           .       .    .              int l = level(var(c[i]));
 2,027,762,611     0    0    811,105,042  18,647,211  1,148           0       0    0              if (l != 0 && seen2[l] != counter){
   132,668,221     0    0              0           0      0 132,668,221       0    0                  seen2[l] = counter;
   279,703,913     0    0              0           0      0           0       0    0                  lbd++; } }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .          return lbd;
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  #ifdef BIN_DRUP
             .     .    .              .           .      .           .       .    .      static int buf_len;
             .     .    .              .           .      .           .       .    .      static unsigned char drup_buf[];
             .     .    .              .           .      .           .       .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      template<class V>
             .     .    .              .           .      .           .       .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .     .    .              .           .      .           .       .    .          assert(op == 'a' || op == 'd');
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = op; buf_len++;
             .     .    .              .           .      .           .       .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = 0; buf_len++;
        81,154    34   30              0           0      0      81,154       0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .     .    .              .           .      .           .       .    .      }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = 'a'; buf_len++;
             .     .    .              .           .      .           .       .    .          for (int i = 0; i < c.size(); i++)
             .     .    .              .           .      .           .       .    .              if (c[i] != l) byteDRUP(c[i]);
             .     .    .              .           .      .           .       .    .          *buf_ptr++ = 0; buf_len++;
             .     .    .              .           .      .           .       .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .     .    .              .           .      .           .       .    .      double    my_var_decay;
             .     .    .              .           .      .           .       .    .      bool   DISTANCE;
             .     .    .              .           .      .           .       .    .  };
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  //=================================================================================================
             .     .    .              .           .      .           .       .    .  // Implementation of inline methods:
             .     .    .              .           .      .           .       .    .  
   473,433,149     0    0    473,433,149   8,252,236 22,322           0       0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
 4,138,201,618    48   35  3,488,323,008 675,024,413  3,890 642,502,352       0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::insertVarOrder(Var x) {
             .     .    .              .           .      .           .       .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
 4,855,789,962 1,463   67  1,499,998,811   1,009,853      0           0       0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    22,445,799     1    1     14,963,866   4,914,671  5,510           0       0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::varDecayActivity() {
     2,826,120     0    0      1,413,060     501,663     31     706,530       0    0      var_inc *= (1 / var_decay); }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::varBumpActivity(Var v, double mult) {
 1,010,324,096    10    8    597,560,008  80,648,767 15,369 149,066,743       0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .     .    .              .           .      .           .       .    .          // Rescale:
         1,862    84   66              1           0      0           0       0    0          for (int i = 0; i < nVars(); i++)
     1,950,768     0    0        487,692     117,803    799     487,692       0    0              activity_VSIDS[i] *= 1e-100;
           372     0    0            186         186      0         186       0    0          var_inc *= 1e-100; }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .      // Update order_heap with respect to new activity:
    63,145,972     0    0              0           0      0           0       0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .     .    .              .           .      .           .       .    .  
     5,172,144 1,097   18      2,586,072       1,999      0   1,293,036       0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .     .    .              .           .      .           .       .    .  inline void Solver::claBumpActivity (Clause& c) {
    49,836,282 1,886  179     14,924,529   2,126,118    187   4,996,806     194   12      if ( (c.activity() += cla_inc) > 1e20 ) {
             .     .    .              .           .      .           .       .    .          // Rescale:
     1,753,892    28   28             84           0      0           0       0    0          for (int i = 0; i < learnts_local.size(); i++)
     4,091,892     2    0        584,556     557,748 29,366     584,556       0    0              ca[learnts_local[i]].activity() *= 1e-20;
       131,862    89   72         65,889           0      0          28      28    0          cla_inc *= 1e-20; } }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .     .    .              .           .      .           .       .    .  inline void Solver::checkGarbage(double gf){
        45,909    52    0         15,303         166      0           0       0    0      if (ca.wasted() > ca.size() * gf)
           340     0    0            170         170     84           0       0    0          garbageCollect(); }
             .     .    .              .           .      .           .       .    .  
             .     .    .              .           .      .           .       .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
            25     0    0              0           0      0           5       0    0  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .     .    .              .           .      .           .       .    .  inline bool     Solver::locked          (const Clause& c) const {
    15,814,535    86   83      5,610,774     137,638      0           0       0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    17,607,565   132  122      4,130,997     196,954      0           0       0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .     .    .              .           .      .           .       .    .  }
     6,268,658     1    1      3,134,322           0      0           0       0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .     .    .              .           .      .           .       .    .  
     1,084,829     2    2        550,896           5      0     533,933       0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
 1,519,384,953   630   92    188,040,644  33,267,876      0           0       0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
     7,523,621     2    2      7,523,605       2,433     36           0       0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
16,683,936,187    38   32 16,683,936,187         168      0           0       0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .     .    .              .           .      .           .       .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .     .    .              .           .      .           .       .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .     .    .              .           .      .           .       .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3     0    0              2           0      0           1       1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .     .    .              .           .      .           .       .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
       984,919     2    1          5,623         192      0           0       0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6     1    1              3           2      0           0       0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .     .    .              .           .      .           .       .    .  { 
        31,464     0    0         15,732          33      0           0       0    0      if      ( b && !decision[v]) dec_vars++;
           339     0    0            226          26      0           0       0    0      else if (!b &&  decision[v]) dec_vars--;
             .     .    .              .           .      .           .       .    .  
         5,357     0    0              0           0      0       5,357       0    0      decision[v] = b;
             .     .    .              .           .      .           .       .    .      if (b && !order_heap_CHB.inHeap(v)){
             .     .    .              .           .      .           .       .    .          order_heap_CHB.insert(v);
             .     .    .              .           .      .           .       .    .          order_heap_VSIDS.insert(v);
             .     .    .              .           .      .           .       .    .          order_heap_distance.insert(v);}
             .     .    .              .           .      .           .       .    .  }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .     .    .              .           .      .           .       .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .     .    .              .           .      .           .       .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
Ir                I1mr    ILmr   Dr              D1mr           DLmr       Dw              D1mw          DLmw       
--------------------------------------------------------------------------------
1,057,748,666,057 336,303 12,892 329,995,136,060 21,040,297,450 13,952,257 121,452,375,738 5,244,972,187 23,916,238  events annotated

