--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/ASG_96_len112_known_last12_2.cnf
Data file:        ASG_96_len112_known_last12_2.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr      ILmr  Dr              D1mr           DLmr      Dw              D1mw           DLmw      
--------------------------------------------------------------------------------
2,752,180,579,284 1,515,227 7,433 945,991,332,080 61,578,898,373 1,978,693 343,625,897,364 15,276,495,705 2,596,893  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                I1mr    ILmr Dr              D1mr           DLmr    Dw              D1mw          DLmw     file:function
--------------------------------------------------------------------------------
1,315,884,200,071   2,920   58 521,571,205,228 31,724,946,318   6,286 152,491,456,909     6,075,502       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
  499,865,471,378      11    6  72,068,618,085  3,685,788,907   1,565  75,400,469,913             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
  235,509,681,968  48,352    8  47,323,105,546  4,285,942,224      33  29,479,051,197 5,276,263,676 355,742  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
   84,680,011,619   8,991   41  33,137,643,534  6,686,310,370       2   9,893,872,851 1,990,083,382       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
   83,117,372,510      16    8  35,367,176,970  1,374,049,696     403  25,252,502,095 6,190,956,260   6,051  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   66,751,071,591       3    2  63,846,983,308  1,636,765,920       0   2,903,750,873             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
   53,411,877,226  21,460  114  20,400,849,313  1,634,665,616       3   2,792,269,789    60,498,310       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   49,337,581,959   5,492   25  19,408,297,372  2,692,872,470      17  12,240,056,125    83,066,986       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
   41,456,236,044     497   16  21,772,179,529  1,876,816,228     685   1,540,777,379    16,542,766       2  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   30,399,497,054       0    0  15,199,748,527         31,519       0               0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
   23,047,047,302   3,237   63   3,524,261,711      7,192,388       0   2,109,021,290    38,814,284   3,740  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   22,581,347,887     202    7   9,009,476,337     16,498,199     163               0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   18,559,276,856     616   46   3,784,716,107    583,367,262      71      96,045,428     2,140,340       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   18,310,730,640      12    7   6,164,134,370      4,730,406       0   5,982,461,900   188,019,382     258  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   18,275,744,952 262,913  228   3,979,409,216     57,945,628      97   1,817,163,670    12,135,792       0  ???:__ieee754_pow_fma
   17,947,579,116       0    0  11,965,020,373    187,816,366       0   2,991,230,815   914,228,563     165  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   16,047,245,770     422  102   4,171,233,624    622,481,770  87,181   1,620,789,831     8,830,158   1,095  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
   13,612,649,045   1,839   13   4,406,141,314        745,095       0      37,439,965     4,005,172       1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   13,511,260,941      23   13   4,584,402,494    734,996,653      46   2,550,277,604   143,125,880      36  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
   13,277,503,641   7,507   27   4,393,284,884     82,738,567       2   1,678,920,510     2,691,233       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   12,718,359,825   1,539   60   5,844,840,368    812,814,952   1,147   1,883,893,431    55,439,174      69  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   11,964,923,800       0    0   2,991,230,950              0       0   2,991,230,950        24,628       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   10,676,210,137     108   31   2,757,007,560    119,501,224  21,242               0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
   10,280,541,992     615   48   5,774,879,066    570,498,144   1,136   1,123,591,364            70       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
    9,078,183,782 216,316   15   2,137,095,350              0       0   1,592,489,338     8,580,005      74  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
    7,709,948,838      51   13   1,920,263,392     95,841,026   1,822   1,433,030,765   158,147,327  71,278  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
    6,147,136,616       0    0   4,067,484,860    871,074,871       7               0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
    5,199,488,202   4,704  125   1,247,350,042     57,001,956   1,066     138,776,804        20,680       0  ???:__exp1_fma
    4,846,069,262       0    0               0              0       0               0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
    4,795,597,819     179    4   1,533,972,454    365,228,032       0               0             0       0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
    3,290,955,776   3,385   22     913,140,769         13,621       8     547,721,073            19       0  ???:pow

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr      DLmr   Dw         D1mw DLmw 

-- line 40 ----------------------------------------
             .     .    .              .         .      .          .    .    .      void capacity(uint32_t min_cap);
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .   public:
             .     .    .              .         .      .          .    .    .      // TODO: make this a class for better type-checking?
             .     .    .              .         .      .          .    .    .      typedef uint32_t Ref;
             .     .    .              .         .      .          .    .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .              .         .      .          .    .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .              .         .      .          .    .    .  
           961     1    1              0         0      0        768  189    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .              .         .      .          .    .    .      ~RegionAllocator()
             .     .    .              .         .      .          .    .    .      {
             .     .    .              .         .      .          .    .    .          if (memory != NULL)
             .     .    .              .         .      .          .    .    .              ::free(memory);
             .     .    .              .         .      .          .    .    .      }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .      uint32_t size      () const      { return sz; }
             .     .    .              .         .      .          .    .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .      Ref      alloc     (int size); 
     8,405,344     0    0      2,801,781         0      0  2,801,781    0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
33,262,870,291   555   34 16,463,798,083 6,226,859 11,515    149,644    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    22,258,037     0    0     22,258,037 2,969,638      2          0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .              .         .      .          .    .    .  
    56,853,191 6,362    8      2,899,311         0      0          0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     4,826,393     0    0              0         0      0          0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .              .         .      .          .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .              .         .      .          .    .    .          return  (Ref)(t - &memory[0]); }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .      void     moveTo(RegionAllocator& to) {
           764     0    0            191         0      0        191    0    0          if (to.memory != NULL) ::free(to.memory);
           382     0    0            191         0      0        191    0    0          to.memory = memory;
           382     0    0            191         0      0        191    0    0          to.sz = sz;
             .     .    .              .         .      .          .    .    .          to.cap = cap;
           382     0    0            191         0      0        191    0    0          to.wasted_ = wasted_;
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .          memory = NULL;
             .     .    .              .         .      .          .    .    .          sz = cap = wasted_ = 0;
             .     .    .              .         .      .          .    .    .      }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  };
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  template<class T>
         1,680    79   10              0         0      0        560    0    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .              .         .      .          .    .    .  {
    54,003,852     1    0     18,001,284         0      0          0    0    0      if (cap >= min_cap) return;
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .      uint32_t prev_cap = cap;
        11,026     0    0              0         0      0        280    0    0      while (cap < min_cap){
             .     .    .              .         .      .          .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .              .         .      .          .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .              .         .      .          .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .              .         .      .          .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        32,238     0    0              0         0      0          0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         5,373     0    0              0         0      0          0    0    0          cap += delta;
             .     .    .              .         .      .          .    .    .  
        10,746     0    0              0         0      0          0    0    0          if (cap <= prev_cap)
             .     .    .              .         .      .          .    .    .              throw OutOfMemoryException();
             .     .    .              .         .      .          .    .    .      }
             .     .    .              .         .      .          .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .      assert(cap > 0);
           560     2    1              0         0      0        280   84    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
         1,120     0    0            840         0      0          0    0    0  }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  template<class T>
             .     .    .              .         .      .          .    .    .  typename RegionAllocator<T>::Ref
       197,580     2    1              0         0      0    148,185    0    0  RegionAllocator<T>::alloc(int size)
             .     .    .              .         .      .          .    .    .  { 
             .     .    .              .         .      .          .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .              .         .      .          .    .    .      assert(size > 0);
    99,259,224     0    0     18,001,092 2,544,377      0 48,155,254  204    0      capacity(sz + size);
             .     .    .              .         .      .          .    .    .  
    56,705,004     0    0     33,053,474         0      0          0    0    0      uint32_t prev_sz = sz;
    18,001,092     2    1              0         0      0 18,001,092    0    0      sz += size;
             .     .    .              .         .      .          .    .    .      
             .     .    .              .         .      .          .    .    .      // Handle overflow:
    81,307,523   156   18     15,101,780         0      0          0    0    0      if (sz < prev_sz)
             2     1    1              1         1      0          0    0    0          throw OutOfMemoryException();
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .      return prev_sz;
       197,580     0    0        197,580         0      0          0    0    0  }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  //=================================================================================================
             .     .    .              .         .      .          .    .    .  }
             .     .    .              .         .      .          .    .    .  
             .     .    .              .         .      .          .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr          DLmr  Dw            D1mw        DLmw  

-- line 31 ----------------------------------------
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  template<class Comp>
             .     .    .              .             .     .             .           .     .  class Heap {
             .     .    .              .             .     .             .           .     .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
             .     .    .              .             .     .             .           .     .      vec<int> heap;     // Heap of integers
             .     .    .              .             .     .             .           .     .      vec<int> indices;  // Each integers position (index) in the Heap
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .      // Index "traversal" functions
 1,537,510,334     5    4              0             0     0             0           0     0      static inline int left  (int i) { return i*2+1; }
 5,893,939,084    21    8  2,357,365,656 1,764,840,582 3,375             0           0     0      static inline int right (int i) { return (i+1)*2; }
 3,049,375,612     8    6    510,509,360             0     0             0           0     0      static inline int parent(int i) { return (i-1) >> 1; }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
 1,021,018,720    13    7              0             0     0 1,021,018,720           0     0      void percolateUp(int i)
             .     .    .              .             .     .             .           .     .      {
 2,874,539,892     0    0  1,696,830,451   257,743,438   448   667,200,081           0     0          int x  = heap[i];
             .     .    .              .             .     .             .           .     .          int p  = parent(i);
             .     .    .              .             .     .             .           .     .          
 9,584,561,924    47   22  3,259,456,642   929,437,959   602    73,853,560           0     0          while (i != 0 && lt(x, heap[p])){
   416,731,259    33   11              0             0     0   416,731,259           0     0              heap[i]          = heap[p];
   416,731,259     0    0              0             0     0   416,731,259 215,103,155   107              indices[heap[p]] = i;
             .     .    .              .             .     .             .           .     .              i                = p;
   295,834,606     0    0              0             0     0             0           0     0              p                = parent(p);
             .     .    .              .             .     .             .           .     .          }
 1,186,321,091    17    8    333,621,597             0     0   852,699,494           0     0          heap   [i] = x;
 1,195,388,827     2    2    333,664,962             0     0   852,742,732           0     0          indices[x] = i;
 1,899,667,314     0    0  1,531,528,080             0     0             0           0     0      }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
 9,362,677,583     0    0  1,337,525,369             0     0 8,025,152,214           0     0      void percolateDown(int i)
             .     .    .              .             .     .             .           .     .      {
 4,032,084,636 1,426   17  2,684,602,393   887,338,759     0 1,347,448,685           0     0          int x = heap[i];
 5,971,844,617 4,078   17  1,529,097,671            44     0             0           0     0          while (left(i) < heap.size()){
 7,413,240,018     6    3  1,176,418,353   104,524,759   138             0           0     0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
 3,447,290,340    18    3              0             0     0             0           0     0              if (!lt(heap[child], x)) break;
   190,546,116     0    0              0             0     0   190,546,116           0     0              heap[i]          = heap[child];
   190,560,979     0    0         14,863             0     0   190,546,116 118,233,855 2,182              indices[heap[i]] = i;
    89,271,745     0    0              0             0     0             0           0     0              i                = child;
             .     .    .              .             .     .             .           .     .          }
 2,693,762,517    29   10  1,346,881,291             1     0 1,346,881,226           0     0          heap   [i] = x;
 1,365,151,385     1    0      9,143,658             0     0 1,346,881,226       3,085     0          indices[x] = i;
 9,381,669,339     0    0  9,362,677,583             0     0             0           0     0      }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .    public:
             .     .    .              .             .     .             .           .     .      Heap(const Comp& c) : lt(c) { }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .      int  size      ()          const { return heap.size(); }
     8,549,494     3    1      8,549,494     2,455,962     2             0           0     0      bool empty     ()          const { return heap.size() == 0; }
37,752,844,515 2,244   49 19,058,323,448 2,411,717,323 1,171             0           0     0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
    11,481,330    16    8      7,476,253     1,050,214     5             0           0     0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
 2,480,450,202     0    0  1,750,734,461           518     0   510,509,360       2,480     0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
 7,661,807,275    14    7  4,986,756,536             0     0 1,337,525,369       6,632     0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .      // Safe variant of insert/decrease/increase:
             .     .    .              .             .     .             .           .     .      void update(int n)
             .     .    .              .             .     .             .           .     .      {
             .     .    .              .             .     .             .           .     .          if (!inHeap(n))
             .     .    .              .             .     .             .           .     .              insert(n);
             .     .    .              .             .     .             .           .     .          else {
             .     .    .              .             .     .             .           .     .              percolateUp(indices[n]);
        86,226     0    0         43,113             0     0             0           0     0              percolateDown(indices[n]); }
             .     .    .              .             .     .             .           .     .      }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .      void insert(int n)
             .     .    .              .             .     .             .           .     .      {
     8,568,537     2    2              0             0     0             0           0     0          indices.growTo(n+1, -1);
             .     .    .              .             .     .             .           .     .          assert(!inHeap(n));
             .     .    .              .             .     .             .           .     .  
    17,137,074     1    1      8,568,537     1,376,475     0     8,568,537           0     0          indices[n] = heap.size();
        58,597     1    1              0             0     0        39,014           0     0          heap.push(n);
    17,137,074     0    0      8,568,537             5     0             0           0     0          percolateUp(indices[n]); 
             .     .    .              .             .     .             .           .     .      }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .      int  removeMin()
             .     .    .              .             .     .             .           .     .      {
    25,648,479     1    1     17,098,986     1,622,327     3     8,549,493           0     0          int x            = heap[0];
    17,098,986     0    0      8,549,493     2,644,069     7     8,549,493           0     0          heap[0]          = heap.last();
    17,098,986    27   11      8,549,493     1,541,595     2     8,549,493   6,736,612   100          indices[heap[0]] = 0;
     8,549,493     1    1              0             0     0     8,549,493   2,591,407     2          indices[x]       = -1;
             .     .    .              .             .     .             .           .     .          heap.pop();
    17,098,986     0    0              0             0     0             0           0     0          if (heap.size() > 1) percolateDown(0);
             .     .    .              .             .     .             .           .     .          return x; 
             .     .    .              .             .     .             .           .     .      }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .      // Rebuild the heap from scratch, using the elements in 'ns':
             .     .    .              .             .     .             .           .     .      void build(const vec<int>& ns) {
       150,500    11    3         75,250            10     0             0           0     0          for (int i = 0; i < heap.size(); i++)
        75,265     4    1             15             5     0        75,220       6,375     0              indices[heap[i]] = -1;
            15     0    0              0             0     0             0           0     0          heap.clear();
             .     .    .              .             .     .             .           .     .  
       134,319     3    1         67,137            15     0             0           0     0          for (int i = 0; i < ns.size(); i++){
       134,244     0    0         67,122             5     0        67,122       5,353     0              indices[ns[i]] = i;
             .     .    .              .             .     .             .           .     .              heap.push(ns[i]); }
             .     .    .              .             .     .             .           .     .  
       235,061    14    3         33,573             0     0            15           0     0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
             .     .    .              .             .     .             .           .     .              percolateDown(i);
             .     .    .              .             .     .             .           .     .      }
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .      void clear(bool dealloc = false) 
             .     .    .              .             .     .             .           .     .      { 
             4     0    0              2             0     0             0           0     0          for (int i = 0; i < heap.size(); i++)
             .     .    .              .             .     .             .           .     .              indices[heap[i]] = -1;
             .     .    .              .             .     .             .           .     .          heap.clear(dealloc); 
             .     .    .              .             .     .             .           .     .      }
             .     .    .              .             .     .             .           .     .  };
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  
             .     .    .              .             .     .             .           .     .  //=================================================================================================
             .     .    .              .             .     .             .           .     .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr             D1mr          DLmr  Dw             D1mw          DLmw    

-- line 40 ----------------------------------------
              .       .    .              .             .     .              .             .       .      int sz;
              .       .    .              .             .     .              .             .       .      int cap;
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .      // Don't allow copying (error prone):
              .       .    .              .             .     .              .             .       .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              .       .    .              .             .     .              .             .       .               vec        (vec<T>& other) { assert(0); }
              .       .    .              .             .     .              .             .       .               
              .       .    .              .             .     .              .             .       .      // Helpers for calculating next capacity:
      1,959,979      10    8              0             0     0              0             0       0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
              .       .    .              .             .     .              .             .       .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .    .              .             .     .              .             .       .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  public:
              .       .    .              .             .     .              .             .       .      // Constructors:
        401,306      25   23              2             0     0        368,012         8,717   7,597      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
             52       0    0              0             0     0             52             0       0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
              .       .    .              .             .     .              .             .       .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
              .       .    .              .             .     .              .             .       .     ~vec()                                                          { clear(true); }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .      // Pointer to first element:
              .       .    .              .             .     .              .             .       .      operator T*       (void)           { return data; }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .      // Size operations:
              .       .    .              .             .     .              .             .       .      int      size     (void) const     { return sz; }
  6,021,377,593     291    1     22,135,091     1,605,264     0     35,000,788             3       0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
              .       .    .              .             .     .              .             .       .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
              .       .    .              .             .     .              .             .       .      int      capacity (void) const     { return cap; }
              .       .    .              .             .     .              .             .       .      void     capacity (int min_cap);
              .       .    .              .             .     .              .             .       .      void     growTo   (int size);
              .       .    .              .             .     .              .             .       .      void     growTo   (int size, const T& pad);
              .       .    .              .             .     .              .             .       .      void     clear    (bool dealloc = false);
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .      // Stack interface:
     11,469,310     699    4      5,732,093         1,835     0      2,862,203             0       0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
111,490,599,974  54,599  143 41,091,532,627 4,381,203,356 5,042 30,320,942,400 5,495,449,016 442,293      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
 12,006,691,728       0    0  3,002,605,552         4,486     0  5,999,512,660   188,748,854     514      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
    673,521,919       8    1      8,549,493             0     0    332,538,679             7       0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
              .       .    .              .             .     .              .             .       .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
              .       .    .              .             .     .              .             .       .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
              .       .    .              .             .     .              .             .       .      // happen given the way capacities are calculated (below). Essentially, all capacities are
              .       .    .              .             .     .              .             .       .      // even, but INT_MAX is odd.
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .      const T& last  (void) const        { return data[sz-1]; }
    323,828,989       0    0              0             0     0              0             0       0      T&       last  (void)              { return data[sz-1]; }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .      // Vector interface:
102,724,438,103     482   33    222,845,611             3     0      8,787,584             0       0      const T& operator [] (int index) const { return data[index]; }
 78,941,177,408   1,033   65 20,656,543,336    12,511,716     0  3,592,239,916     1,325,919       0      T&       operator [] (int index)       { return data[index]; }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .      // Duplicatation (preferred instead):
  1,276,820,172      21    7    427,506,668     5,152,746     0    209,478,460             0       0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
         87,605       1    0         87,530             5     0             50             0       0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
              .       .    .              .             .     .              .             .       .  };
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  template<class T>
        489,860       0    0              0             0     0        244,930             0       0  void vec<T>::capacity(int min_cap) {
      9,583,614      51   14      3,194,538             0     0              0             0       0      if (cap >= min_cap) return;
      1,715,044       7    5              0             0     0             34             0       0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
      3,204,420      81   19        245,081             5     0        735,004         1,363       0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
              .       .    .              .             .     .              .             .       .          throw OutOfMemoryException();
      3,412,836       2    2      3,412,836            53     0              0             0       0   }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  template<class T>
              .       .    .              .             .     .              .             .       .  void vec<T>::growTo(int size, const T& pad) {
     25,765,533       7    6      8,581,853            37     0              0             0       0      if (sz >= size) return;
        133,160       4    4         13,316             0     0         59,922             0       0      capacity(size);
        752,356       7    7        119,845             0     0         59,923           548       0      for (int i = sz; i < size; i++) data[i] = pad;
      8,867,231       5    4          8,321             0     0         59,922             0       0      sz = size; }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  template<class T>
        133,160       1    1              0             0     0         53,264             0       0  void vec<T>::growTo(int size) {
      5,859,681       1    1         46,609            56     0         26,632             0       0      if (sz >= size) return;
     11,413,063     435    6              0             0     0      5,706,519             0       0      capacity(size);
     40,431,791      53   10     11,466,302             0     0      5,699,860             0       0      for (int i = sz; i < size; i++) new (&data[i]) T();
      8,689,673       0    0      2,929,888            17     0      2,883,235             5       0      sz = size; }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  template<class T>
              .       .    .              .             .     .              .             .       .  void vec<T>::clear(bool dealloc) {
    588,016,318 216,963   42    183,476,229     2,870,898     0          6,718             0       0      if (data != NULL){
         13,322       0    0              1             0     0              0             0       0          for (int i = 0; i < sz; i++) data[i].~T();
  1,221,620,476       6    3     17,168,744             1     0    205,056,490       385,757       0          sz = 0;
        118,697       5    5         30,658             0     0         84,061           213       0          if (dealloc) free(data), data = NULL, cap = 0; } }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  //=================================================================================================
              .       .    .              .             .     .              .             .       .  }
              .       .    .              .             .     .              .             .       .  
              .       .    .              .             .     .              .             .       .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr          DLmr    Dw             D1mw        DLmw    

-- line 54 ----------------------------------------
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  struct Lit {
              .     .    .              .             .       .              .           .       .      int     x;
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      // Use this as a constructor:
              .     .    .              .             .       .              .           .       .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      bool operator == (Lit p) const { return x == p.x; }
  1,953,593,978     0    0    977,519,232   503,945,323     125              0           0       0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .             .       .              .           .       .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .             .       .              .           .       .  };
              .     .    .              .             .       .              .           .       .  
        346,164     0    0              0             0       0          2,565           4       0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 33,986,855,093    44   16  9,835,519,182       167,893       0  5,720,198,646   2,140,340       0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .             .       .              .           .       .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
173,962,775,768    28   12 11,965,879,480             0       0  5,983,417,850 914,253,191     165  inline  bool sign      (Lit p)              { return p.x & 1; }
270,838,037,548 6,667   44  5,529,200,810   232,057,950      18 58,038,554,344           0       0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .             .       .              .           .       .  inline  int  toInt     (Var v)              { return v; } 
          4,230     0    0             24             0       0             24           0       0  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .             .       .              .           .       .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .             .       .              .           .       .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .             .       .              .           .       .  const Lit lit_Error = { -1 };  // }
              .     .    .              .             .       .              .           .       .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .     .    .              .             .       .              .           .       .  #define l_Undef (lbool((uint8_t)2))
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  class lbool {
              .     .    .              .             .       .              .           .       .      uint8_t value;
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  public:
              .     .    .              .             .       .              .           .       .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .             .       .              .           .       .  
          1,677     1    1              0             0       0            418         103      76      lbool()       : value(0) { }
              .     .    .              .             .       .              .           .       .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .             .       .              .           .       .  
  1,027,381,163     1    1              0             0       0              0           0       0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
         19,974     0    0         13,316           105       0              0           0       0      bool  operator != (lbool b) const { return !(*this == b); }
 27,749,328,168    48    9 27,258,680,941   768,437,914     103              0           0       0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      lbool operator && (lbool b) const {
              .     .    .              .             .       .              .           .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .             .       .              .           .       .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .             .       .              .           .       .          return lbool(v); }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      lbool operator || (lbool b) const {
              .     .    .              .             .       .              .           .       .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .             .       .              .           .       .          unsigned simplified : 1;}                            header;
              .     .    .              .             .       .              .           .       .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      friend class ClauseAllocator;
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .             .       .              .           .       .      template<class V>
              .     .    .              .             .       .              .           .       .      Clause(const V& ps, bool use_extra, bool learnt) {
     63,454,624     0    0     15,151,177             0       0     18,001,092     171,939       0          header.mark      = 0;
     45,305,343     1    1     15,101,781       943,257  51,527              0           0       0          header.learnt    = learnt;
     90,956,458     3    3     15,200,573             2       0     15,151,177           0       0          header.has_extra = learnt | use_extra;
              .     .    .              .             .       .              .           .       .          header.reloced   = 0;
     20,900,401     0    0      2,899,310            84       0     18,001,091   2,797,038  29,882          header.size      = ps.size();
              .     .    .              .             .       .              .           .       .          header.lbd       = 0;
              .     .    .              .             .       .              .           .       .          header.removable = 1;
              .     .    .              .             .       .              .           .       .          //simplify
              .     .    .              .             .       .              .           .       .          //
     18,001,092     7    4     18,001,092     2,067,356 119,774              0           0       0          header.simplified = 0;
              .     .    .              .             .       .              .           .       .  
    623,320,891   276   27      3,095,858             0       0              0           0       0          for (int i = 0; i < ps.size(); i++)
    326,211,729   245   11    106,256,405    13,849,059   8,128    142,062,306  14,196,582 882,503              data[i].lit = ps[i];
              .     .    .              .             .       .              .           .       .  
     54,003,275    60   12     18,001,091             0       0              0           0       0          if (header.has_extra){
     24,651,546    21    5              0             0       0              0           0       0              if (header.learnt){
     24,492,978     2    2      9,396,570             0       0     12,246,489     765,257  41,325                  data[header.size].act = 0;
     24,492,982     0    0              0             0       0     12,246,489     767,944  41,446                  data[header.size+1].touched = 0;
              .     .    .              .             .       .              .           .       .              }else
              .     .    .              .             .       .              .           .       .                  calcAbstraction(); }
              .     .    .              .             .       .              .           .       .      }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  public:
              .     .    .              .             .       .              .           .       .      void calcAbstraction() {
              .     .    .              .             .       .              .           .       .          assert(header.has_extra);
         79,623     0    0              0             0       0              0           0       0          uint32_t abstraction = 0;
      1,396,576     3    2         29,904             0       0              0           0       0          for (int i = 0; i < size(); i++)
      2,185,976     3    2              0             0       0              1           0       0              abstraction |= 1 << (var(data[i].lit) & 31);
        248,439     0    0         29,888             0       0        109,380       4,917   4,917          data[header.size].abs = abstraction;  }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
 27,655,598,396   189   51 13,426,518,493 1,624,647,409   5,171 11,659,780,238          46       0      int          size        ()      const   { return header.size; }
      1,005,437    30    7        251,364        44,458       2        251,364       2,502       0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .             .       .              .           .       .      void         pop         ()              { shrink(1); }
    490,272,679     7    7      2,831,669             1       0              0           0       0      bool         learnt      ()      const   { return header.learnt; }
         39,050     0    0              0             0       0              0           0       0      bool         has_extra   ()      const   { return header.has_extra; }
    276,614,848   198    4     30,316,135    26,822,022  45,229     92,857,435           0       0      uint32_t     mark        ()      const   { return header.mark; }
     73,002,077   238   11     18,422,288        51,673       0     18,165,042           0       0      void         mark        (uint32_t m)    { header.mark = m; }
        108,426     0    0              0             0       0         54,213      11,488       0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .             .       .              .           .       .  
     45,510,129     0    0     45,510,129    29,488,854   1,228              0           0       0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .             .       .              .           .       .      CRef         relocation  ()      const   { return data[0].rel; }
     60,407,124    16    9     15,101,781             0       0     30,203,562           0       0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .             .       .              .           .       .  
     17,659,142     0    0      5,878,226             0       0              0           0       0      int          lbd         ()      const   { return header.lbd; }
     81,666,211   201    9     21,958,306             0       0     12,563,079           0       0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .             .       .              .           .       .      bool         removable   ()      const   { return header.removable; }
     59,425,573     5    5     21,839,277             0       0      9,396,574           0       0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .             .       .              .           .       .      //       subsumption operations to behave correctly.
 23,351,706,897   134   24 23,165,205,274 1,811,285,572  17,766              0           0       0      Lit&         operator [] (int i)         { return data[i].lit; }
    171,461,360   428   23    150,263,579     5,877,927   3,661              0           0       0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .             .       .              .           .       .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .             .       .              .           .       .  
      9,491,550     0    0      9,491,550             3       0              0           0       0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     13,158,322     0    0      4,102,277       887,545       0              0           0       0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .             .       .              .           .       .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .             .       .              .           .       .      void         strengthen  (Lit p);
              .     .    .              .             .       .              .           .       .      // simplify
              .     .    .              .             .       .              .           .       .      //
     66,019,342     0    0     18,914,810             0       0      9,396,574           0       0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .             .       .              .           .       .      bool simplified() { return header.simplified; }
              .     .    .              .             .       .              .           .       .  };
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  //=================================================================================================
              .     .    .              .             .       .              .           .       .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .             .       .              .           .       .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .             .       .              .           .       .  {
              .     .    .              .             .       .              .           .       .      static int clauseWord32Size(int size, int extras){
     35,904,658     2    2     17,903,563       845,706   1,132              0           0       0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .             .       .              .           .       .  public:
              .     .    .              .             .       .              .           .       .      bool extra_clause_field;
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0             0       0              1           0       0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      void moveTo(ClauseAllocator& to){
            382    56    3            191           191       0            191           0       0          to.extra_clause_field = extra_clause_field;
              .     .    .              .             .       .              .           .       .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      template<class Lits>
              .     .    .              .             .       .              .           .       .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .             .       .              .           .       .      {
              .     .    .              .             .       .              .           .       .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .             .       .              .           .       .          assert(sizeof(float)    == sizeof(uint32_t));
     35,958,164   203   13      5,754,602            34       0              0           0       0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .             .       .              .           .       .  
      2,948,705     0    0              0             0       0         49,395           0       0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .             .       .              .           .       .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .          return cid;
              .     .    .              .             .       .              .           .       .      }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    118,820,706   190    3    108,128,482        48,927       0         58,570           0       0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
         30,024     1    1         15,012             0       0              0           0       0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     15,101,781     0    0     15,101,781             0       0              0           0       0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .           .       .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .       .              .           .       .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      void free(CRef cid)
              .     .    .              .             .       .              .           .       .      {
              .     .    .              .             .       .              .           .       .          Clause& c = operator[](cid);
      8,444,393     3    1              0             0       0              0           0       0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .             .       .              .           .       .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .             .       .              .           .       .      }
              .     .    .              .             .       .              .           .       .  
     59,639,496   190    3              0             0       0     51,119,568           1       0      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .             .       .              .           .       .      {
              .     .    .              .             .       .              .           .       .          Clause& c = operator[](cr);
              .     .    .              .             .       .              .           .       .          
    158,489,815     0    0     30,408,348     4,612,172       0     30,408,348           0       0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .             .       .              .           .       .          
     15,101,782     0    0              1             0       0     15,101,781           0       0          cr = to.alloc(c, c.learnt());
              .     .    .              .             .       .              .           .       .          c.relocate(cr);
              .     .    .              .             .       .              .           .       .          
              .     .    .              .             .       .              .           .       .          // Copy extra data-fields:
              .     .    .              .             .       .              .           .       .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .             .       .              .           .       .          to[cr].mark(c.mark());
     30,203,562     2    2              0             0       0              0           0       0          if (to[cr].learnt()){
     37,586,296     0    0      9,396,574       511,405      55      9,396,574           0       0              to[cr].touched() = c.touched();
     37,586,292     0    0     18,793,148       511,809      43      9,396,574           0       0              to[cr].activity() = c.activity();
              .     .    .              .             .       .              .           .       .              to[cr].set_lbd(c.lbd());
              .     .    .              .             .       .              .           .       .              to[cr].removable(c.removable());
              .     .    .              .             .       .              .           .       .              // simplify
              .     .    .              .             .       .              .           .       .              //
              .     .    .              .             .       .              .           .       .              to[cr].setSimplified(c.simplified());
              .     .    .              .             .       .              .           .       .          }
     11,410,414   379    8              0             0       0              0           0       0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     68,159,424     0    0     59,639,496             0       0              0           0       0      }
              .     .    .              .             .       .              .           .       .  };
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .             .       .              .           .       .  {
              .     .    .              .             .       .              .           .       .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .             .       .              .           .       .      {
              .     .    .              .             .       .              .           .       .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .             .       .              .           .       .  class OccLists
              .     .    .              .             .       .              .           .       .  {
              .     .    .              .             .       .              .           .       .      vec<Vec>  occs;
              .     .    .              .             .       .              .           .       .      vec<char> dirty;
              .     .    .              .             .       .              .           .       .      vec<Idx>  dirties;
              .     .    .              .             .       .              .           .       .      Deleted   deleted;
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  public:
              3     0    0              0             0       0              3           0       0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .             .       .              .           .       .      unsigned int size(){
              .     .    .              .             .       .              .           .       .          auto m_size=0;
             64     2    2              4             3       0              0           0       0          for(int i=0;i<occs.size();i++){
        146,544    14   14         53,268        13,320   2,187              0           0       0              m_size+=occs[i].size();
              .     .    .              .             .       .              .           .       .          }
              .     .    .              .             .       .              .           .       .          
              .     .    .              .             .       .              .           .       .          return m_size;
              .     .    .              .             .       .              .           .       .      }
         73,238     1    1              0             0       0         13,316           0       0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .             .       .              .           .       .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
  2,914,807,912    36    5  2,914,807,912     2,682,522       0              0           0       0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
        209,027     1    1        106,238         8,226       0          6,718           0       0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      void  cleanAll  ();
              .     .    .              .             .       .              .           .       .      void  clean     (const Idx& idx);
              .     .    .              .             .       .              .           .       .      void  smudge    (const Idx& idx){
     16,936,066     0    0     11,269,813       268,300     389              0           0       0          if (dirty[toInt(idx)] == 0){
        247,318   195    3              0             0       0        247,318           0       0              dirty[toInt(idx)] = 1;
             48     1    1              0             0       0              0           0       0              dirties.push(idx);
              .     .    .              .             .       .              .           .       .          }
              .     .    .              .             .       .              .           .       .      }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .      void  clear(bool free = true){
              .     .    .              .             .       .              .           .       .          occs   .clear(free);
              .     .    .              .             .       .              .           .       .          dirty  .clear(free);
              .     .    .              .             .       .              .           .       .          dirties.clear(free);
              .     .    .              .             .       .              .           .       .      }
              .     .    .              .             .       .              .           .       .  };
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  template<class Idx, class Vec, class Deleted>
            828     0    0              0             0       0            621           0       0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .             .       .              .           .       .  {
     69,178,284   325    3     34,337,902     1,349,146       0              0           0       0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .             .       .              .           .       .          // Dirties may contain duplicates so check here if a variable is already cleaned:
        741,954     0    0        494,636       196,317       0              0           0       0          if (dirty[toInt(dirties[i])])
              .     .    .              .             .       .              .           .       .              clean(dirties[i]);
              .     .    .              .             .       .              .           .       .      dirties.clear();
            828     0    0            828           191       0              0           0       0  }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  template<class Idx, class Vec, class Deleted>
              .     .    .              .             .       .              .           .       .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .             .       .              .           .       .  {
              .     .    .              .             .       .              .           .       .      Vec& vec = occs[toInt(idx)];
              .     .    .              .             .       .              .           .       .      int  i, j;
     75,138,275     2    2        938,569       243,838       0              0           0       0      for (i = j = 0; i < vec.size(); i++)
     45,379,711     0    0        287,286        10,979       0              0           0       0          if (!deleted(vec[i]))
    117,355,195     7    2     33,482,291           230       0     16,815,585     148,162       0              vec[j++] = vec[i];
        239,620   194    3              0             0       0              0           0       0      vec.shrink(i - j);
        996,906     1    1        494,636        10,640       0        249,861      10,662       0      dirty[toInt(idx)] = 0;
              .     .    .              .             .       .              .           .       .  }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  //=================================================================================================
              .     .    .              .             .       .              .           .       .  // CMap -- a class for mapping clauses to values:
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .             .       .              .           .       .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .             .       .              .           .       .  |________________________________________________________________________________________________@*/
              .     .    .              .             .       .              .           .       .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .             .       .              .           .       .  {
              .     .    .              .             .       .              .           .       .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .             .       .              .           .       .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .             .       .              .           .       .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .             .       .              .           .       .      assert(header.has_extra); assert(other.header.has_extra);
     13,794,741     0    0      4,598,247        71,262       0              0           0       0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .             .       .              .           .       .          return lit_Error;
              .     .    .              .             .       .              .           .       .  
        664,323     0    0              0             0       0              0           0       0      Lit        ret = lit_Undef;
              .     .    .              .             .       .              .           .       .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .             .       .              .           .       .      const Lit* d   = (const Lit*)other;
              .     .    .              .             .       .              .           .       .  
      8,745,600     1    1      1,854,298             0       0              0           0       0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .             .       .              .           .       .          // search for c[i] or ~c[i]
     23,853,047     2    2        664,323            73       0        664,323           0       0          for (unsigned j = 0; j < other.header.size; j++)
     40,016,373     0    0      9,526,864            26       0              0           0       0              if (c[i] == d[j])
              .     .    .              .             .       .              .           .       .                  goto ok;
      5,267,336     0    0              0             0       0              0           0       0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .             .       .              .           .       .                  ret = c[i];
              .     .    .              .             .       .              .           .       .                  goto ok;
              .     .    .              .             .       .              .           .       .              }
              .     .    .              .             .       .              .           .       .  
              .     .    .              .             .       .              .           .       .          // did not find it
              .     .    .              .             .       .              .           .       .          return lit_Error;
              .     .    .              .             .       .              .           .       .  ok:;
              .     .    .              .             .       .              .           .       .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr          DLmr  Dw            D1mw    DLmw 

-- line 77 ----------------------------------------
             .     .    .              .             .     .             .       .    .  private:
             .     .    .              .             .     .             .       .    .      template<typename T>
             .     .    .              .             .     .             .       .    .      class MyQueue {
             .     .    .              .             .     .             .       .    .          int max_sz, q_sz;
             .     .    .              .             .     .             .       .    .          int ptr;
             .     .    .              .             .     .             .       .    .          int64_t sum;
             .     .    .              .             .     .             .       .    .          vec<T> q;
             .     .    .              .             .     .             .       .    .      public:
             4     1    1              0             0     0             3       0    0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .     .    .              .             .     .             .       .    .          inline bool   full () const { return q_sz == max_sz; }
             .     .    .              .             .     .             .       .    .  #ifdef INT_QUEUE_AVG
     2,974,060    59    7        743,515             0     0             0       0    0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .     .    .              .             .     .             .       .    .  #else
             .     .    .              .             .     .             .       .    .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .     .    .              .             .     .             .       .    .  #endif
        12,266    19    9              0             0     0        12,266   1,998    0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .     .    .              .             .     .             .       .    .          void push(T e) {
    10,617,624     0    0      5,107,962             0     0       200,850       0    0              if (q_sz < max_sz) q_sz++;
     4,505,412    15    7      1,501,804     1,500,076     0             0       0    0              else sum -= q[ptr];
     5,107,962    39    7              0             0     0     1,702,654       0    0              sum += e;
     5,107,962     0    0              0             0     0     3,405,308 199,961   11              q[ptr++] = e;
     5,141,215     0    0      3,405,308             0     0        33,253       0    0              if (ptr == max_sz) ptr = 0;
             .     .    .              .             .     .             .       .    .          }
             .     .    .              .             .     .             .       .    .      };
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  public:
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .      // Constructor/Destructor:
             .     .    .              .             .     .             .       .    .      //
             .     .    .              .             .     .             .       .    .      Solver();
             .     .    .              .             .     .             .       .    .      virtual ~Solver();
            10     2    2              0             0     0             4       0    0      void print_size(std::ostream &os)
             .     .    .              .             .     .             .       .    .      {
             4     2    2              0             0     0             4       1    0          program_end_time=std::chrono::steady_clock::now();
             2     0    0              0             0     0             2       0    0          total_work_time=program_end_time-program_start_time;
             4     0    0              2             1     0             0       0    0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2     0    0              2             2     0             0       0    0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4     0    0              2             0     0             0       0    0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4     0    0              2             1     0             0       0    0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4     0    0              2             0     0             0       0    0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4     0    0              2             2     0             0       0    0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .     .    .              .             .     .             .       .    .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .     .    .              .             .     .             .       .    .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2     0    0              2             2     0             0       0    0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2     0    0              2             0     0             0       0    0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2     0    0              2             0     0             0       0    0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4     0    0              2             0     0             0       0    0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4     0    0              2             2     0             0       0    0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4     0    0              2             0     0             0       0    0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4     0    0              2             0     0             0       0    0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .     .    .              .             .     .             .       .    .          os << "total_Watchers: " << total_Watchers << "\n";
             .     .    .              .             .     .             .       .    .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .     .    .              .             .     .             .       .    .          os << "total_indexs: " << total_indexs << "\n";
             .     .    .              .             .     .             .       .    .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .     .    .              .             .     .             .       .    .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .     .    .              .             .     .             .       .    .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .     .    .              .             .     .             .       .    .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .     .    .              .             .     .             .       .    .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .     .    .              .             .     .             .       .    .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .     .    .              .             .     .             .       .    .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .     .    .              .             .     .             .       .    .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .     .    .              .             .     .             .       .    .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .     .    .              .             .     .             .       .    .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .     .    .              .             .     .             .       .    .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .     .    .              .             .     .             .       .    .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .     .    .              .             .     .             .       .    .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6     0    0              4             0     0             0       0    0      }
             .     .    .              .             .     .             .       .    .      using ull=unsigned long long;
             .     .    .              .             .     .             .       .    .      ull total_Watchers = 0;
             .     .    .              .             .     .             .       .    .      ull total_act_watchers = 0;
             .     .    .              .             .     .             .       .    .      ull total_indexs = 0;
             .     .    .              .             .     .             .       .    .      ull time_find_conflict = 0;
             .     .    .              .             .     .             .       .    .      ull total_find_conflict_length = 0;
             .     .    .              .             .     .             .       .    .      ull total_find_conflict_allsize = 0;
             .     .    .              .             .     .             .       .    .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .     .    .              .             .     .             .       .    .      {
             .     .    .              .             .     .             .       .    .          const ClauseAllocator& ca;
             .     .    .              .             .     .             .       .    .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .     .    .              .             .     .             .       .    .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .     .    .              .             .     .             .       .    .      };
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .      struct VarOrderLt {
             .     .    .              .             .     .             .       .    .          const vec<double>&  activity;
 9,292,477,889   338   26  6,737,270,078   920,023,750 3,042   332,555,311       9    0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .     .    .              .             .     .             .       .    .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .     .    .              .             .     .             .       .    .      };
             .     .    .              .             .     .             .       .    .      
             .     .    .              .             .     .             .       .    .      struct ConflictData
             .     .    .              .             .     .             .       .    .  	{
             .     .    .              .             .     .             .       .    .  		ConflictData() :
             .     .    .              .             .     .             .       .    .  			nHighestLevel(-1),
             .     .    .              .             .     .             .       .    .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .     .    .              .             .     .             .       .    .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .     .    .              .             .     .             .       .    .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .     .    .              .             .     .             .       .    .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .     .    .              .             .     .             .       .    .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .     .    .              .             .     .             .       .    .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .     .    .              .             .     .             .       .    .      std::chrono::nanoseconds total_duration;
             .     .    .              .             .     .             .       .    .      CRef     propagate(){
             .     .    .              .             .     .             .       .    .  
    15,256,398 6,290    8              0             0     0     7,628,199       1    0          auto start_time=std::chrono::steady_clock::now();
    22,884,597     0    0              0             0     0     7,628,199       0    0          auto ref= propagate_();
     7,628,199     1    1              0             0     0     7,628,199       0    0          auto end_time=std::chrono::steady_clock::now();
             .     .    .              .             .     .             .       .    .          auto duration=end_time-start_time;
             .     .    .              .             .     .             .       .    .          total_duration+=duration;
             .     .    .              .             .     .             .       .    .          return ref;
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .      }
             .     .    .              .             .     .             .       .    .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .     .    .              .             .     .             .       .    .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .     .    .              .             .     .             .       .    .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .     .    .              .             .     .             .       .    .      
             .     .    .              .             .     .             .       .    .  public:
             .     .    .              .             .     .             .       .    .      int      level            (Var x) const;
             .     .    .              .             .     .             .       .    .  protected:
             .     .    .              .             .     .             .       .    .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .     .    .              .             .     .             .       .    .      bool     withinBudget     ()      const;
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .      template<class V> int computeLBD(const V& c) {
   104,226,413    48   10              0             0     0             0       0    0          int lbd = 0;
             .     .    .              .             .     .             .       .    .  
    14,435,789    52   14     11,585,873     1,036,538     0             0       0    0          counter++;
   414,980,333     0    0      2,850,286             0     0             0       0    0          for (int i = 0; i < c.size(); i++){
             .     .    .              .             .     .             .       .    .              int l = level(var(c[i]));
   964,744,235     0    0    385,897,682    15,245,340    17             0       0    0              if (l != 0 && seen2[l] != counter){
   102,094,080     0    0              0             0     0   102,094,080       0    0                  seen2[l] = counter;
   179,792,480     0    0              0             0     0             0       0    0                  lbd++; } }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .          return lbd;
             .     .    .              .             .     .             .       .    .      }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  #ifdef BIN_DRUP
             .     .    .              .             .     .             .       .    .      static int buf_len;
             .     .    .              .             .     .             .       .    .      static unsigned char drup_buf[];
             .     .    .              .             .     .             .       .    .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .     .    .              .             .     .             .       .    .      }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .      template<class V>
             .     .    .              .             .     .             .       .    .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .     .    .              .             .     .             .       .    .          assert(op == 'a' || op == 'd');
             .     .    .              .             .     .             .       .    .          *buf_ptr++ = op; buf_len++;
             .     .    .              .             .     .             .       .    .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .     .    .              .             .     .             .       .    .          *buf_ptr++ = 0; buf_len++;
        80,128    46    8              0             0     0        80,128       0    0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .     .    .              .             .     .             .       .    .      }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .     .    .              .             .     .             .       .    .          *buf_ptr++ = 'a'; buf_len++;
             .     .    .              .             .     .             .       .    .          for (int i = 0; i < c.size(); i++)
             .     .    .              .             .     .             .       .    .              if (c[i] != l) byteDRUP(c[i]);
             .     .    .              .             .     .             .       .    .          *buf_ptr++ = 0; buf_len++;
             .     .    .              .             .     .             .       .    .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .     .    .              .             .     .             .       .    .      double    my_var_decay;
             .     .    .              .             .     .             .       .    .      bool   DISTANCE;
             .     .    .              .             .     .             .       .    .  };
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  //=================================================================================================
             .     .    .              .             .     .             .       .    .  // Implementation of inline methods:
             .     .    .              .             .     .             .       .    .  
   408,322,392     0    0    408,322,392     2,277,232    38             0       0    0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
13,298,751,255    53   10 10,388,697,916 1,788,126,215     2 2,903,750,873       0    0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  inline void Solver::insertVarOrder(Var x) {
             .     .    .              .             .     .             .       .    .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
19,538,769,684   201    6  5,975,439,847     2,388,334     0             0       0    0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    25,625,139     1    1     17,083,426     7,217,059   163             0       0    0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  inline void Solver::varDecayActivity() {
     6,810,616     0    0      3,405,308     1,450,308     0     1,702,654       0    0      var_inc *= (1 / var_decay); }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  inline void Solver::varBumpActivity(Var v, double mult) {
 4,481,508,870    18   12  2,735,631,716   421,457,785   659   683,195,450       0    0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .     .    .              .             .     .             .       .    .          // Rescale:
         4,082   130   16              1             0     0             0       0    0          for (int i = 0; i < nVars(); i++)
     5,432,928     0    0      1,358,232       313,681   461     1,358,232       0    0              activity_VSIDS[i] *= 1e-100;
           816     0    0            408           408     0           408       0    0          var_inc *= 1e-100; }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .      // Update order_heap with respect to new activity:
   582,605,958     0    0              0             0     0             0       0    0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .     .    .              .             .     .             .       .    .  
    11,399,664   322    1      5,699,832            96     0     2,849,916       0    0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .     .    .              .             .     .             .       .    .  inline void Solver::claBumpActivity (Clause& c) {
    63,893,278   651    6     19,129,291     4,092,905     0     6,408,674   1,352    0      if ( (c.activity() += cla_inc) > 1e20 ) {
             .     .    .              .             .     .             .       .    .          // Rescale:
     4,061,801    57    6            183             0     0             0       0    0          for (int i = 0; i < learnts_local.size(); i++)
     9,476,397    11    0      1,353,771     1,205,601     0     1,353,771       0    0              ca[learnts_local[i]].activity() *= 1e-20;
       193,645   156    2         96,731             1     0            61      61    0          cla_inc *= 1e-20; } }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .     .    .              .             .     .             .       .    .  inline void Solver::checkGarbage(double gf){
        62,649   145    0         20,883           244     0             0       0    0      if (ca.wasted() > ca.size() * gf)
           759     1    1            380           380     2             1       0    0          garbageCollect(); }
             .     .    .              .             .     .             .       .    .  
             .     .    .              .             .     .             .       .    .  // NOTE: enqueue does not set the ok flag! (only public methods do)
            40     0    0              0             0     0             8       0    0  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .     .    .              .             .     .             .       .    .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .     .    .              .             .     .             .       .    .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .     .    .              .             .     .             .       .    .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .     .    .              .             .     .             .       .    .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .     .    .              .             .     .             .       .    .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .     .    .              .             .     .             .       .    .  inline bool     Solver::locked          (const Clause& c) const {
    34,908,347   190    3     13,578,554       327,990     0             0       0    0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    43,540,624   192    3      8,905,984       245,539     0             0       0    0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .     .    .              .             .     .             .       .    .  }
     9,530,597     1    1      4,765,290             0     0             0       0    0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .     .    .              .             .     .             .       .    .  
       746,392     4    4        381,189             1     0       365,203       0    0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
 1,166,475,505   452    6    206,628,544    75,236,856     0             0       0    0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
     8,579,452     1    1      8,579,436         1,081     1             0       0    0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
58,732,954,908    52   11 58,732,954,908           549     0             0       0    0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .     .    .              .             .     .             .       .    .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .     .    .              .             .     .             .       .    .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .     .    .              .             .     .             .       .    .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3     0    0              2             0     0             1       1    0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .     .    .              .             .     .             .       .    .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
     2,751,064     2    1         20,799           415     0             1       0    0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6     1    1              3             3     0             0       0    0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .     .    .              .             .     .             .       .    .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .     .    .              .             .     .             .       .    .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .     .    .              .             .     .             .       .    .  { 
        39,948     0    0         19,974            34     0             0       0    0      if      ( b && !decision[v]) dec_vars++;
         7,695     0    0          5,130         1,540     0             0       0    0      else if (!b &&  decision[v]) dec_vars--;
             .     .    .              .             .     .             .       .    .  
         9,223     0    0              0             0     0         9,223       0    0      decision[v] = b;
             .     .    .              .             .     .             .       .    .      if (b && !order_heap_CHB.inHeap(v)){
             .     .    .              .             .     .             .       .    .          order_heap_CHB.insert(v);
             .     .    .              .             .     .             .       .    .          order_heap_VSIDS.insert(v);
             .     .    .              .             .     .             .       .    .          order_heap_distance.insert(v);}
             .     .    .              .             .     .             .       .    .  }
             .     .    .              .             .     .             .       .    .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .     .    .              .             .     .             .       .    .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .     .    .              .             .     .             .       .    .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr             D1mr           DLmr    Dw             D1mw          DLmw  

-- line 51 ----------------------------------------
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  //=================================================================================================
              .       .    .              .              .       .              .             .     .  // Options:
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  static const char* _cat = "CORE";
              .       .    .              .              .       .              .             .     .  
              4       0    0              0              0       0              1             0     0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1             0     0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1             0     0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
              4       1    1              0              0       0              1             0     0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1             0     0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
              4       0    0              0              0       0              1             0     0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
              4       0    0              0              0       0              1             0     0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
              4       0    0              0              0       0              1             0     0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
              4       0    0              0              0       0              1             0     0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
              4       1    1              0              0       0              1             0     0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
              4       0    0              0              0       0              1             0     0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
              4       1    1              0              0       0              1             0     0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
              4       1    1              0              0       0              1             0     0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
              4       1    1              0              0       0              1             0     0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
              4       1    1              0              0       0              1             0     0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
              .       .    .              .              .       .              .             .     .  
              4       1    1              0              0       0              1             0     0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
              1       1    1              0              0       0              1             0     0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
              4       0    0              0              0       0              1             0     0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
              .       .    .              .              .       .              .             .     .  
              4       1    1              0              0       0              1             0     0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  //VSIDS_props_limit
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  //=================================================================================================
              .       .    .              .              .       .              .             .     .  // Constructor/Destructor:
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              4       1    1              0              0       0              2             0     0  Solver::Solver() :
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Parameters (user settable):
              .       .    .              .              .       .              .             .     .      //
              .       .    .              .              .       .              .             .     .      drup_file        (NULL)
              .       .    .              .              .       .              .             .     .    , verbosity        (0)
              .       .    .              .              .       .              .             .     .    , step_size        (opt_step_size)
              .       .    .              .              .       .              .             .     .    , step_size_dec    (opt_step_size_dec)
              .       .    .              .              .       .              .             .     .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
              .       .    .              .              .       .              .             .     .    , garbage_frac     (opt_garbage_frac)
              .       .    .              .              .       .              .             .     .    , restart_first    (opt_restart_first)
              .       .    .              .              .       .              .             .     .    , restart_inc      (opt_restart_inc)
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .    , min_number_of_learnts_copies(opt_min_dupl_app)  
              .       .    .              .              .       .              .             .     .    , max_lbd_dup(opt_max_lbd_dup)
              .       .    .              .              .       .              .             .     .    , dupl_db_init_size(opt_dupl_db_init_size)
              3       1    1              1              0       0              1             0     0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .    // Parameters (the rest):
              .       .    .              .              .       .              .             .     .    //
              .       .    .              .              .       .              .             .     .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .    // Parameters (experimental):
              .       .    .              .              .       .              .             .     .    //
              .       .    .              .              .       .              .             .     .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
              .       .    .              .              .       .              .             .     .    //
              .       .    .              .              .       .              .             .     .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
              .       .    .              .              .       .              .             .     .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
              .       .    .              .              .       .              .             .     .    , chrono_backtrack(0), non_chrono_backtrack(0)
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .    , ok                 (true)
              .       .    .              .              .       .              .             .     .    , cla_inc            (1)
              .       .    .              .              .       .              .             .     .    , var_inc            (1)
              1       0    0              0              0       0              0             0     0    , watches_bin        (WatcherDeleted(ca))
              .       .    .              .              .       .              .             .     .    , watches            (WatcherDeleted(ca))
              .       .    .              .              .       .              .             .     .    , qhead              (0)
              .       .    .              .              .       .              .             .     .    , simpDB_assigns     (-1)
              .       .    .              .              .       .              .             .     .    , simpDB_props       (0)
              .       .    .              .              .       .              .             .     .    , order_heap_CHB     (VarOrderLt(activity_CHB))
              .       .    .              .              .       .              .             .     .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
              .       .    .              .              .       .              .             .     .    , progress_estimate  (0)
              .       .    .              .              .       .              .             .     .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
              .       .    .              .              .       .              .             .     .    // simplifyAll adjust occasion
              .       .    .              .              .       .              .             .     .    , curSimplify(1)
              .       .    .              .              .       .              .             .     .    , nbconfbeforesimplify(1000)
              .       .    .              .              .       .              .             .     .    , incSimplify(1000)
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .    , my_var_decay       (0.6)
              .       .    .              .              .       .              .             .     .    , DISTANCE           (true)
              .       .    .              .              .       .              .             .     .    , var_iLevel_inc     (1)
             94       8    8             25              2       2             63             1     0    , order_heap_distance(VarOrderLt(activity_distance))
              .       .    .              .              .       .              .             .     .  
              4       0    0              3              0       0              0             0     0  {}
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  Solver::~Solver()
              .       .    .              .              .       .              .             .     .  {
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  // simplify All
              .       .    .              .              .       .              .             .     .  //
              .       .    .              .              .       .              .             .     .  CRef Solver::simplePropagate()
      7,648,680      20    4              0              0       0      5,736,510         6,344     0  {
        956,085       0    0              0              0       0        956,085             0     0      CRef    confl = CRef_Undef;
        956,085       0    0              0              0       0        956,085             0     0      int     num_props = 0;
      1,912,170       0    0              0              0       0        956,085         5,960     0      watches.cleanAll();
      2,868,255      48    8        956,085              0       0        956,085             0     0      watches_bin.cleanAll();
     17,801,056       0    0      8,900,528             25       0              0             0     0      while (qhead < trail.size())
              .       .    .              .              .       .              .             .     .      {
     39,752,345       2    2     15,900,938        431,156       0     15,900,938             0     0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .    .              .              .       .              .             .     .          vec<Watcher>&  ws = watches[p];
              .       .    .              .              .       .              .             .     .          Watcher        *i, *j, *end;
      7,944,443       0    0      7,944,443              0       0              0             0     0          num_props++;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          // First, Propagate binary clauses
              .       .    .              .              .       .              .             .     .          vec<Watcher>&  wbin = watches_bin[p];
              .       .    .              .              .       .              .             .     .  
     55,086,927       0    0      7,950,469      7,857,143   3,962              0             0     0          for (int k = 0; k<wbin.size(); k++)
              .       .    .              .              .       .              .             .     .          {
              .       .    .              .              .       .              .             .     .  
     14,397,028       0    0     12,032,592      5,015,196     231              0             0     0              Lit imp = wbin[k].blocker;
              .       .    .              .              .       .              .             .     .  
     14,397,028       0    0              0              0       0              0             0     0              if (value(imp) == l_False)
              .       .    .              .              .       .              .             .     .              {
         12,052       0    0          6,026              0       0          6,026             0     0                  return wbin[k].cref;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
     14,384,976      14    8              0              0       0              0             0     0              if (value(imp) == l_Undef)
              .       .    .              .              .       .              .             .     .              {
      2,752,109       0    0      2,752,109              0       0              0             0     0                  simpleUncheckEnqueue(imp, wbin[k].cref);
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
  1,456,026,168      12    2    704,096,933      6,005,714     465     15,753,831             0     0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
              .       .    .              .              .       .              .             .     .          {
              .       .    .              .              .       .              .             .     .              // Try to avoid inspecting the clause:
    688,208,047      46   14    688,208,047     89,400,944  28,092              0             0     0              Lit blocker = i->blocker;
  1,376,416,094       0    0    688,208,047     18,907,567      85              0             0     0              if (value(blocker) == l_True)
              .       .    .              .              .       .              .             .     .              {
              .       .    .              .              .       .              .             .     .                  *j++ = *i++; continue;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Make sure the false literal is data[1]:
  1,008,101,046       0    0    504,050,523              0       0              0             0     0              CRef     cr = i->cref;
              .       .    .              .              .       .              .             .     .              Clause&  c = ca[cr];
              .       .    .              .              .       .              .             .     .              Lit      false_lit = ~p;
  1,512,151,569       0    0    504,050,523    480,325,000  52,575              0             0     0              if (c[0] == false_lit)
    553,965,747       0    0    184,655,249     10,843,007   1,736    369,310,498             0     0                  c[0] = c[1], c[1] = false_lit;
              .       .    .              .              .       .              .             .     .              assert(c[1] == false_lit);
              .       .    .              .              .       .              .             .     .              //  i++;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // If 0th watch is true, then clause is already satisfied.
              .       .    .              .              .       .              .             .     .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
              .       .    .              .              .       .              .             .     .              // why not simply do i->blocker=first in this case?
              .       .    .              .              .       .              .             .     .              Lit     first = c[0];
              .       .    .              .              .       .              .             .     .              //  Watcher w     = Watcher(cr, first);
  1,265,070,402       0    0    128,484,678      2,243,750      17              0             0     0              if (first != blocker && value(first) == l_True)
              .       .    .              .              .       .              .             .     .              {
     29,240,668       0    0              0              0       0     29,240,668             0     0                  i->blocker = first;
    853,592,768       0    0    213,398,192              0       0    213,398,192     1,872,511     0                  *j++ = *i++; continue;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Look for new watch:
              .       .    .              .              .       .              .             .     .              //if (incremental)
              .       .    .              .              .       .              .             .     .              //{ // ----------------- INCREMENTAL MODE
              .       .    .              .              .       .              .             .     .              //	int choosenPos = -1;
              .       .    .              .              .       .              .             .     .              //	for (int k = 2; k < c.size(); k++)
              .       .    .              .              .       .              .             .     .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
              .       .    .              .              .       .              .             .     .              //		Watcher w = Watcher(cr, first); i++;
              .       .    .              .              .       .              .             .     .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
              .       .    .              .              .       .              .             .     .              //		watches[~c[1]].push(w);
              .       .    .              .              .       .              .             .     .              //		goto NextClause;
              .       .    .              .              .       .              .             .     .              //	}
              .       .    .              .              .       .              .             .     .              //}
              .       .    .              .              .       .              .             .     .              else
              .       .    .              .              .       .              .             .     .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
  1,471,763,482      48    8              0              0       0              0             0     0                  for (int k = 2; k < c.size(); k++)
              .       .    .              .              .       .              .             .     .                  {
              .       .    .              .              .       .              .             .     .  
  2,844,865,720       0    0              0              0       0              0             0     0                      if (value(c[k]) != l_False)
              .       .    .              .              .       .              .             .     .                      {
              .       .    .              .              .       .              .             .     .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
              .       .    .              .              .       .              .             .     .                          // the blocker is first in the watcher. However,
              .       .    .              .              .       .              .             .     .                          // the blocker in the corresponding watcher in ~first is not c[1]
              .       .    .              .              .       .              .             .     .                          Watcher w = Watcher(cr, first); i++;
  1,880,184,992       0    0    470,046,248              0       0    940,092,496             0     0                          c[1] = c[k]; c[k] = false_lit;
              .       .    .              .              .       .              .             .     .                          watches[~c[1]].push(w);
    470,046,248       0    0              0              0       0              0             0     0                          goto NextClause;
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Did not find watch -- clause is unit under assignment:
      4,763,607       0    0              0              0       0      4,763,607             0     0              i->blocker = first;
     19,054,428      12    2      4,763,607              0       0      4,763,607        33,452     0              *j++ = *i++;
      9,527,214      48   13              0              0       0              0             0     0              if (value(first) == l_False)
              .       .    .              .              .       .              .             .     .              {
        280,098      24    4              0              0       0         43,534            19     0                  confl = cr;
         87,068      44    7         43,534              0       0         43,534         1,667     0                  qhead = trail.size();
              .       .    .              .              .       .              .             .     .                  // Copy the remaining watches:
      6,186,720       5    1         82,140          3,816       0              0             0     0                  while (i < end)
      2,967,686       0    0      2,967,686        365,405      18      2,967,686        30,605     0                      *j++ = *i++;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              else
              .       .    .              .              .       .              .             .     .              {
              .       .    .              .              .       .              .             .     .                  simpleUncheckEnqueue(first, cr);
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  NextClause:;
              .       .    .              .              .       .              .             .     .          }
     15,618,776      48   14              0              0       0              0             0     0          ws.shrink(i - j);
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
      1,900,118       0    0      1,900,118        464,307       0              0             0     0      s_propagations += num_props;
              .       .    .              .              .       .              .             .     .  
        950,059       0    0        950,059              0       0              0             0     0      return confl;
    368,271,187      51   15      6,692,595        456,908       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
              .       .    .              .              .       .              .             .     .      assert(value(p) == l_Undef);
      7,472,182       0    0              0              0       0      7,472,182             0     0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
     16,856,534      48    7      8,428,267        168,669       0      8,428,267     7,751,359 1,261      vardata[var(p)].reason = from;
      5,676,158       0    0      5,676,158              0       0              0             0     0      trail.push_(p);
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::cancelUntilTrailRecord()
              .       .    .              .              .       .              .             .     .  {
     17,379,499       0    0        209,186            819       0              0             0     0      for (int c = trail.size() - 1; c >= trailRecord; c--)
              .       .    .              .              .       .              .             .     .      {
        104,593      48   10        104,593              0       0              0             0     0          Var x = var(trail[c]);
      8,742,046       0    0        104,593              0       0      8,428,267       285,511     0          assigns[x] = l_Undef;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      }
        104,593       0    0              0              0       0        104,593             0     0      qhead = trailRecord;
        209,186       0    0              0              0       0              0             0     0      trail.shrink(trail.size() - trailRecord);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::litsEnqueue(int cutP, Clause& c)
              .       .    .              .              .       .              .             .     .  {
              .       .    .              .              .       .              .             .     .      for (int i = cutP; i < c.size(); i++)
              .       .    .              .              .       .              .             .     .      {
              .       .    .              .              .       .              .             .     .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  bool Solver::removed(CRef cr) {
              .       .    .              .              .       .              .             .     .      return ca[cr].mark() == 1;
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
      1,141,503      43    9              0              0       0        622,638             0     0  {
        103,773       0    0              0              0       0              0             0     0      int pathC = 0;
        103,773       0    0              0              0       0              0             0     0      Lit p = lit_Undef;
        311,319       0    0        103,773              0       0              0             0     0      int index = trail.size() - 1;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      do{
      4,678,510      48    9              0              0       0              0             0     0          if (confl != CRef_Undef){
              .       .    .              .              .       .              .             .     .              reason_clause.push(confl);
              .       .    .              .              .       .              .             .     .              Clause& c = ca[confl];
              .       .    .              .              .       .              .             .     .              // Special case for binary clauses
              .       .    .              .              .       .              .             .     .              // The first one has to be SAT
      6,315,060      49    9              0              0       0              0             0     0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                  assert(value(c[1]) == l_True);
              .       .    .              .              .       .              .             .     .                  Lit tmp = c[0];
        337,761       0    0        112,587          6,579       1        225,174             0     0                  c[0] = c[1], c[1] = tmp;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              // if True_confl==true, then choose p begin with the 1th index of c;
     13,734,668       0    0      2,936,748         97,172       0              0             0     0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
              .       .    .              .              .       .              .             .     .                  Lit q = c[j];
      7,908,948       0    0      3,954,474        800,870      53              0             0     0                  if (!seen[var(q)]){
      2,235,485       0    0              0              0       0      2,235,485             0     0                      seen[var(q)] = 1;
      6,706,455       0    0      2,235,485              0       0              0             0     0                      pathC++;
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          else if (confl == CRef_Undef){
              .       .    .              .              .       .              .             .     .              out_learnt.push(~p);
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
      7,663,034      48   10      2,235,485              0       0              0             0     0          if (pathC == 0) break;
              .       .    .              .              .       .              .             .     .          // Select next clause to look at:
     56,712,846       0    0     18,904,283      1,872,198     153              0             0     0          while (!seen[var(trail[index--])]);
              .       .    .              .              .       .              .             .     .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
              .       .    .              .              .       .              .             .     .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
      4,470,970       0    0      2,235,485         96,749       0              0             0     0          if (trailRecord > index + 1) break;
              .       .    .              .              .       .              .             .     .          p = trail[index + 1];
              .       .    .              .              .       .              .             .     .          confl = reason(var(p));
      2,235,482       0    0              0              0       0      2,235,482             0     0          seen[var(p)] = 0;
      2,235,482       0    0              0              0       0              0             0     0          pathC--;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      } while (pathC >= 0);
      1,037,730      48   11        726,411            714       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::simplifyLearnt(Clause& c)
        941,337      96   17              0              0       0        627,558         5,537     0  {
              .       .    .              .              .       .              .             .     .      ////
        104,593       0    0        104,593          9,050       0              0             0     0      original_length_record += c.size();
              .       .    .              .              .       .              .             .     .  
        209,186       0    0        104,593          5,631       0        104,593        10,394     0      trailRecord = trail.size();// record the start pointer
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      vec<Lit> falseLit;
              .       .    .              .              .       .              .             .     .      falseLit.clear();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
              .       .    .              .              .       .              .             .     .  
         99,120      45    6              0              0       0              0             0     0      bool True_confl = false;
              .       .    .              .              .       .              .             .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .             .     .      beforeSize = c.size();
              .       .    .              .              .       .              .             .     .      int i, j;
              .       .    .              .              .       .              .             .     .      CRef confl;
              .       .    .              .              .       .              .             .     .  
      3,480,567      48   12              0              0       0              0             0     0      for (i = 0, j = 0; i < c.size(); i++){
      2,109,552       0    0              0              0       0              0             0     0          if (value(c[i]) == l_Undef){
              .       .    .              .              .       .              .             .     .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
              .       .    .              .              .       .              .             .     .              simpleUncheckEnqueue(~c[i]);
      3,774,780       0    0        956,085              0       0        956,085         2,636     0              c[j++] = c[i];
      2,868,255       0    0              0              0       0        956,085           224     0              confl = simplePropagate();
      2,868,255      48    8        956,085        444,340       0              0             0     0              if (confl != CRef_Undef){
              .       .    .              .              .       .              .             .     .                  break;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          else{
        197,382       0    0              0              0       0              0             0     0              if (value(c[i]) == l_True){
              .       .    .              .              .       .              .             .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
        216,852      46    9         54,213              0       0         54,213           553     0                  c[j++] = c[i];
         54,213      27    5              0              0       0              0             0     0                  True_confl = true;
              .       .    .              .              .       .              .             .     .                  confl = reason(var(c[i]));
              .       .    .              .              .       .              .             .     .                  break;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              else{
              .       .    .              .              .       .              .             .     .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
              .       .    .              .              .       .              .             .     .                  falseLit.push(c[i]);
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .      c.shrink(c.size() - j);
              .       .    .              .              .       .              .             .     .      afterSize = c.size();
              .       .    .              .              .       .              .             .     .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      if (confl != CRef_Undef || True_confl == true){
        103,773       0    0              0              0       0              0             0     0          simp_learnt_clause.clear();
        103,773       0    0              0              0       0              0             0     0          simp_reason_clause.clear();
        207,546       0    0              0              0       0              0             0     0          if (True_confl == true){
              .       .    .              .              .       .              .             .     .              simp_learnt_clause.push(c.last());
              .       .    .              .              .       .              .             .     .          }
        726,411      21    3              0              0       0        103,773             0     0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
              .       .    .              .              .       .              .             .     .  
        311,319       0    0        103,773              0       0              0             0     0          if (simp_learnt_clause.size() < c.size()){
        537,820      48    8        226,898              0       0              0             0     0              for (i = 0; i < simp_learnt_clause.size(); i++){
        823,568       0    0        205,892              7       0        205,892         1,703     0                  c[i] = simp_learnt_clause[i];
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              c.shrink(c.size() - i);
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      cancelUntilTrailRecord();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      ////
        104,593       0    0        104,593              0       0              0             0     0      simplified_length_record += c.size();
              .       .    .              .              .       .              .             .     .  
        836,744       0    0        732,151         97,649       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
              .       .    .              .              .       .              .             .     .  {
              .       .    .              .              .       .              .             .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .             .     .      int learnts_x_size_before = learnts_x.size();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      int ci, cj, li, lj;
              .       .    .              .              .       .              .             .     .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .              .              .       .              .             .     .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      return true;
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  bool Solver::simplifyLearnt_core()
            528       0    0              0              0       0            288             0     0  {
              .       .    .              .              .       .              .             .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .             .     .      int learnts_core_size_before = learnts_core.size();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      int ci, cj, li, lj;
              .       .    .              .              .       .              .             .     .      bool sat, false_lit;
              .       .    .              .              .       .              .             .     .      unsigned int nblevels;
              .       .    .              .              .       .              .             .     .      ////
              .       .    .              .              .       .              .             .     .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      ////
              .       .    .              .              .       .              .             .     .      int nbSimplified = 0;
              .       .    .              .              .       .              .             .     .      int nbSimplifing = 0;
              .       .    .              .              .       .              .             .     .  
      2,325,364      48    9             48              0       0              0             0     0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
      3,487,779      48    8      2,325,186         72,711   4,865              0             0     0          CRef cr = learnts_core[ci];
              .       .    .              .              .       .              .             .     .          Clause& c = ca[cr];
              .       .    .              .              .       .              .             .     .  
      2,325,186       0    0              0              0       0              0             0     0          if (removed(cr)) continue;
      2,325,186       0    0      1,162,593        139,231   4,482              0             0     0          else if (c.simplified()){
      2,276,256       0    0              0              0       0      1,138,128             0     0              learnts_core[cj++] = learnts_core[ci];
              .       .    .              .              .       .              .             .     .              ////
      3,414,386       0    0      1,138,128              0       0              0             0     0              nbSimplified++;
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          else{
              .       .    .              .              .       .              .             .     .              int saved_size=c.size();
              .       .    .              .              .       .              .             .     .              //         if (drup_file){
              .       .    .              .              .       .              .             .     .              //                 add_oc.clear();
              .       .    .              .              .       .              .             .     .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .    .              .              .       .              .             .     .              ////
              .       .    .              .              .       .              .             .     .              nbSimplifing++;
         24,465       0    0              0              0       0              0             0     0              sat = false_lit = false;
        400,058       0    0              0              0       0              0             0     0              for (int i = 0; i < c.size(); i++){
        400,058       0    0              0              0       0              0             0     0                  if (value(c[i]) == l_True){
              .       .    .              .              .       .              .             .     .                      sat = true;
              .       .    .              .              .       .              .             .     .                      break;
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .                  else if (value(c[i]) == l_False){
        448,988      48    9              0              0       0         24,465             0     0                      false_lit = true;
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              if (sat){
              .       .    .              .              .       .              .             .     .                  removeClause(cr);
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              else{
        146,790       0    0              0              0       0         73,395             0     0                  detachClause(cr, true);
              .       .    .              .              .       .              .             .     .  
         97,860      48   12         48,930              0       0              0             0     0                  if (false_lit){
             40       0    0              4              0       0              0             0     0                      for (li = lj = 0; li < c.size(); li++){
             22       0    0              0              0       0              0             0     0                          if (value(c[li]) != l_False){
             27       0    0              0              0       0              9             0     0                              c[lj++] = c[li];
              .       .    .              .              .       .              .             .     .                          }
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                      c.shrink(li - lj);
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                  beforeSize = c.size();
              .       .    .              .              .       .              .             .     .                  assert(c.size() > 1);
              .       .    .              .              .       .              .             .     .                  // simplify a learnt clause c
         97,860       0    0              0              0       0         48,930             0     0                  simplifyLearnt(c);
              .       .    .              .              .       .              .             .     .                  assert(c.size() > 0);
              .       .    .              .              .       .              .             .     .                  afterSize = c.size();
              .       .    .              .              .       .              .             .     .                  
        112,746       0    0         73,395         21,398       1              0             0     0                  if(drup_file && saved_size !=c.size()){
              .       .    .              .              .       .              .             .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .             .     .                      binDRUP('a', c , drup_file);
              .       .    .              .              .       .              .             .     .                      //                    binDRUP('d', add_oc, drup_file);
              .       .    .              .              .       .              .             .     .  #else
              .       .    .              .              .       .              .             .     .                      for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .             .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .             .     .                      fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
              .       .    .              .              .       .              .             .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .    .              .              .       .              .             .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .              .              .       .              .             .     .                      //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .    .              .              .       .              .             .     .  
         48,930       0    0              0              0       0              0             0     0                  if (c.size() == 1){
              .       .    .              .              .       .              .             .     .                      // when unit clause occur, enqueue and propagate
              5       1    1              1              0       0              1             0     0                      uncheckedEnqueue(c[0]);
              3       0    0              1              0       0              0             0     0                      if (propagate() != CRef_Undef){
              .       .    .              .              .       .              .             .     .                          ok = false;
              .       .    .              .              .       .              .             .     .                          return false;
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                      // delete the clause memory in logic
              .       .    .              .              .       .              .             .     .                      c.mark(1);
              .       .    .              .              .       .              .             .     .                      ca.free(cr);
              .       .    .              .              .       .              .             .     .  //#ifdef BIN_DRUP
              .       .    .              .              .       .              .             .     .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
              .       .    .              .              .       .              .             .     .  //#else
              .       .    .              .              .       .              .             .     .  //                    fprintf(drup_file, "d ");
              .       .    .              .              .       .              .             .     .  //                    for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .             .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .             .     .  //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  //#endif
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .                  else{
         73,392       0    0              0              0       0         24,464             0     0                      attachClause(cr);
        146,784      47   11         73,392         43,461       0         24,464             0     0                      learnts_core[cj++] = learnts_core[ci];
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                      nblevels = computeLBD(c);
         48,928      46    8              0              0       0              0             0     0                      if (nblevels < c.lbd()){
              .       .    .              .              .       .              .             .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .    .              .              .       .              .             .     .                          c.set_lbd(nblevels);
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                      c.setSimplified(true);
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
             48       0    0              0              0       0              0             0     0      learnts_core.shrink(ci - cj);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .              .              .       .              .             .     .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
              .       .    .              .              .       .              .             .     .  
             48      37   11              0              0       0              0             0     0      return true;
              .       .    .              .              .       .              .             .     .  
            384       0    0            336             48       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
     10,462,257       2    2              0              0       0      6,974,838             0     0  int Solver::is_duplicate(std::vector<uint32_t>&c){
      2,324,946       0    0              0              0       0      2,324,946        11,479     0     auto time_point_0 = std::chrono::high_resolution_clock::now();
      1,162,473       0    0      1,162,473        912,754       0              0             0     0      dupl_db_size++;
      2,872,438     238    6        620,306              0       0              0             0     0      int res = 0;    
              .       .    .              .              .       .              .             .     .      
      2,324,946       0    0      2,324,946              0       0              0             0     0      int sz = c.size();
              .       .    .              .              .       .              .             .     .      std::vector<uint32_t> tmp(c);    
              .       .    .              .              .       .              .             .     .      sort(tmp.begin(),tmp.end());
              .       .    .              .              .       .              .             .     .      
      1,162,473 138,483    3              0              0       0      1,162,473             0     0      uint64_t hash = 0;    
              .       .    .              .              .       .              .             .     .      
     57,773,754   5,850    4              0              0       0      1,162,473             0     0      for (int i =0; i<sz; i++) {
    242,369,850       0    0     24,236,985              0       0              0             0     0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
              .       .    .              .              .       .              .             .     .      }    
              .       .    .              .              .       .              .             .     .      
      1,162,473       0    0              0              0       0      1,162,473             0     0      int32_t head = tmp[0];
              .       .    .              .              .       .              .             .     .      auto it0 = ht.find(head);
      5,800,359       0    0      1,162,464              0       0              0             0     0      if (it0 != ht.end()){
              .       .    .              .              .       .              .             .     .          auto it1=ht[head].find(sz);
      2,316,954       0    0              0              0       0              0             0     0          if (it1 != ht[head].end()){
      1,134,569       0    0              0              0       0      1,134,569             0     0              auto it2 = ht[head][sz].find(hash);
      3,403,707       0    0              0              0       0      1,134,569             0     0              if (it2 != ht[head][sz].end()){
        109,221       0    0         36,407          6,922      51         36,407             0     0                  it2->second++;
         36,407       0    0              0              0       0              0             0     0                  res = it2->second;            
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              else{
      1,098,162       0    0              0              0       0      1,098,162             0     0                  ht[head][sz][hash]=1;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          else{            
         47,816       5    1              0              0       0         23,908             0     0              ht[head][sz][hash]=1;
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }else{        
      1,130,062   2,267    6              0              0       0      1,130,062           140     0          ht[head][sz][hash]=1;
              .       .    .              .              .       .              .             .     .      } 
      1,162,473      48    1              0              0       0      1,162,473             0     0      auto time_point_1 = std::chrono::high_resolution_clock::now();
              .       .    .              .              .       .              .             .     .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
              .       .    .              .              .       .              .             .     .      return res;
     10,462,257       0    0      8,137,311          1,702       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  bool Solver::simplifyLearnt_tier2()
            528      48    6              0              0       0            288             0     0  {
              .       .    .              .              .       .              .             .     .      int beforeSize, afterSize;
              .       .    .              .              .       .              .             .     .      int learnts_tier2_size_before = learnts_tier2.size();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      int ci, cj, li, lj;
              .       .    .              .              .       .              .             .     .      bool sat, false_lit;
              .       .    .              .              .       .              .             .     .      unsigned int nblevels;
              .       .    .              .              .       .              .             .     .      ////
              .       .    .              .              .       .              .             .     .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      ////
              .       .    .              .              .       .              .             .     .      int nbSimplified = 0;
              .       .    .              .              .       .              .             .     .      int nbSimplifing = 0;
              .       .    .              .              .       .              .             .     .  
        299,430      48    3             48              0       0              0             0     0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
        448,929       0    0        299,286         16,318     255              0             0     0          CRef cr = learnts_tier2[ci];
              .       .    .              .              .       .              .             .     .          Clause& c = ca[cr];
              .       .    .              .              .       .              .             .     .  
        299,286       0    0              0              0       0              0             0     0          if (removed(cr)) continue;
        299,286       0    0        149,643         18,091      25              0             0     0          else if (c.simplified()){
        139,030       0    0              0              0       0         69,515           302     0              learnts_tier2[cj++] = learnts_tier2[ci];
              .       .    .              .              .       .              .             .     .              ////
        368,801       0    0         69,515              0       0              0             0     0              nbSimplified++;
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          else{
              .       .    .              .              .       .              .             .     .              int saved_size=c.size();
              .       .    .              .              .       .              .             .     .              //            if (drup_file){
              .       .    .              .              .       .              .             .     .              //                    add_oc.clear();
              .       .    .              .              .       .              .             .     .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .    .              .              .       .              .             .     .              ////
              .       .    .              .              .       .              .             .     .              nbSimplifing++;
         80,128       0    0              0              0       0              0             0     0              sat = false_lit = false;
      2,195,540       0    0              0              0       0              0             0     0              for (int i = 0; i < c.size(); i++){
      2,195,540       0    0              0              0       0              0             0     0                  if (value(c[i]) == l_True){
              .       .    .              .              .       .              .             .     .                      sat = true;
              .       .    .              .              .       .              .             .     .                      break;
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .                  else if (value(c[i]) == l_False){
      2,355,796      10    4              0              0       0         80,128             0     0                      false_lit = true;
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              if (sat){
              .       .    .              .              .       .              .             .     .                  removeClause(cr);
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              else{
        480,768      37    8              0              0       0        240,384            46     0                  detachClause(cr, true);
              .       .    .              .              .       .              .             .     .  
        320,512       0    0        160,256          5,532       0              0             0     0                  if (false_lit){
            172       1    1             12              0       0              0             0     0                      for (li = lj = 0; li < c.size(); li++){
            118       0    0              0              0       0              0             0     0                          if (value(c[li]) != l_False){
            159       0    0              0              0       0             53             0     0                              c[lj++] = c[li];
              .       .    .              .              .       .              .             .     .                          }
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                      c.shrink(li - lj);
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                  beforeSize = c.size();
              .       .    .              .              .       .              .             .     .                  assert(c.size() > 1);
              .       .    .              .              .       .              .             .     .                  // simplify a learnt clause c
        400,640       0    0              0              0       0        240,384             0     0                  simplifyLearnt(c);
              .       .    .              .              .       .              .             .     .                  assert(c.size() > 0);
              .       .    .              .              .       .              .             .     .                  afterSize = c.size();
              .       .    .              .              .       .              .             .     .                  
        320,512      47    7        160,256         75,895       0              0             0     0                  if(drup_file && saved_size!=c.size()){
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .             .     .                      binDRUP('a', c , drup_file);
              .       .    .              .              .       .              .             .     .                      //                    binDRUP('d', add_oc, drup_file);
              .       .    .              .              .       .              .             .     .  #else
              .       .    .              .              .       .              .             .     .                      for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .             .     .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .             .     .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
              .       .    .              .              .       .              .             .     .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .    .              .              .       .              .             .     .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .              .              .       .              .             .     .                      //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .    .              .              .       .              .             .     .  
        160,256       0    0              0              0       0              0             0     0                  if (c.size() == 1){
              .       .    .              .              .       .              .             .     .                      // when unit clause occur, enqueue and propagate
              .       .    .              .              .       .              .             .     .                      uncheckedEnqueue(c[0]);
              .       .    .              .              .       .              .             .     .                      if (propagate() != CRef_Undef){
              .       .    .              .              .       .              .             .     .                          ok = false;
              .       .    .              .              .       .              .             .     .                          return false;
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                      // delete the clause memory in logic
              .       .    .              .              .       .              .             .     .                      c.mark(1);
-- line 838 ----------------------------------------
-- line 845 ----------------------------------------
              .       .    .              .              .       .              .             .     .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .             .     .  //                    fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  //#endif
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .                  else{
              .       .    .              .              .       .              .             .     .                      
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                      nblevels = computeLBD(c);
        160,256       0    0              0              0       0              0             0     0                      if (nblevels < c.lbd()){
              .       .    .              .              .       .              .             .     .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .    .              .              .       .              .             .     .                          c.set_lbd(nblevels);
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                       //duplicate learnts 
              .       .    .              .              .       .              .             .     .                      int id = 0;                    
              .       .    .              .              .       .              .             .     .                      
              .       .    .              .              .       .              .             .     .                      std::vector<uint32_t> tmp;
      3,049,757       0    0      2,233,267              0       0              0             0     0                      for (int i = 0; i < c.size(); i++)                           
      1,595,682       0    0        797,841              0       0        797,841             0     0                          tmp.push_back(c[i].x);
        320,512       0    0              0              0       0         80,128             0     0                      id = is_duplicate(tmp);
              .       .    .              .              .       .              .             .     .                       
              .       .    .              .              .       .              .             .     .                                          
              .       .    .              .              .       .              .             .     .                      //duplicate learnts 
              .       .    .              .              .       .              .             .     .  
        320,512       4    4         80,128              0       0              0             0     0                      if (id < min_number_of_learnts_copies+2){
        218,202      25    3              0              0       0         72,734             0     0                          attachClause(cr);
        360,801       0    0        218,202        137,975       0         72,734        53,606     0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
        290,936      48    6         72,734              0       0              0             0     0                          if (id == min_number_of_learnts_copies+1){                            
            236       4    2            236              0       0              0             0     0                              duplicates_added_minimization++;                                  
              .       .    .              .              .       .              .             .     .                          }
        144,996       0    0         72,498         68,836       2              0             0     0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
              .       .    .              .              .       .              .             .     .                          //if (id == min_number_of_learnts_copies+1){
              .       .    .              .              .       .              .             .     .                              cj--;
              .       .    .              .              .       .              .             .     .                              learnts_core.push(cr);
              .       .    .              .              .       .              .             .     .                              c.mark(CORE);
              .       .    .              .              .       .              .             .     .                          }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                          c.setSimplified(true);
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
             48      43    7              0              0       0              0             0     0      learnts_tier2.shrink(ci - cj);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .              .              .       .              .             .     .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
              .       .    .              .              .       .              .             .     .  
             48       0    0              0              0       0              0             0     0      return true;
              .       .    .              .              .       .              .             .     .  
            384       0    0            336             48       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  bool Solver::simplifyAll()
            240      15    7              0              0       0            144             0     0  {
              .       .    .              .              .       .              .             .     .      ////
             96       0    0              0              0       0             48             0     0      simplified_length_record = original_length_record = 0;
              .       .    .              .              .       .              .             .     .  
            192       0    0             48             48       0              0             0     0      if (!ok || propagate() != CRef_Undef)
              .       .    .              .              .       .              .             .     .          return ok = false;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      //// cleanLearnts(also can delete these code), here just for analyzing
              .       .    .              .              .       .              .             .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .    .              .              .       .              .             .     .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
              .       .    .              .              .       .              .             .     .      //local_learnts_dirty = tier2_learnts_dirty = false;
              .       .    .              .              .       .              .             .     .  
            192       0    0              0              0       0             48             0     0      if (!simplifyLearnt_core()) return ok = false;
            192      48    9              0              0       0             48             0     0      if (!simplifyLearnt_tier2()) return ok = false;
              .       .    .              .              .       .              .             .     .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      checkGarbage();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      ////
              .       .    .              .              .       .              .             .     .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
              .       .    .              .              .       .              .             .     .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      return true;
            240       0    0            192             48       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  //=================================================================================================
              .       .    .              .              .       .              .             .     .  // Minor methods:
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
              .       .    .              .              .       .              .             .     .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
              .       .    .              .              .       .              .             .     .  //
              .       .    .              .              .       .              .             .     .  Var Solver::newVar(bool sign, bool dvar)
         66,580       1    1              0              0       0         53,264             0     0  {
              .       .    .              .              .       .              .             .     .      int v = nVars();
              .       .    .              .              .       .              .             .     .      watches_bin.init(mkLit(v, false));
              .       .    .              .              .       .              .             .     .      watches_bin.init(mkLit(v, true ));
              .       .    .              .              .       .              .             .     .      watches  .init(mkLit(v, false));
              .       .    .              .              .       .              .             .     .      watches  .init(mkLit(v, true ));
             19       1    1              0              0       0              0             0     0      assigns  .push(l_Undef);
             19       1    1              0              0       0              0             0     0      vardata  .push(mkVarData(CRef_Undef, 0));
             19       0    0              0              0       0              0             0     0      activity_CHB  .push(0);
         20,012       0    0          6,658             27       0             19             0     0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
              .       .    .              .              .       .              .             .     .  
             19       1    1              0              0       0              0             0     0      picked.push(0);
             19       0    0              0              0       0              0             0     0      conflicted.push(0);
             19       0    0              0              0       0              0             0     0      almost_conflicted.push(0);
              .       .    .              .              .       .              .             .     .  #ifdef ANTI_EXPLORATION
             19       0    0              0              0       0              0             0     0      canceled.push(0);
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .  
             19       0    0              0              0       0              0             0     0      seen     .push(0);
             19       0    0              0              0       0              0             0     0      seen2    .push(0);
             19       0    0              0              0       0              0             0     0      polarity .push(sign);
             19       0    0              0              0       0              0             0     0      decision .push();
         33,290       1    1              0              0       0         13,316           120     0      trail    .capacity(v+1);
              .       .    .              .              .       .              .             .     .      setDecisionVar(v, dvar);
              .       .    .              .              .       .              .             .     .  
             19       0    0              0              0       0              0             0     0      activity_distance.push(0);
             19       1    1              0              0       0              0             0     0      var_iLevel.push(0);
             19       0    0              0              0       0              0             0     0      var_iLevel_tmp.push(0);
             19       0    0              0              0       0              0             0     0      pathCs.push(0);
              .       .    .              .              .       .              .             .     .      return v;
         59,922       0    0         46,606             19       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  bool Solver::addClause_(vec<Lit>& ps)
        348,418       2    1              0              0       0        298,644             0     0  {
              .       .    .              .              .       .              .             .     .      assert(decisionLevel() == 0);
        149,322       1    1         49,774              0       0              0             0     0      if (!ok) return false;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Check if clause is satisfied and remove false/duplicate literals:
              .       .    .              .              .       .              .             .     .      sort(ps);
              .       .    .              .              .       .              .             .     .      Lit p; int i, j;
              .       .    .              .              .       .              .             .     .  
         99,548       0    0         49,774             25       0              0             0     0      if (drup_file){
              .       .    .              .              .       .              .             .     .          add_oc.clear();
         49,774       2    1         49,774              0       0              0             0     0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
              .       .    .              .              .       .              .             .     .  
        691,742       0    0              0              0       0              0             0     0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
      1,186,759       0    0        197,653              0       0              0             0     0          if (value(ps[i]) == l_True || ps[i] == ~p)
              .       .    .              .              .       .              .             .     .              return true;
        789,082       4    2              0              0       0              0             0     0          else if (value(ps[i]) != l_False && ps[i] != p)
        591,429       0    0        197,143              0       0        197,143             0     0              ps[j++] = p = ps[i];
        396,152       0    0         49,519              0       0              0             0     0      ps.shrink(i - j);
              .       .    .              .              .       .              .             .     .  
         99,038       2    1              0              0       0              0             0     0      if (drup_file && i != j){
              .       .    .              .              .       .              .             .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .             .     .          binDRUP('a', ps, drup_file);
         49,519       0    0         49,519              0       0              0             0     0          binDRUP('d', add_oc, drup_file);
              .       .    .              .              .       .              .             .     .  #else
              .       .    .              .              .       .              .             .     .          for (int i = 0; i < ps.size(); i++)
              .       .    .              .              .       .              .             .     .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
              .       .    .              .              .       .              .             .     .          fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          fprintf(drup_file, "d ");
              .       .    .              .              .       .              .             .     .          for (int i = 0; i < add_oc.size(); i++)
              .       .    .              .              .       .              .             .     .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .              .              .       .              .             .     .          fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .      
         99,038       0    0              0              0       0              0             0     0      if (ps.size() == 0)
              .       .    .              .              .       .              .             .     .          return ok = false;
         99,038       2    1              0              0       0              0             0     0      else if (ps.size() == 1){
            744       1    1            248              0       0            124             0     0          uncheckedEnqueue(ps[0]);
            496       0    0              0              0       0            124             0     0          return ok = (propagate() == CRef_Undef);
              .       .    .              .              .       .              .             .     .      }else{
         49,395       0    0              0              0       0         49,395             0     0          CRef cr = ca.alloc(ps, false);
              .       .    .              .              .       .              .             .     .          //auto ca_size=ca.size();
              .       .    .              .              .       .              .             .     .          //printf("ca size:%d\n",ca_size);
        148,185       0    0              0              0       0         49,395             0     0          clauses.push(cr);
        148,185       1    0         49,395              0       0         49,395             0     0          attachClause(cr);
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
         49,395       0    0              0              0       0              0             0     0      return true;
        547,514       0    0        348,418              7       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
     29,965,750       4    1              0              0       0     17,979,450            24     0  void Solver::attachClause(CRef cr) {
              .       .    .              .              .       .              .             .     .      const Clause& c = ca[cr];
              .       .    .              .              .       .              .             .     .      assert(c.size() > 1);
     11,985,498       0    0      2,996,575             23       0              0             0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .    .              .              .       .              .             .     .      ws[~c[0]].push(Watcher(cr, c[1]));
              .       .    .              .              .       .              .             .     .      ws[~c[1]].push(Watcher(cr, c[0]));
      8,940,263       0    0      5,943,688      2,602,682       0              0             0     0      if (c.learnt()) learnts_literals += c.size();
     24,022,062       1    0     21,025,487             37       0              0             0     0      else            clauses_literals += c.size(); }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
     17,438,640     240    3              0              0       0     11,625,760            53     0  void Solver::detachClause(CRef cr, bool strict) {
              .       .    .              .              .       .              .             .     .      const Clause& c = ca[cr];
              .       .    .              .              .       .              .             .     .      assert(c.size() > 1);
     11,625,760       0    0              0              0       0              0             0     0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .    .              .              .       .              .             .     .      
     11,625,760       0    0              0              0       0              0             0     0      if (strict){
              .       .    .              .              .       .              .             .     .          remove(ws[~c[0]], Watcher(cr, c[1]));
              .       .    .              .              .       .              .             .     .          remove(ws[~c[1]], Watcher(cr, c[0]));
              .       .    .              .              .       .              .             .     .      }else{
              .       .    .              .              .       .              .             .     .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
              .       .    .              .              .       .              .             .     .          ws.smudge(~c[0]);
              .       .    .              .              .       .              .             .     .          ws.smudge(~c[1]);
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
      8,699,728      11    1      5,793,288         15,467       1              0             0     0      if (c.learnt()) learnts_literals -= c.size();
     17,458,232       0    0     14,551,792          5,834       0              0             0     0      else            clauses_literals -= c.size(); }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
     22,414,240     385    4              0              0       0     11,207,120             7     0  void Solver::removeClause(CRef cr) {
              .       .    .              .              .       .              .             .     .      Clause& c = ca[cr];
              .       .    .              .              .       .              .             .     .  
      8,405,340       0    0      2,801,780            205       0              0             0     0      if (drup_file){
              .       .    .              .              .       .              .             .     .          if (c.mark() != 1){
              .       .    .              .              .       .              .             .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .             .     .              binDRUP('d', c, drup_file);
              .       .    .              .              .       .              .             .     .  #else
              .       .    .              .              .       .              .             .     .              fprintf(drup_file, "d ");
              .       .    .              .              .       .              .             .     .              for (int i = 0; i < c.size(); i++)
              .       .    .              .              .       .              .             .     .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .              .              .       .              .             .     .              fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .          }else
              .       .    .              .              .       .              .             .     .              printf("c Bug. I don't expect this to happen.\n");
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
     11,207,120     190    3              0              0       0      2,801,780             0     0      detachClause(cr);
              .       .    .              .              .       .              .             .     .      // Don't leave pointers to free'd memory!
              .       .    .              .              .       .              .             .     .      if (locked(c)){
              4       0    0              1              0       0              0             0     0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
              2       0    0              0              0       0              1             0     0          vardata[var(implied)].reason = CRef_Undef; }
              .       .    .              .              .       .              .             .     .      c.mark(1);
              .       .    .              .              .       .              .             .     .      ca.free(cr);
     16,810,680       0    0     14,008,900              0       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  bool Solver::satisfied(const Clause& c) const {
      1,857,556       8    2              0              0       0              0             0     0      for (int i = 0; i < c.size(); i++)
      2,181,884       0    0        766,638          3,504       0              0             0     0          if (value(c[i]) == l_True)
              .       .    .              .              .       .              .             .     .              return true;
        123,598       0    0         61,799              0       0              0             0     0      return false; }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
              .       .    .              .              .       .              .             .     .  //
     25,709,337   1,625    8              0              0       0     17,139,558             0     0  void Solver::cancelUntil(int bLevel) {
              .       .    .              .              .       .              .             .     .  	
     11,439,183       6    2          6,677              0       0      2,856,593             0     0      if (decisionLevel() > bLevel){
              .       .    .              .              .       .              .             .     .  #ifdef PRINT_OUT
              .       .    .              .              .       .              .             .     .  		std::cout << "bt " << bLevel << "\n";
              .       .    .              .              .       .              .             .     .  #endif				
      5,713,186       0    0              0              0       0      2,856,593             0     0  		add_tmp.clear();
 14,996,631,942   6,818    4  3,005,610,893      6,411,586       2              0             0     0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
              .       .    .              .              .       .              .             .     .          {
              .       .    .              .              .       .              .             .     .              Var      x  = var(trail[c]);
              .       .    .              .              .       .              .             .     .  
  5,982,655,856       0    0  2,991,327,928  2,289,713,302       0              0             0     0  			if (level(x) <= bLevel)
              .       .    .              .              .       .              .             .     .  			{
              .       .    .              .              .       .              .             .     .  				add_tmp.push(trail[c]);
              .       .    .              .              .       .              .             .     .  			}
              .       .    .              .              .       .              .             .     .  			else
              .       .    .              .              .       .              .             .     .  			{
  5,982,461,630       0    0  2,991,230,815      1,133,306       0              0             0     0  				 if (!VSIDS){
  4,132,212,579       0    0  2,754,808,386         88,158       0              0             0     0  					uint32_t age = conflicts - picked[x];
  2,754,808,386       0    0  1,377,404,193  1,097,926,225       0              0             0     0  					if (age > 0){
 13,772,072,590     286    8  5,508,829,036  2,201,749,652       0              0             0     0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
  1,377,207,259       0    0  1,377,207,259  1,084,663,108       0              0             0     0  						double old_activity = activity_CHB[x];
  9,640,450,813      23    6  2,754,414,518      2,137,525       0  1,377,207,259             0     0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
              .       .    .              .              .       .              .             .     .  						if (order_heap_CHB.inHeap(x)){
  8,250,355,680     119    1              0              0       0  4,125,177,840           578     0  							if (activity_CHB[x] > old_activity)
              .       .    .              .              .       .              .             .     .  								order_heap_CHB.decrease(x);
              .       .    .              .              .       .              .             .     .  							else
              .       .    .              .              .       .              .             .     .  								order_heap_CHB.increase(x);
              .       .    .              .              .       .              .             .     .  						}
              .       .    .              .              .       .              .             .     .  					}
              .       .    .              .              .       .              .             .     .  #ifdef ANTI_EXPLORATION
  2,754,808,386       0    0  1,377,404,193              0       0  1,377,404,193 1,100,072,726     0  					canceled[x] = conflicts;
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .  				}
              .       .    .              .              .       .              .             .     .  				
  5,982,461,630     118   12  2,991,230,815              0       0  2,991,230,815   890,010,078     0  				assigns [x] = l_Undef;
              .       .    .              .              .       .              .             .     .  #ifdef PRINT_OUT
              .       .    .              .              .       .              .             .     .  				std::cout << "undo " << x << "\n";
              .       .    .              .              .       .              .             .     .  #endif				
  5,982,461,630       0    0  2,991,230,815              0       0              0             0     0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
  2,991,230,815       0    0  2,991,230,815              0       0              0             0     0  					polarity[x] = sign(trail[c]);
              .       .    .              .              .       .              .             .     .  				insertVarOrder(x);
              .       .    .              .              .       .              .             .     .  			}
              .       .    .              .              .       .              .             .     .          }
      2,856,593       0    0              0              0       0      2,856,593             0     0          qhead = trail_lim[bLevel];
      5,713,186       0    0              0              0       0              0             0     0          trail.shrink(trail.size() - trail_lim[bLevel]);
      8,569,779       0    0      2,856,593              0       0              0             0     0          trail_lim.shrink(trail_lim.size() - bLevel);
      8,764,005       2    2      2,856,593              0       0              0             0     0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
              .       .    .              .              .       .              .             .     .  		{
         13,593       0    0          4,531              0       0              0             0     0  			trail.push_(add_tmp[nLitId]);
              .       .    .              .              .       .              .             .     .  		}
              .       .    .              .              .       .              .             .     .  		
              .       .    .              .              .       .              .             .     .  		add_tmp.clear();
     22,852,744       0    0     19,996,151      2,487,508       0              0             0     0      } }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  //=================================================================================================
              .       .    .              .              .       .              .             .     .  // Major methods:
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  Lit Solver::pickBranchLit()
     38,122,328     211    3              0              0       0     28,591,746           286     0  {
              .       .    .              .              .       .              .             .     .      Var next = var_Undef;
              .       .    .              .              .       .              .             .     .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
     27,096,246     496    7      7,789,838      2,688,384       2              0             0     0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Random decision:
              .       .    .              .              .       .              .             .     .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
              .       .    .              .              .       .              .             .     .          next = order_heap[irand(random_seed,order_heap.size())];
              .       .    .              .              .       .              .             .     .          if (value(next) == l_Undef && decision[next])
              .       .    .              .              .       .              .             .     .              rnd_decisions++; }*/
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Activity based decision:
     72,292,895   1,085    1     31,381,156      6,080,516      80              0             0     0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
     17,085,288       0    0              0              0       0              0             0     0          if (order_heap.empty())
              1       0    0              0              0       0              0             0     0              return lit_Undef;
              .       .    .              .              .       .              .             .     .          else{
              .       .    .              .              .       .              .             .     .  #ifdef ANTI_EXPLORATION
     17,085,286       0    0      8,542,643            684       0              0             0     0              if (!VSIDS){
              .       .    .              .              .       .              .             .     .                  Var v = order_heap_CHB[0];
      6,942,352       0    0      6,942,352         71,222       0              0             0     0                  uint32_t age = conflicts - canceled[v];
      8,263,528       0    0      4,005,077      2,453,023   1,517        126,687             0     0                  while (age > 0){
              .       .    .              .              .       .              .             .     .                      double decay = pow(0.95, age);
      1,067,802       0    0        533,901         25,470       5        533,901             0     0                      activity_CHB[v] *= decay;
              .       .    .              .              .       .              .             .     .                      if (order_heap_CHB.inHeap(v))
              .       .    .              .              .       .              .             .     .                          order_heap_CHB.increase(v);
      1,601,703       0    0      1,067,802              1       0        533,901             0     0                      canceled[v] = conflicts;
              .       .    .              .              .       .              .             .     .                      v = order_heap_CHB[0];
              .       .    .              .              .       .              .             .     .                      age = conflicts - canceled[v];
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .              next = order_heap.removeMin();
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .  
     19,061,160       0    0      9,530,580      4,173,491      39              0             0     0      return mkLit(next, polarity[next]);
     42,887,618       0    0     33,357,037          3,863       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
              .       .    .              .              .       .              .             .     .  {
              .       .    .              .              .       .              .             .     .  	ConflictData data;
              .       .    .              .              .       .              .             .     .  	Clause& conflCls = ca[cind];
              .       .    .              .              .       .              .             .     .  	data.nHighestLevel = level(var(conflCls[0]));
     11,396,190       0    0      5,698,095         29,711       0              0             0     0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
              .       .    .              .              .       .              .             .     .  	{
              .       .    .              .              .       .              .             .     .  		return data;
              .       .    .              .              .       .              .             .     .  	}
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  	int highestId = 0;
              .       .    .              .              .       .              .             .     .      data.bOnlyOneLitFromHighest = true;
              .       .    .              .              .       .              .             .     .  	// find the largest decision level in the clause
         98,968       8    1              0              0       0              0             0     0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
              .       .    .              .              .       .              .             .     .  	{
              .       .    .              .              .       .              .             .     .  		int nLevel = level(var(conflCls[nLitId]));
         76,907       0    0              0              0       0              0             0     0  		if (nLevel > data.nHighestLevel)
              .       .    .              .              .       .              .             .     .  		{
              .       .    .              .              .       .              .             .     .  			highestId = nLitId;
              .       .    .              .              .       .              .             .     .  			data.nHighestLevel = nLevel;
            401       0    0              0              0       0              0             0     0  			data.bOnlyOneLitFromHighest = true;
              .       .    .              .              .       .              .             .     .  		}
              .       .    .              .              .       .              .             .     .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
              .       .    .              .              .       .              .             .     .  		{
         74,902       0    0              0              0       0              0             0     0  			data.bOnlyOneLitFromHighest = false;
              .       .    .              .              .       .              .             .     .  		}
              .       .    .              .              .       .              .             .     .  	}
              .       .    .              .              .       .              .             .     .  
          5,816     549    1              0              0       0              0             0     0  	if (highestId != 0)
              .       .    .              .              .       .              .             .     .  	{
              .       .    .              .              .       .              .             .     .  		std::swap(conflCls[0], conflCls[highestId]);
            694       0    0              0              0       0              0             0     0  		if (highestId > 1)
              .       .    .              .              .       .              .             .     .  		{
            820       0    0              0              0       0              0             0     0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
              .       .    .              .              .       .              .             .     .  			//ws.smudge(~conflCls[highestId]);
              .       .    .              .              .       .              .             .     .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
              .       .    .              .              .       .              .             .     .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
              .       .    .              .              .       .              .             .     .  		}
              .       .    .              .              .       .              .             .     .  	}
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  	return data;
              .       .    .              .              .       .              .             .     .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
              .       .    .              .              .       .              .             .     .  |  
              .       .    .              .              .       .              .             .     .  |    Post-conditions:
              .       .    .              .              .       .              .             .     .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
              .       .    .              .              .       .              .             .     .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
              .       .    .              .              .       .              .             .     .  |        rest of literals. There may be others from the same level though.
              .       .    .              .              .       .              .             .     .  |  
              .       .    .              .              .       .              .             .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .             .     .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
     37,048,908      71   16              0              0       0     25,649,244             0     0  {
      2,849,916       0    0              0              0       0      2,849,916             0     0      int pathC = 0;
      2,849,916       0    0              0              0       0              0             0     0      Lit p     = lit_Undef;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Generate conflict clause:
              .       .    .              .              .       .              .             .     .      //
              .       .    .              .              .       .              .             .     .      out_learnt.push();      // (leave room for the asserting literal)
      5,699,832       0    0      2,849,916            272       0              0             0     0      int index   = trail.size() - 1;
      2,849,916       0    0      2,849,916              0       0              0             0     0      int nDecisionLevel = level(var(ca[confl][0]));
              .       .    .              .              .       .              .             .     .      assert(nDecisionLevel == level(var(ca[confl][0])));
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      do{
              .       .    .              .              .       .              .             .     .          assert(confl != CRef_Undef); // (otherwise should be UIP)
              .       .    .              .              .       .              .             .     .          Clause& c = ca[confl];
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
  2,008,049,510       0    0              0              0       0              0             0     0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
              .       .    .              .              .       .              .             .     .              assert(value(c[1]) == l_True);
              .       .    .              .              .       .              .             .     .              Lit tmp = c[0];
      7,147,086       0    0      2,382,362        150,787       1      4,764,724             0     0              c[0] = c[1], c[1] = tmp; }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          // Update LBD if improved.
  1,218,234,113       1    1     51,289,144              0       0              0             0     0          if (c.learnt() && c.mark() != CORE){
              .       .    .              .              .       .              .             .     .              int lbd = computeLBD(c);
     11,562,528       0    0              0              0       0              0             0     0              if (lbd < c.lbd()){
        589,254       0    0              0              0       0              0             0     0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
              .       .    .              .              .       .              .             .     .                  c.set_lbd(lbd);
        589,254       0    0        294,627        237,676       0              0             0     0                  if (lbd <= core_lbd_cut){
             16       4    0              0              0       0              8             0     0                      learnts_core.push(confl);
              .       .    .              .              .       .              .             .     .                      c.mark(CORE);
        827,045       0    0        116,767              0       0              0             0     0                  }else if (lbd <= 6 && c.mark() == LOCAL){
              .       .    .              .              .       .              .             .     .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
              .       .    .              .              .       .              .             .     .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     20,123,212       4    3              0              0       0      5,786,732     2,823,634     0                      learnts_tier2.push(confl);
              .       .    .              .              .       .              .             .     .                      c.mark(TIER2); }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
     11,406,568       0    0      5,703,284              5       0              0             0     0              if (c.mark() == TIER2)
      8,733,188      42    9      2,183,297      1,015,904       0      2,183,297       264,048     0                  c.touched() = conflicts;
      7,126,874       0    0      3,563,437              0       0              0             0     0              else if (c.mark() == LOCAL)
              .       .    .              .              .       .              .             .     .                  claBumpActivity(c);
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .  
  7,611,973,847      14    4  1,970,317,370            156       0    488,037,373            61     0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
  1,482,279,997       0    0  1,482,279,997    137,081,315       2              0             0     0              Lit q = c[j];
              .       .    .              .              .       .              .             .     .  
  5,048,557,913       3    3  2,176,945,970    569,807,448       0              0             0     0              if (!seen[var(q)] && level(var(q)) > 0){
  1,389,331,834       0    0    694,665,917          2,583       0              0             0     0                  if (VSIDS){
              .       .    .              .              .       .              .             .     .                      varBumpActivity(var(q), .5);
             18       0    0              0              0       0              9             0     0                      add_tmp.push(q);
              .       .    .              .              .       .              .             .     .                  }else
    315,179,663       0    0    315,179,663    194,618,183       0              0             0     0                      conflicted[var(q)]++;
    694,665,917       0    0              0              0       0    694,665,917           143     0                  seen[var(q)] = 1;
  1,389,331,834       0    0    694,665,917            144       0              0             0     0                  if (level(var(q)) >= nDecisionLevel){
    976,074,746       0    0    976,074,746            113       0              0             0     0                      pathC++;
              .       .    .              .              .       .              .             .     .                  }else
              .       .    .              .              .       .              .             .     .                      out_learnt.push(q);
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          
              .       .    .              .              .       .              .             .     .          // Select next clause to look at:
              .       .    .              .              .       .              .             .     .  		do {
 15,887,514,626       0    0  6,452,613,325    451,082,354       0              0             0     0  			while (!seen[var(trail[index--])]);
              .       .    .              .              .       .              .             .     .  			p  = trail[index+1];
    976,087,622       0    0    488,043,811     24,875,609       0              0             0     0  		} while (level(var(p)) < nDecisionLevel);
              .       .    .              .              .       .              .             .     .  		
    976,074,746       0    0    488,037,373              0       0    488,037,373           585     0          confl = reason(var(p));
    488,037,373       0    0              0              0       0    488,037,373             0     0          seen[var(p)] = 0;
    976,074,746       0    0    976,074,746              0       0              0             0     0          pathC--;
              .       .    .              .              .       .              .             .     .  
  2,916,824,574       0    0    970,374,914            474       0              0             0     0      }while (pathC > 0);
      2,849,916       0    0      2,849,916            381       0              0             0     0      out_learnt[0] = ~p;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Simplify conflict clause:
              .       .    .              .              .       .              .             .     .      //
              .       .    .              .              .       .              .             .     .      int i, j;
      5,699,832       0    0              0              0       0      2,849,916             0     0      out_learnt.copyTo(analyze_toclear);
      8,549,748       0    0      2,849,916              6       0              0             0     0      if (ccmin_mode == 2){
      2,849,915     325    6              0              0       0              0             0     0          uint32_t abstract_level = 0;
    418,956,920     625    5              0              0       0              0             0     0          for (i = 1; i < out_learnt.size(); i++)
    212,328,374       0    0      2,849,915              0       0              0             0     0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
              .       .    .              .              .       .              .             .     .  
  1,474,898,958      60    6    617,035,717             44       0      2,849,915             0     0          for (i = j = 1; i < out_learnt.size(); i++)
  1,371,031,968      29    7    249,323,669      6,575,500       0    174,476,926             0     0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
    224,540,229      11    2     74,846,743            103       0     74,846,743        16,294     0                  out_learnt[j++] = out_learnt[i];
              .       .    .              .              .       .              .             .     .          
              .       .    .              .              .       .              .             .     .      }else if (ccmin_mode == 1){
              .       .    .              .              .       .              .             .     .          for (i = j = 1; i < out_learnt.size(); i++){
              .       .    .              .              .       .              .             .     .              Var x = var(out_learnt[i]);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              if (reason(x) == CRef_Undef)
              .       .    .              .              .       .              .             .     .                  out_learnt[j++] = out_learnt[i];
              .       .    .              .              .       .              .             .     .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
              .       .    .              .              .       .              .             .     .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
              .       .    .              .              .       .              .             .     .                          out_learnt[j++] = out_learnt[i];
              .       .    .              .              .       .              .             .     .                          break; }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }else
              .       .    .              .              .       .              .             .     .          i = j = out_learnt.size();
              .       .    .              .              .       .              .             .     .  
      5,699,832       0    0      2,849,916      2,841,557       0              0             0     0      max_literals += out_learnt.size();
    292,397,696       2    2     72,386,945              0       0              0             0     0      out_learnt.shrink(i - j);
      2,849,916      66    2      2,849,916              0       0              0             0     0      tot_literals += out_learnt.size();
              .       .    .              .              .       .              .             .     .  
      5,699,832       0    0      2,849,916        355,358       0      2,849,916             0     0      out_lbd = computeLBD(out_learnt);
     31,535,165   7,180   17     14,311,035              4       0              0             0     0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
        430,213   4,633    6         61,459              0       0        122,918             0     0          if (binResMinimize(out_learnt))
            555       0    0            185              0       0            185             0     0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Find correct backtrack level:
              .       .    .              .              .       .              .             .     .      //
      5,698,112       0    0              0              0       0              0             0     0      if (out_learnt.size() == 1)
              3       0    0              1              0       0              1             0     0          out_btlevel = 0;
              .       .    .              .              .       .              .             .     .      else{
      5,699,662       0    0              0              0       0              0             0     0          int max_i = 1;
              .       .    .              .              .       .              .             .     .          // Find the first literal assigned at the next-highest level:
    293,376,066       0    0              0              0       0              0             0     0          for (int i = 2; i < out_learnt.size(); i++)
    240,029,883       0    0     71,996,641              9       0              0             0     0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
              .       .    .              .              .       .              .             .     .                  max_i = i;
              .       .    .              .              .       .              .             .     .          // Swap-in this literal at index 1:
              .       .    .              .              .       .              .             .     .          Lit p             = out_learnt[max_i];
      5,699,830       2    0      2,849,915              0       0      2,849,915             0     0          out_learnt[max_i] = out_learnt[1];
      2,849,915       0    0              0              0       0      2,849,915             0     0          out_learnt[1]     = p;
      5,699,830       0    0      2,849,915              0       0      2,849,915             0     0          out_btlevel       = level(var(p));
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
      5,699,832     564    9      2,849,916        377,872       0              0             0     0      if (VSIDS){
  1,238,560,615   6,995   16    384,594,216      1,350,965       0              0             0     0          for (int i = 0; i < add_tmp.size(); i++){
              .       .    .              .              .       .              .             .     .              Var v = var(add_tmp[i]);
  1,138,458,762       0    0    379,486,254    225,937,615       0              0             0     0              if (level(v) >= out_btlevel - 1)
              .       .    .              .              .       .              .             .     .                  varBumpActivity(v, 1);
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          add_tmp.clear();
              .       .    .              .              .       .              .             .     .      }else{
      2,294,524       0    0      1,147,262              0       0      1,147,262        21,120     0          seen[var(p)] = true;
    110,224,819       0    0      1,147,262              0       0              0             0     0          for(int i = out_learnt.size() - 1; i >= 0; i--){
              .       .    .              .              .       .              .             .     .              Var v = var(out_learnt[i]);
              .       .    .              .              .       .              .             .     .              CRef rea = reason(v);
     65,069,958       0    0              0              0       0              0             0     0              if (rea != CRef_Undef){
              .       .    .              .              .       .              .             .     .                  const Clause& reaC = ca[rea];
    262,337,134       0    0              0              0       0              0             0     0                  for (int i = 0; i < reaC.size(); i++){
              .       .    .              .              .       .              .             .     .                      Lit l = reaC[i];
    196,774,642       0    0     98,387,321      1,096,457       0              0             0     0                      if (!seen[var(l)]){
     17,959,057       0    0              0              0       0     17,959,057             0     0                          seen[var(l)] = true;
     17,959,057       0    0     17,959,057     13,828,172       0              0             0     0                          almost_conflicted[var(l)]++;
              .       .    .              .              .       .              .             .     .                          analyze_toclear.push(l); } } } } }
              .       .    .              .              .       .              .             .     .  
  1,240,670,536     829    0    616,060,394              0       0    306,605,239    57,372,425     0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
     22,799,328       0    0     19,949,412      3,428,550       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  // Try further learnt clause minimization by means of binary clause resolution.
              .       .    .              .              .       .              .             .     .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
        221,100       0    0              0              0       0        176,880            50     0  {
              .       .    .              .              .       .              .             .     .      // Preparation: remember which false variables we have in 'out_learnt'.
        184,377      16   10         61,459              0       0         61,459             0     0      counter++;
      1,534,916       0    0        122,918              0       0              0             0     0      for (int i = 1; i < out_learnt.size(); i++)
        583,248       0    0         61,458              0       0        521,790       479,057 1,762          seen2[var(out_learnt[i])] = counter;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Get the list of binary clauses containing 'out_learnt[0]'.
              .       .    .              .              .       .              .             .     .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
              .       .    .              .              .       .              .             .     .  
         44,220       0    0              0              0       0              0             0     0      int to_remove = 0;
        331,730       2    2         61,459         46,310       0            185             0     0      for (int i = 0; i < ws.size(); i++){
        109,078       0    0        109,078         36,826       0              0             0     0          Lit the_other = ws[i].blocker;
              .       .    .              .              .       .              .             .     .          // Does 'the_other' appear negatively in 'out_learnt'?
        436,686      19    8        174,310         44,884      90              0             0     0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
            187       0    0              0              0       0              0             0     0              to_remove++;
            561       0    0              0              0       0            187             0     0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Shrink.
        132,660      22    3              0              0       0              0             0     0      if (to_remove > 0){
            185       0    0              0              0       0              0             0     0          int last = out_learnt.size() - 1;
         12,642      62    8            185              0       0              0             0     0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
          3,432       0    0          1,716              0       0              0             0     0              if (seen2[var(out_learnt[i])] != counter)
            800       0    0            320              0       0            160             0     0                  out_learnt[i--] = out_learnt[last--];
              .       .    .              .              .       .              .             .     .          out_learnt.shrink(to_remove);
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .      return to_remove != 0;
        238,339       7    5        238,339              0       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
              .       .    .              .              .       .              .             .     .  // visiting literals at levels that cannot be removed later.
              .       .    .              .              .       .              .             .     .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
  1,744,769,260   6,410    3              0              0       0  1,046,861,556     2,691,103     0  {
    348,953,852       0    0              0              0       0    174,476,926             0     0      analyze_stack.clear(); analyze_stack.push(p);
    523,430,778       0    0    348,953,852              0       0    174,476,926             0     0      int top = analyze_toclear.size();
    911,122,790       0    0              0              0       0              0             0     0      while (analyze_stack.size() > 0){
              .       .    .              .              .       .              .             .     .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
              .       .    .              .              .       .              .             .     .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          // Special handling for binary clauses like in 'analyze()'.
    888,510,958      65    9              0              0       0              0             0     0          if (c.size() == 2 && value(c[0]) == l_False){
              .       .    .              .              .       .              .             .     .              assert(value(c[1]) == l_True);
              .       .    .              .              .       .              .             .     .              Lit tmp = c[0];
      4,097,046       0    0      1,365,682         85,342       0      2,731,364             0     0              c[0] = c[1], c[1] = tmp; }
              .       .    .              .              .       .              .             .     .  
  1,851,927,606       0    0              0              0       0              0             0     0          for (int i = 1; i < c.size(); i++){
    765,355,219      94    8    765,355,219     64,971,295       2              0             0     0              Lit p  = c[i];
  2,740,997,387       0    0  1,530,710,438     17,681,746       0              0             0     0              if (!seen[var(p)] && level(var(p)) > 0){
    808,494,912       0    0    222,465,855              0       0              0             0     0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
    179,770,730       0    0              0              0       0    179,770,730             0     0                      seen[var(p)] = 1;
              .       .    .              .              .       .              .             .     .                      analyze_stack.push(p);
              5       0    0              0              0       0              0             0     0                      analyze_toclear.push(p);
              .       .    .              .              .       .              .             .     .                  }else{
    547,598,732     904    5    185,993,258             45       0              0             0     0                      for (int j = top; j < analyze_toclear.size(); j++)
    175,009,981       0    0     74,406,973              0       0    100,603,008           130     0                          seen[var(analyze_toclear[j])] = 0;
     85,390,250      15    2     42,695,125              0       0              0             0     0                      analyze_toclear.shrink(analyze_toclear.size() - top);
     42,695,125       0    0              0              0       0              0             0     0                      return false;
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
    263,563,602       0    0              0              0       0              0             0     0      return true;
  1,395,815,408      19    0  1,221,338,482            139       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .             .     .  |
              .       .    .              .              .       .              .             .     .  |  analyzeFinal : (p : Lit)  ->  [void]
              .       .    .              .              .       .              .             .     .  |  
              .       .    .              .              .       .              .             .     .  |  Description:
              .       .    .              .              .       .              .             .     .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      seen[var(p)] = 0;
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 29,912,309,500       6    2              0              0       0 14,956,154,750             0     0  {
              .       .    .              .              .       .              .             .     .      assert(value(p) == l_Undef);
              .       .    .              .              .       .              .             .     .      Var x = var(p);
  5,982,461,900       0    0  2,991,230,950      4,063,753       0              0             0     0      if (!VSIDS){
  4,132,212,975       0    0  2,754,808,650      3,202,904       0  1,377,404,325 1,194,119,438 1,897          picked[x] = conflicts;
  2,754,808,650       0    0  1,377,404,325              0       0  1,377,404,325 1,197,158,995 1,785          conflicted[x] = 0;
  2,754,808,650       2    1  1,377,404,325              0       0  1,377,404,325 1,198,881,513 2,100          almost_conflicted[x] = 0;
              .       .    .              .              .       .              .             .     .  #ifdef ANTI_EXPLORATION
  1,377,404,325       0    0  1,377,404,325              0       0              0             0     0          uint32_t age = conflicts - canceled[var(p)];
  2,754,808,650       0    0  1,377,404,325  1,195,433,497     378              0             0     0          if (age > 0){
              .       .    .              .              .       .              .             .     .              double decay = pow(0.95, age);
    363,344,940       0    0    181,672,470    171,348,565      25    181,672,470             0     0              activity_CHB[var(p)] *= decay;
              .       .    .              .              .       .              .             .     .              if (order_heap_CHB.inHeap(var(p)))
    181,672,470       0    0              0              0       0              0             0     0                  order_heap_CHB.increase(var(p));
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
  2,991,230,950       3    2  2,991,230,950            977       0              0             0     0      assigns[x] = lbool(!sign(p));
  5,982,461,900       0    0              0              0       0  5,982,461,900 2,600,796,314   269      vardata[x] = mkVarData(from, level);
  2,991,230,950       5    3  2,991,230,950              0       0              0             0     0      trail.push_(p);
 20,938,616,650       0    0 17,947,385,700              0       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  unsigned number_watch_changed_total=0;
              .       .    .              .              .       .              .             .     .  unsigned number_clause_read_total=0;
              .       .    .              .              .       .              .             .     .  unsigned times_only_access_watch=0;
              .       .    .              .              .       .              .             .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .             .     .  |
              .       .    .              .              .       .              .             .     .  |  propagate : [void]  ->  [Clause*]
              .       .    .              .              .       .              .             .     .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
              .       .    .              .              .       .              .             .     .  |  Description:
              .       .    .              .              .       .              .             .     .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
              .       .    .              .              .       .              .             .     .  |    otherwise CRef_Undef.
              .       .    .              .              .       .              .             .     .  |  
              .       .    .              .              .       .              .             .     .  |    Post-conditions:
              .       .    .              .              .       .              .             .     .  |      * the propagation queue is empty, even if there was a conflict.
              .       .    .              .              .       .              .             .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .             .     .  CRef Solver::propagate_()
     61,025,592       5    3              0              0       0     45,769,194             0     0  {
              .       .    .              .              .       .              .             .     .      //auto start_time=std::chrono::steady_clock::now();
      7,628,199       0    0              0              0       0      7,628,199             0     0      CRef    confl     = CRef_Undef;
      7,628,199       0    0              0              0       0      7,628,199             1     0      int     num_props = 0;
     15,256,398       0    0              0              0       0      7,628,199       780,427     0      watches.cleanAll();
     15,256,398       5    3              0              0       0      7,628,199             0     0      watches_bin.cleanAll();
              .       .    .              .              .       .              .             .     .      
 10,246,313,605       1    1  7,330,087,919      2,553,982       2              0             0     0      while (qhead < trail.size()){
 14,518,754,365       0    0  5,807,501,746     57,385,262       0  2,903,750,873             0     0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .    .              .              .       .              .             .     .          int currLevel = level(var(p));
              .       .    .              .              .       .              .             .     .          vec<Watcher>&  ws  = watches[p];
              .       .    .              .              .       .              .             .     .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          Watcher        *i, *j, *end;
  4,411,162,525       0    0  4,411,162,525      4,665,690       0              0             0     0          num_props++;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
              .       .    .              .              .       .              .             .     .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
 10,876,406,074       3    1  2,903,750,873  2,864,575,492     816              0             0     0          for (int k = 0; k < ws_bin.size(); k++){
  1,019,199,963       0    0  1,019,199,963    454,706,736      32              0             0     0              Lit the_other = ws_bin[k].blocker;
 49,770,115,214       0    0 46,393,862,119              0       0              0             0     0              if (value(the_other) == l_False){
        163,754       1    0         81,877              0       0         81,877             0     0                  confl = ws_bin[k].cref;
              .       .    .              .              .       .              .             .     .                  //auto end_time=std::chrono::steady_clock::now();
              .       .    .              .              .       .              .             .     .                  //auto duration=end_time-start_time;
              .       .    .              .              .       .              .             .     .  #ifdef LOOSE_PROP_STAT
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                  return confl;
              .       .    .              .              .       .              .             .     .  #else
              .       .    .              .              .       .              .             .     .                  goto ExitProp;
              .       .    .              .              .       .              .             .     .  #endif
  1,146,117,246       2    1              0              0       0              0             0     0              }else if(value(the_other) == l_Undef)
              .       .    .              .              .       .              .             .     .              {
  1,000,972,795       6    2    600,583,677              0       0    200,194,559             0     0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
              .       .    .              .              .       .              .             .     .  #ifdef  PRINT_OUT                
              .       .    .              .              .       .              .             .     .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
              .       .    .              .              .       .              .             .     .  #endif                
              .       .    .              .              .       .              .             .     .  			}
              .       .    .              .              .       .              .             .     .          }
  5,807,337,992       0    0  5,807,337,992  2,753,048,417     563              0             0     0          total_Watchers+=ws.size();
  2,903,668,996       0    0  2,903,668,996              0       0              0             0     0          total_indexs++;//number of rounds
              .       .    .              .              .       .              .             .     .          //int count=0;
  2,858,674,365       0    0              0              0       0              0             0     0          bool no_clause_access=true;
  2,858,674,365       0    0              0              0       0  2,858,674,365             0     0          bool no_implication_added=true;
  2,858,674,365       0    0              0              0       0  2,858,674,365             0     0          bool no_change_other_watch=true;
133,454,002,647      11    7 60,942,160,647              0       0  2,903,668,996             0     0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
              .       .    .              .              .       .              .             .     .              // Try to avoid inspecting the clause:
              .       .    .              .              .       .              .             .     .              //count++;
 58,038,491,651       2    1 58,038,491,651  9,554,747,856   2,156              0             0     0              Lit blocker = i->blocker;
116,076,983,302       0    0 58,038,491,651      2,785,236       2              0             0     0              total_access_watches++;
116,076,983,302       0    0 58,038,491,651  1,850,083,748       0              0             0     0              if (value(blocker) == l_True){
              .       .    .              .              .       .              .             .     .                  
171,354,972,496       0    0 42,838,743,124              0       0 42,838,743,124     3,776,586     0                  *j++ = *i++; continue; }//no clause accessed
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Make sure the false literal is data[1]:
 15,214,856,644       0    0      2,467,907            124       0              0             0     0              no_clause_access=false;
 45,599,245,581       3    2 30,399,497,054      2,778,733       2 15,199,748,527             0     0              total_clause_access_times++;
 30,399,497,054       0    0 15,199,748,527              0       0              0             0     0              CRef     cr        = i->cref;
              .       .    .              .              .       .              .             .     .              //std::cout<<"cr: "<<cr<<"\n";
              .       .    .              .              .       .              .             .     .              Clause&  c         = ca[cr];
              .       .    .              .              .       .              .             .     .              Lit      false_lit = ~p;
 15,199,748,527       0    0 15,199,748,527              0       0              0             0     0              total_clause_access_size+=2;
 45,599,245,581       0    0 30,399,497,054 13,550,865,551   2,634              0             0     0              if (c[0] == false_lit)
 30,806,018,736       0    0 15,403,009,368    423,013,844      60 15,403,009,368             0     0                  c[0] = c[1], c[1] = false_lit;
              .       .    .              .              .       .              .             .     .              assert(c[1] == false_lit);
              .       .    .              .              .       .              .             .     .              i++;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // If 0th watch is true, then clause is already satisfied.
              .       .    .              .              .       .              .             .     .              Lit     first = c[0];
              .       .    .              .              .       .              .             .     .              Watcher w     = Watcher(cr, first);
 38,633,907,228       0    0  4,117,205,087    181,384,531       0              0             0     0              if (first != blocker && value(first) == l_True){
 10,665,356,985       0    0              0              0       0  7,110,237,990     1,305,334     0                  *j++ = w; continue; }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Look for new watch:
 63,806,933,882       1    1              0              0       0              0             0     0              for (int k = 2; k < c.size(); k++)
              .       .    .              .              .       .              .             .     .              {
105,949,544,800       0    0              0              0       0 22,364,331,504             0     0                  total_clause_access_size++;
 75,283,366,041       0    0  7,265,443,969              0       0              0             0     0                  if (value(c[k]) != l_False){
 35,433,759,592   1,599    0 17,716,879,796              0       0 17,716,879,796             0     0                      c[1] = c[k]; c[k] = false_lit;
  8,858,439,898       0    0  8,858,439,898              0       0              0             0     0                      total_change_other_watch++;
  8,858,439,898       0    0              0              0       0  8,858,439,898           396     0                      no_change_other_watch=false;
              .       .    .              .              .       .              .             .     .                      watches[~c[1]].push(w);
              .       .    .              .              .       .              .             .     .                      goto NextClause; }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Did not find watch -- clause is unit under assignment:
  8,361,337,484       0    0              0              0       0  5,572,379,268       155,561     0              *j++ = w;
  5,572,379,268       0    0              0              0       0              0             0     0              if (value(first) == l_False){
      2,768,582       0    0      2,768,582         14,434       0              0             0     0                  time_find_conflict++;
     16,611,492       0    0     11,074,328         12,442       0              0             0     0                  total_find_conflict_length+=i-(Watcher*)ws;
      5,537,164       0    0      5,537,164              0       0              0             0     0                  total_find_conflict_allsize+=ws.size();
              .       .    .              .              .       .              .             .     .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
      2,768,582       0    0              0              0       0      2,768,582             0     0                  confl = cr;
      5,537,164       0    0      2,768,582              0       0      2,768,582         3,255     0                  qhead = trail.size();
              .       .    .              .              .       .              .             .     .                  // Copy the remaining watches:
              .       .    .              .              .       .              .             .     .  
    121,180,564       3    3      5,236,489            125       0              0             0     0                  while (i < end)
     53,969,502       0    0     53,969,502      6,718,605      17     53,969,502        53,942     0                      *j++ = *i++;
              .       .    .              .              .       .              .             .     .              }else
              .       .    .              .              .       .              .             .     .              {//new implecate
  2,783,421,052       0    0              0              0       0  2,783,421,052             0     0                  no_implication_added=false;
  2,783,421,052       0    0  2,783,421,052      3,902,054       0              0             0     0                  total_push_new_implication++;
  8,350,263,156       0    0  5,566,842,104        677,724       0              0             0     0  				if (currLevel == decisionLevel())
              .       .    .              .              .       .              .             .     .  				{
  5,566,842,104       0    0              0              0       0              0             0     0  					uncheckedEnqueue(first, currLevel, cr);
              .       .    .              .              .       .              .             .     .  #ifdef PRINT_OUT					
              .       .    .              .              .       .              .             .     .  					std::cout << "i " << first << " l " << currLevel << "\n";
              .       .    .              .              .       .              .             .     .  #endif					
              .       .    .              .              .       .              .             .     .  				}
              .       .    .              .              .       .              .             .     .  				else
              .       .    .              .              .       .              .             .     .  				{
              .       .    .              .              .       .              .             .     .  					int nMaxLevel = currLevel;
        337,410       0    0              0              0       0              0             0     0  					int nMaxInd = 1;
              .       .    .              .              .       .              .             .     .  					// pass over all the literals in the clause and find the one with the biggest level
      1,979,822       0    0        168,705              0       0              0             0     0  					for (int nInd = 2; nInd < c.size(); ++nInd)
              .       .    .              .              .       .              .             .     .  					{
              .       .    .              .              .       .              .             .     .  						int nLevel = level(var(c[nInd]));
      1,331,084       0    0              0              0       0              0             0     0  						if (nLevel > nMaxLevel)
              .       .    .              .              .       .              .             .     .  						{
              .       .    .              .              .       .              .             .     .  							nMaxLevel = nLevel;
              .       .    .              .              .       .              .             .     .  							nMaxInd = nInd;
              .       .    .              .              .       .              .             .     .  						}
              .       .    .              .              .       .              .             .     .  					}
              .       .    .              .              .       .              .             .     .  
        337,410       1    1              0              0       0              0             0     0  					if (nMaxInd != 1)
              .       .    .              .              .       .              .             .     .  					{
              .       .    .              .              .       .              .             .     .  						std::swap(c[1], c[nMaxInd]);
              .       .    .              .              .       .              .             .     .  						*j--; // undo last watch
         11,639       0    0         11,639              0       0              0             0     0                          total_change_other_watch++;
         11,639       0    0              0              0       0         11,639             0     0                          no_change_other_watch=false;
              .       .    .              .              .       .              .             .     .  						watches[~c[1]].push(w);
              .       .    .              .              .       .              .             .     .  					}
              .       .    .              .              .       .              .             .     .  					
 13,917,273,965       0    0  2,783,421,052              0       0  2,783,421,052             0     0  					uncheckedEnqueue(first, nMaxLevel, cr);
              .       .    .              .              .       .              .             .     .  #ifdef PRINT_OUT					
              .       .    .              .              .       .              .             .     .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
              .       .    .              .              .       .              .             .     .  #endif	
              .       .    .              .              .       .              .             .     .  				}
              .       .    .              .              .       .              .             .     .  			}
              .       .    .              .              .       .              .             .     .  
      2,467,907      71    7              0              0       0              0             0     0  NextClause:;
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
 14,293,371,825       0    0  2,858,674,365              0       0              0             0     0          if(no_clause_access==true){
    190,293,488      94    6    190,293,488         51,821       0              0             0     0              total_no_clause_access++;
              .       .    .              .              .       .              .             .     .          }
  5,862,647,587      25    8  2,858,674,365              0       0              0             0     0          if(no_implication_added==true){
    519,352,331       3    2    474,357,700      2,358,915       2              0             0     0              total_no_implication_added++;
              .       .    .              .              .       .              .             .     .          }
  5,909,350,633       0    0  2,858,674,365              0       0              0             0     0          if(no_change_other_watch==true){
  1,396,175,467      56    4  1,396,175,467             53       0              0             0     0              total_no_change_other_watch++;
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          ws.shrink(i - j);
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  ExitProp:;
     15,092,644       3    1     15,092,644      3,259,754       0              0             0     0      propagations += num_props;
      7,546,322       0    0      7,546,322              0       0              0             0     0      simpDB_props -= num_props;
              .       .    .              .              .       .              .             .     .  
      7,546,322       0    0      7,546,322              0       0              0             0     0      return confl;
  4,440,211,155   1,025    4     53,397,393      5,355,189       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .             .     .  |
              .       .    .              .              .       .              .             .     .  |  reduceDB : ()  ->  [void]
              .       .    .              .              .       .              .             .     .  |  
              .       .    .              .              .       .              .             .     .  |  Description:
              .       .    .              .              .       .              .             .     .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
              .       .    .              .              .       .              .             .     .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
              .       .    .              .              .       .              .             .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .             .     .  struct reduceDB_lt { 
              .       .    .              .              .       .              .             .     .      ClauseAllocator& ca;
              .       .    .              .              .       .              .             .     .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    140,594,224     380    7    137,583,527     38,419,941       1              0             0     0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
              .       .    .              .              .       .              .             .     .  };
              .       .    .              .              .       .              .             .     .  void Solver::reduceDB()
          1,140     155    2              0              0       0            760             0     0  {
              .       .    .              .              .       .              .             .     .      int     i, j;
              .       .    .              .              .       .              .             .     .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .    .              .              .       .              .             .     .      //local_learnts_dirty = false;
              .       .    .              .              .       .              .             .     .  
            190       0    0              0              0       0              0             0     0      sort(learnts_local, reduceDB_lt(ca));
              .       .    .              .              .       .              .             .     .  
            950       0    0            190            190       0              0             0     0      int limit = learnts_local.size() / 2;
     11,185,386     190    3              0              0       0              0             0     0      for (i = j = 0; i < learnts_local.size(); i++){
     16,776,654     190    3     11,184,436        349,743       0              0             0     0          Clause& c = ca[learnts_local[i]];
     11,184,436       0    0      5,592,218      5,538,685       1              0             0     0          if (c.mark() == LOCAL)
     21,863,960       0    0      5,544,668              0       0              0             0     0              if (c.removable() && !locked(c) && i < limit)
     13,911,275       0    0      2,782,255              0       0      2,782,255             0     0                  removeClause(learnts_local[i]);
              .       .    .              .              .       .              .             .     .              else{
        156,281       0    0              0              0       0              0             0     0                  if (!c.removable()) limit++;
              .       .    .              .              .       .              .             .     .                  c.removable(true);
     13,907,165       0    0      2,762,413              0       0      2,762,413       173,008     0                  learnts_local[j++] = learnts_local[i]; }
              .       .    .              .              .       .              .             .     .      }
            190       0    0              0              0       0              0             0     0      learnts_local.shrink(i - j);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      checkGarbage();
            951       0    0            761            190       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  void Solver::reduceDB_Tier2()
          1,710     229    3              0              0       0          1,425             0     0  {
              .       .    .              .              .       .              .             .     .      int i, j;
      1,747,014      99    3            285            279       0              0             0     0      for (i = j = 0; i < learnts_tier2.size(); i++){
      2,237,607     191    3      1,491,738         46,967       0              0             0     0          Clause& c = ca[learnts_tier2[i]];
      1,491,738       0    0              0              0       0              0             0     0          if (c.mark() == TIER2)
      3,573,995     277    3      1,429,598        538,931       0              0             0     0              if (!locked(c) && c.touched() + 30000 < conflicts){
              1       1    1              0              0       0              0             0     0                  learnts_local.push(learnts_tier2[i]);
              .       .    .              .              .       .              .             .     .                  c.mark(LOCAL);
              .       .    .              .              .       .              .             .     .                  //c.removable(true);
              .       .    .              .              .       .              .             .     .                  c.activity() = 0;
              .       .    .              .              .       .              .             .     .                  claBumpActivity(c);
              .       .    .              .              .       .              .             .     .              }else
      3,095,430       0    0        619,086              0       0        619,086        16,226     0                  learnts_tier2[j++] = learnts_tier2[i];
              .       .    .              .              .       .              .             .     .      }
            285       0    0              0              0       0              0             0     0      learnts_tier2.shrink(i - j);
          1,710       0    0          1,710            285       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::removeSatisfied(vec<CRef>& cs)
             54       0    0              0              0       0             24             0     0  {
              .       .    .              .              .       .              .             .     .      int i, j;
        457,536       4    1         91,510              3       0              0             0     0      for (i = j = 0; i < cs.size(); i++){
        274,509       0    0        183,006          5,725       0              0             0     0          Clause& c = ca[cs[i]];
              .       .    .              .              .       .              .             .     .          if (satisfied(c))
             55       1    1              1              0       0             18             5     0              removeClause(cs[i]);
              .       .    .              .              .       .              .             .     .          else
        182,970       0    0              0              0       0         91,485             0     0              cs[j++] = cs[i];
              .       .    .              .              .       .              .             .     .      }
              6       0    0              0              0       0              0             0     0      cs.shrink(i - j);
             36       3    0             30              4       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
             48       0    0              0              0       0             40             0     0  {
              .       .    .              .              .       .              .             .     .      int i, j;
         19,276       3    1              8              4       0              0             0     0      for (i = j = 0; i < cs.size(); i++){
         27,696       0    0         18,464            581       0              0             0     0          Clause& c = ca[cs[i]];
         18,464       0    0              0              0       0              0             0     0          if (c.mark() == valid_mark)
              .       .    .              .              .       .              .             .     .              if (satisfied(c))
              .       .    .              .              .       .              .             .     .                  removeClause(cs[i]);
              .       .    .              .              .       .              .             .     .              else
         44,280       0    0          8,856              0       0          8,856             0     0                  cs[j++] = cs[i];
              .       .    .              .              .       .              .             .     .      }
              6       0    0              0              0       0              0             0     0      cs.shrink(i - j);
             48       4    2             48              6       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::rebuildOrderHeap()
             45       2    1              0              0       0             30             0     0  {
              .       .    .              .              .       .              .             .     .      vec<Var> vs;
         66,600       0    0              5              0       0              5             0     0      for (Var v = 0; v < nVars(); v++)
        179,220       0    0         89,610            901       0              0             0     0          if (decision[v] && value(v) == l_Undef)
              .       .    .              .              .       .              .             .     .              vs.push(v);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      order_heap_CHB  .build(vs);
              .       .    .              .              .       .              .             .     .      order_heap_VSIDS.build(vs);
              .       .    .              .              .       .              .             .     .      order_heap_distance.build(vs);
             40       5    1             35              5       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  /*_________________________________________________________________________________________________
              .       .    .              .              .       .              .             .     .  |
              .       .    .              .              .       .              .             .     .  |  simplify : [void]  ->  [bool]
              .       .    .              .              .       .              .             .     .  |  
              .       .    .              .              .       .              .             .     .  |  Description:
              .       .    .              .              .       .              .             .     .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
              .       .    .              .              .       .              .             .     .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
              .       .    .              .              .       .              .             .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .             .     .  bool Solver::simplify()
         36,810     731    3              0              0       0         24,540             0     0  {
              .       .    .              .              .       .              .             .     .      assert(decisionLevel() == 0);
              .       .    .              .              .       .              .             .     .  
         30,675       0    0          6,135          6,060       0              0             0     0      if (!ok || propagate() != CRef_Undef)
              .       .    .              .              .       .              .             .     .          return ok = false;
              .       .    .              .              .       .              .             .     .  
         18,437     321    4         12,286              0       0              0             0     0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
              .       .    .              .              .       .              .             .     .          return true;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Remove satisfied clauses:
             12       0    0              0              0       0              4             0     0      removeSatisfied(learnts_core); // Should clean core first.
             16       0    0              0              0       0              4             0     0      safeRemoveSatisfied(learnts_tier2, TIER2);
             16       4    1              0              0       0              4             0     0      safeRemoveSatisfied(learnts_local, LOCAL);
              8       0    0              4              4       0              0             0     0      if (remove_satisfied)        // Can be turned off.
             12       6    1              0              0       0              3             0     0          removeSatisfied(clauses);
              .       .    .              .              .       .              .             .     .      checkGarbage();
              8       1    1              0              0       0              4             0     0      rebuildOrderHeap();
              .       .    .              .              .       .              .             .     .  
              8       0    0              4              4       0              4             4     0      simpDB_assigns = nAssigns();
             12       0    0              8              8       0              4             0     0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
              .       .    .              .              .       .              .             .     .  
              4       0    0              0              0       0              0             0     0      return true;
         42,945       0    0         30,675              4       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  // pathCs[k] is the number of variables assigned at level k,
              .       .    .              .              .       .              .             .     .  // it is initialized to 0 at the begining and reset to 0 after the function execution
         78,760       4    1              0              0       0         59,070             0     0  bool Solver::collectFirstUIP(CRef confl){
         19,690       0    0              0              0       0          9,845             0     0      involved_lits.clear();
        389,038       4    1              0              0       0              0             0     0      int max_level=1;
              .       .    .              .              .       .              .             .     .      Clause& c=ca[confl]; int minLevel=decisionLevel();
        128,077       0    0          9,845              0       0              0             0     0      for(int i=0; i<c.size(); i++) {
              .       .    .              .              .       .              .             .     .          Var v=var(c[i]);
              .       .    .              .              .       .              .             .     .          //        assert(!seen[v]);
        118,272      26    1         39,424         10,255       0              0             0     0          if (level(v)>0) {
         78,830       0    0         39,415          8,139       0         39,415        25,729     0              seen[v]=1;
         88,675       0    0         49,260         16,369       0         39,415        36,571     0              var_iLevel_tmp[v]=1;
         39,415       0    0         39,415         21,945       0              0             0     0              pathCs[level(v)]++;
              .       .    .              .              .       .              .             .     .              if (minLevel>level(v)) {
              .       .    .              .              .       .              .             .     .                  minLevel=level(v);
              .       .    .              .              .       .              .             .     .                  assert(minLevel>0);
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              //    varBumpActivity(v);
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
         29,535       0    0         19,690          8,670       0              0             0     0      int limit=trail_lim[minLevel-1];
     43,137,092       0    0          9,845              0       0              0             0     0      for(int i=trail.size()-1; i>=limit; i--) {
     21,548,856      35    1     21,548,856        642,426       0              0             0     0          Lit p=trail[i]; Var v=var(p);
     21,548,856       0    0     10,774,428        873,447       0              0             0     0          if (seen[v]) {
              .       .    .              .              .       .              .             .     .              int currentDecLevel=level(v);
              .       .    .              .              .       .              .             .     .              //      if (currentDecLevel==decisionLevel())
              .       .    .              .              .       .              .             .     .              //      	varBumpActivity(v);
        303,048       0    0              0              0       0        303,048             0     0              seen[v]=0;
        606,096       0    0        303,048            637       0              0             0     0              if (--pathCs[currentDecLevel]!=0) {
              .       .    .              .              .       .              .             .     .                  Clause& rc=ca[reason(v)];
        709,161       5    1        494,952            745       0              0             0     0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
        329,968       0    0              0              0       0              0             0     0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
        395,840       0    0              0              0       0              0             0     0                  if (rc.size()==2 && value(rc[0])==l_False) {
              .       .    .              .              .       .              .             .     .                      // Special case for binary clauses
              .       .    .              .              .       .              .             .     .                      // The first one has to be SAT
              .       .    .              .              .       .              .             .     .                      assert(value(rc[1]) != l_False);
              .       .    .              .              .       .              .             .     .                      Lit tmp = rc[0];
         19,578       0    0          6,526            507       0         13,052             0     0                      rc[0] =  rc[1], rc[1] = tmp;
              .       .    .              .              .       .              .             .     .                  }
      1,168,964       0    0              0              0       0              0             0     0                  for (int j = 1; j < rc.size(); j++){
              .       .    .              .              .       .              .             .     .                      Lit q = rc[j]; Var v1=var(q);
        904,868       0    0              0              0       0              0             0     0                      if (level(v1) > 0) {
        904,504       0    0              0              0       0              0             0     0                          if (minLevel>level(v1)) {
         91,108       0    0         45,554         20,995       0              0             0     0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
              .       .    .              .              .       .              .             .     .                          }
      1,356,756       0    0        904,504         29,869       0              0             0     0                          if (seen[v1]) {
        377,238       0    0        188,619            735       0              0             0     0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
        227,970       0    0              0              0       0        113,985             0     0                                  var_iLevel_tmp[v1]=reasonVarLevel;
              .       .    .              .              .       .              .             .     .                          }
              .       .    .              .              .       .              .             .     .                          else {
        263,633       0    0              0              0       0        263,633       198,592     0                              var_iLevel_tmp[v1]=reasonVarLevel;
              .       .    .              .              .       .              .             .     .                              //   varBumpActivity(v1);
        263,633       0    0              0              0       0        263,633             0     0                              seen[v1] = 1;
        790,899       6    1        527,266         83,568       0              0             0     0                              pathCs[level(v1)]++;
              .       .    .              .              .       .              .             .     .                          }
              .       .    .              .              .       .              .             .     .                      }
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              involved_lits.push(p);
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
         29,535     729    1          9,845              0       0          9,845             0     0      double inc=var_iLevel_inc;
              .       .    .              .              .       .              .             .     .      vec<int> level_incs; level_incs.clear();
        377,100       0    0        139,026              0       0              0             0     0      for(int i=0;i<max_level;i++){
        158,716       5    1         79,358              0       0              0             0     0          level_incs.push(inc);
        238,074       0    0        158,716              1       0         79,358             0     0          inc = inc/my_var_decay;
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
        645,476       0    0        312,893              0       0              0             0     0      for(int i=0;i<involved_lits.size();i++){
          9,845       0    0          9,845              1       0              0             0     0          Var v =var(involved_lits[i]);
              .       .    .              .              .       .              .             .     .          //        double old_act=activity_distance[v];
              .       .    .              .              .       .              .             .     .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
      2,884,952   5,904    2        948,524        302,867       0        312,893             0     0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
              .       .    .              .              .       .              .             .     .  
        606,096       0    0              0              0       0              0             0     0          if(activity_distance[v]>1e100){
              .       .    .              .              .       .              .             .     .              for(int vv=0;vv<nVars();vv++)
         49,225     540    1         19,690         18,152       0         19,690             0     0                  activity_distance[vv] *= 1e-100;
              .       .    .              .              .       .              .             .     .              var_iLevel_inc*=1e-100;
          4,536      35    1              0              0       0              0             0     0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .          if (order_heap_distance.inHeap(v))
              .       .    .              .              .       .              .             .     .              order_heap_distance.decrease(v);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          //        var_iLevel_inc *= (1 / my_var_decay);
              .       .    .              .              .       .              .             .     .      }
         49,225      67    1         19,690              0       0          9,845           311     0      var_iLevel_inc=level_incs[level_incs.size()-1];
              .       .    .              .              .       .              .             .     .      return true;
         88,605       0    0         68,915          2,050       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  struct UIPOrderByILevel_Lt {
              .       .    .              .              .       .              .             .     .      Solver& solver;
              .       .    .              .              .       .              .             .     .      const vec<double>&  var_iLevel;
              .       .    .              .              .       .              .             .     .      bool operator () (Lit x, Lit y) const
              .       .    .              .              .       .              .             .     .      {
              .       .    .              .              .       .              .             .     .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
              .       .    .              .              .       .              .             .     .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
              .       .    .              .              .       .              .             .     .  |    Search for a model the specified number of conflicts. 
              .       .    .              .              .       .              .             .     .  |  
              .       .    .              .              .       .              .             .     .  |  Output:
              .       .    .              .              .       .              .             .     .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
              .       .    .              .              .       .              .             .     .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
              .       .    .              .              .       .              .             .     .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
              .       .    .              .              .       .              .             .     .  |________________________________________________________________________________________________@*/
              .       .    .              .              .       .              .             .     .  lbool Solver::search(int& nof_conflicts)
         67,474   3,559    5              0              0       0         42,938             0     0  {
              .       .    .              .              .       .              .             .     .      assert(ok);
              .       .    .              .              .       .              .             .     .      int         backtrack_level;
              .       .    .              .              .       .              .             .     .      int         lbd;
              .       .    .              .              .       .              .             .     .      vec<Lit>    learnt_clause;
              .       .    .              .              .       .              .             .     .      bool        cached = false;
          6,134       0    0          6,134             51       0              0             0     0      starts++;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // simplify
              .       .    .              .              .       .              .             .     .      //
         24,536       3    3         18,402          6,134       2              0             0     0      if (conflicts >= curSimplify * nbconfbeforesimplify){
              .       .    .              .              .       .              .             .     .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
              .       .    .              .              .       .              .             .     .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
              .       .    .              .              .       .              .             .     .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
              .       .    .              .              .       .              .             .     .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
             48      36    5             48             48       4              0             0     0          nbSimplifyAll++;
            144      48    5              0              0       0             48             0     0          if (!simplifyAll()){
              .       .    .              .              .       .              .             .     .              return l_False;
              .       .    .              .              .       .              .             .     .          }
            336       0    0             96             96       0             48             0     0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
            144       0    0             48              0       0             48             0     0          nbconfbeforesimplify += incSimplify;
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      for (;;){
              .       .    .              .              .       .              .             .     .          CRef confl = propagate();
              .       .    .              .              .       .              .             .     .  
     15,243,766       0    0              0              0       0              0             0     0          if (confl != CRef_Undef){
              .       .    .              .              .       .              .             .     .              // CONFLICT
      8,551,377       0    0      2,850,459          5,911       0              0             0     0              if (VSIDS){
      3,405,750       0    0      1,702,860      1,684,786       0             30             0     0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
              .       .    .              .              .       .              .             .     .              }else
      4,462,941      77    0      2,635,293      1,140,509       0        340,001             0     0                  if (step_size > min_step_size) step_size -= step_size_dec;
              .       .    .              .              .       .              .             .     .  
     11,401,836     112   12      5,700,918      2,901,888       0      2,850,459             0     0              conflicts++; nof_conflicts--;
              .       .    .              .              .       .              .             .     .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
              .       .    .              .              .       .              .             .     .              ConflictData data = FindConflictLevel(confl);
      5,700,918     131    1              0              0       0              0             0     0              if (data.nHighestLevel == 0) return l_False;
         10,546       0    0          4,730              0       0              0             0     0              if (data.bOnlyOneLitFromHighest)
              .       .    .              .              .       .              .             .     .              {
            543      30    0              0              0       0              0             0     0  				cancelUntil(data.nHighestLevel - 1);
              .       .    .              .              .       .              .             .     .  				continue;
              .       .    .              .              .       .              .             .     .  			}
              .       .    .              .              .       .              .             .     .  			
              .       .    .              .              .       .              .             .     .              learnt_clause.clear();
      5,699,832       0    0              0              0       0      2,849,916     2,808,379     0              if(conflicts>50000) DISTANCE=0;
              .       .    .              .              .       .              .             .     .              else DISTANCE=1;
      9,105,140       0    0              0              0       0              0             0     0              if(VSIDS && DISTANCE)
         39,380       5    1              0              0       0          9,845             0     0                  collectFirstUIP(confl);
              .       .    .              .              .       .              .             .     .  
     17,099,496     118    3              0              0       0      2,849,916             0     0              analyze(confl, learnt_clause, backtrack_level, lbd);
              .       .    .              .              .       .              .             .     .              // check chrono backtrack condition
     39,870,831      54   10     14,245,581      2,268,806       0              0             0     0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
              .       .    .              .              .       .              .             .     .              {
          4,015       0    0          4,015            625       0              0             0     0  				++chrono_backtrack;
          4,015       0    0              0              0       0              0             0     0  				cancelUntil(data.nHighestLevel -1);
              .       .    .              .              .       .              .             .     .  			}
              .       .    .              .              .       .              .             .     .  			else // default behavior
              .       .    .              .              .       .              .             .     .  			{
      2,845,901     507    7      2,845,901      1,229,546       0              0             0     0  				++non_chrono_backtrack;
              .       .    .              .              .       .              .             .     .  				cancelUntil(backtrack_level);
              .       .    .              .              .       .              .             .     .  			}
              .       .    .              .              .       .              .             .     .  
      8,549,748       0    0      2,849,916      2,441,724       0      2,849,916             0     0              lbd--;
      5,699,832       0    0      2,849,916              0       0              0             0     0              if (VSIDS){
      1,702,654      35    5              0              0       0      1,702,654             0     0                  cached = false;
      5,107,962     226    7      5,107,962      3,065,992       0              0             0     0                  conflicts_VSIDS++;
              .       .    .              .              .       .              .             .     .                  lbd_queue.push(lbd);
     13,621,232       0    0      5,107,962              0       0      1,702,654             0     0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
              .       .    .              .              .       .              .             .     .  
      8,549,748      48    9      2,849,916              0       0              0             0     0              if (learnt_clause.size() == 1){
              7       1    0              2              0       0              1             0     0                  uncheckedEnqueue(learnt_clause[0]);
              .       .    .              .              .       .              .             .     .              }else{
              .       .    .              .              .       .              .             .     .                  CRef cr = ca.alloc(learnt_clause, true);
      2,849,915       0    0      2,849,915              0       0              0             0     0                  ca[cr].set_lbd(lbd);
              .       .    .              .              .       .              .             .     .                  //duplicate learnts 
              .       .    .              .              .       .              .             .     .                  int  id = 0;
      5,699,830       0    0      2,849,915      2,845,665       0              0             0     0                  if (lbd <= max_lbd_dup){                        
              .       .    .              .              .       .              .             .     .                      std::vector<uint32_t> tmp;
    100,330,658       0    0     68,152,742              0       0      1,082,345             0     0                      for (int i = 0; i < learnt_clause.size(); i++)
     70,317,432      13    4     46,878,288              3       0     23,439,144             0     0                          tmp.push_back(learnt_clause[i].x);
      3,247,035       6    3      1,082,345              0       0      1,082,345             0     0                      id = is_duplicate(tmp);             
      5,411,725       0    0      1,082,345              0       0              0             0     0                      if (id == min_number_of_learnts_copies +1){
             13       0    0             13              6       0              0             0     0                          duplicates_added_conflicts++;                        
              .       .    .              .              .       .              .             .     .                      }                    
      2,164,690       0    0              0              0       0              0             0     0                      if (id == min_number_of_learnts_copies){
            154       0    0            154             29       0              0             0     0                          duplicates_added_tier2++;
              .       .    .              .              .       .              .             .     .                      }                                        
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .                  //duplicate learnts
              .       .    .              .              .       .              .             .     .  
     17,073,810       0    0      5,693,410      1,144,134       0              0             0     0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
             16       3    1              0              0       0              0             0     0                      learnts_core.push(cr);
              .       .    .              .              .       .              .             .     .                      ca[cr].mark(CORE);
     11,184,060   2,146    6              0              0       0              0             0     0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
             19       2    1              0              0       0              0             0     0                      learnts_tier2.push(cr);
              .       .    .              .              .       .              .             .     .                      ca[cr].mark(TIER2);
        379,904       0    0         94,976             83       0         94,976            68     0                      ca[cr].touched() = conflicts;
              .       .    .              .              .       .              .             .     .                  }else{
             22      19    1              0              0       0              0             0     0                      learnts_local.push(cr);
              .       .    .              .              .       .              .             .     .                      claBumpActivity(ca[cr]); }
      8,549,745   1,330    6              0              0       0      2,849,915             0     0                  attachClause(cr);
              .       .    .              .              .       .              .             .     .  
     17,099,490       0    0      8,549,745          1,139       0      2,849,915             0     0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
              .       .    .              .              .       .              .             .     .  #ifdef PRINT_OUT
              .       .    .              .              .       .              .             .     .                  std::cout << "new " << ca[cr] << "\n";
              .       .    .              .              .       .              .             .     .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
              .       .    .              .              .       .              .             .     .  #endif                
              .       .    .              .              .       .              .             .     .              }
      8,549,748       0    0      2,849,916      1,600,362       0              0             0     0              if (drup_file){
              .       .    .              .              .       .              .             .     .  #ifdef BIN_DRUP
              .       .    .              .              .       .              .             .     .                  binDRUP('a', learnt_clause, drup_file);
              .       .    .              .              .       .              .             .     .  #else
              .       .    .              .              .       .              .             .     .                  for (int i = 0; i < learnt_clause.size(); i++)
              .       .    .              .              .       .              .             .     .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
              .       .    .              .              .       .              .             .     .                  fprintf(drup_file, "0\n");
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
      8,549,748     353    5      5,699,832      1,698,799       2              0             0     0              if (VSIDS) varDecayActivity();
              .       .    .              .              .       .              .             .     .              claDecayActivity();
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              /*if (--learntsize_adjust_cnt == 0){
              .       .    .              .              .       .              .             .     .                  learntsize_adjust_confl *= learntsize_adjust_inc;
              .       .    .              .              .       .              .             .     .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
              .       .    .              .              .       .              .             .     .                  max_learnts             *= learntsize_inc;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
              .       .    .              .              .       .              .             .     .                             (int)conflicts,
              .       .    .              .              .       .              .             .     .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
              .       .    .              .              .       .              .             .     .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
              .       .    .              .              .       .              .             .     .              }*/
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .          }else{
              .       .    .              .              .       .              .             .     .              // NO CONFLICT
              .       .    .              .              .       .              .             .     .              bool restart = false;
     14,314,272      37    7      4,771,424        197,022       0              0             0     0              if (!VSIDS)
              .       .    .              .              .       .              .             .     .                  restart = nof_conflicts <= 0;
      4,789,676       1    1      2,394,838              0       0              0             0     0              else if (!cached){
     13,788,562       1    0      3,920,221      1,532,860       0        844,838             0     0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
              .       .    .              .              .       .              .             .     .                  cached = true;
              .       .    .              .              .       .              .             .     .              }
      7,129,758       0    0      2,376,586      1,085,735       0              0             0     0              if (restart /*|| !withinBudget()*/){
              .       .    .              .              .       .              .             .     .                  lbd_queue.clear();
              .       .    .              .              .       .              .             .     .                  cached = false;
              .       .    .              .              .       .              .             .     .                  // Reached bound on number of conflicts:
         18,399       0    0              0              0       0         12,266         5,877     0                  progress_estimate = progressEstimate();
              .       .    .              .              .       .              .             .     .                  cancelUntil(0);
         12,266       0    0              0              0       0              0             0     0                  return l_Undef; }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Simplify the set of problem clauses:
     15,059,907      74    7      4,765,291              0       0        745,632             0     0              if (decisionLevel() == 0 && !simplify())
              .       .    .              .              .       .              .             .     .                  return l_False;
              .       .    .              .              .       .              .             .     .  
     14,295,873      27    1      9,530,582      1,811,977       0              0             0     0              if (conflicts >= next_T2_reduce){
            570       0    0              0              0       0            285             0     0                  next_T2_reduce = conflicts + 10000;
          1,140       0    0            285              0       0            285             0     0                  reduceDB_Tier2(); }
      9,530,582      21    1      4,765,291          5,862       0              0             0     0              if (conflicts >= next_L_reduce){
            380       0    0              0              0       0            190             0     0                  next_L_reduce = conflicts + 15000;
            380       0    0              0              0       0            190             0     0                  reduceDB(); }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              Lit next = lit_Undef;
              .       .    .              .              .       .              .             .     .              /*while (decisionLevel() < assumptions.size()){
              .       .    .              .              .       .              .             .     .                  // Perform user provided assumption:
              .       .    .              .              .       .              .             .     .                  Lit p = assumptions[decisionLevel()];
              .       .    .              .              .       .              .             .     .                  if (value(p) == l_True){
              .       .    .              .              .       .              .             .     .                      // Dummy decision level:
              .       .    .              .              .       .              .             .     .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
              .       .    .              .              .       .              .             .     .                  }else{
              .       .    .              .              .       .              .             .     .                      next = p;
              .       .    .              .              .       .              .             .     .                      break;
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              if (next == lit_Undef)*/{
              .       .    .              .              .       .              .             .     .                  // New variable decision:
      4,765,291       0    0      4,765,291            190       0              0             0     0                  decisions++;
     14,295,873     374    6              0              0       0      4,765,291             0     0                  next = pickBranchLit();
              .       .    .              .              .       .              .             .     .  
      9,530,582       0    0              0              0       0              0             0     0                  if (next == lit_Undef)
              .       .    .              .              .       .              .             .     .                      // Model found:
              2       0    0              0              0       0              0             0     0                      return l_True;
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .              // Increase decision level and enqueue 'next'
              .       .    .              .              .       .              .             .     .              newDecisionLevel();
     28,591,740      40   10      4,765,290              0       0      4,765,290             0     0              uncheckedEnqueue(next, decisionLevel());
              .       .    .              .              .       .              .             .     .  #ifdef PRINT_OUT            
              .       .    .              .              .       .              .             .     .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
              .       .    .              .              .       .              .             .     .  #endif            
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
         55,206      38    6         42,938          6,134       2              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  double Solver::progressEstimate() const
         36,798       5    4              0              0       0         30,665             0     0  {
         12,266       0    0              0              0       0              0             0     0      double  progress = 0;
         30,665       0    0         12,266          5,597       0          6,133             0     0      double  F = 1.0 / nVars();
              .       .    .              .              .       .              .             .     .  
      1,126,274       4    4              0              0       0              0             0     0      for (int i = 0; i <= decisionLevel(); i++){
      1,089,476       0    0        718,140              0       0              0             0     0          int beg = i == 0 ? 0 : trail_lim[i - 1];
      1,454,679       0    0        724,273         29,021       0              0             0     0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
      2,209,617      27    9        371,336              0       0              0             0     0          progress += pow(F, i) * (end - beg);
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
         12,266       0    0              0              0       0              0             0     0      return progress / nVars();
         42,931       0    0         36,798              0       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  /*
              .       .    .              .              .       .              .             .     .    Finite subsequences of the Luby-sequence:
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .    0: 1
              .       .    .              .              .       .              .             .     .    1: 1 1 2
              .       .    .              .              .       .              .             .     .    2: 1 1 2 1 1 2 4
              .       .    .              .              .       .              .             .     .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .   */
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  static double luby(double y, int x){
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Find the finite subsequence that contains index 'x', and the
              .       .    .              .              .       .              .             .     .      // size of that subsequence:
              .       .    .              .              .       .              .             .     .      int size, seq;
        106,603       0    0              0              0       0              0             0     0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
              .       .    .              .              .       .              .             .     .  
         59,765      12    6              0              0       0              0             0     0      while (size-1 != x){
         34,214       0    0              0              0       0              0             0     0          size = (size-1)>>1;
         17,107       0    0              0              0       0              0             0     0          seq--;
         51,321       0    0              0              0       0              0             0     0          x = x % size;
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      return pow(y, seq);
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  static bool switch_mode = false;
              .       .    .              .              .       .              .             .     .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
              .       .    .              .              .       .              .             .     .  
             16       2    2              0              0       0             12             0     0  uint32_t Solver::reduceduplicates(){
              .       .    .              .              .       .              .             .     .      uint32_t removed_duplicates = 0;
              .       .    .              .              .       .              .             .     .      std::vector<std::vector<uint64_t>> tmp;
              .       .    .              .              .       .              .             .     .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
         12,716       0    0              4              0       0              0             0     0      for (auto & outer_mp: ht){//variables
         86,929       0    0              0              0       0              0             0     0          for (auto &inner_mp:outer_mp.second){//sizes
      2,360,392       0    0              0              0       0              0             0     0              for (auto &in_in_mp: inner_mp.second){
      3,438,774       2    2      1,146,258      1,095,383 378,756              0             0     0                  if (in_in_mp.second >= 2){
              .       .    .              .              .       .              .             .     .                  //min_number_of_learnts_copies
        508,310       2    2        203,324          1,412     875        203,324           168     0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
              .       .    .              .              .       .              .             .     .                  }
              .       .    .              .              .       .              .             .     .              }                    
              .       .    .              .              .       .              .             .     .           }
              .       .    .              .              .       .              .             .     .      }          
              6       0    0              2              2       0              2             0     0      removed_duplicates = dupl_db_size-tmp.size();  
              .       .    .              .              .       .              .             .     .      ht.clear();
        355,827       2    2        152,495             14       1              0             0     0      for (auto i=0;i<tmp.size();i++){
        508,310       0    0        254,155         57,217  19,844        152,493             7     1          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .      return removed_duplicates;
             18       0    0             16              4       1              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  // NOTE: assumptions passed in member-variable 'assumptions'.
              .       .    .              .              .       .              .             .     .  lbool Solver::solve_()
              8       0    0              0              0       0              6             0     0  {
              .       .    .              .              .       .              .             .     .      //signal(SIGALRM, SIGALRM_switch);
              .       .    .              .              .       .              .             .     .      //alarm(2500);
              .       .    .              .              .       .              .             .     .  
              1       1    1              0              0       0              0             0     0      model.clear();
              .       .    .              .              .       .              .             .     .      conflict.clear();
              2       1    1              1              0       0              0             0     0      if (!ok) return l_False;
              .       .    .              .              .       .              .             .     .  
              1       1    1              1              0       0              0             0     0      solves++;
              .       .    .              .              .       .              .             .     .  
              5       0    0              2              1       0              1             0     0      max_learnts               = nClauses() * learntsize_factor;
              3       0    0              1              1       0              0             0     0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
              1       0    0              0              0       0              1             1     0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
              .       .    .              .              .       .              .             .     .      lbool   status            = l_Undef;
              .       .    .              .              .       .              .             .     .  
              3       0    0              1              0       0              0             0     0      if (verbosity >= 1){
              2       0    0              0              0       0              1             0     0          printf("c ============================[ Search Statistics ]==============================\n");
              2       1    1              0              0       0              1             0     0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
              2       0    0              0              0       0              1             0     0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
              2       0    0              0              0       0              1             0     0          printf("c ===============================================================================\n");
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      add_tmp.clear();
              .       .    .              .              .       .              .             .     .  
              1       0    0              0              0       0              1             0     0      VSIDS = true;
              1       1    1              0              0       0              1             0     0      int init = 10000;
            255       0    0             51             51       0              0             0     0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
            204       3    0              0              0       0             51             0     0          status = search(init);
              1       0    0              0              0       0              1             0     0      VSIDS = false;
              .       .    .              .              .       .              .             .     .  
              3       1    1              0              0       0              2             2     0      duplicates_added_conflicts = 0;
              .       .    .              .              .       .              .             .     .      duplicates_added_minimization=0;
              .       .    .              .              .       .              .             .     .      duplicates_added_tier2 =0;    
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      dupl_db_size=0;
              1       0    0              1              1       0              0             0     0      size_t dupl_db_size_limit = dupl_db_init_size;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // Search:
              1       0    0              0              0       0              0             0     0      int curr_restarts = 0;
              1       0    0              0              0       0              0             0     0      uint64_t curr_props = 0;
              .       .    .              .              .       .              .             .     .      uint32_t removed_duplicates =0;
         12,166   1,695    3              0              0       0              0             0     0      while (status == l_Undef /*&& withinBudget()*/){
         12,166       1    1          6,083          3,953       0              0             0     0          if (dupl_db_size >= dupl_db_size_limit){    
              8       2    2              2              2       0              2             0     0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
              8       0    0              2              0       0              2             0     0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
              8       0    0              2              0       0              2             0     0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
              8       2    2              2              2       0              2             0     0              printf("c Duptime: %i\n",duptime.count());
              8       0    0              2              2       0              2             0     0              printf("c Number of conflicts: %i\n",conflicts);
              8       0    0              2              2       0              2             0     0              printf("c Core size: %i\n",learnts_core.size());
              .       .    .              .              .       .              .             .     .              
              4       0    0              0              0       0              2             0     0              removed_duplicates = reduceduplicates();
             16       2    2              4              4       0              0             0     0              dupl_db_size_limit*=1.1;
              4       0    0              2              2       0              0             0     0              dupl_db_size -= removed_duplicates;
             10       0    0              0              0       0              2             0     0              printf("c removed duplicates %i\n",removed_duplicates);
              .       .    .              .              .       .              .             .     .          }   
         36,498     155    3         12,166          9,904       1              0             0     0          if (propagations - curr_props >  VSIDS_props_limit){
             24       0    0              0              0       0              0             0     0              curr_props = propagations;
             24       0    0              0              0       0             24             2     0              switch_mode = true;
            121       0    0              0              0       0             24             0     0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
              .       .    .              .              .       .              .             .     .          }     
         12,166       0    0          6,083              2       0              0             0     0          if (VSIDS){
          3,966       0    0              0              0       0          3,966         3,965     2              int weighted = INT32_MAX;
         15,864   3,922    3              0              0       0          3,966             0     0              status = search(weighted);
              .       .    .              .              .       .              .             .     .          }else{
         12,702   1,071    7          4,234              0       0          2,117         2,110     0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          2,117       0    0              0              0       0              0             0     0              curr_restarts++;
         10,585   1,959    0              0              0       0          2,117             0     0              status = search(nof_conflicts);
              .       .    .              .              .       .              .             .     .          }
         12,166   1,955    1          6,083          6,083       4              0             0     0          if (switch_mode){ 
             24       0    0              0              0       0             24             0     0              switch_mode = false;
              .       .    .              .              .       .              .             .     .              VSIDS = !VSIDS;
             48       0    0             24              0       0              0             0     0              if (VSIDS){
             24      12    3              0              0       0             12             0     0                  printf("c Switched to VSIDS.\n");
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              else{
             36      12    7              0              0       0             12             0     0                 printf("c Switched to LRB.\n");
              .       .    .              .              .       .              .             .     .              }
              .       .    .              .              .       .              .             .     .              //            reduceduplicates();            
             48      12    6             24             24       3             24             0     0              fflush(stdout);
              .       .    .              .              .       .              .             .     .              picked.clear();
              .       .    .              .              .       .              .             .     .              conflicted.clear();
              .       .    .              .              .       .              .             .     .              almost_conflicted.clear();
              .       .    .              .              .       .              .             .     .  #ifdef ANTI_EXPLORATION
              .       .    .              .              .       .              .             .     .              canceled.clear();
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              3       1    1              1              1       0              0             0     0      if (verbosity >= 1)
              2       0    0              0              0       0              1             0     0          printf("c ===============================================================================\n");
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  #ifdef BIN_DRUP
              3       0    0              1              0       0              0             0     0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
              .       .    .              .              .       .              .             .     .  #endif
              .       .    .              .              .       .              .             .     .  
              2       1    1              0              0       0              0             0     0      if (status == l_True){
              .       .    .              .              .       .              .             .     .          // Extend & copy model:
              .       .    .              .              .       .              .             .     .          model.growTo(nVars());
            843       0    0            417             67       1            418             0     0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
              .       .    .              .              .       .              .             .     .      }else if (status == l_False && conflict.size() == 0)
              .       .    .              .              .       .              .             .     .          ok = false;
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      cancelUntil(0);
              1       0    0              0              0       0              0             0     0      return status;
              8       1    1              7              2       1              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  //=================================================================================================
              .       .    .              .              .       .              .             .     .  // Writing CNF to DIMACS:
              .       .    .              .              .       .              .             .     .  // 
              .       .    .              .              .       .              .             .     .  // FIXME: this needs to be rewritten completely.
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  static Var mapVar(Var x, vec<Var>& map, Var& max)
              .       .    .              .              .       .              .             .     .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
              .       .    .              .              .       .              .             .     .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
              .       .    .              .              .       .              .             .     .  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  //=================================================================================================
              .       .    .              .              .       .              .             .     .  // Garbage Collection methods:
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::relocAll(ClauseAllocator& to)
          1,910     101   12              0              0       0          1,528             0     0  {
              .       .    .              .              .       .              .             .     .      // All watchers:
              .       .    .              .              .       .              .             .     .      //
              .       .    .              .              .       .              .             .     .      // for (int i = 0; i < watches.size(); i++)
            382       0    0              0              0       0            191             1     0      watches.cleanAll();
            382       0    0              0              0       0            191             0     0      watches_bin.cleanAll();
     12,717,926      10    5      8,901,937         16,555       0      1,272,060           190     0      for (int v = 0; v < nVars(); v++)
      5,086,712       0    0      2,543,356              0       0              0             0     0          for (int s = 0; s < 2; s++){
              .       .    .              .              .       .              .             .     .              Lit p = mkLit(v, s);
              .       .    .              .              .       .              .             .     .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
              .       .    .              .              .       .              .             .     .              vec<Watcher>& ws = watches[p];
    125,760,332      55    9     62,475,440        636,030   1,759              0             0     0              for (int j = 0; j < ws.size(); j++)
              .       .    .              .              .       .              .             .     .                  ca.reloc(ws[j].cref, to);
              .       .    .              .              .       .              .             .     .              vec<Watcher>& ws_bin = watches_bin[p];
     21,264,290       8    3      8,105,088        650,275   1,781              0             0     0              for (int j = 0; j < ws_bin.size(); j++)
              .       .    .              .              .       .              .             .     .                  ca.reloc(ws_bin[j].cref, to);
              .       .    .              .              .       .              .             .     .          }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // All reasons:
              .       .    .              .              .       .              .             .     .      //
        174,124       0    0            573            191       0              0             0     0      for (int i = 0; i < trail.size(); i++){
              .       .    .              .              .       .              .             .     .          Var v = var(trail[i]);
              .       .    .              .              .       .              .             .     .  
        285,610       0    0         56,316         54,164       0              0             0     0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
        281,962       0    0         56,316              0       0         56,316             0     0              ca.reloc(vardata[v].reason, to);
              .       .    .              .              .       .              .             .     .      }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // All learnt:
              .       .    .              .              .       .              .             .     .      //
     12,370,463     163    3      6,185,135            322       0              0             0     0      for (int i = 0; i < learnts_core.size(); i++)
              .       .    .              .              .       .              .             .     .          ca.reloc(learnts_core[i], to);
        938,128     571    9        469,063            378       0              0             0     0      for (int i = 0; i < learnts_tier2.size(); i++)
              .       .    .              .              .       .              .             .     .          ca.reloc(learnts_tier2[i], to);
      5,518,338     191    3      2,758,788            191       0              0             0     0      for (int i = 0; i < learnts_local.size(); i++)
      8,275,218       0    0              0              0       0      2,758,406           189     0          ca.reloc(learnts_local[i], to);
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      // All original:
              .       .    .              .              .       .              .             .     .      //
              .       .    .              .              .       .              .             .     .      int i, j;
     11,412,131     191    3            764            378       0              0             0     0      for (i = j = 0; i < clauses.size(); i++)
     11,410,412       0    0              0              0       0              0             0     0          if (ca[clauses[i]].mark() != 1){
     17,116,000     191    3      5,705,206              0       0      5,705,206             1     0              ca.reloc(clauses[i], to);
     57,051,869     163    3     22,820,633              0       0      5,705,206             0     0              clauses[j++] = clauses[i]; }
            191     190    3              0              0       0              0             0     0      clauses.shrink(i - j);
          1,528     190    3          1,337            191       0              0             0     0  }
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .  void Solver::garbageCollect()
              .       .    .              .              .       .              .             .     .  {
              .       .    .              .              .       .              .             .     .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
              .       .    .              .              .       .              .             .     .      // is not precise but should avoid some unnecessary reallocations for the new region:
              .       .    .              .              .       .              .             .     .      ClauseAllocator to(ca.size() - ca.wasted());
              .       .    .              .              .       .              .             .     .  
              .       .    .              .              .       .              .             .     .      relocAll(to);
              .       .    .              .              .       .              .             .     .      if (verbosity >= 2)
              .       .    .              .              .       .              .             .     .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
              .       .    .              .              .       .              .             .     .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
              .       .    .              .              .       .              .             .     .      to.moveTo(ca);
            155      18   18             47              4       4             61             0     0  }

--------------------------------------------------------------------------------
Ir                I1mr    ILmr  Dr              D1mr           DLmr    Dw              D1mw           DLmw      
--------------------------------------------------------------------------------
2,716,060,972,908 535,746 2,364 937,115,091,143 61,280,122,747 791,779 339,349,548,900 15,228,213,132 1,462,197  events annotated

