--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/knight_20.cnf
Data file:        knight_20.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr      ILmr    Dr                D1mr            DLmr          Dw              D1mw           DLmw        
--------------------------------------------------------------------------------
4,579,461,897,648 5,600,050 768,583 1,404,072,893,592 162,126,791,986 3,707,208,929 433,414,457,755 29,683,637,236 518,520,599  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir              I1mr    ILmr   Dr              D1mr           DLmr          Dw              D1mw          DLmw         file:function
--------------------------------------------------------------------------------
784,673,851,167  99,891  7,205 276,334,854,317 29,994,713,516    12,732,274  54,749,028,243 5,158,075,477          34  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
644,971,707,540 268,602  4,011 203,042,901,241      1,396,762             0 108,599,024,428 1,146,677,705     398,872  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
641,828,908,100  64,115  1,442 155,597,710,130 19,884,800,507 1,962,242,684  58,746,682,418    16,749,566          77  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
343,501,326,128     231    231  83,688,109,015 11,627,213,212    69,968,641               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
267,376,917,230       4      4  78,182,510,668 14,946,096,233   387,571,145  16,541,180,745             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
184,798,325,795 489,150 89,143  39,507,852,043     89,687,383        62,788  17,056,354,434    12,830,708         134  ???:__ieee754_pow_fma
130,373,381,860     917    816  23,881,138,209  2,856,695,378    10,153,410  12,277,729,937 2,007,402,883   1,698,770  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
124,508,875,396 227,644  4,274  19,579,472,727    828,123,177    67,468,886   7,635,499,978   856,298,340 266,294,763  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
118,758,745,393  46,862 10,027  44,689,646,701 10,925,220,308     5,314,401  12,656,192,655 4,087,168,995     855,198  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
115,896,456,953 109,294 22,713  39,505,922,360  9,394,954,046     5,483,464   9,164,828,418 1,433,540,138      13,069  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
106,700,181,140       5      5  45,373,881,456  2,632,240,036     3,375,731  32,485,431,695 8,315,867,794  24,273,398  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 95,024,504,930  64,851  2,302  37,474,543,344  5,637,503,806     4,907,870  24,532,824,771   322,576,952     588,321  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
 88,635,961,939  26,055  8,747  27,859,045,497     66,052,682           673   8,186,074,674   236,005,637   3,103,521  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 83,178,555,949   3,925  2,747  34,611,169,109 19,348,521,490     1,151,121               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 66,054,789,435     447    447  15,510,796,815  3,806,658,580   296,139,399   7,030,220,274   849,300,066   2,841,259  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
 64,500,047,953  14,590  5,081  19,569,389,800  1,839,940,622    23,191,443      64,508,814       941,627           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 64,298,963,770     104    104  30,063,005,946  3,468,926,796     4,960,835   3,960,204,742   257,342,740     100,425  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
 61,355,189,692  48,991 16,186  14,640,837,928    175,154,969       502,738   1,656,036,434     6,267,654          76  ???:__exp1_fma
 44,410,209,749  98,264  4,893  14,764,018,933     55,591,228             0   5,458,116,488   149,085,901   2,187,069  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
 35,712,383,316     120    120   9,362,762,312  1,824,911,275    53,246,281               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
 31,535,257,487  12,231  3,867  13,983,032,350  4,294,506,051     7,478,890     997,693,780            33           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 29,762,373,402   6,651  2,521  13,331,526,569    343,750,231     9,185,934               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
 29,595,775,953       0      0  19,730,517,302    378,413,612             1               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
 25,049,318,951  19,061    558   9,347,423,125  2,166,440,942       496,943      50,708,646     9,572,634   1,728,129  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::collectFirstUIP(unsigned int)
 24,623,341,606       0      0  16,022,468,918    303,812,463    10,280,812   3,710,798,115 2,422,393,303   2,771,715  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
 24,350,755,464      17     17   8,464,575,631      5,418,500            63   7,421,604,202   241,136,362  10,777,100  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 22,717,454,290       3      3  18,210,691,443  3,944,472,089        97,905   4,381,046,955             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
 22,410,114,917      86     86   4,691,598,170    267,017,517     6,084,085   3,958,156,693   333,262,609  44,144,757  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
 22,140,928,780  34,543 12,164   5,987,005,385         93,547        11,005   3,565,887,885       512,718           1  ???:pow
 18,897,437,577   1,068  1,068   4,720,429,294    572,749,387   252,722,582   2,521,621,924    77,452,166  77,419,202  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
 14,843,208,404       0      0   3,710,802,101              0             0   3,710,802,101       761,188           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 14,524,105,942       9      9   2,083,598,384     90,396,861       963,105       6,085,203            23           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::SimpSolver::backwardSubsumptionCheck(bool)
 13,619,567,768  14,309  3,496   4,381,901,556  1,316,153,191    23,027,785   2,168,529,293   432,991,818   1,327,957  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
 12,793,034,486   3,628  2,541   6,545,216,572  1,920,833,849     7,205,563               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::pickBranchLit()
 12,515,657,148       0      0   7,300,800,003    963,817,330     1,332,611   1,042,971,429             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
 12,381,084,366     102     99   3,387,696,790  1,192,674,695       608,735   2,285,047,938   450,128,646     558,079  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
 12,152,058,305       0      0     347,236,167         55,663             7     487,805,036             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::pickBranchLit()
  9,540,106,668     214     74   3,151,995,556      1,532,219            11      35,138,239     1,537,995      27,441  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::collectFirstUIP(unsigned int)
  9,518,323,579       0      0   6,225,225,992  1,630,983,056     1,682,992               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  8,920,142,426     435    435   1,916,742,231    271,631,677    19,750,534     313,317,203     2,103,341          80  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::removeSatisfied(Minisat::vec<unsigned int>&)
  8,914,362,904       0      0               0              0             0               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  7,300,800,003       0      0   1,042,971,429      5,565,268           212   3,128,914,287     5,747,975          43  /usr/include/c++/8/cmath:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  6,965,940,578     427    335   1,385,027,831     70,912,803       129,199     943,017,052    60,253,740  58,825,643  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::search(int&)
  6,681,460,617     244    244   2,171,042,343    664,896,198        90,642      34,990,631             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simpleAnalyze(unsigned int, Minisat::vec<Minisat::Lit>&, Minisat::vec<unsigned int>&, bool)
  6,251,184,361   5,879     44      54,969,052     14,507,843     1,724,542               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::collectFirstUIP(unsigned int)
  5,734,329,170  72,758  4,156   2,418,433,278    461,303,998     2,626,790     687,557,303        27,492           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::pickBranchLit()
  5,284,062,591   1,198  1,198   1,953,493,560     21,720,346    18,773,825     371,813,277           159          70  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
  5,263,590,959     258    258   1,554,800,068     93,726,184    89,851,877     769,009,328        94,853           1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
  5,012,460,838 164,863 36,140     736,895,399     21,013,630         7,108     185,156,860     1,614,928          48  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::search(int&)
  4,907,482,432       0      0   2,453,741,216     15,542,768            73               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
  4,883,961,800     145    145   1,290,108,403    381,493,056   157,770,280               0             0           0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::removeSatisfied(Minisat::vec<unsigned int>&)

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/8/cmath
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr            D1mr      DLmr Dw            D1mw      DLmw 

-- line 410 ----------------------------------------
            .    .    .             .         .    .             .         .    .  #endif
            .    .    .             .         .    .             .         .    .  
            .    .    .             .         .    .             .         .    .    template<typename _Tp, typename _Up>
            .    .    .             .         .    .             .         .    .      inline _GLIBCXX_CONSTEXPR
            .    .    .             .         .    .             .         .    .      typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
            .    .    .             .         .    .             .         .    .      pow(_Tp __x, _Up __y)
            .    .    .             .         .    .             .         .    .      {
            .    .    .             .         .    .             .         .    .        typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
8,090,096,716   39   39 1,188,627,248 6,322,889  286 3,274,572,153 5,747,975   43        return pow(__type(__x), __type(__y));
            .    .    .             .         .    .             .         .    .      }
            .    .    .             .         .    .             .         .    .  
            .    .    .             .         .    .             .         .    .    using ::sin;
            .    .    .             .         .    .             .         .    .  
            .    .    .             .         .    .             .         .    .  #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
            .    .    .             .         .    .             .         .    .    inline _GLIBCXX_CONSTEXPR float
            .    .    .             .         .    .             .         .    .    sin(float __x)
            .    .    .             .         .    .             .         .    .    { return __builtin_sinf(__x); }
-- line 426 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr              D1mr           DLmr        Dw             D1mw          DLmw       

-- line 51 ----------------------------------------
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  //=================================================================================================
              .       .     .               .              .           .              .             .          .  // Options:
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  static const char* _cat = "CORE";
              .       .     .               .              .           .              .             .          .  
              4       0     0               0              0           0              1             0          0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
              4       0     0               0              0           0              1             0          0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
              4       0     0               0              0           0              1             0          0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
              4       1     1               0              0           0              1             0          0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
              4       0     0               0              0           0              1             0          0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
              4       0     0               0              0           0              1             0          0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
              4       0     0               0              0           0              1             0          0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
              4       0     0               0              0           0              1             0          0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
              4       0     0               0              0           0              1             0          0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
              4       1     1               0              0           0              1             0          0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
              4       0     0               0              0           0              1             0          0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
              4       1     1               0              0           0              1             0          0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
              4       1     1               0              0           0              1             0          0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
              4       1     1               0              0           0              1             0          0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
              4       1     1               0              0           0              1             0          0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
              .       .     .               .              .           .              .             .          .  
              4       1     1               0              0           0              1             0          0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
              1       1     1               0              0           0              1             0          0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
              4       0     0               0              0           0              1             0          0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
              .       .     .               .              .           .              .             .          .  
              4       1     1               0              0           0              1             0          0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  //VSIDS_props_limit
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  //=================================================================================================
              .       .     .               .              .           .              .             .          .  // Constructor/Destructor:
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              4       1     1               0              0           0              2             0          0  Solver::Solver() :
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Parameters (user settable):
              .       .     .               .              .           .              .             .          .      //
              .       .     .               .              .           .              .             .          .      drup_file        (NULL)
              .       .     .               .              .           .              .             .          .    , verbosity        (0)
              .       .     .               .              .           .              .             .          .    , step_size        (opt_step_size)
              .       .     .               .              .           .              .             .          .    , step_size_dec    (opt_step_size_dec)
              .       .     .               .              .           .              .             .          .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
              .       .     .               .              .           .              .             .          .    , garbage_frac     (opt_garbage_frac)
              .       .     .               .              .           .              .             .          .    , restart_first    (opt_restart_first)
              .       .     .               .              .           .              .             .          .    , restart_inc      (opt_restart_inc)
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .    , min_number_of_learnts_copies(opt_min_dupl_app)  
              .       .     .               .              .           .              .             .          .    , max_lbd_dup(opt_max_lbd_dup)
              .       .     .               .              .           .              .             .          .    , dupl_db_init_size(opt_dupl_db_init_size)
              3       1     1               1              0           0              1             0          0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .    // Parameters (the rest):
              .       .     .               .              .           .              .             .          .    //
              .       .     .               .              .           .              .             .          .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .    // Parameters (experimental):
              .       .     .               .              .           .              .             .          .    //
              .       .     .               .              .           .              .             .          .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
              .       .     .               .              .           .              .             .          .    //
              .       .     .               .              .           .              .             .          .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
              .       .     .               .              .           .              .             .          .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
              .       .     .               .              .           .              .             .          .    , chrono_backtrack(0), non_chrono_backtrack(0)
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .    , ok                 (true)
              .       .     .               .              .           .              .             .          .    , cla_inc            (1)
              .       .     .               .              .           .              .             .          .    , var_inc            (1)
              1       0     0               0              0           0              0             0          0    , watches_bin        (WatcherDeleted(ca))
              .       .     .               .              .           .              .             .          .    , watches            (WatcherDeleted(ca))
              .       .     .               .              .           .              .             .          .    , qhead              (0)
              .       .     .               .              .           .              .             .          .    , simpDB_assigns     (-1)
              .       .     .               .              .           .              .             .          .    , simpDB_props       (0)
              .       .     .               .              .           .              .             .          .    , order_heap_CHB     (VarOrderLt(activity_CHB))
              .       .     .               .              .           .              .             .          .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
              .       .     .               .              .           .              .             .          .    , progress_estimate  (0)
              .       .     .               .              .           .              .             .          .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
              .       .     .               .              .           .              .             .          .    // simplifyAll adjust occasion
              .       .     .               .              .           .              .             .          .    , curSimplify(1)
              .       .     .               .              .           .              .             .          .    , nbconfbeforesimplify(1000)
              .       .     .               .              .           .              .             .          .    , incSimplify(1000)
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .    , my_var_decay       (0.6)
              .       .     .               .              .           .              .             .          .    , DISTANCE           (true)
              .       .     .               .              .           .              .             .          .    , var_iLevel_inc     (1)
             94       8     8              25              2           2             63             1          0    , order_heap_distance(VarOrderLt(activity_distance))
              .       .     .               .              .           .              .             .          .  
              4       0     0               3              0           0              0             0          0  {}
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  Solver::~Solver()
              .       .     .               .              .           .              .             .          .  {
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  // simplify All
              .       .     .               .              .           .              .             .          .  //
              .       .     .               .              .           .              .             .          .  CRef Solver::simplePropagate()
     36,329,120       0     0               0              0           0     27,246,840       223,302          0  {
      4,541,140       0     0               0              0           0      4,541,140             0          0      CRef    confl = CRef_Undef;
      4,541,140       0     0               0              0           0      4,541,140            10          0      int     num_props = 0;
      9,082,280       0     0               0              0           0      4,541,140       237,122          1      watches.cleanAll();
     13,623,420      48    48       4,541,140             11           0      4,541,140             0          0      watches_bin.cleanAll();
  2,002,589,224       0     0   1,001,294,612              0           0              0             0          0      while (qhead < trail.size())
              .       .     .               .              .           .              .             .          .      {
  4,983,781,195      19    19   1,993,512,478     59,584,297           0  1,993,512,478             0          0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .     .               .              .           .              .             .          .          vec<Watcher>&  ws = watches[p];
              .       .     .               .              .           .              .             .          .          Watcher        *i, *j, *end;
    996,753,472       5     5     996,753,472            672           0              0             0          0          num_props++;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          // First, Propagate binary clauses
              .       .     .               .              .           .              .             .          .          vec<Watcher>&  wbin = watches_bin[p];
              .       .     .               .              .           .              .             .          .  
  7,123,092,113       0     0     996,756,239    981,748,552  43,059,047              0             0          0          for (int k = 0; k<wbin.size(); k++)
              .       .     .               .              .           .              .             .          .          {
              .       .     .               .              .           .              .             .          .  
  2,661,353,162       0     0   1,401,078,003    221,248,152  54,136,287              0             0          0              Lit imp = wbin[k].blocker;
              .       .     .               .              .           .              .             .          .  
  2,661,353,162       0     0               0              0           0              0             0          0              if (value(imp) == l_False)
              .       .     .               .              .           .              .             .          .              {
          5,534       0     0           2,767              0           0          2,767             0          0                  return wbin[k].cref;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
  2,661,347,628      41    41               0              0           0              0             0          0              if (value(imp) == l_Undef)
              .       .     .               .              .           .              .             .          .              {
    725,429,881       0     0     725,429,881              0           0              0             0          0                  simpleUncheckEnqueue(imp, wbin[k].cref);
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
 10,796,870,695      48    48   2,952,366,816    979,009,366  27,947,264  1,379,480,888            62          0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
              .       .     .               .              .           .              .             .          .          {
              .       .     .               .              .           .              .             .          .              // Try to avoid inspecting the clause:
    958,859,872      48    48     958,859,872    436,684,235  60,327,900              0             0          0              Lit blocker = i->blocker;
  1,917,719,744       0     0     958,859,872    543,462,343       5,733              0             0          0              if (value(blocker) == l_True)
              .       .     .               .              .           .              .             .          .              {
              .       .     .               .              .           .              .             .          .                  *j++ = *i++; continue;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Make sure the false literal is data[1]:
  1,198,862,356       0     0     599,431,178              0           0              0             0          0              CRef     cr = i->cref;
              .       .     .               .              .           .              .             .          .              Clause&  c = ca[cr];
              .       .     .               .              .           .              .             .          .              Lit      false_lit = ~p;
  1,798,293,534       0     0     599,431,178    575,300,002 110,297,556              0             0          0              if (c[0] == false_lit)
     75,732,000       0     0      25,244,000      1,302,529     349,594     50,488,000             0          0                  c[0] = c[1], c[1] = false_lit;
              .       .     .               .              .           .              .             .          .              assert(c[1] == false_lit);
              .       .     .               .              .           .              .             .          .              //  i++;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // If 0th watch is true, then clause is already satisfied.
              .       .     .               .              .           .              .             .          .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
              .       .     .               .              .           .              .             .          .              // why not simply do i->blocker=first in this case?
              .       .     .               .              .           .              .             .          .              Lit     first = c[0];
              .       .     .               .              .           .              .             .          .              //  Watcher w     = Watcher(cr, first);
  1,229,537,468       0     0      15,337,556      6,472,975          75              0             0          0              if (first != blocker && value(first) == l_True)
              .       .     .               .              .           .              .             .          .              {
      3,923,566       0     0               0              0           0      3,923,566             0          0                  i->blocker = first;
  1,453,409,040       0     0     363,352,260              0           0    363,352,260        17,933          0                  *j++ = *i++; continue;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Look for new watch:
              .       .     .               .              .           .              .             .          .              //if (incremental)
              .       .     .               .              .           .              .             .          .              //{ // ----------------- INCREMENTAL MODE
              .       .     .               .              .           .              .             .          .              //	int choosenPos = -1;
              .       .     .               .              .           .              .             .          .              //	for (int k = 2; k < c.size(); k++)
              .       .     .               .              .           .              .             .          .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
              .       .     .               .              .           .              .             .          .              //		Watcher w = Watcher(cr, first); i++;
              .       .     .               .              .           .              .             .          .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
              .       .     .               .              .           .              .             .          .              //		watches[~c[1]].push(w);
              .       .     .               .              .           .              .             .          .              //		goto NextClause;
              .       .     .               .              .           .              .             .          .              //	}
              .       .     .               .              .           .              .             .          .              //}
              .       .     .               .              .           .              .             .          .              else
              .       .     .               .              .           .              .             .          .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
  8,099,596,232      48    48               0              0           0              0             0          0                  for (int k = 2; k < c.size(); k++)
              .       .     .               .              .           .              .             .          .                  {
              .       .     .               .              .           .              .             .          .  
  6,719,108,021       0     0               0              0           0              0             0          0                      if (value(c[k]) != l_False)
              .       .     .               .              .           .              .             .          .                      {
              .       .     .               .              .           .              .             .          .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
              .       .     .               .              .           .              .             .          .                          // the blocker is first in the watcher. However,
              .       .     .               .              .           .              .             .          .                          // the blocker in the corresponding watcher in ~first is not c[1]
              .       .     .               .              .           .              .             .          .                          Watcher w = Watcher(cr, first); i++;
  1,278,324,836       2     2     319,581,209              0           0    639,162,418        44,352          0                          c[1] = c[k]; c[k] = false_lit;
              .       .     .               .              .           .              .             .          .                          watches[~c[1]].push(w);
    319,581,209       0     0               0              0           0              0             0          0                          goto NextClause;
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Did not find watch -- clause is unit under assignment:
    275,926,403       0     0               0              0           0    275,926,403         3,110          0              i->blocker = first;
  1,103,705,612       0     0     275,926,403              0           0    275,926,403        13,796          0              *j++ = *i++;
    551,852,806      48    48               0              0           0              0             0          0              if (value(first) == l_False)
              .       .     .               .              .           .              .             .          .              {
        246,506       0     0               0              0           0         45,828           117          0                  confl = cr;
         91,656      47    47          45,828            884           0         45,828             0          0                  qhead = trail.size();
              .       .     .               .              .           .              .             .          .                  // Copy the remaining watches:
        887,498       3     3          76,798          1,409           0              0             0          0                  while (i < end)
        321,123       0     0         321,123         39,205      15,943        321,123         1,140          0                      *j++ = *i++;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              else
              .       .     .               .              .           .              .             .          .              {
              .       .     .               .              .           .              .             .          .                  simpleUncheckEnqueue(first, cr);
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  NextClause:;
              .       .     .               .              .           .              .             .          .          }
    765,454,832      43    43               0              0           0              0             0          0          ws.shrink(i - j);
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
      9,076,746       0     0       9,076,746        886,172           0              0             0          0      s_propagations += num_props;
              .       .     .               .              .           .              .             .          .  
      4,538,373       0     0       4,538,373              0           0              0             0          0      return confl;
    329,234,893      47    47      31,787,980        888,529           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
              .       .     .               .              .           .              .             .          .      assert(value(p) == l_Undef);
  1,001,310,456       0     0               0              0           0  1,001,310,456             0          0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
  2,011,703,192      48    48   1,005,851,596         29,274           0  1,005,851,596   853,106,707  2,848,657      vardata[var(p)].reason = from;
    280,421,715       0     0     280,421,715              0           0              0             0          0      trail.push_(p);
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::cancelUntilTrailRecord()
              .       .     .               .              .           .              .             .          .  {
  2,013,863,002       0     0         863,924              0           0              0             0          0      for (int c = trail.size() - 1; c >= trailRecord; c--)
              .       .     .               .              .           .              .             .          .      {
        431,962      48    48         431,962              0           0              0             0          0          Var x = var(trail[c]);
  1,007,147,482       0     0         431,962        350,060           0  1,005,851,596   585,661,933          0          assigns[x] = l_Undef;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      }
        431,962       0     0               0              0           0        431,962       418,842          0      qhead = trailRecord;
        863,924       0     0               0              0           0              0             0          0      trail.shrink(trail.size() - trailRecord);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::litsEnqueue(int cutP, Clause& c)
              .       .     .               .              .           .              .             .          .  {
              .       .     .               .              .           .              .             .          .      for (int i = cutP; i < c.size(); i++)
              .       .     .               .              .           .              .             .          .      {
              .       .     .               .              .           .              .             .          .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  bool Solver::removed(CRef cr) {
              .       .     .               .              .           .              .             .          .      return ca[cr].mark() == 1;
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
      4,750,152      45    45               0              0           0      2,590,992             0          0  {
        431,832       0     0               0              0           0              0             0          0      int pathC = 0;
        431,832       0     0               0              0           0              0             0          0      Lit p = lit_Undef;
      1,295,496       0     0         431,832              0           0              0             0          0      int index = trail.size() - 1;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      do{
     32,733,562      48    48               0              0           0              0             0          0          if (confl != CRef_Undef){
              .       .     .               .              .           .              .             .          .              reason_clause.push(confl);
              .       .     .               .              .           .              .             .          .              Clause& c = ca[confl];
              .       .     .               .              .           .              .             .          .              // Special case for binary clauses
              .       .     .               .              .           .              .             .          .              // The first one has to be SAT
     50,890,848      54    54               0              0           0              0             0          0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                  assert(value(c[1]) == l_True);
              .       .     .               .              .           .              .             .          .                  Lit tmp = c[0];
        790,338       0     0         263,446         13,222      10,700        526,892             0          0                  c[0] = c[1], c[1] = tmp;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              // if True_confl==true, then choose p begin with the 1th index of c;
    183,458,400       0     0      25,579,520        679,614           1              0             0          0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
              .       .     .               .              .           .              .             .          .                  Lit q = c[j];
    134,105,008       0     0      67,052,504     20,714,660       3,664              0             0          0                  if (!seen[var(q)]){
     15,937,798       0     0               0              0           0     15,937,798             0          0                      seen[var(q)] = 1;
     47,813,394       0     0      15,937,798              0           0              0             0          0                      pathC++;
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          else if (confl == CRef_Undef){
              .       .     .               .              .           .              .             .          .              out_learnt.push(~p);
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
     60,114,868      48    48      15,935,867          1,145           0              0             0          0          if (pathC == 0) break;
              .       .     .               .              .           .              .             .          .          // Select next clause to look at:
  6,080,647,137       0     0   2,026,882,685    642,078,592      76,277              0             0          0          while (!seen[var(trail[index--])]);
              .       .     .               .              .           .              .             .          .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
              .       .     .               .              .           .              .             .          .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
     31,871,734       0     0      15,935,867        567,329           0              0             0          0          if (trailRecord > index + 1) break;
              .       .     .               .              .           .              .             .          .          p = trail[index + 1];
              .       .     .               .              .           .              .             .          .          confl = reason(var(p));
     15,934,949       0     0               0              0           0     15,934,949             0          0          seen[var(p)] = 0;
     15,934,949       0     0               0              0           0              0             0          0          pathC--;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      } while (pathC >= 0);
      4,318,320      49    49       3,022,824        841,636           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::simplifyLearnt(Clause& c)
      3,887,658      96    96               0              0           0      2,591,772           469          1  {
              .       .     .               .              .           .              .             .          .      ////
        431,962       0     0         431,962          3,174           0              0             0          0      original_length_record += c.size();
              .       .     .               .              .           .              .             .          .  
        863,924       0     0         431,962          1,970           0        431,962             0          0      trailRecord = trail.size();// record the start pointer
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      vec<Lit> falseLit;
              .       .     .               .              .           .              .             .          .      falseLit.clear();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
              .       .     .               .              .           .              .             .          .  
         97,190      47    47               0              0           0              0             0          0      bool True_confl = false;
              .       .     .               .              .           .              .             .          .      int beforeSize, afterSize;
              .       .     .               .              .           .              .             .          .      beforeSize = c.size();
              .       .     .               .              .           .              .             .          .      int i, j;
              .       .     .               .              .           .              .             .          .      CRef confl;
              .       .     .               .              .           .              .             .          .  
     16,614,582      48    48               0              0           0              0             0          0      for (i = 0, j = 0; i < c.size(); i++){
     10,212,204       0     0               0              0           0              0             0          0          if (value(c[i]) == l_Undef){
              .       .     .               .              .           .              .             .          .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
              .       .     .               .              .           .              .             .          .              simpleUncheckEnqueue(~c[i]);
     18,115,965       0     0       4,541,140              0           0      4,541,140         4,519          0              c[j++] = c[i];
     13,623,420       0     0               0              0           0      4,541,140             0          0              confl = simplePropagate();
     13,623,420      48    48       4,541,140        883,674           0              0             0          0              if (confl != CRef_Undef){
              .       .     .               .              .           .              .             .          .                  break;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          else{
      1,129,924       0     0               0              0           0              0             0          0              if (value(c[i]) == l_True){
              .       .     .               .              .           .              .             .          .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
      1,532,948      45    45         383,237              0           0        383,237         1,076          0                  c[j++] = c[i];
        383,237      39    39               0              0           0              0             0          0                  True_confl = true;
              .       .     .               .              .           .              .             .          .                  confl = reason(var(c[i]));
              .       .     .               .              .           .              .             .          .                  break;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              else{
              .       .     .               .              .           .              .             .          .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
              .       .     .               .              .           .              .             .          .                  falseLit.push(c[i]);
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .      c.shrink(c.size() - j);
              .       .     .               .              .           .              .             .          .      afterSize = c.size();
              .       .     .               .              .           .              .             .          .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      if (confl != CRef_Undef || True_confl == true){
        431,832       0     0               0              0           0              0             0          0          simp_learnt_clause.clear();
        431,832       0     0               0              0           0              0             0          0          simp_reason_clause.clear();
        863,664       0     0               0              0           0              0             0          0          if (True_confl == true){
              .       .     .               .              .           .              .             .          .              simp_learnt_clause.push(c.last());
              .       .     .               .              .           .              .             .          .          }
      3,022,824      12    12               0              0           0        431,832             0          0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
              .       .     .               .              .           .              .             .          .  
      1,295,496       0     0         431,832              0           0              0             0          0          if (simp_learnt_clause.size() < c.size()){
      1,092,488      70    68         530,276              0           0              0             0          0              for (i = 0; i < simp_learnt_clause.size(); i++){
      2,089,168       0     0         522,292         21,802           0        522,292        32,716          0                  c[i] = simp_learnt_clause[i];
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              c.shrink(c.size() - i);
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      cancelUntilTrailRecord();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      ////
        431,962       0     0         431,962        418,704           0              0             0          0      simplified_length_record += c.size();
              .       .     .               .              .           .              .             .          .  
      3,455,696       0     0       3,023,734        431,641           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
              .       .     .               .              .           .              .             .          .  {
              .       .     .               .              .           .              .             .          .      int beforeSize, afterSize;
              .       .     .               .              .           .              .             .          .      int learnts_x_size_before = learnts_x.size();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      int ci, cj, li, lj;
              .       .     .               .              .           .              .             .          .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .     .               .              .           .              .             .          .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      return true;
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  bool Solver::simplifyLearnt_core()
            528       0     0               0              0           0            288             0          0  {
              .       .     .               .              .           .              .             .          .      int beforeSize, afterSize;
              .       .     .               .              .           .              .             .          .      int learnts_core_size_before = learnts_core.size();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      int ci, cj, li, lj;
              .       .     .               .              .           .              .             .          .      bool sat, false_lit;
              .       .     .               .              .           .              .             .          .      unsigned int nblevels;
              .       .     .               .              .           .              .             .          .      ////
              .       .     .               .              .           .              .             .          .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      ////
              .       .     .               .              .           .              .             .          .      int nbSimplified = 0;
              .       .     .               .              .           .              .             .          .      int nbSimplifing = 0;
              .       .     .               .              .           .              .             .          .  
     11,228,975      48    48              48              0           0              0             0          0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     16,843,179      48    48      11,228,786        352,640     350,934              0             0          0          CRef cr = learnts_core[ci];
              .       .     .               .              .           .              .             .          .          Clause& c = ca[cr];
              .       .     .               .              .           .              .             .          .  
     11,228,786       0     0               0              0           0              0             0          0          if (removed(cr)) continue;
     11,228,786       0     0       5,614,393        674,457     468,665              0             0          0          else if (c.simplified()){
     10,730,530       0     0               0              0           0      5,365,265           251         41              learnts_core[cj++] = learnts_core[ci];
              .       .     .               .              .           .              .             .          .              ////
     16,099,389       0     0       5,365,265              0           0              0             0          0              nbSimplified++;
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          else{
              .       .     .               .              .           .              .             .          .              int saved_size=c.size();
              .       .     .               .              .           .              .             .          .              //         if (drup_file){
              .       .     .               .              .           .              .             .          .              //                 add_oc.clear();
              .       .     .               .              .           .              .             .          .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .     .               .              .           .              .             .          .              ////
              .       .     .               .              .           .              .             .          .              nbSimplifing++;
        249,120       0     0               0              0           0              0             0          0              sat = false_lit = false;
      5,477,464       0     0               0              0           0              0             0          0              for (int i = 0; i < c.size(); i++){
      5,477,754       0     0               0              0           0              0             0          0                  if (value(c[i]) == l_True){
              .       .     .               .              .           .              .             .          .                      sat = true;
              .       .     .               .              .           .              .             .          .                      break;
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .                  else if (value(c[i]) == l_False){
      5,975,688      48    48               0              0           0        249,120           272          0                      false_lit = true;
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              if (sat){
          1,071      23    23             306              0           0            306             0          0                  removeClause(cr);
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              else{
      1,493,850       0     0               0              0           0        746,925           262          0                  detachClause(cr, true);
              .       .     .               .              .           .              .             .          .  
        995,900      48    48         497,950              0           0              0             0          0                  if (false_lit){
         80,974       0     0             416              4           0              0             0          0                      for (li = lj = 0; li < c.size(); li++){
         79,102       0     0               0              0           0              0             0          0                          if (value(c[li]) != l_False){
        115,200       0     0               0              0           0         38,400             0          0                              c[lj++] = c[li];
              .       .     .               .              .           .              .             .          .                          }
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                      c.shrink(li - lj);
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                  beforeSize = c.size();
              .       .     .               .              .           .              .             .          .                  assert(c.size() > 1);
              .       .     .               .              .           .              .             .          .                  // simplify a learnt clause c
        995,900       0     0               0              0           0        497,950             7          0                  simplifyLearnt(c);
              .       .     .               .              .           .              .             .          .                  assert(c.size() > 0);
              .       .     .               .              .           .              .             .          .                  afterSize = c.size();
              .       .     .               .              .           .              .             .          .                  
      1,053,590       0     0         746,925        497,737           0              0             0          0                  if(drup_file && saved_size !=c.size()){
              .       .     .               .              .           .              .             .          .  #ifdef BIN_DRUP
              .       .     .               .              .           .              .             .          .                      binDRUP('a', c , drup_file);
              .       .     .               .              .           .              .             .          .                      //                    binDRUP('d', add_oc, drup_file);
              .       .     .               .              .           .              .             .          .  #else
              .       .     .               .              .           .              .             .          .                      for (int i = 0; i < c.size(); i++)
              .       .     .               .              .           .              .             .          .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .               .              .           .              .             .          .                      fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
              .       .     .               .              .           .              .             .          .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .     .               .              .           .              .             .          .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .     .               .              .           .              .             .          .                      //                    fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .     .               .              .           .              .             .          .  
        497,950       0     0               0              0           0              0             0          0                  if (c.size() == 1){
              .       .     .               .              .           .              .             .          .                      // when unit clause occur, enqueue and propagate
          8,220      39    39           1,644            184           0          1,644             0          0                      uncheckedEnqueue(c[0]);
          4,932       0     0           1,644              0           0              0             0          0                      if (propagate() != CRef_Undef){
              .       .     .               .              .           .              .             .          .                          ok = false;
              .       .     .               .              .           .              .             .          .                          return false;
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                      // delete the clause memory in logic
              .       .     .               .              .           .              .             .          .                      c.mark(1);
              .       .     .               .              .           .              .             .          .                      ca.free(cr);
              .       .     .               .              .           .              .             .          .  //#ifdef BIN_DRUP
              .       .     .               .              .           .              .             .          .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
              .       .     .               .              .           .              .             .          .  //#else
              .       .     .               .              .           .              .             .          .  //                    fprintf(drup_file, "d ");
              .       .     .               .              .           .              .             .          .  //                    for (int i = 0; i < c.size(); i++)
              .       .     .               .              .           .              .             .          .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .               .              .           .              .             .          .  //                    fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  //#endif
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .                  else{
        741,993       0     0               0              0           0        247,331             0          0                      attachClause(cr);
      1,483,986      45    45         741,993        494,489           0        247,331       129,798        834                      learnts_core[cj++] = learnts_core[ci];
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                      nblevels = computeLBD(c);
        494,662      48    48               0              0           0              0             0          0                      if (nblevels < c.lbd()){
              .       .     .               .              .           .              .             .          .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .     .               .              .           .              .             .          .                          c.set_lbd(nblevels);
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                      c.setSimplified(true);
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
             48       0     0               0              0           0              0             0          0      learnts_core.shrink(ci - cj);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .     .               .              .           .              .             .          .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
              .       .     .               .              .           .              .             .          .  
             48       8     8               0              0           0              0             0          0      return true;
              .       .     .               .              .           .              .             .          .  
            384       0     0             336             48          41              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
      7,373,844       2     2               0              0           0      4,915,896             0          0  int Solver::is_duplicate(std::vector<uint32_t>&c){
      1,638,632       0     0               0              0           0      1,638,632       193,040          0     auto time_point_0 = std::chrono::high_resolution_clock::now();
        819,316       0     0         819,316        585,598         281              0             0          0      dupl_db_size++;
      2,063,404   4,422 1,774         726,510              0           0              0             0          0      int res = 0;    
              .       .     .               .              .           .              .             .          .      
      1,638,632       0     0       1,638,632              0           0              0             0          0      int sz = c.size();
              .       .     .               .              .           .              .             .          .      std::vector<uint32_t> tmp(c);    
              .       .     .               .              .           .              .             .          .      sort(tmp.begin(),tmp.end());
              .       .     .               .              .           .              .             .          .      
        819,316 242,320 1,017               0              0           0        819,316             0          0      uint64_t hash = 0;    
              .       .     .               .              .           .              .             .          .      
     33,756,450  12,471 3,653               0              0           0        819,316             0          0      for (int i =0; i<sz; i++) {
    136,009,610       0     0      13,600,961              0           0              0             0          0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
              .       .     .               .              .           .              .             .          .      }    
              .       .     .               .              .           .              .             .          .      
        819,316       0     0               0              0           0        819,316             0          0      int32_t head = tmp[0];
              .       .     .               .              .           .              .             .          .      auto it0 = ht.find(head);
      3,456,335       0     0         819,298              0           0              0             0          0      if (it0 != ht.end()){
              .       .     .               .              .           .              .             .          .          auto it1=ht[head].find(sz);
      1,211,826       0     0               0              0           0              0             0          0          if (it1 != ht[head].end()){
        395,017       0     0               0              0           0        395,017             0          0              auto it2 = ht[head][sz].find(hash);
      1,185,051       0     0               0              0           0        395,017             0          0              if (it2 != ht[head][sz].end()){
        452,607       0     0         150,869         29,465      24,754        150,869             0          0                  it2->second++;
        150,869       0     0               0              0           0              0             0          0                  res = it2->second;            
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              else{
        244,148       0     0               0              0           0        244,148             0          0                  ht[head][sz][hash]=1;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          else{            
        421,792     436   299               0              0           0        210,896            10          0              ht[head][sz][hash]=1;
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }else{        
        881,850  25,475 3,533               0              0           0        881,850             1          0          ht[head][sz][hash]=1;
              .       .     .               .              .           .              .             .          .      } 
        819,316     592   416               0              0           0        819,316             0          0      auto time_point_1 = std::chrono::high_resolution_clock::now();
              .       .     .               .              .           .              .             .          .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
              .       .     .               .              .           .              .             .          .      return res;
      7,373,844       0     0       5,735,212             25           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  bool Solver::simplifyLearnt_tier2()
            528      48    48               0              0           0            288             0          0  {
              .       .     .               .              .           .              .             .          .      int beforeSize, afterSize;
              .       .     .               .              .           .              .             .          .      int learnts_tier2_size_before = learnts_tier2.size();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      int ci, cj, li, lj;
              .       .     .               .              .           .              .             .          .      bool sat, false_lit;
              .       .     .               .              .           .              .             .          .      unsigned int nblevels;
              .       .     .               .              .           .              .             .          .      ////
              .       .     .               .              .           .              .             .          .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      ////
              .       .     .               .              .           .              .             .          .      int nbSimplified = 0;
              .       .     .               .              .           .              .             .          .      int nbSimplifing = 0;
              .       .     .               .              .           .              .             .          .  
        479,667      31    31              48             48          33              0             0          0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
        719,283       0     0         479,522         16,371      15,026              0             0          0          CRef cr = learnts_tier2[ci];
              .       .     .               .              .           .              .             .          .          Clause& c = ca[cr];
              .       .     .               .              .           .              .             .          .  
        479,522       0     0               0              0           0              0             0          0          if (removed(cr)) continue;
        479,498       0     0         239,749         29,804       8,347              0             0          0          else if (c.simplified()){
        113,126       0     0               0              0           0         56,563           245        124              learnts_tier2[cj++] = learnts_tier2[ci];
              .       .     .               .              .           .              .             .          .              ////
        533,265       0     0          56,563              0           0              0             0          0              nbSimplified++;
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          else{
              .       .     .               .              .           .              .             .          .              int saved_size=c.size();
              .       .     .               .              .           .              .             .          .              //            if (drup_file){
              .       .     .               .              .           .              .             .          .              //                    add_oc.clear();
              .       .     .               .              .           .              .             .          .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .     .               .              .           .              .             .          .              ////
              .       .     .               .              .           .              .             .          .              nbSimplifing++;
        183,162       0     0               0              0           0              0             0          0              sat = false_lit = false;
      6,085,984       0     0               0              0           0              0             0          0              for (int i = 0; i < c.size(); i++){
      6,086,334       0     0               0              0           0              0             0          0                  if (value(c[i]) == l_True){
              .       .     .               .              .           .              .             .          .                      sat = true;
              .       .     .               .              .           .              .             .          .                      break;
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .                  else if (value(c[i]) == l_False){
      6,452,260      26    26               0              0           0        183,162             0          0                      false_lit = true;
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              if (sat){
            995       0     0             199              0           0            199             0          0                  removeClause(cr);
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              else{
      1,097,922      46    46               0              0           0        548,961           407          0                  detachClause(cr, true);
              .       .     .               .              .           .              .             .          .  
        731,948       0     0         365,974              3           0              0             0          0                  if (false_lit){
        801,494      35    35           3,004             14           0              0             0          0                      for (li = lj = 0; li < c.size(); li++){
        787,976       0     0               0              0           0              0             0          0                          if (value(c[li]) != l_False){
      1,154,241       0     0               0              0           0        384,747             0          0                              c[lj++] = c[li];
              .       .     .               .              .           .              .             .          .                          }
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                      c.shrink(li - lj);
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                  beforeSize = c.size();
              .       .     .               .              .           .              .             .          .                  assert(c.size() > 1);
              .       .     .               .              .           .              .             .          .                  // simplify a learnt clause c
        914,935       0     0               0              0           0        548,961            30          0                  simplifyLearnt(c);
              .       .     .               .              .           .              .             .          .                  assert(c.size() > 0);
              .       .     .               .              .           .              .             .          .                  afterSize = c.size();
              .       .     .               .              .           .              .             .          .                  
        731,948      45    45         365,974        365,576           0              0             0          0                  if(drup_file && saved_size!=c.size()){
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  #ifdef BIN_DRUP
              .       .     .               .              .           .              .             .          .                      binDRUP('a', c , drup_file);
              .       .     .               .              .           .              .             .          .                      //                    binDRUP('d', add_oc, drup_file);
              .       .     .               .              .           .              .             .          .  #else
              .       .     .               .              .           .              .             .          .                      for (int i = 0; i < c.size(); i++)
              .       .     .               .              .           .              .             .          .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .               .              .           .              .             .          .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
              .       .     .               .              .           .              .             .          .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .     .               .              .           .              .             .          .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .     .               .              .           .              .             .          .                      //                    fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .     .               .              .           .              .             .          .  
        365,974       0     0               0              0           0              0             0          0                  if (c.size() == 1){
              .       .     .               .              .           .              .             .          .                      // when unit clause occur, enqueue and propagate
          7,050       0     0           1,410            182           0          1,410             0          0                      uncheckedEnqueue(c[0]);
          4,230       0     0           1,410              2           0              0             0          0                      if (propagate() != CRef_Undef){
              .       .     .               .              .           .              .             .          .                          ok = false;
              .       .     .               .              .           .              .             .          .                          return false;
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                      // delete the clause memory in logic
              .       .     .               .              .           .              .             .          .                      c.mark(1);
              .       .     .               .              .           .              .             .          .                      ca.free(cr);
              .       .     .               .              .           .              .             .          .  //#ifdef BIN_DRUP
              .       .     .               .              .           .              .             .          .  //                    binDRUP('d', c, drup_file);
-- line 841 ----------------------------------------
-- line 845 ----------------------------------------
              .       .     .               .              .           .              .             .          .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .               .              .           .              .             .          .  //                    fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  //#endif
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .                  else{
              .       .     .               .              .           .              .             .          .                      
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                      nblevels = computeLBD(c);
        363,154       0     0               0              0           0              0             0          0                      if (nblevels < c.lbd()){
              .       .     .               .              .           .              .             .          .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .     .               .              .           .              .             .          .                          c.set_lbd(nblevels);
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                       //duplicate learnts 
              .       .     .               .              .           .              .             .          .                      int id = 0;                    
              .       .     .               .              .           .              .             .          .                      
              .       .     .               .              .           .              .             .          .                      std::vector<uint32_t> tmp;
      9,785,299       0     0       7,156,343            161           0              0             0          0                      for (int i = 0; i < c.size(); i++)                           
      5,012,998       0     0       2,506,499          4,362           0      2,506,499             0          0                          tmp.push_back(c[i].x);
        726,308       0     0               0              0           0        181,577             0          0                      id = is_duplicate(tmp);
              .       .     .               .              .           .              .             .          .                       
              .       .     .               .              .           .              .             .          .                                          
              .       .     .               .              .           .              .             .          .                      //duplicate learnts 
              .       .     .               .              .           .              .             .          .  
        726,308       5     5         181,577        181,409          41              0             0          0                      if (id < min_number_of_learnts_copies+2){
        544,698      31    31               0              0           0        181,566             0          0                          attachClause(cr);
        874,752       0     0         544,698        362,776           0        181,566       177,264      4,854                          learnts_tier2[cj++] = learnts_tier2[ci];                    
        726,264      48    48         181,566              0           0              0             0          0                          if (id == min_number_of_learnts_copies+1){                            
          1,953       6     6           1,953              0           0              0             0          0                              duplicates_added_minimization++;                                  
              .       .     .               .              .           .              .             .          .                          }
        359,226       0     0         179,613        179,455          41              0             0          0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
              .       .     .               .              .           .              .             .          .                          //if (id == min_number_of_learnts_copies+1){
              .       .     .               .              .           .              .             .          .                              cj--;
              2       2     2               0              0           0              0             0          0                              learnts_core.push(cr);
              .       .     .               .              .           .              .             .          .                              c.mark(CORE);
              .       .     .               .              .           .              .             .          .                          }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                          c.setSimplified(true);
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
             48      10    10               0              0           0              0             0          0      learnts_tier2.shrink(ci - cj);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .     .               .              .           .              .             .          .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
              .       .     .               .              .           .              .             .          .  
             48       0     0               0              0           0              0             0          0      return true;
              .       .     .               .              .           .              .             .          .  
            384       0     0             336             49          47              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  bool Solver::simplifyAll()
            240      46    46               0              0           0            144             0          0  {
              .       .     .               .              .           .              .             .          .      ////
             96       0     0               0              0           0             48             0          0      simplified_length_record = original_length_record = 0;
              .       .     .               .              .           .              .             .          .  
            192       0     0              48             24           1              0             0          0      if (!ok || propagate() != CRef_Undef)
              .       .     .               .              .           .              .             .          .          return ok = false;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      //// cleanLearnts(also can delete these code), here just for analyzing
              .       .     .               .              .           .              .             .          .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .     .               .              .           .              .             .          .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
              .       .     .               .              .           .              .             .          .      //local_learnts_dirty = tier2_learnts_dirty = false;
              .       .     .               .              .           .              .             .          .  
            192       0     0               0              0           0             48             0          0      if (!simplifyLearnt_core()) return ok = false;
            192      62    62               0              0           0             48             0          0      if (!simplifyLearnt_tier2()) return ok = false;
              .       .     .               .              .           .              .             .          .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      checkGarbage();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      ////
              .       .     .               .              .           .              .             .          .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
              .       .     .               .              .           .              .             .          .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      return true;
            240       0     0             192              0           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  //=================================================================================================
              .       .     .               .              .           .              .             .          .  // Minor methods:
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
              .       .     .               .              .           .              .             .          .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
              .       .     .               .              .           .              .             .          .  //
              .       .     .               .              .           .              .             .          .  Var Solver::newVar(bool sign, bool dvar)
      1,894,460       1     1               0              0           0      1,515,568             0          0  {
              .       .     .               .              .           .              .             .          .      int v = nVars();
              .       .     .               .              .           .              .             .          .      watches_bin.init(mkLit(v, false));
              .       .     .               .              .           .              .             .          .      watches_bin.init(mkLit(v, true ));
              .       .     .               .              .           .              .             .          .      watches  .init(mkLit(v, false));
              .       .     .               .              .           .              .             .          .      watches  .init(mkLit(v, true ));
             28       1     1               0              0           0              0             0          0      assigns  .push(l_Undef);
             28       1     1               0              0           0              0             0          0      vardata  .push(mkVarData(CRef_Undef, 0));
             28       0     0               0              0           0              0             0          0      activity_CHB  .push(0);
        568,394       0     0         189,446          6,737           0             28             0          0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
              .       .     .               .              .           .              .             .          .  
             28       1     1               0              0           0              0             0          0      picked.push(0);
             28       0     0               0              0           0              0             0          0      conflicted.push(0);
             28       0     0               0              0           0              0             0          0      almost_conflicted.push(0);
              .       .     .               .              .           .              .             .          .  #ifdef ANTI_EXPLORATION
             28       0     0               0              0           0              0             0          0      canceled.push(0);
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .  
             28       0     0               0              0           0              0             0          0      seen     .push(0);
             28       0     0               0              0           0              0             0          0      seen2    .push(0);
             28       0     0               0              0           0              0             0          0      polarity .push(sign);
             28       0     0               0              0           0              0             0          0      decision .push();
        947,230       1     1               0              0           0        378,892        10,341      1,052      trail    .capacity(v+1);
              .       .     .               .              .           .              .             .          .      setDecisionVar(v, dvar);
              .       .     .               .              .           .              .             .          .  
             28       0     0               0              0           0              0             0          0      activity_distance.push(0);
             28       1     1               0              0           0              0             0          0      var_iLevel.push(0);
             28       0     0               0              0           0              0             0          0      var_iLevel_tmp.push(0);
             28       0     0               0              0           0              0             0          0      pathCs.push(0);
              .       .     .               .              .           .              .             .          .      return v;
      1,705,014       0     0       1,326,122          2,285           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  bool Solver::addClause_(vec<Lit>& ps)
     14,045,521       2     2               0              0           0     12,039,018         1,045          0  {
              .       .     .               .              .           .              .             .          .      assert(decisionLevel() == 0);
      6,019,509       1     1       2,006,503              0           0              0             0          0      if (!ok) return false;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Check if clause is satisfied and remove false/duplicate literals:
              .       .     .               .              .           .              .             .          .      sort(ps);
              .       .     .               .              .           .              .             .          .      Lit p; int i, j;
              .       .     .               .              .           .              .             .          .  
      4,013,006       0     0       2,006,503          1,594           0              0             0          0      if (drup_file){
              .       .     .               .              .           .              .             .          .          add_oc.clear();
      2,006,503       2     2       2,006,503              0           0              0             0          0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
              .       .     .               .              .           .              .             .          .  
     20,163,053       0     0               0              0           0              0             0          0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
     34,942,757       0     0       5,383,349            387           0              0             0          0          if (value(ps[i]) == l_True || ps[i] == ~p)
              .       .     .               .              .           .              .             .          .              return true;
     21,533,396       4     4               0              0           0              0             0          0          else if (value(ps[i]) != l_False && ps[i] != p)
     16,150,047       0     0       5,383,349              0           0      5,383,349             0          0              ps[j++] = p = ps[i];
     16,052,024       0     0       2,006,503            140           0              0             0          0      ps.shrink(i - j);
              .       .     .               .              .           .              .             .          .  
      4,013,006       2     2               0              0           0              0             0          0      if (drup_file && i != j){
              .       .     .               .              .           .              .             .          .  #ifdef BIN_DRUP
              .       .     .               .              .           .              .             .          .          binDRUP('a', ps, drup_file);
      2,006,503       0     0       2,006,503              0           0              0             0          0          binDRUP('d', add_oc, drup_file);
              .       .     .               .              .           .              .             .          .  #else
              .       .     .               .              .           .              .             .          .          for (int i = 0; i < ps.size(); i++)
              .       .     .               .              .           .              .             .          .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
              .       .     .               .              .           .              .             .          .          fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          fprintf(drup_file, "d ");
              .       .     .               .              .           .              .             .          .          for (int i = 0; i < add_oc.size(); i++)
              .       .     .               .              .           .              .             .          .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .     .               .              .           .              .             .          .          fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .      
      4,013,006       0     0               0              0           0              0             0          0      if (ps.size() == 0)
              .       .     .               .              .           .              .             .          .          return ok = false;
      4,013,006       2     2               0              0           0              0             0          0      else if (ps.size() == 1){
              .       .     .               .              .           .              .             .          .          uncheckedEnqueue(ps[0]);
              .       .     .               .              .           .              .             .          .          return ok = (propagate() == CRef_Undef);
              .       .     .               .              .           .              .             .          .      }else{
      2,006,503       0     0               0              0           0      2,006,503             0          0          CRef cr = ca.alloc(ps, false);
              .       .     .               .              .           .              .             .          .          //auto ca_size=ca.size();
              .       .     .               .              .           .              .             .          .          //printf("ca size:%d\n",ca_size);
      6,019,509       0     0               0              0           0      2,006,503             0          0          clauses.push(cr);
      6,019,509       2     2       2,006,503              0           0      2,006,503             0          0          attachClause(cr);
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
      2,006,503       0     0               0              0           0              0             0          0      return true;
     22,071,533       0     0      14,045,521            203           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
     39,750,810      19    15               0              0           0     23,850,486             0          0  void Solver::attachClause(CRef cr) {
              .       .     .               .              .           .              .             .          .      const Clause& c = ca[cr];
              .       .     .               .              .           .              .             .          .      assert(c.size() > 1);
     14,911,849       0     0       3,975,081             22           0              0             0          0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .     .               .              .           .              .             .          .      ws[~c[0]].push(Watcher(cr, c[1]));
              .       .     .               .              .           .              .             .          .      ws[~c[1]].push(Watcher(cr, c[0]));
      9,913,851       0     0       5,938,770      1,786,035           0              0             0          0      if (c.learnt()) learnts_literals += c.size();
     33,812,040       1     1      29,836,959          1,304           0              0             0          0      else            clauses_literals += c.size(); }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
     10,177,662     318   318               0              0           0      6,785,108         1,406          1  void Solver::detachClause(CRef cr, bool strict) {
              .       .     .               .              .           .              .             .          .      const Clause& c = ca[cr];
              .       .     .               .              .           .              .             .          .      assert(c.size() > 1);
      6,785,108       0     0               0              0           0              0             0          0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .     .               .              .           .              .             .          .      
      6,785,108       0     0               0              0           0              0             0          0      if (strict){
              .       .     .               .              .           .              .             .          .          remove(ws[~c[0]], Watcher(cr, c[1]));
              .       .     .               .              .           .              .             .          .          remove(ws[~c[1]], Watcher(cr, c[0]));
              .       .     .               .              .           .              .             .          .      }else{
              .       .     .               .              .           .              .             .          .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
              .       .     .               .              .           .              .             .          .          ws.smudge(~c[0]);
              .       .     .               .              .           .              .             .          .          ws.smudge(~c[1]);
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
      5,038,877      37    37       3,342,600         10,054       1,074              0             0          0      if (c.learnt()) learnts_literals -= c.size();
     10,227,616       0     0       8,531,339         25,904         113              0             0          0      else            clauses_literals -= c.size(); }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
     10,075,408     739   697               0              0           0      5,037,704        27,909        123  void Solver::removeClause(CRef cr) {
              .       .     .               .              .           .              .             .          .      Clause& c = ca[cr];
              .       .     .               .              .           .              .             .          .  
      3,778,278       0     0       1,259,426         27,779         128              0             0          0      if (drup_file){
              .       .     .               .              .           .              .             .          .          if (c.mark() != 1){
              .       .     .               .              .           .              .             .          .  #ifdef BIN_DRUP
              .       .     .               .              .           .              .             .          .              binDRUP('d', c, drup_file);
              .       .     .               .              .           .              .             .          .  #else
              .       .     .               .              .           .              .             .          .              fprintf(drup_file, "d ");
              .       .     .               .              .           .              .             .          .              for (int i = 0; i < c.size(); i++)
              .       .     .               .              .           .              .             .          .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .               .              .           .              .             .          .              fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .          }else
              .       .     .               .              .           .              .             .          .              printf("c Bug. I don't expect this to happen.\n");
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
      5,037,704     374   371               0              0           0      1,259,426             0          0      detachClause(cr);
              .       .     .               .              .           .              .             .          .      // Don't leave pointers to free'd memory!
              .       .     .               .              .           .              .             .          .      if (locked(c)){
          2,792       0     0             670              0           0              0             0          0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
          1,452       0     0               0              0           0            726             0          0          vardata[var(implied)].reason = CRef_Undef; }
              .       .     .               .              .           .              .             .          .      c.mark(1);
              .       .     .               .              .           .              .             .          .      ca.free(cr);
      7,556,556       0     0       6,297,130              2           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  bool Solver::satisfied(const Clause& c) const {
  4,226,013,074     433   433               0              0           0              0             0          0      for (int i = 0; i < c.size(); i++)
  4,857,248,074       0     0   1,797,461,179    526,968,309     177,105              0             0          0          if (value(c[i]) == l_True)
              .       .     .               .              .           .              .             .          .              return true;
              .       .     .               .              .           .              .             .          .      return false; }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
              .       .     .               .              .           .              .             .          .  //
     21,098,394  19,157 2,789               0              0           0     14,065,596             1          0  void Solver::cancelUntil(int bLevel) {
              .       .     .               .              .           .              .             .          .  	
     10,199,278      13    11         809,269        136,533           0      2,344,266       138,204          0      if (decisionLevel() > bLevel){
              .       .     .               .              .           .              .             .          .  #ifdef PRINT_OUT
              .       .     .               .              .           .              .             .          .  		std::cout << "bt " << bLevel << "\n";
              .       .     .               .              .           .              .             .          .  #endif				
      4,688,532       0     0               0              0           0      2,344,266       979,183          4  		add_tmp.clear();
 24,483,192,589  16,366 2,877   4,901,795,903      3,444,898       8,712              0             0          0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
              .       .     .               .              .           .              .             .          .          {
              .       .     .               .              .           .              .             .          .              Var      x  = var(trail[c]);
              .       .     .               .              .           .              .             .          .  
  9,780,149,146       0     0   4,890,074,573  4,236,405,341   2,368,456              0             0          0  			if (level(x) <= bLevel)
              .       .     .               .              .           .              .             .          .  			{
              .       .     .               .              .           .              .             .          .  				add_tmp.push(trail[c]);
              .       .     .               .              .           .              .             .          .  			}
              .       .     .               .              .           .              .             .          .  			else
              .       .     .               .              .           .              .             .          .  			{
  7,421,596,230       0     0   3,710,798,115      1,457,283           0              0             0          0  				 if (!VSIDS){
  5,466,841,302       0     0   3,644,560,868      1,068,911           0              0             0          0  					uint32_t age = conflicts - picked[x];
  3,644,560,868       0     0   1,822,280,434  1,672,355,404   1,206,886              0             0          0  					if (age > 0){
 18,204,298,820   5,002 1,340   7,281,719,528  3,341,214,866   1,061,575              0             0          0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
  1,820,429,882       0     0   1,820,429,882  1,662,732,987     668,761              0             0          0  						double old_activity = activity_CHB[x];
 12,743,009,174     369   197   3,640,859,764      2,150,063           2  1,820,429,882             0          0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
              .       .     .               .              .           .              .             .          .  						if (order_heap_CHB.inHeap(x)){
 10,567,860,192   2,907 1,209               0              0           0  5,283,930,096       141,512          0  							if (activity_CHB[x] > old_activity)
              .       .     .               .              .           .              .             .          .  								order_heap_CHB.decrease(x);
              .       .     .               .              .           .              .             .          .  							else
              .       .     .               .              .           .              .             .          .  								order_heap_CHB.increase(x);
              .       .     .               .              .           .              .             .          .  						}
              .       .     .               .              .           .              .             .          .  					}
              .       .     .               .              .           .              .             .          .  #ifdef ANTI_EXPLORATION
  3,644,560,868       5     0   1,822,280,434      1,074,779           9  1,822,280,434 1,672,545,005    820,879  					canceled[x] = conflicts;
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .  				}
              .       .     .               .              .           .              .             .          .  				
  7,421,596,230   3,055 1,614   3,710,798,115      1,563,338           0  3,710,798,115 2,413,503,294     34,315  				assigns [x] = l_Undef;
              .       .     .               .              .           .              .             .          .  #ifdef PRINT_OUT
              .       .     .               .              .           .              .             .          .  				std::cout << "undo " << x << "\n";
              .       .     .               .              .           .              .             .          .  #endif				
  7,421,596,230       0     0   3,710,798,115          4,020           0              0             0          0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
  3,710,798,115       0     0   3,710,798,115              0           0              0             0          0  					polarity[x] = sign(trail[c]);
              .       .     .               .              .           .              .             .          .  				insertVarOrder(x);
              .       .     .               .              .           .              .             .          .  			}
              .       .     .               .              .           .              .             .          .          }
      2,344,266       0     0               0              0           0      2,344,266             0          0          qhead = trail_lim[bLevel];
      4,688,532       0     0               0              0           0              0             0          0          trail.shrink(trail.size() - trail_lim[bLevel]);
      7,032,798       0     0       2,344,266              0           0              0             0          0          trail_lim.shrink(trail_lim.size() - bLevel);
  2,365,585,714       1     1       2,344,266              0           0              0             0          0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
              .       .     .               .              .           .              .             .          .  		{
      4,063,383       0     0       1,354,461              0           0              0             0          0  			trail.push_(add_tmp[nLitId]);
              .       .     .               .              .           .              .             .          .  		}
              .       .     .               .              .           .              .             .          .  		
              .       .     .               .              .           .              .             .          .  		add_tmp.clear();
     18,754,128       0     0      16,409,862      1,748,418           0              0             0          0      } }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  //=================================================================================================
              .       .     .               .              .           .              .             .          .  // Major methods:
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  Lit Solver::pickBranchLit()
    630,601,040   3,896   304               0              0           0    472,950,780             0          0  {
              .       .     .               .              .           .              .             .          .      Var next = var_Undef;
              .       .     .               .              .           .              .             .          .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
    507,556,429  64,250 3,760     139,682,197      5,319,328         347              0             0          0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Random decision:
              .       .     .               .              .           .              .             .          .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
              .       .     .               .              .           .              .             .          .          next = order_heap[irand(random_seed,order_heap.size())];
              .       .     .               .              .           .              .             .          .          if (value(next) == l_Undef && decision[next])
              .       .     .               .              .           .              .             .          .              rnd_decisions++; }*/
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Activity based decision:
  1,606,211,111   4,612    92     724,280,425    239,564,170   2,042,881              0             0          0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    487,805,040       0     0               0              0           0              0             0          0          if (order_heap.empty())
              1       0     0               0              0           0              0             0          0              return lit_Undef;
              .       .     .               .              .           .              .             .          .          else{
              .       .     .               .              .           .              .             .          .  #ifdef ANTI_EXPLORATION
    487,805,038       0     0     243,902,519        783,992           1              0             0          0              if (!VSIDS){
              .       .     .               .              .           .              .             .          .                  Var v = order_heap_CHB[0];
    125,204,918       0     0     125,204,918        241,269          33              0             0          0                  uint32_t age = conflicts - canceled[v];
    347,750,668       0     0     165,936,107    148,647,970     427,029      7,939,227            27          0                  while (age > 0){
              .       .     .               .              .           .              .             .          .                      double decay = pow(0.95, age);
    206,667,296       0     0     103,333,648        222,512          28    103,333,648             0          0                      activity_CHB[v] *= decay;
              .       .     .               .              .           .              .             .          .                      if (order_heap_CHB.inHeap(v))
              .       .     .               .              .           .              .             .          .                          order_heap_CHB.increase(v);
    310,000,944       0     0     206,667,296          5,079           0    103,333,648        27,465          0                      canceled[v] = conflicts;
              .       .     .               .              .           .              .             .          .                      v = order_heap_CHB[0];
              .       .     .               .              .           .              .             .          .                      age = conflicts - canceled[v];
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .              next = order_heap.removeMin();
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .  
    315,300,516       0     0     157,650,258     64,991,807     156,471              0             0          0      return mkLit(next, polarity[next]);
    709,426,169       0     0     551,775,910      1,527,871           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
              .       .     .               .              .           .              .             .          .  {
              .       .     .               .              .           .              .             .          .  	ConflictData data;
              .       .     .               .              .           .              .             .          .  	Clause& conflCls = ca[cind];
              .       .     .               .              .           .              .             .          .  	data.nHighestLevel = level(var(conflCls[0]));
      7,620,414       0     0       3,810,207        215,813           0              0             0          0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
              .       .     .               .              .           .              .             .          .  	{
              .       .     .               .              .           .              .             .          .  		return data;
              .       .     .               .              .           .              .             .          .  	}
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  	int highestId = 0;
              .       .     .               .              .           .              .             .          .      data.bOnlyOneLitFromHighest = true;
              .       .     .               .              .           .              .             .          .  	// find the largest decision level in the clause
    872,420,390     269   269               0              0           0              0             0          0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
              .       .     .               .              .           .              .             .          .  	{
              .       .     .               .              .           .              .             .          .  		int nLevel = level(var(conflCls[nLitId]));
    876,948,251       0     0               0              0           0              0             0          0  		if (nLevel > data.nHighestLevel)
              .       .     .               .              .           .              .             .          .  		{
              .       .     .               .              .           .              .             .          .  			highestId = nLitId;
              .       .     .               .              .           .              .             .          .  			data.nHighestLevel = nLevel;
      4,074,983       0     0               0              0           0              0             0          0  			data.bOnlyOneLitFromHighest = true;
              .       .     .               .              .           .              .             .          .  		}
              .       .     .               .              .           .              .             .          .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
              .       .     .               .              .           .              .             .          .  		{
    856,573,336       0     0               0              0           0              0             0          0  			data.bOnlyOneLitFromHighest = false;
              .       .     .               .              .           .              .             .          .  		}
              .       .     .               .              .           .              .             .          .  	}
              .       .     .               .              .           .              .             .          .  
      1,924,272  12,279 4,801               0              0           0              0             0          0  	if (highestId != 0)
              .       .     .               .              .           .              .             .          .  	{
              .       .     .               .              .           .              .             .          .  		std::swap(conflCls[0], conflCls[highestId]);
      1,438,930       0     0               0              0           0              0             0          0  		if (highestId > 1)
              .       .     .               .              .           .              .             .          .  		{
      2,770,956       0     0               0              0           0              0             0          0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
              .       .     .               .              .           .              .             .          .  			//ws.smudge(~conflCls[highestId]);
              .       .     .               .              .           .              .             .          .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
              .       .     .               .              .           .              .             .          .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
              .       .     .               .              .           .              .             .          .  		}
              .       .     .               .              .           .              .             .          .  	}
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  	return data;
              .       .     .               .              .           .              .             .          .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
              .       .     .               .              .           .              .             .          .  |  
              .       .     .               .              .           .              .             .          .  |    Post-conditions:
              .       .     .               .              .           .              .             .          .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
              .       .     .               .              .           .              .             .          .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
              .       .     .               .              .           .              .             .          .  |        rest of literals. There may be others from the same level though.
              .       .     .               .              .           .              .             .          .  |  
              .       .     .               .              .           .              .             .          .  |________________________________________________________________________________________________@*/
              .       .     .               .              .           .              .             .          .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
     19,954,974   2,152 1,668               0              0           0     13,814,982        21,699          0  {
      1,534,998       0     0               0              0           0      1,534,998       155,044          1      int pathC = 0;
      1,534,998       0     0               0              0           0              0             0          0      Lit p     = lit_Undef;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Generate conflict clause:
              .       .     .               .              .           .              .             .          .      //
              .       .     .               .              .           .              .             .          .      out_learnt.push();      // (leave room for the asserting literal)
      3,069,996       0     0       1,534,998              0           0              0             0          0      int index   = trail.size() - 1;
      1,534,998       0     0       1,534,998              1           0              0             0          0      int nDecisionLevel = level(var(ca[confl][0]));
              .       .     .               .              .           .              .             .          .      assert(nDecisionLevel == level(var(ca[confl][0])));
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      do{
              .       .     .               .              .           .              .             .          .          assert(confl != CRef_Undef); // (otherwise should be UIP)
              .       .     .               .              .           .              .             .          .          Clause& c = ca[confl];
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
  1,011,802,082       0     0               0              0           0              0             0          0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
              .       .     .               .              .           .              .             .          .              assert(value(c[1]) == l_True);
              .       .     .               .              .           .              .             .          .              Lit tmp = c[0];
      9,807,651       0     0       3,269,217        160,208     113,718      6,538,434             0          0              c[0] = c[1], c[1] = tmp; }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          // Update LBD if improved.
    669,823,256       1     1      75,138,574        151,497           0              0             0          0          if (c.learnt() && c.mark() != CORE){
              .       .     .               .              .           .              .             .          .              int lbd = computeLBD(c);
      5,340,844       0     0               0              0           0              0             0          0              if (lbd < c.lbd()){
      1,069,198       0     0               0              0           0              0             0          0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
              .       .     .               .              .           .              .             .          .                  c.set_lbd(lbd);
      1,069,198       0     0         534,599        480,254          70              0             0          0                  if (lbd <= core_lbd_cut){
             10       2     2               0              0           0              5             0          0                      learnts_core.push(confl);
              .       .     .               .              .           .              .             .          .                      c.mark(CORE);
      1,179,171       0     0          79,089            325           0              0             0          0                  }else if (lbd <= 6 && c.mark() == LOCAL){
              .       .     .               .              .           .              .             .          .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
              .       .     .               .              .           .              .             .          .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     10,865,994      27    26               0              0           0      3,130,500     1,446,455        105                      learnts_tier2.push(confl);
              .       .     .               .              .           .              .             .          .                      c.mark(TIER2); }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
      5,183,298       0     0       2,591,649        482,855           3              0             0          0              if (c.mark() == TIER2)
      3,249,932      62    62         812,483        391,559           0        812,483        90,912     12,952                  c.touched() = conflicts;
      3,618,836       0     0       1,809,418              0           0              0             0          0              else if (c.mark() == LOCAL)
              .       .     .               .              .           .              .             .          .                  claBumpActivity(c);
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .  
  6,830,917,773      32    32   2,518,379,780        687,456          13    234,810,116           185          0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
  2,283,569,664       0     0   2,283,569,664    148,646,472   1,080,160              0             0          0              Lit q = c[j];
              .       .     .               .              .           .              .             .          .  
  8,282,290,203      11    11   3,521,953,289  1,823,745,111     540,150              0             0          0              if (!seen[var(q)] && level(var(q)) > 0){
  2,475,090,730       0     0   1,237,545,365        988,417           0              0             0          0                  if (VSIDS){
              .       .     .               .              .           .              .             .          .                      varBumpActivity(var(q), .5);
             28       1     1               0              0           0             14             0          0                      add_tmp.push(q);
              .       .     .               .              .           .              .             .          .                  }else
    957,123,263       0     0     957,123,263    666,399,326     558,348              0             0          0                      conflicted[var(q)]++;
  1,237,545,365       0     0               0              0           0  1,237,545,365           159          0                  seen[var(q)] = 1;
  2,475,090,730       0     0   1,237,545,365          7,516           0              0             0          0                  if (level(var(q)) >= nDecisionLevel){
    469,620,232       0     0     469,620,232        327,859           4              0             0          0                      pathC++;
              .       .     .               .              .           .              .             .          .                  }else
              .       .     .               .              .           .              .             .          .                      out_learnt.push(q);
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          
              .       .     .               .              .           .              .             .          .          // Select next clause to look at:
              .       .     .               .              .           .              .             .          .  		do {
 10,907,596,072       0     0   4,410,000,452  1,206,891,573   2,673,947              0             0          0  			while (!seen[var(trail[index--])]);
              .       .     .               .              .           .              .             .          .  			p  = trail[index+1];
    497,214,970       3     3     248,607,485    175,033,926           0              0             0          0  		} while (level(var(p)) < nDecisionLevel);
              .       .     .               .              .           .              .             .          .  		
    469,620,232       0     0     234,810,116              0           0    234,810,116       353,642         10          confl = reason(var(p));
    234,810,116       0     0               0              0           0    234,810,116             0          0          seen[var(p)] = 0;
    469,620,232       0     0     469,620,232        378,089           0              0             0          0          pathC--;
              .       .     .               .              .           .              .             .          .  
  1,402,720,704       0     0     466,550,236      1,716,201           9              0             0          0      }while (pathC > 0);
      1,534,998       0     0       1,534,998        211,348           0              0             0          0      out_learnt[0] = ~p;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Simplify conflict clause:
              .       .     .               .              .           .              .             .          .      //
              .       .     .               .              .           .              .             .          .      int i, j;
      3,069,996       0     0               0              0           0      1,534,998             0          0      out_learnt.copyTo(analyze_toclear);
      4,604,994       0     0       1,534,998        117,775           0              0             0          0      if (ccmin_mode == 2){
      1,534,796   4,892 2,900               0              0           0              0             0          0          uint32_t abstract_level = 0;
  2,008,540,494   3,296 1,858               0              0           0              0             0          0          for (i = 1; i < out_learnt.size(); i++)
  1,005,804,841       0     0       1,534,796              0           0              0             0          0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
              .       .     .               .              .           .              .             .          .  
  7,034,494,703      31    31   3,006,670,951      3,431,413           0      1,534,796       376,532          1          for (i = j = 1; i < out_learnt.size(); i++)
  8,224,653,920     114   114   1,841,764,760    917,721,440           0    908,224,880            38          0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
  2,800,619,640       9     9     933,539,880     17,180,780           0    933,539,880    33,765,046          0                  out_learnt[j++] = out_learnt[i];
              .       .     .               .              .           .              .             .          .          
              .       .     .               .              .           .              .             .          .      }else if (ccmin_mode == 1){
              .       .     .               .              .           .              .             .          .          for (i = j = 1; i < out_learnt.size(); i++){
              .       .     .               .              .           .              .             .          .              Var x = var(out_learnt[i]);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              if (reason(x) == CRef_Undef)
              .       .     .               .              .           .              .             .          .                  out_learnt[j++] = out_learnt[i];
              .       .     .               .              .           .              .             .          .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
              .       .     .               .              .           .              .             .          .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
              .       .     .               .              .           .              .             .          .                          out_learnt[j++] = out_learnt[i];
              .       .     .               .              .           .              .             .          .                          break; }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }else
              .       .     .               .              .           .              .             .          .          i = j = out_learnt.size();
              .       .     .               .              .           .              .             .          .  
      3,069,996       0     0       1,534,998      1,504,619         362              0             0          0      max_literals += out_learnt.size();
    557,151,498       2     2     138,904,125              0           0              0             0          0      out_learnt.shrink(i - j);
      1,534,998     861   643       1,534,998              0           0              0             0          0      tot_literals += out_learnt.size();
              .       .     .               .              .           .              .             .          .  
      3,069,996       0     0       1,534,998        852,989          37      1,534,998       369,386          0      out_lbd = computeLBD(out_learnt);
     18,163,393  21,379 5,076       8,097,937      1,041,316           0              0             0          0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
      2,966,397  35,448 3,226         423,771              0           0        847,542             0          0          if (binResMinimize(out_learnt))
          3,921       0     0           1,307              0           0          1,307             0          0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Find correct backtrack level:
              .       .     .               .              .           .              .             .          .      //
      3,061,246       0     0               0              0           0              0             0          0      if (out_learnt.size() == 1)
            618       0     0             206              0           0            206             0          0          out_btlevel = 0;
              .       .     .               .              .           .              .             .          .      else{
      3,064,644       0     0               0              0           0              0             0          0          int max_i = 1;
              .       .     .               .              .           .              .             .          .          // Find the first literal assigned at the next-highest level:
  3,729,595,018       0     0               0              0           0              0             0          0          for (int i = 2; i < out_learnt.size(); i++)
  2,814,204,188       0     0     932,002,492     46,540,150           0              0             0          0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
              .       .     .               .              .           .              .             .          .                  max_i = i;
              .       .     .               .              .           .              .             .          .          // Swap-in this literal at index 1:
              .       .     .               .              .           .              .             .          .          Lit p             = out_learnt[max_i];
      3,069,584      51    11       1,534,792        294,105           0      1,534,792       155,667          0          out_learnt[max_i] = out_learnt[1];
      1,534,792       0     0               0              0           0      1,534,792             0          0          out_learnt[1]     = p;
      3,069,584       0     0       1,534,792        322,479           0      1,534,792       319,580          0          out_btlevel       = level(var(p));
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
      3,069,996  12,292 3,680       1,534,998        852,546           0              0             0          0      if (VSIDS){
  1,024,327,997  13,417 2,102     282,727,188        633,606           0              0             0          0          for (int i = 0; i < add_tmp.size(); i++){
              .       .     .               .              .           .              .             .          .              Var v = var(add_tmp[i]);
    841,266,306       0     0     280,422,102    182,467,371           0              0             0          0              if (level(v) >= out_btlevel - 1)
              .       .     .               .              .           .              .             .          .                  varBumpActivity(v, 1);
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          add_tmp.clear();
              .       .     .               .              .           .              .             .          .      }else{
      1,533,272       0     0         766,636        254,029           0        766,636       487,043          0          seen[var(p)] = true;
  2,288,532,563       0     0         766,636              0           0              0             0          0          for(int i = out_learnt.size() - 1; i >= 0; i--){
              .       .     .               .              .           .              .             .          .              Var v = var(out_learnt[i]);
              .       .     .               .              .           .              .             .          .              CRef rea = reason(v);
  1,520,066,378       0     0               0              0           0              0             0          0              if (rea != CRef_Undef){
              .       .     .               .              .           .              .             .          .                  const Clause& reaC = ca[rea];
 13,403,598,438       0     0               0              0           0              0             0          0                  for (int i = 0; i < reaC.size(); i++){
              .       .     .               .              .           .              .             .          .                      Lit l = reaC[i];
 10,622,539,582       0     0   5,311,269,791  2,505,021,235      18,368              0             0          0                      if (!seen[var(l)]){
  2,089,023,618       0     0               0              0           0  2,089,023,618             0          0                          seen[var(l)] = true;
  2,089,023,618       0     0   2,089,023,618  1,688,512,120     498,275              0             0          0                          almost_conflicted[var(l)]++;
              .       .     .               .              .           .              .             .          .                          analyze_toclear.push(l); } } } } }
              .       .     .               .              .           .              .             .          .  
 13,029,307,198  15,211 1,255   6,512,351,102        271,062           0  3,255,408,052 1,395,998,750          0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
     12,279,984       0     0      10,744,986      1,235,018           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  // Try further learnt clause minimization by means of binary clause resolution.
              .       .     .               .              .           .              .             .          .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
      2,100,975       0     0               0              0           0      1,680,780             0          0  {
              .       .     .               .              .           .              .             .          .      // Preparation: remember which false variables we have in 'out_learnt'.
      1,271,313     186   173         423,771              0           0        423,771             0          0      counter++;
      9,161,910       0     0         847,542              0           0              0             0          0      for (int i = 1; i < out_learnt.size(); i++)
      3,314,172       0     0         423,569              0           0      2,890,603     2,885,036  1,590,193          seen2[var(out_learnt[i])] = counter;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Get the list of binary clauses containing 'out_learnt[0]'.
              .       .     .               .              .           .              .             .          .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
              .       .     .               .              .           .              .             .          .  
        420,195       0     0               0              0           0              0             0          0      int to_remove = 0;
      6,839,578       0     0         423,771        313,136          10          1,307             0          0      for (int i = 0; i < ws.size(); i++){
      3,201,158       0     0       3,201,158        494,500          20              0             0          0          Lit the_other = ws[i].blocker;
              .       .     .               .              .           .              .             .          .          // Does 'the_other' appear negatively in 'out_learnt'?
     12,809,824      75    75       5,987,313      2,739,509   1,807,727              0             0          0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
          2,596       0     0               0              0           0              0             0          0              to_remove++;
          7,788       0     0               0              0           0          2,596             0          0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Shrink.
      1,260,585      80    77               0              0           0              0             0          0      if (to_remove > 0){
          1,307       0     0               0              0           0              0             0          0          int last = out_learnt.size() - 1;
         68,855     952   863           1,303              0           0              0             0          0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
         18,834       0     0           9,417              0           0              0             0          0              if (seen2[var(out_learnt[i])] != counter)
          8,170       0     0           3,268              0           0          1,634             0          0                  out_learnt[i--] = out_learnt[last--];
              .       .     .               .              .           .              .             .          .          out_learnt.shrink(to_remove);
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .      return to_remove != 0;
      2,104,551       4     4       2,104,551              0           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
              .       .     .               .              .           .              .             .          .  // visiting literals at levels that cannot be removed later.
              .       .     .               .              .           .              .             .          .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
  9,082,248,800  89,251   260               0              0           0  5,449,349,280     1,344,494         34  {
  1,816,449,760       0     0               0              0           0    908,224,880             0          0      analyze_stack.clear(); analyze_stack.push(p);
  2,724,674,640       0     0   1,816,449,760              0           0    908,224,880             0          0      int top = analyze_toclear.size();
 19,868,908,040       0     0               0              0           0              0             0          0      while (analyze_stack.size() > 0){
              .       .     .               .              .           .              .             .          .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
              .       .     .               .              .           .              .             .          .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          // Special handling for binary clauses like in 'analyze()'.
 24,254,793,492     109   108               0              0           0              0             0          0          if (c.size() == 2 && value(c[0]) == l_False){
              .       .     .               .              .           .              .             .          .              assert(value(c[1]) == l_True);
              .       .     .               .              .           .              .             .          .              Lit tmp = c[0];
     22,794,360       0     0       7,598,120        461,003     337,056     15,196,240             0          0              c[0] = c[1], c[1] = tmp; }
              .       .     .               .              .           .              .             .          .  
143,144,794,554       0     0               0              0           0              0             0          0          for (int i = 1; i < c.size(); i++){
 64,808,306,232   3,912 3,040  64,808,306,232  4,719,963,384  11,426,061              0             0          0              Lit p  = c[i];
243,916,739,612       0     0 129,616,612,464 25,236,175,805     969,154              0             0          0              if (!seen[var(p)] && level(var(p)) > 0){
 96,967,368,132       0     0  24,654,103,086              0           0              0             0          0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
 23,815,073,575       0     0               0              0           0 23,815,073,575             0          0                      seen[var(p)] = 1;
              .       .     .               .              .           .              .             .          .                      analyze_stack.push(p);
              4       0     0               0              0           0              0             0          0                      analyze_toclear.push(p);
              .       .     .               .              .           .              .             .          .                  }else{
 97,773,299,693   6,608 3,786  25,331,018,410     17,458,734           0              0             0          0                      for (int j = top; j < analyze_toclear.size(); j++)
 46,557,121,962       0     0  22,904,162,574              0           0 23,652,959,388 5,156,730,983          0                          seen[var(analyze_toclear[j])] = 0;
  1,678,059,022      11    11     839,029,511      3,143,037           0              0             0          0                      analyze_toclear.shrink(analyze_toclear.size() - top);
    839,029,511       0     0               0              0           0              0             0          0                      return false;
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
    138,390,738       0     0               0              0           0              0             0          0      return true;
  7,265,799,040       0     0   6,357,574,160     17,511,553           3              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  /*_________________________________________________________________________________________________
              .       .     .               .              .           .              .             .          .  |
              .       .     .               .              .           .              .             .          .  |  analyzeFinal : (p : Lit)  ->  [void]
              .       .     .               .              .           .              .             .          .  |  
              .       .     .               .              .           .              .             .          .  |  Description:
              .       .     .               .              .           .              .             .          .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      seen[var(p)] = 0;
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 37,108,021,010       2     2               0              0           0 18,554,010,505             1          0  {
              .       .     .               .              .           .              .             .          .      assert(value(p) == l_Undef);
              .       .     .               .              .           .              .             .          .      Var x = var(p);
  7,421,604,202       0     0   3,710,802,101      9,760,758         499              0             0          0      if (!VSIDS){
  5,466,845,559       0     0   3,644,563,706     12,537,493         323  1,822,281,853 1,655,793,595  2,661,491          picked[x] = conflicts;
  3,644,563,706       0     0   1,822,281,853              0           0  1,822,281,853 1,655,471,198  2,234,047          conflicted[x] = 0;
  3,644,563,706       0     0   1,822,281,853              0           0  1,822,281,853 1,655,792,493  2,201,919          almost_conflicted[x] = 0;
              .       .     .               .              .           .              .             .          .  #ifdef ANTI_EXPLORATION
  1,822,281,853       0     0   1,822,281,853      5,806,806          37              0             0          0          uint32_t age = conflicts - canceled[var(p)];
  3,644,563,706       0     0   1,822,281,853  1,640,165,718   2,062,018              0             0          0          if (age > 0){
              .       .     .               .              .           .              .             .          .              double decay = pow(0.95, age);
  2,085,942,858       0     0   1,042,971,429    963,298,833   1,312,847  1,042,971,429             0          0              activity_CHB[var(p)] *= decay;
              .       .     .               .              .           .              .             .          .              if (order_heap_CHB.inHeap(var(p)))
  1,042,971,429       0     0               0              0           0              0             0          0                  order_heap_CHB.increase(var(p));
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
  3,710,802,101       1     1   3,710,802,101        670,428           7              0             0          0      assigns[x] = lbool(!sign(p));
  7,421,604,202       0     0               0              0           0  7,421,604,202 3,348,810,507 17,175,941      vardata[x] = mkVarData(from, level);
  3,710,802,101       2     2   3,710,802,101              0           0              0             0          0      trail.push_(p);
 25,975,614,707       0     0  22,264,812,606              0           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  unsigned number_watch_changed_total=0;
              .       .     .               .              .           .              .             .          .  unsigned number_clause_read_total=0;
              .       .     .               .              .           .              .             .          .  unsigned times_only_access_watch=0;
              .       .     .               .              .           .              .             .          .  /*_________________________________________________________________________________________________
              .       .     .               .              .           .              .             .          .  |
              .       .     .               .              .           .              .             .          .  |  propagate : [void]  ->  [Clause*]
              .       .     .               .              .           .              .             .          .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
              .       .     .               .              .           .              .             .          .  |  Description:
              .       .     .               .              .           .              .             .          .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
              .       .     .               .              .           .              .             .          .  |    otherwise CRef_Undef.
              .       .     .               .              .           .              .             .          .  |  
              .       .     .               .              .           .              .             .          .  |    Post-conditions:
              .       .     .               .              .           .              .             .          .  |      * the propagation queue is empty, even if there was a conflict.
              .       .     .               .              .           .              .             .          .  |________________________________________________________________________________________________@*/
              .       .     .               .              .           .              .             .          .  CRef Solver::propagate_()
    649,484,288       3     3               0              0           0    487,113,216             0          0  {
              .       .     .               .              .           .              .             .          .      //auto start_time=std::chrono::steady_clock::now();
     81,185,536       0     0               0              0           0     81,185,536             0          0      CRef    confl     = CRef_Undef;
     81,185,536       0     0               0              0           0     81,185,536           211          3      int     num_props = 0;
    162,371,072       0     0               0              0           0     81,185,536     2,611,114         24      watches.cleanAll();
    162,371,072       2     2               0              0           0     81,185,536             0          0      watches_bin.cleanAll();
              .       .     .               .              .           .              .             .          .      
 13,897,368,057       0     0   9,377,542,024      1,627,779           7              0             0          0      while (qhead < trail.size()){
 21,905,234,775       0     0   8,762,093,910    250,904,599           1  4,381,046,955             0          0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .     .               .              .           .              .             .          .          int currLevel = level(var(p));
              .       .     .               .              .           .              .             .          .          vec<Watcher>&  ws  = watches[p];
              .       .     .               .              .           .              .             .          .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          Watcher        *i, *j, *end;
  4,834,206,142       4     4   4,834,206,142      3,545,672           0              0             0          0          num_props++;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
              .       .     .               .              .           .              .             .          .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
 44,725,644,051       1     1   4,381,046,955  4,325,884,649 328,585,309              0             0          0          for (int k = 0; k < ws_bin.size(); k++){
 10,901,554,518       0     0  10,901,554,518  1,730,593,558 280,212,674              0             0          0              Lit the_other = ws_bin[k].blocker;
 29,830,026,780       0     0   6,344,242,187              0           0              0             0          0              if (value(the_other) == l_False){
        164,290     222     2          82,145              0           0         82,145             0          0                  confl = ws_bin[k].cref;
              .       .     .               .              .           .              .             .          .                  //auto end_time=std::chrono::steady_clock::now();
              .       .     .               .              .           .              .             .          .                  //auto duration=end_time-start_time;
              .       .     .               .              .           .              .             .          .  #ifdef LOOSE_PROP_STAT
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                  return confl;
              .       .     .               .              .           .              .             .          .  #else
              .       .     .               .              .           .              .             .          .                  goto ExitProp;
              .       .     .               .              .           .              .             .          .  #endif
 20,681,112,958      14    13               0              0           0              0             0          0              }else if(value(the_other) == l_Undef)
              .       .     .               .              .           .              .             .          .              {
 11,410,542,160       2     1   6,846,325,296        148,986           0  2,282,108,432     2,320,812         13                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
              .       .     .               .              .           .              .             .          .  #ifdef  PRINT_OUT                
              .       .     .               .              .           .              .             .          .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
              .       .     .               .              .           .              .             .          .  #endif                
              .       .     .               .              .           .              .             .          .  			}
              .       .     .               .              .           .              .             .          .          }
  8,761,929,620       0     0   8,761,929,620  4,330,399,148 242,789,113              0             0          0          total_Watchers+=ws.size();
  4,380,964,810       0     0   4,380,964,810              0           0              0             0          0          total_indexs++;//number of rounds
              .       .     .               .              .           .              .             .          .          //int count=0;
  2,668,384,708       0     0               0              0           0              0             0          0          bool no_clause_access=true;
  2,668,384,708       0     0               0              0           0  2,668,384,708             0          0          bool no_implication_added=true;
  2,668,384,708       0     0               0              0           0  2,668,384,708             0          0          bool no_change_other_watch=true;
 42,121,862,274       4     4  13,155,291,568              0           0  4,380,964,810             0          0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
              .       .     .               .              .           .              .             .          .              // Try to avoid inspecting the clause:
              .       .     .               .              .           .              .             .          .              //count++;
  8,774,326,758       1     1   8,774,326,758  3,295,301,857 405,388,957              0             0          0              Lit blocker = i->blocker;
 17,548,653,516       0     0   8,774,326,758     17,267,121         858              0             0          0              total_access_watches++;
 17,548,653,516       0     0   8,774,326,758  3,472,454,708     100,338              0             0          0              if (value(blocker) == l_True){
              .       .     .               .              .           .              .             .          .                  
 25,282,342,168       0     0   6,320,585,542              0           0  6,320,585,542     1,543,419          0                  *j++ = *i++; continue; }//no clause accessed
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Make sure the false literal is data[1]:
  2,462,670,184       0     0       1,335,958              0           0              0             0          0              no_clause_access=false;
  7,361,223,648       2     2   4,907,482,432     19,902,106       1,358  2,453,741,216             0          0              total_clause_access_times++;
  4,907,482,432       0     0   2,453,741,216              0           0              0             0          0              CRef     cr        = i->cref;
              .       .     .               .              .           .              .             .          .              //std::cout<<"cr: "<<cr<<"\n";
              .       .     .               .              .           .              .             .          .              Clause&  c         = ca[cr];
              .       .     .               .              .           .              .             .          .              Lit      false_lit = ~p;
  2,453,741,216       0     0   2,453,741,216              0           0              0             0          0              total_clause_access_size+=2;
  7,361,223,648       0     0   4,907,482,432  2,383,466,153 703,397,615              0             0          0              if (c[0] == false_lit)
    436,442,656       0     0     218,221,328      6,015,463   1,405,072    218,221,328             0          0                  c[0] = c[1], c[1] = false_lit;
              .       .     .               .              .           .              .             .          .              assert(c[1] == false_lit);
              .       .     .               .              .           .              .             .          .              i++;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // If 0th watch is true, then clause is already satisfied.
              .       .     .               .              .           .              .             .          .              Lit     first = c[0];
              .       .     .               .              .           .              .             .          .              Watcher w     = Watcher(cr, first);
  5,048,766,578       0     0      70,642,073     27,150,734       1,118              0             0          0              if (first != blocker && value(first) == l_True){
     70,969,935       0     0               0              0           0     47,313,290       113,302          0                  *j++ = w; continue; }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Look for new watch:
 73,181,110,991       1     1               0              0           0              0             0          0              for (int k = 2; k < c.size(); k++)
              .       .     .               .              .           .              .             .          .              {
118,796,524,099       0     0               0              0           0 23,853,152,188             0          0                  total_clause_access_size++;
 54,271,727,736       0     0   1,705,254,218              0           0              0             0          0                  if (value(c[k]) != l_False){
  4,318,019,620  43,144   158   2,159,009,810      2,392,214          40  2,159,009,810     2,189,862          0                      c[1] = c[k]; c[k] = false_lit;
  1,079,504,905       0     0   1,079,504,905              0           0              0             0          0                      total_change_other_watch++;
  1,079,504,905       0     0               0              0           0  1,079,504,905             0          0                      no_change_other_watch=false;
              .       .     .               .              .           .              .             .          .                      watches[~c[1]].push(w);
              .       .     .               .              .           .              .             .          .                      goto NextClause; }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Did not find watch -- clause is unit under assignment:
  4,053,988,176       0     0               0              0           0  2,701,159,332       983,394          0              *j++ = w;
  2,701,159,332       0     0               0              0           0              0             0          0              if (value(first) == l_False){
      2,249,178       0     0       2,249,178        119,281           0              0             0          0                  time_find_conflict++;
     13,495,068       1     1       8,996,712        406,627           1              0             0          0                  total_find_conflict_length+=i-(Watcher*)ws;
      4,498,356       0     0       4,498,356              0           0              0             0          0                  total_find_conflict_allsize+=ws.size();
              .       .     .               .              .           .              .             .          .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
      2,249,178       0     0               0              0           0      2,249,178             0          0                  confl = cr;
      4,498,356       0     0       2,249,178        129,777           0      2,249,178             0          0                  qhead = trail.size();
              .       .     .               .              .           .              .             .          .                  // Copy the remaining watches:
              .       .     .               .              .           .              .             .          .  
     39,120,036      38    38       3,585,136              0           0              0             0          0                  while (i < end)
     14,850,293       0     0      14,850,293      1,816,967     359,915     14,850,293         6,882          0                      *j++ = *i++;
              .       .     .               .              .           .              .             .          .              }else
              .       .     .               .              .           .              .             .          .              {//new implecate
  1,348,330,488       0     0               0              0           0  1,348,330,488        17,703          0                  no_implication_added=false;
  1,348,330,488       0     0   1,348,330,488              0           0              0             0          0                  total_push_new_implication++;
  4,044,991,464       0     0   2,696,660,976      1,217,816          21              0             0          0  				if (currLevel == decisionLevel())
              .       .     .               .              .           .              .             .          .  				{
  2,696,660,976       0     0               0              0           0              0             0          0  					uncheckedEnqueue(first, currLevel, cr);
              .       .     .               .              .           .              .             .          .  #ifdef PRINT_OUT					
              .       .     .               .              .           .              .             .          .  					std::cout << "i " << first << " l " << currLevel << "\n";
              .       .     .               .              .           .              .             .          .  #endif					
              .       .     .               .              .           .              .             .          .  				}
              .       .     .               .              .           .              .             .          .  				else
              .       .     .               .              .           .              .             .          .  				{
              .       .     .               .              .           .              .             .          .  					int nMaxLevel = currLevel;
    125,715,892       0     0               0              0           0              0             0          0  					int nMaxInd = 1;
              .       .     .               .              .           .              .             .          .  					// pass over all the literals in the clause and find the one with the biggest level
  1,348,541,550       0     0      62,857,946              0           0              0             0          0  					for (int nInd = 2; nInd < c.size(); ++nInd)
              .       .     .               .              .           .              .             .          .  					{
              .       .     .               .              .           .              .             .          .  						int nLevel = level(var(c[nInd]));
  1,114,880,952       0     0               0              0           0              0             0          0  						if (nLevel > nMaxLevel)
              .       .     .               .              .           .              .             .          .  						{
              .       .     .               .              .           .              .             .          .  							nMaxLevel = nLevel;
              .       .     .               .              .           .              .             .          .  							nMaxInd = nInd;
              .       .     .               .              .           .              .             .          .  						}
              .       .     .               .              .           .              .             .          .  					}
              .       .     .               .              .           .              .             .          .  
    125,715,892       1     1               0              0           0              0             0          0  					if (nMaxInd != 1)
              .       .     .               .              .           .              .             .          .  					{
              .       .     .               .              .           .              .             .          .  						std::swap(c[1], c[nMaxInd]);
              .       .     .               .              .           .              .             .          .  						*j--; // undo last watch
      5,158,064       0     0       5,158,064        123,487           0              0             0          0                          total_change_other_watch++;
      5,158,064       0     0               0              0           0      5,158,064       123,728          0                          no_change_other_watch=false;
              .       .     .               .              .           .              .             .          .  						watches[~c[1]].push(w);
              .       .     .               .              .           .              .             .          .  					}
              .       .     .               .              .           .              .             .          .  					
  6,804,510,386       0     0   1,348,330,488              0           0  1,348,330,488     6,839,139         37  					uncheckedEnqueue(first, nMaxLevel, cr);
              .       .     .               .              .           .              .             .          .  #ifdef PRINT_OUT					
              .       .     .               .              .           .              .             .          .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
              .       .     .               .              .           .              .             .          .  #endif	
              .       .     .               .              .           .              .             .          .  				}
              .       .     .               .              .           .              .             .          .  			}
              .       .     .               .              .           .              .             .          .  
      1,335,958     807   513               0              0           0              0             0          0  NextClause:;
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
 13,341,923,540       0     0   2,668,384,708              0           0              0             0          0          if(no_clause_access==true){
  3,291,354,861     315   307   3,291,354,861      5,052,602          75              0             0          0              total_no_clause_access++;
              .       .     .               .              .           .              .             .          .          }
  6,915,544,175     247   245   2,668,384,708              0           0              0             0          0          if(no_implication_added==true){
  5,350,318,059       1     1   3,637,737,957             71           0              0             0          0              total_no_implication_added++;
              .       .     .               .              .           .              .             .          .          }
  6,922,627,061       0     0   2,668,384,708              0           0              0             0          0          if(no_change_other_watch==true){
  3,927,723,478      51    51   3,927,723,478          8,717           0              0             0          0              total_no_change_other_watch++;
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          ws.shrink(i - j);
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  ExitProp:;
    162,206,782       2     2     162,206,782      4,088,424         206              0             0          0      propagations += num_props;
     81,103,391       0     0      81,103,391              0           0              0             0          0      simpDB_props -= num_props;
              .       .     .               .              .           .              .             .          .  
     81,103,391       0     0      81,103,391              0           0              0             0          0      return confl;
  1,374,314,641  19,252    91     568,298,752      4,781,991           6              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  /*_________________________________________________________________________________________________
              .       .     .               .              .           .              .             .          .  |
              .       .     .               .              .           .              .             .          .  |  reduceDB : ()  ->  [void]
              .       .     .               .              .           .              .             .          .  |  
              .       .     .               .              .           .              .             .          .  |  Description:
              .       .     .               .              .           .              .             .          .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
              .       .     .               .              .           .              .             .          .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
              .       .     .               .              .           .              .             .          .  |________________________________________________________________________________________________@*/
              .       .     .               .              .           .              .             .          .  struct reduceDB_lt { 
              .       .     .               .              .           .              .             .          .      ClauseAllocator& ca;
              .       .     .               .              .           .              .             .          .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
     58,648,324     308   308      57,437,471     17,558,358   1,515,332              0             0          0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
              .       .     .               .              .           .              .             .          .  };
              .       .     .               .              .           .              .             .          .  void Solver::reduceDB()
            924     154   154               0              0           0            616             0          0  {
              .       .     .               .              .           .              .             .          .      int     i, j;
              .       .     .               .              .           .              .             .          .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .     .               .              .           .              .             .          .      //local_learnts_dirty = false;
              .       .     .               .              .           .              .             .          .  
            154       0     0               0              0           0              0             0          0      sort(learnts_local, reduceDB_lt(ca));
              .       .     .               .              .           .              .             .          .  
            770       0     0             154            154           0              0             0          0      int limit = learnts_local.size() / 2;
      4,887,502     154   154               0              0           0              0             0          0      for (i = j = 0; i < learnts_local.size(); i++){
      7,330,098     154   154       4,886,732        152,900           0              0             0          0          Clause& c = ca[learnts_local[i]];
      4,886,732       0     0       2,443,366      2,424,803      49,164              0             0          0          if (c.mark() == LOCAL)
      9,428,820       0     0       2,417,564              0           0              0             0          0              if (c.removable() && !locked(c) && i < limit)
      6,047,460       0     0       1,209,492              2           0      1,209,492             0          0                  removeClause(learnts_local[i]);
              .       .     .               .              .           .              .             .          .              else{
        110,081       0     0               0              0           0              0             0          0                  if (!c.removable()) limit++;
              .       .     .               .              .           .              .             .          .                  c.removable(true);
      6,091,964       0     0       1,208,072              0           0      1,208,072        76,717          0                  learnts_local[j++] = learnts_local[i]; }
              .       .     .               .              .           .              .             .          .      }
            154       0     0               0              0           0              0             0          0      learnts_local.shrink(i - j);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      checkGarbage();
            837       0     0             683            154           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  void Solver::reduceDB_Tier2()
          1,386     231   231               0              0           0          1,155             0          0  {
              .       .     .               .              .           .              .             .          .      int i, j;
      2,966,814     204   204             231             85           0              0             0          0      for (i = j = 0; i < learnts_tier2.size(); i++){
      3,689,151     229   229       2,459,434         77,120      76,426              0             0          0          Clause& c = ca[learnts_tier2[i]];
      2,459,434       0     0               0              0           0              0             0          0          if (c.mark() == TIER2)
      5,930,980     175   175       2,372,392        719,514     566,998              0             0          0              if (!locked(c) && c.touched() + 30000 < conflicts){
              1       0     0               0              0           0              0             0          0                  learnts_local.push(learnts_tier2[i]);
              .       .     .               .              .           .              .             .          .                  c.mark(LOCAL);
              .       .     .               .              .           .              .             .          .                  //c.removable(true);
              .       .     .               .              .           .              .             .          .                  c.activity() = 0;
              .       .     .               .              .           .              .             .          .                  claBumpActivity(c);
              .       .     .               .              .           .              .             .          .              }else
      4,883,600       0     0         976,720              0           0        976,720        50,229          0                  learnts_tier2[j++] = learnts_tier2[i];
              .       .     .               .              .           .              .             .          .      }
            231       0     0               0              0           0              0             0          0      learnts_tier2.shrink(i - j);
          1,386       0     0           1,386            231           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::removeSatisfied(vec<CRef>& cs)
          2,610       0     0               0              0           0          1,160             0          0  {
              .       .     .               .              .           .              .             .          .      int i, j;
  1,566,581,088     145   145     313,316,334         19,012         175              0             0          0      for (i = j = 0; i < cs.size(); i++){
    939,948,129       0     0     626,632,086     19,595,010  19,582,163              0             0          0          Clause& c = ca[cs[i]];
              .       .     .               .              .           .              .             .          .          if (satisfied(c))
        138,409     112   112               1              0           0         46,136        27,225         80              removeClause(cs[i]);
              .       .     .               .              .           .              .             .          .          else
    626,539,814       0     0               0              0           0    313,269,907     2,076,116          0              cs[j++] = cs[i];
              .       .     .               .              .           .              .             .          .      }
            290       0     0               0              0           0              0             0          0      cs.shrink(i - j);
          1,740      34    34           1,450            576         149              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
          1,752       0     0               0              0           0          1,460             0          0  {
              .       .     .               .              .           .              .             .          .      int i, j;
      4,673,574     145   145             292            145          10              0             0          0      for (i = j = 0; i < cs.size(); i++){
      6,916,401       0     0       4,610,934        311,040     142,902              0             0          0          Clause& c = ca[cs[i]];
      4,610,934       0     0               0              0           0              0             0          0          if (c.mark() == valid_mark)
              .       .     .               .              .           .              .             .          .              if (satisfied(c))
          4,160      12    12           1,040             15           0          1,040           637          4                  removeClause(cs[i]);
              .       .     .               .              .           .              .             .          .              else
     11,377,255       0     0       2,275,451        207,554           0      2,275,451       262,645          0                  cs[j++] = cs[i];
              .       .     .               .              .           .              .             .          .      }
            290       0     0               0              0           0              0             0          0      cs.shrink(i - j);
          1,752      84    84           1,752            573          36              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::rebuildOrderHeap()
          1,323      11    11               0              0           0            882             0          0  {
              .       .     .               .              .           .              .             .          .      vec<Var> vs;
     55,697,859       0     0             147              0           0            147            21          0      for (Var v = 0; v < nVars(); v++)
    167,066,552       0     0      83,533,276        870,935     444,262              0             0          0          if (decision[v] && value(v) == l_Undef)
              .       .     .               .              .           .              .             .          .              vs.push(v);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      order_heap_CHB  .build(vs);
              .       .     .               .              .           .              .             .          .      order_heap_VSIDS.build(vs);
              .       .     .               .              .           .              .             .          .      order_heap_distance.build(vs);
          1,176     147   147           1,029            293           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  /*_________________________________________________________________________________________________
              .       .     .               .              .           .              .             .          .  |
              .       .     .               .              .           .              .             .          .  |  simplify : [void]  ->  [bool]
              .       .     .               .              .           .              .             .          .  |  
              .       .     .               .              .           .              .             .          .  |  Description:
              .       .     .               .              .           .              .             .          .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
              .       .     .               .              .           .              .             .          .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
              .       .     .               .              .           .              .             .          .  |________________________________________________________________________________________________@*/
              .       .     .               .              .           .              .             .          .  bool Solver::simplify()
         78,228   2,414 1,627               0              0           0         52,152             0          0  {
              .       .     .               .              .           .              .             .          .      assert(decisionLevel() == 0);
              .       .     .               .              .           .              .             .          .  
         65,190       0     0          13,038         11,017         436              0             0          0      if (!ok || propagate() != CRef_Undef)
              .       .     .               .              .           .              .             .          .          return ok = false;
              .       .     .               .              .           .              .             .          .  
         43,846   2,499 1,912          28,442              0           0              0             0          0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
              .       .     .               .              .           .              .             .          .          return true;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Remove satisfied clauses:
            438       0     0               0              0           0            146             0          0      removeSatisfied(learnts_core); // Should clean core first.
            584       0     0               0              0           0            146             0          0      safeRemoveSatisfied(learnts_tier2, TIER2);
            584     146   146               0              0           0            146             0          0      safeRemoveSatisfied(learnts_local, LOCAL);
            292       0     0             146            146          78              0             0          0      if (remove_satisfied)        // Can be turned off.
            580     290   290               0              0           0            145             0          0          removeSatisfied(clauses);
              .       .     .               .              .           .              .             .          .      checkGarbage();
            292       1     1               0              0           0            146             0          0      rebuildOrderHeap();
              .       .     .               .              .           .              .             .          .  
            292       0     0             146            146           0            146             0          0      simpDB_assigns = nAssigns();
            438       0     0             292            146           4            146             0          0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
              .       .     .               .              .           .              .             .          .  
            146       0     0               0              0           0              0             0          0      return true;
         91,266       0     0          65,190              0           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  // pathCs[k] is the number of variables assigned at level k,
              .       .     .               .              .           .              .             .          .  // it is initialized to 0 at the begining and reset to 0 after the function execution
        190,536       9     9               0              0           0        142,902             0          0  bool Solver::collectFirstUIP(CRef confl){
         47,634       0     0               0              0           0         23,817           108          0      involved_lits.clear();
     16,518,656      11    11               0              0           0              0             0          0      int max_level=1;
              .       .     .               .              .           .              .             .          .      Clause& c=ca[confl]; int minLevel=decisionLevel();
      6,223,867       0     0          23,817              0           0              0             0          0      for(int i=0; i<c.size(); i++) {
              .       .     .               .              .           .              .             .          .          Var v=var(c[i]);
              .       .     .               .              .           .              .             .          .          //        assert(!seen[v]);
      9,157,173     291   124       3,052,391      1,558,744         159              0             0          0          if (level(v)>0) {
      6,104,518       0     0       3,052,259         23,067           4      3,052,259       700,656        251              seen[v]=1;
      6,128,335       0     0       3,076,076         46,381          24      3,052,259     1,977,188    642,635              var_iLevel_tmp[v]=1;
      3,052,259       0     0       3,052,259      1,215,668      93,161              0             0          0              pathCs[level(v)]++;
              .       .     .               .              .           .              .             .          .              if (minLevel>level(v)) {
              .       .     .               .              .           .              .             .          .                  minLevel=level(v);
              .       .     .               .              .           .              .             .          .                  assert(minLevel>0);
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              //    varBumpActivity(v);
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
         71,451       0     0          47,634         23,622       1,006              0             0          0      int limit=trail_lim[minLevel-1];
 12,247,917,060       0     0          23,817              0           0              0             0          0      for(int i=trail.size()-1; i>=limit; i--) {
  6,123,910,896     127    95   6,123,910,896    191,295,052       3,568              0             0          0          Lit p=trail[i]; Var v=var(p);
  6,123,910,896       0     0   3,061,955,448  1,934,392,245      19,494              0             0          0          if (seen[v]) {
              .       .     .               .              .           .              .             .          .              int currentDecLevel=level(v);
              .       .     .               .              .           .              .             .          .              //      if (currentDecLevel==decisionLevel())
              .       .     .               .              .           .              .             .          .              //      	varBumpActivity(v);
     11,956,170       0     0               0              0           0     11,956,170             0          0              seen[v]=0;
     23,912,340       0     0      11,956,170      2,692,295           0              0             0          0              if (--pathCs[currentDecLevel]!=0) {
              .       .     .               .              .           .              .             .          .                  Clause& rc=ca[reason(v)];
     32,870,593      12    10      24,563,631      5,503,173           0              0             0          0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
     16,375,754       0     0               0              0           0              0             0          0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
     25,689,948       0     0               0              0           0              0             0          0                  if (rc.size()==2 && value(rc[0])==l_False) {
              .       .     .               .              .           .              .             .          .                      // Special case for binary clauses
              .       .     .               .              .           .              .             .          .                      // The first one has to be SAT
              .       .     .               .              .           .              .             .          .                      assert(value(rc[1]) != l_False);
              .       .     .               .              .           .              .             .          .                      Lit tmp = rc[0];
        180,183       0     0          60,061          2,295       1,934        120,122             0          0                      rc[0] =  rc[1], rc[1] = tmp;
              .       .     .               .              .           .              .             .          .                  }
     42,616,572       0     0               0              0           0              0             0          0                  for (int j = 1; j < rc.size(); j++){
              .       .     .               .              .           .              .             .          .                      Lit q = rc[j]; Var v1=var(q);
     35,555,012       0     0               0              0           0              0             0          0                      if (level(v1) > 0) {
     35,554,102       0     0               0              0           0              0             0          0                          if (minLevel>level(v1)) {
        170,840       0     0          85,420         41,418       1,726              0             0          0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
              .       .     .               .              .           .              .             .          .                          }
     53,331,153       0     0      35,554,102      4,084,507         120              0             0          0                          if (seen[v1]) {
     17,746,280       0     0       8,873,140      1,812,177           0              0             0          0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
      4,107,108       0     0               0              0           0      2,053,554             0          0                                  var_iLevel_tmp[v1]=reasonVarLevel;
              .       .     .               .              .           .              .             .          .                          }
              .       .     .               .              .           .              .             .          .                          else {
      8,903,911       0     0               0              0           0      8,903,911     6,894,682  1,085,243                              var_iLevel_tmp[v1]=reasonVarLevel;
              .       .     .               .              .           .              .             .          .                              //   varBumpActivity(v1);
      8,903,911       0     0               0              0           0      8,903,911             0          0                              seen[v1] = 1;
     26,711,733      10     7      17,807,822      2,306,558      81,206              0             0          0                              pathCs[level(v1)]++;
              .       .     .               .              .           .              .             .          .                          }
              .       .     .               .              .           .              .             .          .                      }
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              involved_lits.push(p);
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
         71,451   5,989    18          23,817             14           0         23,817             0          0      double inc=var_iLevel_inc;
              .       .     .               .              .           .              .             .          .      vec<int> level_incs; level_incs.clear();
      2,074,796       0     0         801,338              0           0              0             0          0      for(int i=0;i<max_level;i++){
        848,972       8     8         424,486              0           0              0             0          0          level_incs.push(inc);
      1,273,458       0     0         848,972              2           0        424,486             0          0          inc = inc/my_var_decay;
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
     24,007,608       0     0      11,979,987              0           0              0             0          0      for(int i=0;i<involved_lits.size();i++){
         23,817       0     0          23,817              0           0              0             0          0          Var v =var(involved_lits[i]);
              .       .     .               .              .           .              .             .          .          //        double old_act=activity_distance[v];
              .       .     .               .              .           .              .             .          .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
    107,986,602  10,057    46      35,963,778     21,371,276     294,525     11,979,987             0          0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
              .       .     .               .              .           .              .             .          .  
     23,912,340       0     0               0              0           0              0             0          0          if(activity_distance[v]>1e100){
              .       .     .               .              .           .              .             .          .              for(int vv=0;vv<nVars();vv++)
        119,085   1,780   112          47,634         47,634          16         47,634             0          0                  activity_distance[vv] *= 1e-100;
              .       .     .               .              .           .              .             .          .              var_iLevel_inc*=1e-100;
        848,493      70    57               0              0           0              0             0          0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .          if (order_heap_distance.inHeap(v))
              .       .     .               .              .           .              .             .          .              order_heap_distance.decrease(v);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          //        var_iLevel_inc *= (1 / my_var_decay);
              .       .     .               .              .           .              .             .          .      }
        119,085     697    61          47,634          1,000           0         23,817             0          0      var_iLevel_inc=level_incs[level_incs.size()-1];
              .       .     .               .              .           .              .             .          .      return true;
        214,353       0     0         166,719         23,814           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  struct UIPOrderByILevel_Lt {
              .       .     .               .              .           .              .             .          .      Solver& solver;
              .       .     .               .              .           .              .             .          .      const vec<double>&  var_iLevel;
              .       .     .               .              .           .              .             .          .      bool operator () (Lit x, Lit y) const
              .       .     .               .              .           .              .             .          .      {
              .       .     .               .              .           .              .             .          .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
              .       .     .               .              .           .              .             .          .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
              .       .     .               .              .           .              .             .          .  |    Search for a model the specified number of conflicts. 
              .       .     .               .              .           .              .             .          .  |  
              .       .     .               .              .           .              .             .          .  |  Output:
              .       .     .               .              .           .              .             .          .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
              .       .     .               .              .           .              .             .          .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
              .       .     .               .              .           .              .             .          .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
              .       .     .               .              .           .              .             .          .  |________________________________________________________________________________________________@*/
              .       .     .               .              .           .              .             .          .  lbool Solver::search(int& nof_conflicts)
        142,384  12,879 4,229               0              0           0         90,608            48         47  {
              .       .     .               .              .           .              .             .          .      assert(ok);
              .       .     .               .              .           .              .             .          .      int         backtrack_level;
              .       .     .               .              .           .              .             .          .      int         lbd;
              .       .     .               .              .           .              .             .          .      vec<Lit>    learnt_clause;
              .       .     .               .              .           .              .             .          .      bool        cached = false;
         12,944       0     0          12,944            172           0              0             0          0      starts++;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // simplify
              .       .     .               .              .           .              .             .          .      //
         51,776       2     2          38,832         12,944       5,147              0             0          0      if (conflicts >= curSimplify * nbconfbeforesimplify){
              .       .     .               .              .           .              .             .          .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
              .       .     .               .              .           .              .             .          .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
              .       .     .               .              .           .              .             .          .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
              .       .     .               .              .           .              .             .          .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
             48       3     2              48             48           0              0             0          0          nbSimplifyAll++;
            144      48    48               0              0           0             48             0          0          if (!simplifyAll()){
              .       .     .               .              .           .              .             .          .              return l_False;
              .       .     .               .              .           .              .             .          .          }
            336       0     0              96             44           0             48             0          0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
            144       0     0              48              0           0             48             0          0          nbconfbeforesimplify += incSimplify;
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      for (;;){
              .       .     .               .              .           .              .             .          .          CRef confl = propagate();
              .       .     .               .              .           .              .             .          .  
    162,338,792       0     0               0              0           0              0             0          0          if (confl != CRef_Undef){
              .       .     .               .              .           .              .             .          .              // CONFLICT
      6,993,969       0     0       2,331,323        455,513           0              0             0          0              if (VSIDS){
      2,433,102       0     0       1,216,536      1,068,910          36             30             0          0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
              .       .     .               .              .           .              .             .          .              }else
      4,364,505   1,026   300       2,569,669      1,006,923          79        340,001             0          0                  if (step_size > min_step_size) step_size -= step_size_dec;
              .       .     .               .              .           .              .             .          .  
      9,325,292   2,969 2,416       4,662,646      2,242,525         203      2,331,323             0          0              conflicts++; nof_conflicts--;
              .       .     .               .              .           .              .             .          .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
              .       .     .               .              .           .              .             .          .              ConflictData data = FindConflictLevel(confl);
      4,662,646   1,452 1,135               0              0           0              0             0          0              if (data.nHighestLevel == 0) return l_False;
      2,255,894       0     0         331,622         42,880           0              0             0          0              if (data.bOnlyOneLitFromHighest)
              .       .     .               .              .           .              .             .          .              {
        796,325   2,792   424               0              0           0              0             0          0  				cancelUntil(data.nHighestLevel - 1);
              .       .     .               .              .           .              .             .          .  				continue;
              .       .     .               .              .           .              .             .          .  			}
              .       .     .               .              .           .              .             .          .  			
              .       .     .               .              .           .              .             .          .              learnt_clause.clear();
      3,069,996       0     0               0              0           0      1,534,998     1,410,389          1              if(conflicts>50000) DISTANCE=0;
              .       .     .               .              .           .              .             .          .              else DISTANCE=1;
      4,606,720       0     0               0              0           0              0             0          0              if(VSIDS && DISTANCE)
         95,268       9     9               0              0           0         23,817            96          0                  collectFirstUIP(confl);
              .       .     .               .              .           .              .             .          .  
      9,209,988     160   159               0              0           0      1,534,998        22,048          0              analyze(confl, learnt_clause, backtrack_level, lbd);
              .       .     .               .              .           .              .             .          .              // check chrono backtrack condition
     21,461,979     139   139       7,670,991      2,167,403           0              0             0          0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
              .       .     .               .              .           .              .             .          .              {
        480,578       0     0         480,578        157,007           0              0             0          0  				++chrono_backtrack;
        480,578       0     0               0              0           0              0             0          0  				cancelUntil(data.nHighestLevel -1);
              .       .     .               .              .           .              .             .          .  			}
              .       .     .               .              .           .              .             .          .  			else // default behavior
              .       .     .               .              .           .              .             .          .  			{
      1,054,420  19,670 3,298       1,054,420        695,095           0              0             0          0  				++non_chrono_backtrack;
              .       .     .               .              .           .              .             .          .  				cancelUntil(backtrack_level);
              .       .     .               .              .           .              .             .          .  			}
              .       .     .               .              .           .              .             .          .  
      4,604,994       0     0       1,534,998      1,297,188           0      1,534,998             0          0              lbd--;
      3,069,996       0     0       1,534,998         16,405           0              0             0          0              if (VSIDS){
        768,362   2,095 1,607               0              0           0        768,362             0          0                  cached = false;
      2,305,086  21,179 2,405       2,305,086      1,298,469         151              0             0          0                  conflicts_VSIDS++;
              .       .     .               .              .           .              .             .          .                  lbd_queue.push(lbd);
      6,146,896       0     0       2,305,086              0           0        768,362             0          0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
              .       .     .               .              .           .              .             .          .  
      4,604,994      65    63       1,534,998              0           0              0             0          0              if (learnt_clause.size() == 1){
          1,442      51    18             412            193           0            206             0          0                  uncheckedEnqueue(learnt_clause[0]);
              .       .     .               .              .           .              .             .          .              }else{
              .       .     .               .              .           .              .             .          .                  CRef cr = ca.alloc(learnt_clause, true);
      1,534,792       0     0       1,534,792         43,152           0              0             0          0                  ca[cr].set_lbd(lbd);
              .       .     .               .              .           .              .             .          .                  //duplicate learnts 
              .       .     .               .              .           .              .             .          .                  int  id = 0;
      3,069,584       0     0       1,534,792      1,526,838         444              0             0          0                  if (lbd <= max_lbd_dup){                        
              .       .     .               .              .           .              .             .          .                      std::vector<uint32_t> tmp;
     48,582,248       0     0      32,007,908              0           0        637,739             0          0                      for (int i = 0; i < learnt_clause.size(); i++)
     33,283,386      45    45      22,188,924            911           0     11,094,462             0          0                          tmp.push_back(learnt_clause[i].x);
      1,913,217      34    34         637,739              0           0        637,739             0          0                      id = is_duplicate(tmp);             
      3,188,695       0     0         637,739            162           0              0             0          0                      if (id == min_number_of_learnts_copies +1){
            664       0     0             664            491           0              0             0          0                          duplicates_added_conflicts++;                        
              .       .     .               .              .           .              .             .          .                      }                    
      1,275,478       0     0               0              0           0              0             0          0                      if (id == min_number_of_learnts_copies){
         10,186       0     0          10,186              0           0              0             0          0                          duplicates_added_tier2++;
              .       .     .               .              .           .              .             .          .                      }                                        
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .                  //duplicate learnts
              .       .     .               .              .           .              .             .          .  
      8,369,184       0     0       2,859,692        751,558         202              0             0          0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
             22      11    11               0              0           0              0             0          0                      learnts_core.push(cr);
              .       .     .               .              .           .              .             .          .                      ca[cr].mark(CORE);
      4,757,142  56,360 3,120               0              0           0              0             0          0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
             20       1     1               0              0           0              0             0          0                      learnts_tier2.push(cr);
              .       .     .               .              .           .              .             .          .                      ca[cr].mark(TIER2);
      1,084,064       0     0         271,016              3           0        271,016            41          0                      ca[cr].touched() = conflicts;
              .       .     .               .              .           .              .             .          .                  }else{
             22      19    15               0              0           0              0             0          0                      learnts_local.push(cr);
              .       .     .               .              .           .              .             .          .                      claBumpActivity(ca[cr]); }
      4,604,376  11,327 2,906               0              0           0      1,534,792        43,274          0                  attachClause(cr);
              .       .     .               .              .           .              .             .          .  
      9,208,752       0     0       4,604,376         40,047           0      1,534,792             0          0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
              .       .     .               .              .           .              .             .          .  #ifdef PRINT_OUT
              .       .     .               .              .           .              .             .          .                  std::cout << "new " << ca[cr] << "\n";
              .       .     .               .              .           .              .             .          .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
              .       .     .               .              .           .              .             .          .  #endif                
              .       .     .               .              .           .              .             .          .              }
      4,604,994       0     0       1,534,998        793,489           0              0             0          0              if (drup_file){
              .       .     .               .              .           .              .             .          .  #ifdef BIN_DRUP
              .       .     .               .              .           .              .             .          .                  binDRUP('a', learnt_clause, drup_file);
              .       .     .               .              .           .              .             .          .  #else
              .       .     .               .              .           .              .             .          .                  for (int i = 0; i < learnt_clause.size(); i++)
              .       .     .               .              .           .              .             .          .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
              .       .     .               .              .           .              .             .          .                  fprintf(drup_file, "0\n");
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
      4,604,994   7,278 2,497       3,069,996        846,231         249              0             0          0              if (VSIDS) varDecayActivity();
              .       .     .               .              .           .              .             .          .              claDecayActivity();
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              /*if (--learntsize_adjust_cnt == 0){
              .       .     .               .              .           .              .             .          .                  learntsize_adjust_confl *= learntsize_adjust_inc;
              .       .     .               .              .           .              .             .          .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
              .       .     .               .              .           .              .             .          .                  max_learnts             *= learntsize_inc;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
              .       .     .               .              .           .              .             .          .                             (int)conflicts,
              .       .     .               .              .           .              .             .          .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
              .       .     .               .              .           .              .             .          .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
              .       .     .               .              .           .              .             .          .              }*/
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .          }else{
              .       .     .               .              .           .              .             .          .              // NO CONFLICT
              .       .     .               .              .           .              .             .          .              bool restart = false;
    236,514,219      50    50      78,838,073        627,335           4              0             0          0              if (!VSIDS)
              .       .     .               .              .           .              .             .          .                  restart = nof_conflicts <= 0;
    119,328,412       1     1      59,664,206      2,619,993         142              0             0          0              else if (!cached){
      2,877,622     383   215       1,080,007        244,764           2        405,452             0          0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
              .       .     .               .              .           .              .             .          .                  cached = true;
              .       .     .               .              .           .              .             .          .              }
     57,521,601       0     0      19,173,867      1,980,195          93              0             0          0              if (restart /*|| !withinBudget()*/){
              .       .     .               .              .           .              .             .          .                  lbd_queue.clear();
              .       .     .               .              .           .              .             .          .                  cached = false;
              .       .     .               .              .           .              .             .          .                  // Reached bound on number of conflicts:
         38,829       0     0               0              0           0         25,886           829          0                  progress_estimate = progressEstimate();
              .       .     .               .              .           .              .             .          .                  cancelUntil(0);
         25,886       0     0               0              0           0              0             0          0                  return l_Undef; }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Simplify the set of problem clauses:
    236,606,343   1,719 1,243      78,825,130              0           0         91,841             0          0              if (decisionLevel() == 0 && !simplify())
              .       .     .               .              .           .              .             .          .                  return l_False;
              .       .     .               .              .           .              .             .          .  
    236,475,390     876   390     157,650,260        698,355         256              0             0          0              if (conflicts >= next_T2_reduce){
            462       0     0               0              0           0            231             0          0                  next_T2_reduce = conflicts + 10000;
            924       0     0             231              0           0            231             0          0                  reduceDB_Tier2(); }
    157,650,260     307   158      78,825,130              0           0              0             0          0              if (conflicts >= next_L_reduce){
            308       0     0               0              0           0            154             0          0                  next_L_reduce = conflicts + 15000;
            308       0     0               0              0           0            154             0          0                  reduceDB(); }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              Lit next = lit_Undef;
              .       .     .               .              .           .              .             .          .              /*while (decisionLevel() < assumptions.size()){
              .       .     .               .              .           .              .             .          .                  // Perform user provided assumption:
              .       .     .               .              .           .              .             .          .                  Lit p = assumptions[decisionLevel()];
              .       .     .               .              .           .              .             .          .                  if (value(p) == l_True){
              .       .     .               .              .           .              .             .          .                      // Dummy decision level:
              .       .     .               .              .           .              .             .          .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
              .       .     .               .              .           .              .             .          .                  }else{
              .       .     .               .              .           .              .             .          .                      next = p;
              .       .     .               .              .           .              .             .          .                      break;
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              if (next == lit_Undef)*/{
              .       .     .               .              .           .              .             .          .                  // New variable decision:
     78,825,130       0     0      78,825,130            154          87              0             0          0                  decisions++;
    236,475,390   8,985 3,764               0              0           0     78,825,130             0          0                  next = pickBranchLit();
              .       .     .               .              .           .              .             .          .  
    157,650,260       0     0               0              0           0              0             0          0                  if (next == lit_Undef)
              .       .     .               .              .           .              .             .          .                      // Model found:
              2       1     1               0              0           0              0             0          0                      return l_True;
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .              // Increase decision level and enqueue 'next'
              .       .     .               .              .           .              .             .          .              newDecisionLevel();
    472,950,774     204   193      78,825,129              0           0     78,825,129             0          0              uncheckedEnqueue(next, decisionLevel());
              .       .     .               .              .           .              .             .          .  #ifdef PRINT_OUT            
              .       .     .               .              .           .              .             .          .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
              .       .     .               .              .           .              .             .          .  #endif            
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
        116,496     163   162          90,608         25,888          13              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  double Solver::progressEstimate() const
         77,658       2     2               0              0           0         64,715             0          0  {
         25,886       0     0               0              0           0              0             0          0      double  progress = 0;
         64,715       0     0          25,886          6,691           0         12,943             0          0      double  F = 1.0 / nVars();
              .       .     .               .              .           .              .             .          .  
    127,031,228       6     6               0              0           0              0             0          0      for (int i = 0; i <= decisionLevel(); i++){
    126,953,570       0     0      84,618,456              0           0              0             0          0          int beg = i == 0 ? 0 : trail_lim[i - 1];
    169,275,741       0     0      84,631,399      2,657,580     460,547              0             0          0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
    253,971,855      43    43      42,335,114              0           0              0             0          0          progress += pow(F, i) * (end - beg);
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
         25,886       0     0               0              0           0              0             0          0      return progress / nVars();
         90,601       0     0          77,658              0           0              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  /*
              .       .     .               .              .           .              .             .          .    Finite subsequences of the Luby-sequence:
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .    0: 1
              .       .     .               .              .           .              .             .          .    1: 1 1 2
              .       .     .               .              .           .              .             .          .    2: 1 1 2 1 1 2 4
              .       .     .               .              .           .              .             .          .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .   */
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  static double luby(double y, int x){
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Find the finite subsequence that contains index 'x', and the
              .       .     .               .              .           .              .             .          .      // size of that subsequence:
              .       .     .               .              .           .              .             .          .      int size, seq;
        102,403       0     0               0              0           0              0             0          0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
              .       .     .               .              .           .              .             .          .  
         57,358      13    13               0              0           0              0             0          0      while (size-1 != x){
         32,796       0     0               0              0           0              0             0          0          size = (size-1)>>1;
         16,398       0     0               0              0           0              0             0          0          seq--;
         49,194       0     0               0              0           0              0             0          0          x = x % size;
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      return pow(y, seq);
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  static bool switch_mode = false;
              .       .     .               .              .           .              .             .          .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
              .       .     .               .              .           .              .             .          .  
              8       1     1               0              0           0              6             0          0  uint32_t Solver::reduceduplicates(){
              .       .     .               .              .           .              .             .          .      uint32_t removed_duplicates = 0;
              .       .     .               .              .           .              .             .          .      std::vector<std::vector<uint64_t>> tmp;
              .       .     .               .              .           .              .             .          .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
        290,387       0     0               2              0           0              0             0          0      for (auto & outer_mp: ht){//variables
        948,410       0     0               0              0           0              0             0          0          for (auto &inner_mp:outer_mp.second){//sizes
      1,316,198       0     0               0              0           0              0             0          0              for (auto &in_in_mp: inner_mp.second){
      1,205,037       1     1         401,679        393,650     323,468              0             0          0                  if (in_in_mp.second >= 2){
              .       .     .               .              .           .              .             .          .                  //min_number_of_learnts_copies
        988,540       1     1         395,416         12,138      11,633        395,416             8          0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
              .       .     .               .              .           .              .             .          .                  }
              .       .     .               .              .           .              .             .          .              }                    
              .       .     .               .              .           .              .             .          .           }
              .       .     .               .              .           .              .             .          .      }          
              3       0     0               1              1           1              1             0          0      removed_duplicates = dupl_db_size-tmp.size();  
              .       .     .               .              .           .              .             .          .      ht.clear();
        691,983       1     1         296,563              1           1              0             0          0      for (auto i=0;i<tmp.size();i++){
        988,540       0     0         494,270        120,238     116,730        296,562             1          1          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .      return removed_duplicates;
              9       0     0               8              3           3              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  // NOTE: assumptions passed in member-variable 'assumptions'.
              .       .     .               .              .           .              .             .          .  lbool Solver::solve_()
              8       0     0               0              0           0              6             0          0  {
              .       .     .               .              .           .              .             .          .      //signal(SIGALRM, SIGALRM_switch);
              .       .     .               .              .           .              .             .          .      //alarm(2500);
              .       .     .               .              .           .              .             .          .  
              1       1     1               0              0           0              0             0          0      model.clear();
              .       .     .               .              .           .              .             .          .      conflict.clear();
              2       1     1               1              0           0              0             0          0      if (!ok) return l_False;
              .       .     .               .              .           .              .             .          .  
              1       1     1               1              1           1              0             0          0      solves++;
              .       .     .               .              .           .              .             .          .  
              5       0     0               2              0           0              1             0          0      max_learnts               = nClauses() * learntsize_factor;
              3       0     0               1              1           1              0             0          0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
              1       0     0               0              0           0              1             1          1      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
              .       .     .               .              .           .              .             .          .      lbool   status            = l_Undef;
              .       .     .               .              .           .              .             .          .  
              3       0     0               1              0           0              0             0          0      if (verbosity >= 1){
              2       0     0               0              0           0              1             0          0          printf("c ============================[ Search Statistics ]==============================\n");
              2       1     1               0              0           0              1             0          0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
              2       0     0               0              0           0              1             0          0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
              2       0     0               0              0           0              1             0          0          printf("c ===============================================================================\n");
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      add_tmp.clear();
              .       .     .               .              .           .              .             .          .  
              1       0     0               0              0           0              1             1          1      VSIDS = true;
              1       1     1               0              0           0              1             0          0      int init = 10000;
            865       0     0             173              0           0              0             0          0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
            692       3     3               0              0           0            173             0          0          status = search(init);
              1       0     0               0              0           0              1             0          0      VSIDS = false;
              .       .     .               .              .           .              .             .          .  
              3       1     1               0              0           0              2             1          0      duplicates_added_conflicts = 0;
              .       .     .               .              .           .              .             .          .      duplicates_added_minimization=0;
              .       .     .               .              .           .              .             .          .      duplicates_added_tier2 =0;    
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      dupl_db_size=0;
              1       0     0               1              1           0              0             0          0      size_t dupl_db_size_limit = dupl_db_init_size;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // Search:
              1       0     0               0              0           0              0             0          0      int curr_restarts = 0;
              1       0     0               0              0           0              0             0          0      uint64_t curr_props = 0;
              .       .     .               .              .           .              .             .          .      uint32_t removed_duplicates =0;
         25,542  12,734 4,851               0              0           0              0             0          0      while (status == l_Undef /*&& withinBudget()*/){
         25,542       1     1          12,771         10,739           5              0             0          0          if (dupl_db_size >= dupl_db_size_limit){    
              4       1     1               1              0           0              1             0          0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
              4       0     0               1              1           0              1             0          0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
              4       0     0               1              0           0              1             0          0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
              4       1     1               1              1           0              1             0          0              printf("c Duptime: %i\n",duptime.count());
              4       0     0               1              0           0              1             0          0              printf("c Number of conflicts: %i\n",conflicts);
              4       0     0               1              1           0              1             0          0              printf("c Core size: %i\n",learnts_core.size());
              .       .     .               .              .           .              .             .          .              
              2       0     0               0              0           0              1             0          0              removed_duplicates = reduceduplicates();
              8       1     1               2              2           2              0             0          0              dupl_db_size_limit*=1.1;
              2       0     0               1              1           1              0             0          0              dupl_db_size -= removed_duplicates;
              5       0     0               0              0           0              1             0          0              printf("c removed duplicates %i\n",removed_duplicates);
              .       .     .               .              .           .              .             .          .          }   
         76,626     321   319          25,542         23,535           2              0             0          0          if (propagations - curr_props >  VSIDS_props_limit){
             28       0     0               0              0           0              0             0          0              curr_props = propagations;
             28       0     0               0              0           0             28             1          1              switch_mode = true;
            141       0     0               0              0           0             28             0          0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
              .       .     .               .              .           .              .             .          .          }     
         25,542       0     0          12,771             35           1              0             0          0          if (VSIDS){
         10,724       0     0               0              0           0         10,724             0          0              int weighted = INT32_MAX;
         42,896  10,699 2,051               0              0           0         10,724             0          0              status = search(weighted);
              .       .     .               .              .           .              .             .          .          }else{
         12,282   2,011 1,453           4,094              0           0          2,047             0          0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          2,047       0     0               0              0           0              0             0          0              curr_restarts++;
         10,235   2,047 1,452               0              0           0          2,047             0          0              status = search(nof_conflicts);
              .       .     .               .              .           .              .             .          .          }
         25,542   2,035 1,118          12,771         12,771       5,593              0             0          0          if (switch_mode){ 
             28       0     0               0              0           0             28             0          0              switch_mode = false;
              .       .     .               .              .           .              .             .          .              VSIDS = !VSIDS;
             56       0     0              28              1           0              0             0          0              if (VSIDS){
             28      14    14               0              0           0             14             0          0                  printf("c Switched to VSIDS.\n");
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              else{
             42      14    14               0              0           0             14             0          0                 printf("c Switched to LRB.\n");
              .       .     .               .              .           .              .             .          .              }
              .       .     .               .              .           .              .             .          .              //            reduceduplicates();            
             56      14    14              28             28          28             28             0          0              fflush(stdout);
              .       .     .               .              .           .              .             .          .              picked.clear();
              .       .     .               .              .           .              .             .          .              conflicted.clear();
              .       .     .               .              .           .              .             .          .              almost_conflicted.clear();
              .       .     .               .              .           .              .             .          .  #ifdef ANTI_EXPLORATION
              .       .     .               .              .           .              .             .          .              canceled.clear();
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              3       1     1               1              1           0              0             0          0      if (verbosity >= 1)
              2       0     0               0              0           0              1             0          0          printf("c ===============================================================================\n");
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  #ifdef BIN_DRUP
              3       0     0               1              0           0              0             0          0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
              .       .     .               .              .           .              .             .          .  #endif
              .       .     .               .              .           .              .             .          .  
              2       1     1               0              0           0              0             0          0      if (status == l_True){
              .       .     .               .              .           .              .             .          .          // Extend & copy model:
              .       .     .               .              .           .              .             .          .          model.growTo(nVars());
         23,707       1     1          11,841          2,961           0         11,846         2,961          0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
              .       .     .               .              .           .              .             .          .      }else if (status == l_False && conflict.size() == 0)
              .       .     .               .              .           .              .             .          .          ok = false;
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      cancelUntil(0);
              1       0     0               0              0           0              0             0          0      return status;
              8       1     1               7              1           1              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  //=================================================================================================
              .       .     .               .              .           .              .             .          .  // Writing CNF to DIMACS:
              .       .     .               .              .           .              .             .          .  // 
              .       .     .               .              .           .              .             .          .  // FIXME: this needs to be rewritten completely.
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  static Var mapVar(Var x, vec<Var>& map, Var& max)
              .       .     .               .              .           .              .             .          .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
              .       .     .               .              .           .              .             .          .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
              .       .     .               .              .           .              .             .          .  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  //=================================================================================================
              .       .     .               .              .           .              .             .          .  // Garbage Collection methods:
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::relocAll(ClauseAllocator& to)
            880     140   140               0              0           0            704             0          0  {
              .       .     .               .              .           .              .             .          .      // All watchers:
              .       .     .               .              .           .              .             .          .      //
              .       .     .               .              .           .              .             .          .      // for (int i = 0; i < watches.size(); i++)
            176       0     0               0              0           0             88             0          0      watches.cleanAll();
            176       0     0               0              0           0             88             0          0      watches_bin.cleanAll();
    166,713,008      73    73     116,698,824        162,201          18     16,671,424            88          5      for (int v = 0; v < nVars(); v++)
     66,684,992       0     0      33,342,496              0           0              0             0          0          for (int s = 0; s < 2; s++){
              .       .     .               .              .           .              .             .          .              Lit p = mkLit(v, s);
              .       .     .               .              .           .              .             .          .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
              .       .     .               .              .           .              .             .          .              vec<Watcher>& ws = watches[p];
  1,046,461,220      60    60     464,429,284      8,392,035   8,248,966              0             0          0              for (int j = 0; j < ws.size(); j++)
              .       .     .               .              .           .              .             .          .                  ca.reloc(ws[j].cref, to);
              .       .     .               .              .           .              .             .          .              vec<Watcher>& ws_bin = watches_bin[p];
    940,841,843      44    44     437,950,028      8,507,553   8,284,235              0             0          0              for (int j = 0; j < ws_bin.size(); j++)
              .       .     .               .              .           .              .             .          .                  ca.reloc(ws_bin[j].cref, to);
              .       .     .               .              .           .              .             .          .          }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // All reasons:
              .       .     .               .              .           .              .             .          .      //
     10,525,127       0     0             264              0           0              0             0          0      for (int i = 0; i < trail.size(); i++){
              .       .     .               .              .           .              .             .          .          Var v = var(trail[i]);
              .       .     .               .              .           .              .             .          .  
     20,371,042       0     0       4,923,222      4,657,681   2,240,238              0             0          0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
     24,616,286       0     0       4,923,222              0           0      4,923,222            71         65              ca.reloc(vardata[v].reason, to);
              .       .     .               .              .           .              .             .          .      }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // All learnt:
              .       .     .               .              .           .              .             .          .      //
     32,786,067      89    89      16,392,989            178         175              0             0          0      for (int i = 0; i < learnts_core.size(); i++)
              .       .     .               .              .           .              .             .          .          ca.reloc(learnts_core[i], to);
        778,079     264   264         389,039            349         105              0             0          0      for (int i = 0; i < learnts_tier2.size(); i++)
              .       .     .               .              .           .              .             .          .          ca.reloc(learnts_tier2[i], to);
      1,469,025      88    88         734,337             87           0              0             0          0      for (int i = 0; i < learnts_local.size(); i++)
      2,202,483       0     0               0              0           0        734,161             0          0          ca.reloc(learnts_local[i], to);
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      // All original:
              .       .     .               .              .           .              .             .          .      //
              .       .     .               .              .           .              .             .          .      int i, j;
    349,484,382      88    88             352             87           0              0             0          0      for (i = j = 0; i < clauses.size(); i++)
    349,483,590       0     0               0              0           0              0             0          0          if (ca[clauses[i]].mark() != 1){
    524,225,561      88    88     174,741,795             87           0    174,741,795             0          0              ca.reloc(clauses[i], to);
  1,747,417,862      88    88     698,967,092              0           0    174,741,795             0          0              clauses[j++] = clauses[i]; }
             88      88    88               0              0           0              0             0          0      clauses.shrink(i - j);
            704      88    88             616             88          88              0             0          0  }
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .  void Solver::garbageCollect()
              .       .     .               .              .           .              .             .          .  {
              .       .     .               .              .           .              .             .          .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
              .       .     .               .              .           .              .             .          .      // is not precise but should avoid some unnecessary reallocations for the new region:
              .       .     .               .              .           .              .             .          .      ClauseAllocator to(ca.size() - ca.wasted());
              .       .     .               .              .           .              .             .          .  
              .       .     .               .              .           .              .             .          .      relocAll(to);
              .       .     .               .              .           .              .             .          .      if (verbosity >= 2)
              .       .     .               .              .           .              .             .          .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
              .       .     .               .              .           .              .             .          .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
              .       .     .               .              .           .              .             .          .      to.moveTo(ca);
            155      18    18              47              4           4             61             0          0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr  Dr             D1mr          DLmr       Dw             D1mw          DLmw      

-- line 31 ----------------------------------------
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  template<class Comp>
             .      .     .              .             .          .              .             .         .  class Heap {
             .      .     .              .             .          .              .             .         .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
             .      .     .              .             .          .              .             .         .      vec<int> heap;     // Heap of integers
             .      .     .              .             .          .              .             .         .      vec<int> indices;  // Each integers position (index) in the Heap
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .      // Index "traversal" functions
 8,661,493,234     55    55              0             0          0              0             0         0      static inline int left  (int i) { return i*2+1; }
35,891,733,520    181   181 14,348,265,786 5,874,332,945 17,217,844              0             0         0      static inline int right (int i) { return (i+1)*2; }
 5,488,627,324     50    50    276,714,573             0          0              0             0         0      static inline int parent(int i) { return (i-1) >> 1; }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
   553,429,146     52    51              0             0          0    553,429,146       160,067         1      void percolateUp(int i)
             .      .     .              .             .          .              .             .         .      {
 1,965,238,237      0     0  1,243,297,924   292,354,706 11,151,660    445,225,740             0         0          int x  = heap[i];
             .      .     .              .             .          .              .             .         .          int p  = parent(i);
             .      .     .              .             .          .              .             .         .          
17,636,261,726  2,294 1,653  5,806,588,611 2,315,980,391 15,107,089    139,685,780             0         0          while (i != 0 && lt(x, heap[p])){
 1,861,853,762    103    98              0             0          0  1,861,853,762             0         0              heap[i]          = heap[p];
 1,861,853,762      0     0              0             0          0  1,861,853,762 1,140,694,429 1,989,720              indices[heap[p]] = i;
             .      .     .              .             .          .              .             .         .              i                = p;
 2,633,678,900      0     0              0             0          0              0             0         0              p                = parent(p);
             .      .     .              .             .          .              .             .         .          }
   966,583,351     20    12    222,616,536             0          0    743,966,815             0         0          heap   [i] = x;
 1,222,614,540      2     2    222,614,229             0          0    743,969,320         3,991         0          indices[x] = i;
 1,208,616,257      0     0    830,143,719             0          0              0             0         0      }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
18,412,140,831      0     0  2,630,305,833             0          0 15,781,834,998       861,654         2      void percolateDown(int i)
             .      .     .              .             .          .              .             .         .      {
 8,870,866,037 10,073 1,704  5,660,210,778 2,331,148,241  1,902,766  3,169,255,370             0         0          int x = heap[i];
36,060,727,790 55,643 1,462  8,328,045,394           302          0              0             0         0          while (left(i) < heap.size()){
53,833,700,763    149   149  7,170,277,448   333,636,241    810,111              0             0         0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
17,814,450,330    295   295              0             0          0              0             0         0              if (!lt(heap[child], x)) break;
 5,573,137,015      0     0              0             0          0  5,573,137,015             0         0              heap[i]          = heap[child];
 5,634,959,390      0     0     61,822,375             0          0  5,573,137,015 2,118,388,656 1,679,442              indices[heap[i]] = i;
 5,078,538,859      0     0              0             0          0              0             0         0              i                = child;
             .      .     .              .             .          .              .             .         .          }
 6,049,048,540    213   213  3,024,526,707           513          0  3,024,521,833             0         0          heap   [i] = x;
 3,801,990,775     19    19    430,035,943             0          0  3,024,521,833     2,611,462         0          indices[x] = i;
18,550,485,095      0     0 18,412,140,831             0          0              0             0         0      }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .    public:
             .      .     .              .             .          .              .             .         .      Heap(const Comp& c) : lt(c) { }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .      int  size      ()          const { return heap.size(); }
   244,092,028      0     0    244,092,028     2,349,328        124              0             0         0      bool empty     ()          const { return heap.size() == 0; }
52,100,301,908 13,148 2,470 27,144,594,832 4,376,224,895  4,854,344              0             0         0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
   394,474,673     38    38    228,538,566     1,513,125         75              0             0         0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
 1,454,809,548      0     0  1,004,119,347        48,956          0    276,714,573       131,624         0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
13,695,892,141     16    16  8,435,280,474            17          0  2,630,305,833             0         0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .      // Safe variant of insert/decrease/increase:
             .      .     .              .             .          .              .             .         .      void update(int n)
             .      .     .              .             .          .              .             .         .      {
             .      .     .              .             .          .              .             .         .          if (!inHeap(n))
             .      .     .              .             .          .              .             .         .              insert(n);
             .      .     .              .             .          .              .             .         .          else {
             .      .     .              .             .          .              .             .         .              percolateUp(indices[n]);
        14,664      0     0          7,332             0          0              0             0         0              percolateDown(indices[n]); }
             .      .     .              .             .          .              .             .         .      }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .      void insert(int n)
             .      .     .              .             .          .              .             .         .      {
   244,635,706      2     2              0             0          0              0             0         0          indices.growTo(n+1, -1);
             .      .     .              .             .          .              .             .         .          assert(!inHeap(n));
             .      .     .              .             .          .              .             .         .  
   489,271,412      1     1    244,635,706             0          0    244,635,706             0         0          indices[n] = heap.size();
         7,330      1     1              0             0          0          4,812             0         0          heap.push(n);
   489,271,412      0     0    244,635,706            30          0              0             0         0          percolateUp(indices[n]); 
             .      .     .              .             .          .              .             .         .      }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .      int  removeMin()
             .      .     .              .             .          .              .             .         .      {
   732,276,081      1     1    488,184,054     2,211,125         65    244,092,027           267         0          int x            = heap[0];
   488,184,054      0     0    244,092,027    18,898,571    465,595    244,092,027             0         0          heap[0]          = heap.last();
   488,184,054     57    57    244,092,027             0          0    244,092,027   228,708,480   642,005          indices[heap[0]] = 0;
   244,092,027      1     1              0             0          0    244,092,027     3,525,914       113          indices[x]       = -1;
             .      .     .              .             .          .              .             .         .          heap.pop();
   488,184,054      0     0              0             0          0              0             0         0          if (heap.size() > 1) percolateDown(0);
             .      .     .              .             .          .              .             .         .          return x; 
             .      .     .              .             .          .              .             .         .      }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .      // Rebuild the heap from scratch, using the elements in 'ns':
             .      .     .              .             .          .              .             .         .      void build(const vec<int>& ns) {
   165,576,866    175   175     82,788,433           294        292              0             0         0          for (int i = 0; i < heap.size(); i++)
    82,788,874    147   147            441             0          0     82,787,551    38,339,471 5,221,795              indices[heap[i]] = -1;
           441      0     0              0             0          0              0             0         0          heap.clear();
             .      .     .              .             .          .              .             .         .  
   165,602,199    146   146     82,800,438           441          0              0             0         0          for (int i = 0; i < ns.size(); i++){
   165,599,994      0     0     82,799,997             0          0     82,799,997     5,219,189         0              indices[ns[i]] = i;
             .      .     .              .             .          .              .             .         .              heap.push(ns[i]); }
             .      .     .              .             .          .              .             .         .  
   289,803,780    382   382     41,400,330             0          0            441             0         0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
             .      .     .              .             .          .              .             .         .              percolateDown(i);
             .      .     .              .             .          .              .             .         .      }
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .      void clear(bool dealloc = false) 
             .      .     .              .             .          .              .             .         .      { 
             4      0     0              2             1          1              0             0         0          for (int i = 0; i < heap.size(); i++)
             .      .     .              .             .          .              .             .         .              indices[heap[i]] = -1;
             .      .     .              .             .          .              .             .         .          heap.clear(dealloc); 
             .      .     .              .             .          .              .             .         .      }
             .      .     .              .             .          .              .             .         .  };
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  
             .      .     .              .             .          .              .             .         .  //=================================================================================================
             .      .     .              .             .          .              .             .         .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr  Dr             D1mr           DLmr       Dw            D1mw    DLmw  

-- line 77 ----------------------------------------
             .      .     .              .              .          .             .       .     .  private:
             .      .     .              .              .          .             .       .     .      template<typename T>
             .      .     .              .              .          .             .       .     .      class MyQueue {
             .      .     .              .              .          .             .       .     .          int max_sz, q_sz;
             .      .     .              .              .          .             .       .     .          int ptr;
             .      .     .              .              .          .             .       .     .          int64_t sum;
             .      .     .              .              .          .             .       .     .          vec<T> q;
             .      .     .              .              .          .             .       .     .      public:
             4      1     1              0              0          0             3       0     0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .      .     .              .              .          .             .       .     .          inline bool   full () const { return q_sz == max_sz; }
             .      .     .              .              .          .             .       .     .  #ifdef INT_QUEUE_AVG
       358,804  3,549 2,100         89,701              0          0             0       0     0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .      .     .              .              .          .             .       .     .  #else
             .      .     .              .              .          .             .       .     .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .      .     .              .              .          .             .       .     .  #endif
        25,886    156   156              0              0          0        25,886   1,356     0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .      .     .              .              .          .             .       .     .          void push(T e) {
     5,699,872      0     0      2,305,086              0          0       544,850       0     0              if (q_sz < max_sz) q_sz++;
       670,536     31    31        223,512        221,376        257             0       0     0              else sum -= q[ptr];
     2,305,086     42    42              0              0          0       768,362       0     0              sum += e;
     2,305,086      0     0              0              0          0     1,536,724 542,722 7,560              q[ptr++] = e;
     2,319,077      0     0      1,536,724              0          0        13,991       0     0              if (ptr == max_sz) ptr = 0;
             .      .     .              .              .          .             .       .     .          }
             .      .     .              .              .          .             .       .     .      };
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  public:
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .      // Constructor/Destructor:
             .      .     .              .              .          .             .       .     .      //
             .      .     .              .              .          .             .       .     .      Solver();
             .      .     .              .              .          .             .       .     .      virtual ~Solver();
            10      2     2              0              0          0             4       0     0      void print_size(std::ostream &os)
             .      .     .              .              .          .             .       .     .      {
             4      2     2              0              0          0             4       1     1          program_end_time=std::chrono::steady_clock::now();
             2      0     0              0              0          0             2       0     0          total_work_time=program_end_time-program_start_time;
             4      0     0              2              1          0             0       0     0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2      0     0              2              1          1             0       0     0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4      0     0              2              0          0             0       0     0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4      0     0              2              0          0             0       0     0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4      0     0              2              0          0             0       0     0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4      0     0              2              1          0             0       0     0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .      .     .              .              .          .             .       .     .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .      .     .              .              .          .             .       .     .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2      0     0              2              2          0             0       0     0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2      0     0              2              0          0             0       0     0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2      0     0              2              0          0             0       0     0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4      0     0              2              2          0             0       0     0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4      0     0              2              0          0             0       0     0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4      0     0              2              0          0             0       0     0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4      0     0              2              2          0             0       0     0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .      .     .              .              .          .             .       .     .          os << "total_Watchers: " << total_Watchers << "\n";
             .      .     .              .              .          .             .       .     .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .      .     .              .              .          .             .       .     .          os << "total_indexs: " << total_indexs << "\n";
             .      .     .              .              .          .             .       .     .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .      .     .              .              .          .             .       .     .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .      .     .              .              .          .             .       .     .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .      .     .              .              .          .             .       .     .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .      .     .              .              .          .             .       .     .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .      .     .              .              .          .             .       .     .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .      .     .              .              .          .             .       .     .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .      .     .              .              .          .             .       .     .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .      .     .              .              .          .             .       .     .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .      .     .              .              .          .             .       .     .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .      .     .              .              .          .             .       .     .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .      .     .              .              .          .             .       .     .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .      .     .              .              .          .             .       .     .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6      0     0              4              0          0             0       0     0      }
             .      .     .              .              .          .             .       .     .      using ull=unsigned long long;
             .      .     .              .              .          .             .       .     .      ull total_Watchers = 0;
             .      .     .              .              .          .             .       .     .      ull total_act_watchers = 0;
             .      .     .              .              .          .             .       .     .      ull total_indexs = 0;
             .      .     .              .              .          .             .       .     .      ull time_find_conflict = 0;
             .      .     .              .              .          .             .       .     .      ull total_find_conflict_length = 0;
             .      .     .              .              .          .             .       .     .      ull total_find_conflict_allsize = 0;
             .      .     .              .              .          .             .       .     .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .      .     .              .              .          .             .       .     .      {
             .      .     .              .              .          .             .       .     .          const ClauseAllocator& ca;
             .      .     .              .              .          .             .       .     .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .      .     .              .              .          .             .       .     .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .      .     .              .              .          .             .       .     .      };
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .      struct VarOrderLt {
             .      .     .              .              .          .             .       .     .          const vec<double>&  activity;
24,804,190,498  4,210 2,836 14,968,227,127  3,746,033,166 14,992,387   212,248,092       0     0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .      .     .              .              .          .             .       .     .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .      .     .              .              .          .             .       .     .      };
             .      .     .              .              .          .             .       .     .      
             .      .     .              .              .          .             .       .     .      struct ConflictData
             .      .     .              .              .          .             .       .     .  	{
             .      .     .              .              .          .             .       .     .  		ConflictData() :
             .      .     .              .              .          .             .       .     .  			nHighestLevel(-1),
             .      .     .              .              .          .             .       .     .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .      .     .              .              .          .             .       .     .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .      .     .              .              .          .             .       .     .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .      .     .              .              .          .             .       .     .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .      .     .              .              .          .             .       .     .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .      .     .              .              .          .             .       .     .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .      .     .              .              .          .             .       .     .      std::chrono::nanoseconds total_duration;
             .      .     .              .              .          .             .       .     .      CRef     propagate(){
             .      .     .              .              .          .             .       .     .  
   162,371,072 46,188 7,367              0              0          0    81,185,536       1     1          auto start_time=std::chrono::steady_clock::now();
   243,556,608      0     0              0              0          0    81,185,536       0     0          auto ref= propagate_();
    81,185,536      0     0              0              0          0    81,185,536       0     0          auto end_time=std::chrono::steady_clock::now();
             .      .     .              .              .          .             .       .     .          auto duration=end_time-start_time;
             .      .     .              .              .          .             .       .     .          total_duration+=duration;
             .      .     .              .              .          .             .       .     .          return ref;
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .      }
             .      .     .              .              .          .             .       .     .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .      .     .              .              .          .             .       .     .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .      .     .              .              .          .             .       .     .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .      .     .              .              .          .             .       .     .      
             .      .     .              .              .          .             .       .     .  public:
             .      .     .              .              .          .             .       .     .      int      level            (Var x) const;
             .      .     .              .              .          .             .       .     .  protected:
             .      .     .              .              .          .             .       .     .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .      .     .              .              .          .             .       .     .      bool     withinBudget     ()      const;
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .      template<class V> int computeLBD(const V& c) {
   949,714,567     48    48              0              0          0             0       0     0          int lbd = 0;
             .      .     .              .              .          .             .       .     .  
     7,705,631     53    53      6,170,633      3,620,579        784             0       0     0          counter++;
 4,548,303,260      0     0      1,537,612              0          0             0       0     0          for (int i = 0; i < c.size(); i++){
             .      .     .              .              .          .             .       .     .              int l = level(var(c[i]));
11,331,234,428      0     0  4,532,415,344    232,221,819  2,398,648             0       0     0              if (l != 0 && seen2[l] != counter){
   380,854,326      0     0              0              0          0   380,854,326       0     0                  seen2[l] = counter;
 1,315,938,294      0     0              0              0          0             0       0     0                  lbd++; } }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .          return lbd;
             .      .     .              .              .          .             .       .     .      }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  #ifdef BIN_DRUP
             .      .     .              .              .          .             .       .     .      static int buf_len;
             .      .     .              .              .          .             .       .     .      static unsigned char drup_buf[];
             .      .     .              .              .          .             .       .     .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .      .     .              .              .          .             .       .     .      }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .      template<class V>
             .      .     .              .              .          .             .       .     .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .      .     .              .              .          .             .       .     .          assert(op == 'a' || op == 'd');
             .      .     .              .              .          .             .       .     .          *buf_ptr++ = op; buf_len++;
             .      .     .              .              .          .             .       .     .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .      .     .              .              .          .             .       .     .          *buf_ptr++ = 0; buf_len++;
       182,987     48    48              0              0          0       182,987       0     0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .      .     .              .              .          .             .       .     .      }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .      .     .              .              .          .             .       .     .          *buf_ptr++ = 'a'; buf_len++;
             .      .     .              .              .          .             .       .     .          for (int i = 0; i < c.size(); i++)
             .      .     .              .              .          .             .       .     .              if (c[i] != l) byteDRUP(c[i]);
             .      .     .              .              .          .             .       .     .          *buf_ptr++ = 0; buf_len++;
             .      .     .              .              .          .             .       .     .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .      .     .              .              .          .             .       .     .      double    my_var_decay;
             .      .     .              .              .          .             .       .     .      bool   DISTANCE;
             .      .     .              .              .          .             .       .     .  };
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  //=================================================================================================
             .      .     .              .              .          .             .       .     .  // Implementation of inline methods:
             .      .     .              .              .          .             .       .     .  
11,439,875,842      0     0 11,439,875,842    642,987,731  1,360,815             0       0     0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
48,812,144,946     58    58 44,296,175,637 25,924,608,877  1,358,917 4,381,046,955       0     0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  inline void Solver::insertVarOrder(Var x) {
             .      .     .              .              .          .             .       .     .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
23,409,031,672  6,650 2,520  7,222,062,699      2,319,406          0             0       0     0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
   731,633,580      1     1    487,755,720    166,946,603  8,294,166             0       0     0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  inline void Solver::varDecayActivity() {
     3,073,448      0     0      1,536,724        620,121          0       768,362       0     0      var_inc *= (1 / var_decay); }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  inline void Solver::varBumpActivity(Var v, double mult) {
 2,601,324,420     39    39  1,547,779,878    312,768,871  3,888,744   386,561,220       0     0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .      .     .              .              .          .             .       .     .          // Rescale:
         1,922    168   168              1              0          0             0       0     0          for (int i = 0; i < nVars(); i++)
    72,747,264      0     0     18,186,816      4,546,676    961,371    18,186,816       0     0              activity_VSIDS[i] *= 1e-100;
           384      0     0            192            192          0           192       0     0          var_inc *= 1e-100; }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .      // Update order_heap with respect to new activity:
   205,477,890      0     0              0              0          0             0       0     0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .      .     .              .              .          .             .       .     .  
     6,139,992  6,334 1,797      3,069,996            965          0     1,534,998       0     0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .      .     .              .              .          .             .       .     .  inline void Solver::claBumpActivity (Clause& c) {
    30,463,994 12,165 3,815      9,047,533      3,745,721      7,430     3,092,232   1,408 1,357      if ( (c.activity() += cla_inc) > 1e20 ) {
             .      .     .              .              .          .             .       .     .          // Rescale:
     1,218,870     33    33             99              0          0             0       0     0          for (int i = 0; i < learnts_local.size(); i++)
     2,843,414     17     4        406,202        360,841    268,995       406,202       0     0              ca[learnts_local[i]].activity() *= 1e-20;
       458,425    215   215        229,163              0          0            33      33     0          cla_inc *= 1e-20; } }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .      .     .              .              .          .             .       .     .  inline void Solver::checkGarbage(double gf){
     1,708,713     45     3        569,571            350        177             0       0     0      if (ca.wasted() > ca.size() * gf)
           348      0     0            174            174         88             0       0     0          garbageCollect(); }
             .      .     .              .              .          .             .       .     .  
             .      .     .              .              .          .             .       .     .  // NOTE: enqueue does not set the ok flag! (only public methods do)
             .      .     .              .              .          .             .       .     .  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .      .     .              .              .          .             .       .     .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .      .     .              .              .          .             .       .     .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .      .     .              .              .          .             .       .     .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .      .     .              .              .          .             .       .     .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .      .     .              .              .          .             .       .     .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .      .     .              .              .          .             .       .     .  inline bool     Solver::locked          (const Clause& c) const {
    17,969,633    154   154      5,874,392        143,683          0             0       0     0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    16,297,751    210   210      4,772,792      2,429,690      2,220             0       0     0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .      .     .              .              .          .             .       .     .  }
   157,650,280      1     1     78,825,129              0          0             0       0     0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .      .     .              .              .          .             .       .     .  
    84,681,102      6     6     42,358,931            129          0    42,322,171       0     0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
51,580,196,975  3,925 2,747  1,002,735,249    766,747,684          0             0       0     0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
   272,117,772      1     1    272,117,756        975,928        103             0       0     0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
10,128,753,095     45    45 10,128,753,095      3,330,522        160             0       0     0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .      .     .              .              .          .             .       .     .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .      .     .              .              .          .             .       .     .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .      .     .              .              .          .             .       .     .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3      0     0              2              0          0             1       0     0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .      .     .              .              .          .             .       .     .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
    36,848,465      2     1        189,978            339          1             0       0     0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6      1     1              3              2          2             0       0     0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .      .     .              .              .          .             .       .     .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .      .     .              .              .          .             .       .     .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .      .     .              .              .          .             .       .     .  { 
     1,136,676      0     0        568,338          4,653          0             0       0     0      if      ( b && !decision[v]) dec_vars++;
           255      0     0            170            148         78             0       0     0      else if (!b &&  decision[v]) dec_vars--;
             .      .     .              .              .          .             .       .     .  
       189,531      0     0              0              0          0       189,531       0     0      decision[v] = b;
             .      .     .              .              .          .             .       .     .      if (b && !order_heap_CHB.inHeap(v)){
             .      .     .              .              .          .             .       .     .          order_heap_CHB.insert(v);
             .      .     .              .              .          .             .       .     .          order_heap_VSIDS.insert(v);
             .      .     .              .              .          .             .       .     .          order_heap_distance.insert(v);}
             .      .     .              .              .          .             .       .     .  }
             .      .     .              .              .          .             .       .     .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .      .     .              .              .          .             .       .     .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .      .     .              .              .          .             .       .     .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir              I1mr    ILmr   Dr              D1mr          DLmr       Dw              D1mw          DLmw        

-- line 40 ----------------------------------------
              .       .      .               .             .          .               .             .           .      int sz;
              .       .      .               .             .          .               .             .           .      int cap;
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .      // Don't allow copying (error prone):
              .       .      .               .             .          .               .             .           .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              .       .      .               .             .          .               .             .           .               vec        (vec<T>& other) { assert(0); }
              .       .      .               .             .          .               .             .           .               
              .       .      .               .             .          .               .             .           .      // Helpers for calculating next capacity:
     40,807,500      12     12               0             0          0               0             0           0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
              .       .      .               .             .          .               .             .           .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .      .               .             .          .               .             .           .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  public:
              .       .      .               .             .          .               .             .           .      // Constructors:
      5,484,812      61     61               2             0          0       4,537,578       279,888     232,452      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
             72       0      0               0             0          0              72             0           0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
              .       .      .               .             .          .               .             .           .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
              .       .      .               .             .          .               .             .           .     ~vec()                                                          { clear(true); }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .      // Pointer to first element:
              .       .      .               .             .          .               .             .           .      operator T*       (void)           { return data; }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .      // Size operations:
              .       .      .               .             .          .               .             .           .      int      size     (void) const     { return sz; }
 13,430,015,220     737    510     691,036,448       358,427          0     755,842,943             2           0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
              .       .      .               .             .          .               .             .           .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
              .       .      .               .             .          .               .             .           .      int      capacity (void) const     { return cap; }
              .       .      .               .             .          .               .             .           .      void     capacity (int min_cap);
              .       .      .               .             .          .               .             .           .      void     growTo   (int size);
              .       .      .               .             .          .               .             .           .      void     growTo   (int size, const T& pad);
              .       .      .               .             .          .               .             .           .      void     clear    (bool dealloc = false);
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .      // Stack interface:
      6,988,496   7,431  1,169       3,664,250        23,813          0       1,560,914         1,856           0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
431,331,523,764 352,954 18,630 203,415,875,866 1,100,090,106 73,989,913 111,405,218,242 2,619,632,918 319,738,434      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
 26,943,583,992       0      0   7,800,636,494    53,279,803          0  11,791,860,310   352,783,258  10,932,180      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
 20,464,801,564   2,269     96     244,092,027             0          0  10,110,922,008             0           0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
              .       .      .               .             .          .               .             .           .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
              .       .      .               .             .          .               .             .           .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
              .       .      .               .             .          .               .             .           .      // happen given the way capacities are calculated (below). Essentially, all capacities are
              .       .      .               .             .          .               .             .           .      // even, but INT_MAX is odd.
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .      const T& last  (void) const        { return data[sz-1]; }
  9,867,265,154       0      0               0             0          0               0             0           0      T&       last  (void)              { return data[sz-1]; }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .      // Vector interface:
139,610,365,145   8,947  3,269  24,839,489,233       440,876          0     257,959,766           262           0      const T& operator [] (int index) const { return data[index]; }
318,167,090,496  19,627  6,297  43,758,475,560    37,537,555  5,177,401   6,124,367,350     2,862,047          14      T&       operator [] (int index)       { return data[index]; }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .      // Duplicatation (preferred instead):
  6,036,366,468      39     39   2,013,145,488    58,588,870          0   1,004,270,247    22,429,543           0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
      6,330,009       1      1       6,329,904            15          0              70             0           0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
              .       .      .               .             .          .               .             .           .  };
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  template<class T>
     10,201,738       0      0               0             0          0       5,100,869             0           0  void vec<T>::capacity(int min_cap) {
     28,431,903      80     71       9,477,301            17          0               0             0           0      if (cap >= min_cap) return;
     35,706,660     101    100               0             0          0               2             0           0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     66,312,175     229    211       5,100,951            35          0      15,302,818        25,866           1      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
              .       .      .               .             .          .               .             .           .          throw OutOfMemoryException();
     13,820,386      15     15      13,820,386             6          0               0             0           0   }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  template<class T>
              .       .      .               .             .          .               .             .           .  void vec<T>::growTo(int size, const T& pad) {
    735,612,132      12     12     245,014,598        13,002          0               0             0           0      if (sz >= size) return;
      3,788,920       4      4         378,892             0          0       1,705,014             0           0      capacity(size);
     21,407,400       7      7       3,410,029            10          0       1,705,015        40,023       9,512      for (int i = sz; i < size; i++) data[i] = pad;
    428,976,224      33     33             104             0          0       1,705,014             0           0      sz = size; }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  template<class T>
      3,788,920       1      1               0             0          0       1,515,568             0           0  void vec<T>::growTo(int size) {
      7,616,777       1      1       1,326,125         7,010          0         757,784             0           0      if (sz >= size) return;
      6,518,997   3,610  2,423               0             0          0       3,259,481             0           0      capacity(size);
     36,646,105      99     83       8,034,530             0          0       3,070,034             0           0      for (int i = sz; i < size; i++) new (&data[i]) T();
      8,583,507       0      0       3,808,456        19,365          0       2,482,267        18,533           0      sz = size; }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  template<class T>
              .       .      .               .             .          .               .             .           .  void vec<T>::clear(bool dealloc) {
  3,093,580,779 274,565  5,645     917,357,924     3,922,823     47,940         189,508             0           0      if (data != NULL){
        378,897       0      0               1             0          0               0             0           0          for (int i = 0; i < sz; i++) data[i].~T();
 22,813,046,295      54     54     171,452,777             0          0   1,091,087,216       424,291           0          sz = 0;
      1,962,950       5      5         947,348             0          0         826,090            17           0          if (dealloc) free(data), data = NULL, cap = 0; } }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  //=================================================================================================
              .       .      .               .             .          .               .             .           .  }
              .       .      .               .             .          .               .             .           .  
              .       .      .               .             .          .               .             .           .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr  ILmr Dr             D1mr        DLmr       Dw          D1mw   DLmw 

-- line 40 ----------------------------------------
             .     .    .              .           .          .           .      .    .      void capacity(uint32_t min_cap);
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .   public:
             .     .    .              .           .          .           .      .    .      // TODO: make this a class for better type-checking?
             .     .    .              .           .          .           .      .    .      typedef uint32_t Ref;
             .     .    .              .           .          .           .      .    .      enum { Ref_Undef = UINT32_MAX };
             .     .    .              .           .          .           .      .    .      enum { Unit_Size = sizeof(uint32_t) };
             .     .    .              .           .          .           .      .    .  
           446     1    1              0           0          0         356      0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .     .    .              .           .          .           .      .    .      ~RegionAllocator()
             .     .    .              .           .          .           .      .    .      {
             .     .    .              .           .          .           .      .    .          if (memory != NULL)
             .     .    .              .           .          .           .      .    .              ::free(memory);
             .     .    .              .           .          .           .      .    .      }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .      uint32_t size      () const      { return sz; }
             .     .    .              .           .          .           .      .    .      uint32_t wasted    () const      { return wasted_; }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .      Ref      alloc     (int size); 
     3,791,904     0    0      1,262,480           0          0   1,262,480      0    0      void     free      (int size)    { wasted_ += size; }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
40,631,539,155   718  635 24,904,093,094 492,111,476 90,649,075     239,761      0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    62,534,967     0    0     62,534,967   8,879,700  8,403,969           0      0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .     .    .              .           .          .           .      .    .  
   588,915,676 7,850  118      3,541,296           0          0           0      0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     1,417,135     0    0              0           0          0           0      0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .     .    .              .           .          .           .      .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .     .    .              .           .          .           .      .    .          return  (Ref)(t - &memory[0]); }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .      void     moveTo(RegionAllocator& to) {
           352     0    0             88           0          0          88      0    0          if (to.memory != NULL) ::free(to.memory);
           176     0    0             88           0          0          88      0    0          to.memory = memory;
           176     0    0             88           0          0          88      0    0          to.sz = sz;
             .     .    .              .           .          .           .      .    .          to.cap = cap;
           176     0    0             88           0          0          88      0    0          to.wasted_ = wasted_;
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .          memory = NULL;
             .     .    .              .           .          .           .      .    .          sz = cap = wasted_ = 0;
             .     .    .              .           .          .           .      .    .      }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  };
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  template<class T>
           942    82   82              0           0          0         314     87    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .     .    .              .           .          .           .      .    .  {
   587,381,169    17   17    195,793,717           0          0           0      0    0      if (cap >= min_cap) return;
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .      uint32_t prev_cap = cap;
         6,235     0    0              0           0          0         163      0    0      while (cap < min_cap){
             .     .    .              .           .          .           .      .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .     .    .              .           .          .           .      .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .     .    .              .           .          .           .      .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .     .    .              .           .          .           .      .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        18,216     0    0              0           0          0           0      0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         3,036     0    0              0           0          0           0      0    0          cap += delta;
             .     .    .              .           .          .           .      .    .  
         6,072     0    0              0           0          0           0      0    0          if (cap <= prev_cap)
             .     .    .              .           .          .           .      .    .              throw OutOfMemoryException();
             .     .    .              .           .          .           .      .    .      }
             .     .    .              .           .          .           .      .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .      assert(cap > 0);
           332     2    2              0           0          0         163      4    0      memory = (T*)xrealloc(memory, sizeof(T)*cap);
           628     0    0            471           0          0           0      0    0  }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  template<class T>
             .     .    .              .           .          .           .      .    .  typename RegionAllocator<T>::Ref
     8,026,012     2    2              0           0          0   6,019,509    150    0  RegionAllocator<T>::alloc(int size)
             .     .    .              .           .          .           .      .    .  { 
             .     .    .              .           .          .           .      .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .     .    .              .           .          .           .      .    .      assert(size > 0);
 1,162,131,378     0    0    195,793,628   1,444,368          3 578,291,789 94,853    1      capacity(sz + size);
             .     .    .              .           .          .           .      .    .  
   582,896,167     0    0    386,039,457           0          0           0      0    0      uint32_t prev_sz = sz;
   195,793,628     2    2              0           0          0 195,793,628      0    0      sz += size;
             .     .    .              .           .          .           .      .    .      
             .     .    .              .           .          .           .      .    .      // Handle overflow:
   968,344,251   128  128    192,252,332           0          0           0      0    0      if (sz < prev_sz)
             2     1    1              1           1          1           0      0    0          throw OutOfMemoryException();
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .      return prev_sz;
     8,026,012     0    0      8,026,012           0          0           0      0    0  }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  //=================================================================================================
             .     .    .              .           .          .           .      .    .  }
             .     .    .              .           .          .           .      .    .  
             .     .    .              .           .          .           .      .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr   ILmr  Dr             D1mr           DLmr        Dw            D1mw          DLmw        

-- line 54 ----------------------------------------
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  struct Lit {
              .      .     .              .              .           .             .             .           .      int     x;
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      // Use this as a constructor:
              .      .     .              .              .           .             .             .           .      friend Lit mkLit(Var var, bool sign );
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      bool operator == (Lit p) const { return x == p.x; }
    951,127,400      0     0    481,507,168    252,508,732  22,303,832             0             0           0      bool operator != (Lit p) const { return x != p.x; }
              .      .     .              .              .           .             .             .           .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .      .     .              .              .           .             .             .           .  };
              .      .     .              .              .           .             .             .           .  
     10,861,803      0     0              0              0           0            85             0           0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 18,514,091,447    120    93  2,007,180,967         96,598      45,985 5,338,304,414       941,627           0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .      .     .              .              .           .             .             .           .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
101,430,871,713     59    59 14,847,737,586         76,084           0 7,426,141,356 2,423,154,491   2,771,715  inline  bool sign      (Lit p)              { return p.x & 1; }
457,189,380,638 18,818 5,069 86,646,027,237  1,351,381,656  10,904,991 8,774,331,603             0           0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  // Mapping Literals to and from compact integers suitable for array indexing:
              .      .     .              .              .           .             .             .           .  inline  int  toInt     (Var v)              { return v; } 
        187,916      0     0             24              0           0            24             1           1  inline  int  toInt     (Lit p)              { return p.x; } 
              .      .     .              .              .           .             .             .           .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .      .     .              .              .           .             .             .           .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .      .     .              .              .           .             .             .           .  const Lit lit_Error = { -1 };  // }
              .      .     .              .              .           .             .             .           .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .      .     .              .              .           .             .             .           .  #define l_Undef (lbool((uint8_t)2))
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  class lbool {
              .      .     .              .              .           .             .             .           .      uint8_t value;
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  public:
              .      .     .              .              .           .             .             .           .      explicit lbool(uint8_t v) : value(v) { }
              .      .     .              .              .           .             .             .           .  
         47,377      1     1              0              0           0        11,846         2,960       2,959      lbool()       : value(0) { }
              .      .     .              .              .           .             .             .           .      explicit lbool(bool x) : value(!x) { }
              .      .     .              .              .           .             .             .           .  
  6,494,596,385      1     1              0              0           0             0             0           0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
        568,338      0     0        378,892          2,961           0             0             0           0      bool  operator != (lbool b) const { return !(*this == b); }
 56,972,249,524     48    48 54,743,755,253 16,445,069,716     434,306             0             0           0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      lbool operator && (lbool b) const {
              .      .     .              .              .           .             .             .           .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .      .     .              .              .           .             .             .           .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .      .     .              .              .           .             .             .           .          return lbool(v); }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      lbool operator || (lbool b) const {
              .      .     .              .              .           .             .             .           .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .      .     .              .              .           .             .             .           .          unsigned simplified : 1;}                            header;
              .      .     .              .              .           .             .             .           .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      friend class ClauseAllocator;
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .      .     .              .              .           .             .             .           .      template<class V>
              .      .     .              .              .           .             .             .           .      Clause(const V& ps, bool use_extra, bool learnt) {
    778,570,137      0     0    194,258,836              0           0   195,793,628        94,617          36          header.mark      = 0;
    576,756,996      0     0    192,252,332     12,106,793  12,012,268             0             0           0          header.learnt    = learnt;
  1,167,559,520      1     1    196,265,340             56           1   194,258,836             0           0          header.has_extra = learnt | use_extra;
              .      .     .              .              .           .             .             .           .          header.reloced   = 0;
    199,334,922      0     0      3,541,295              0           0   195,793,627     1,776,443     442,234          header.size      = ps.size();
              .      .     .              .              .           .             .             .           .          header.lbd       = 0;
              .      .     .              .              .           .             .             .           .          header.removable = 1;
              .      .     .              .              .           .             .             .           .          //simplify
              .      .     .              .              .           .             .             .           .          //
    195,793,628      9     9    195,793,628     24,248,337  24,248,337             0             0           0          header.simplified = 0;
              .      .     .              .              .           .             .             .           .  
  7,528,739,668    187   187      8,924,644              0           0             0             0           0          for (int i = 0; i < ps.size(); i++)
  3,657,217,823    464   373  1,124,311,207    105,955,614  44,656,843 1,592,451,191   134,010,808 134,010,706              data[i].lit = ps[i];
              .      .     .              .              .           .             .             .           .  
    587,380,883    116   116    195,793,627         63,826           0             0             0           0          if (header.has_extra){
     42,103,664      2     2              0              0           0             0             0           0              if (header.learnt){
     38,090,658      0     0     17,510,537         28,011           3    19,045,329     1,190,176   1,190,176                  data[header.size].act = 0;
     38,090,658      0     0              0              0           0    19,045,329     1,188,895   1,188,895                  data[header.size+1].touched = 0;
              .      .     .              .              .           .             .             .           .              }else
              .      .     .              .              .           .             .             .           .                  calcAbstraction(); }
              .      .     .              .              .           .             .             .           .      }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  public:
              .      .     .              .              .           .             .             .           .      void calcAbstraction() {
              .      .     .              .              .           .             .             .           .          assert(header.has_extra);
      2,011,392      0     0              0              0           0             0             0           0          uint32_t abstraction = 0;
     18,869,853      3     3          3,799              0           0             0             0           0          for (int i = 0; i < size(); i++)
     27,670,262      2     2              0              0           0             1             0           0              abstraction |= 1 << (var(data[i].lit) & 31);
      4,017,895      0     0              0              0           0     2,011,392       126,247     126,247          data[header.size].abs = abstraction;  }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
 92,384,162,869    563   524 14,719,838,287 10,513,933,748 269,128,993 2,622,835,006           201           0      int          size        ()      const   { return header.size; }
      3,567,659     34    34        893,090         76,693      11,361       893,090         1,189           0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .      .     .              .              .           .             .             .           .      void         pop         ()              { shrink(1); }
    582,761,453      6     6      1,262,480              0           0             0             0           0      bool         learnt      ()      const   { return header.learnt; }
         90,130      0     0              0              0           0             0             0           0      bool         has_extra   ()      const   { return header.has_extra; }
  1,011,231,587    496   469    250,888,625    232,636,768  96,991,564    62,408,965             0           0      uint32_t     mark        ()      const   { return header.mark; }
    791,002,071    468   458    194,751,322         35,640           0   197,991,016             0           0      void         mark        (uint32_t m)    { header.mark = m; }
        766,474      0     0              0              0           0       383,237             0           0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .      .     .              .              .           .             .             .           .  
    581,685,254      0     0    581,685,254    235,604,589  63,546,428             0             0           0      bool         reloced     ()      const   { return header.reloced; }
              .      .     .              .              .           .             .             .           .      CRef         relocation  ()      const   { return data[0].rel; }
    769,009,328     82    82    192,252,332         25,134           0   384,504,664         4,727           0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .      .     .              .              .           .             .             .           .  
      9,539,429      0     0      3,097,366        443,820           0             0             0           0      int          lbd         ()      const   { return header.lbd; }
    121,995,059    140   139     37,144,674              0           0    19,644,428             0           0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .      .     .              .              .           .             .             .           .      bool         removable   ()      const   { return header.removable; }
    106,492,904      1     1     36,450,756              0           0    17,510,537             0           0      void         removable   (bool b)        { header.removable = b; }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .      .     .              .              .           .             .             .           .      //       subsumption operations to behave correctly.
 28,895,824,807  5,012   286 28,795,528,857  2,029,694,356 350,815,030             0             0           0      Lit&         operator [] (int i)         { return data[i].lit; }
  7,632,045,597  4,271 2,179  7,589,628,750    543,387,780 139,557,238             0             0           0      Lit          operator [] (int i) const   { return data[i].lit; }
              .      .     .              .              .           .             .             .           .      operator const Lit* (void) const         { return (Lit*)data; }
              .      .     .              .              .           .             .             .           .  
     17,781,553      0     0     17,781,553          1,521           0             0             0           0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
      5,080,509      0     0      1,459,853        296,131     197,982             0             0           0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .      .     .              .              .           .             .             .           .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      Lit          subsumes    (const Clause& other) const;
              .      .     .              .              .           .             .             .           .      void         strengthen  (Lit p);
              .      .     .              .              .           .             .             .           .      // simplify
              .      .     .              .              .           .             .             .           .      //
    123,926,215      0     0     35,697,302          1,751           0    17,510,537             0           0      void setSimplified(bool b) { header.simplified = b; }
              .      .     .              .              .           .             .             .           .      bool simplified() { return header.simplified; }
              .      .     .              .              .           .             .             .           .  };
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  //=================================================================================================
              .      .     .              .              .           .             .             .           .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .      .     .              .              .           .             .             .           .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .      .     .              .              .           .             .             .           .  {
              .      .     .              .              .           .             .             .           .      static int clauseWord32Size(int size, int extras){
    389,311,493     78    78    193,517,866     11,691,212  10,429,727             0             0           0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .      .     .              .              .           .             .             .           .  public:
              .      .     .              .              .           .             .             .           .      bool extra_clause_field;
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1      0     0              0              0           0             1             0           0      ClauseAllocator() : extra_clause_field(false){}
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      void moveTo(ClauseAllocator& to){
            176     88    88             88              1           1            88             0           0          to.extra_clause_field = extra_clause_field;
              .      .     .              .              .           .             .             .           .          RegionAllocator<uint32_t>::moveTo(to); }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      template<class Lits>
              .      .     .              .              .           .             .             .           .      CRef alloc(const Lits& ps, bool learnt = false)
              .      .     .              .              .           .             .             .           .      {
              .      .     .              .              .           .             .             .           .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .      .     .              .              .           .             .             .           .          assert(sizeof(float)    == sizeof(uint32_t));
    561,252,962    173   173    176,748,298         96,929          55             0             0           0          int extras = learnt ? 2 : (int)extra_clause_field;
              .      .     .              .              .           .             .             .           .  
      5,547,798      0     0              0              0           0     2,006,503           141           0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .      .     .              .              .           .             .             .           .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .          return cid;
              .      .     .              .              .           .             .             .           .      }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    993,789,129    154   154    987,126,314        141,832         127       823,518             0           0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
          9,576      0     0          4,788              0           0             0             0           0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
    192,252,332      0     0    192,252,332              0           0             0             0           0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .      .     .              .              .           .             .             .           .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .      .     .              .              .           .             .             .           .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      void free(CRef cid)
              .      .     .              .              .           .             .             .           .      {
              .      .     .              .              .           .             .             .           .          Clause& c = operator[](cid);
      3,877,570    133   133              0              0           0             0             0           0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .      .     .              .              .           .             .             .           .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .      .     .              .              .           .             .             .           .      }
              .      .     .              .              .           .             .             .           .  
  1,262,794,246     88    88              0              0           0 1,082,395,068           164          91      void reloc(CRef& cr, ClauseAllocator& to)
              .      .     .              .              .           .             .             .           .      {
              .      .     .              .              .           .             .             .           .          Clause& c = operator[](cr);
              .      .     .              .              .           .             .             .           .          
  1,959,017,764      0     0    389,432,922     71,886,298  31,840,960   389,432,922             0           0          if (c.reloced()) { cr = c.relocation(); return; }
              .      .     .              .              .           .             .             .           .          
    192,252,332      0     0              0              0           0   192,252,332        28,237           0          cr = to.alloc(c, c.learnt());
              .      .     .              .              .           .             .             .           .          c.relocate(cr);
              .      .     .              .              .           .             .             .           .          
              .      .     .              .              .           .             .             .           .          // Copy extra data-fields:
              .      .     .              .              .           .             .             .           .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .      .     .              .              .           .             .             .           .          to[cr].mark(c.mark());
    384,504,664      0     0              0              0           0             0             0           0          if (to[cr].learnt()){
     70,042,148      0     0     17,510,537      1,031,229     731,379    17,510,537             0           0              to[cr].touched() = c.touched();
     70,042,148      0     0     35,021,074      1,035,731     755,602    17,510,537             0           0              to[cr].activity() = c.activity();
              .      .     .              .              .           .             .             .           .              to[cr].set_lbd(c.lbd());
              .      .     .              .              .           .             .             .           .              to[cr].removable(c.removable());
              .      .     .              .              .           .             .             .           .              // simplify
              .      .     .              .              .           .             .             .           .              //
              .      .     .              .              .           .             .             .           .              to[cr].setSimplified(c.simplified());
              .      .     .              .              .           .             .             .           .          }
    349,483,590    176   176              0              0           0             0             0           0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
  1,443,193,424      0     0  1,262,794,246              0           0             0             0           0      }
              .      .     .              .              .           .             .             .           .  };
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .      .     .              .              .           .             .             .           .  {
              .      .     .              .              .           .             .             .           .      for (int i = 0; i < cls.size(); ++i)
              .      .     .              .              .           .             .             .           .      {
              .      .     .              .              .           .             .             .           .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .      .     .              .              .           .             .             .           .  class OccLists
              .      .     .              .              .           .             .             .           .  {
              .      .     .              .              .           .             .             .           .      vec<Vec>  occs;
              .      .     .              .              .           .             .             .           .      vec<char> dirty;
              .      .     .              .              .           .             .             .           .      vec<Idx>  dirties;
              .      .     .              .              .           .             .             .           .      Deleted   deleted;
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  public:
              3      0     0              0              0           0             3             0           0      OccLists(const Deleted& d) : deleted(d) {}
              .      .     .              .              .           .             .             .           .      unsigned int size(){
              .      .     .              .              .           .             .             .           .          auto m_size=0;
             64      2     2              4              3           0             0             0           0          for(int i=0;i<occs.size();i++){
      4,167,880     14    14      1,515,572        378,896     318,993             0             0           0              m_size+=occs[i].size();
              .      .     .              .              .           .             .             .           .          }
              .      .     .              .              .           .             .             .           .          
              .      .     .              .              .           .             .             .           .          return m_size;
              .      .     .              .              .           .             .             .           .      }
      2,083,906      1     1              0              0           0       378,892             0           0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .      .     .              .              .           .             .             .           .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
  5,382,908,035     34    34  5,382,908,035      6,347,946           4             0             0           0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
      5,332,945      1     1      2,667,591      2,126,998      70,411       189,508            47           1      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      void  cleanAll  ();
              .      .     .              .              .           .             .             .           .      void  clean     (const Idx& idx);
              .      .     .              .              .           .             .             .           .      void  smudge    (const Idx& idx){
      7,566,246      0     0      5,042,549      1,702,049     626,454             0             0           0          if (dirty[toInt(idx)] == 0){
      1,300,913    465   421              0              0           0     1,300,913             0           0              dirty[toInt(idx)] = 1;
             55      1     1              0              0           0             0             0           0              dirties.push(idx);
              .      .     .              .              .           .             .             .           .          }
              .      .     .              .              .           .             .             .           .      }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .      void  clear(bool free = true){
              .      .     .              .              .           .             .             .           .          occs   .clear(free);
              .      .     .              .              .           .             .             .           .          dirty  .clear(free);
              .      .     .              .              .           .             .             .           .          dirties.clear(free);
              .      .     .              .              .           .             .             .           .      }
              .      .     .              .              .           .             .             .           .  };
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  template<class Idx, class Vec, class Deleted>
          3,004      0     0              0              0           0         2,253             1           0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .      .     .              .              .           .             .             .           .  {
    688,411,731  6,320 1,850    342,907,056      1,938,905          99             0             0           0      for (int i = 0; i < dirties.size(); i++)
              .      .     .              .              .           .             .             .           .          // Dirties may contain duplicates so check here if a variable is already cleaned:
      3,895,302      0     0      2,596,868      1,264,590      26,693             0             0           0          if (dirty[toInt(dirties[i])])
              .      .     .              .              .           .             .             .           .              clean(dirties[i]);
              .      .     .              .              .           .             .             .           .      dirties.clear();
          3,004      0     0          3,004            453          12             0             0           0  }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  template<class Idx, class Vec, class Deleted>
              .      .     .              .              .           .             .             .           .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .      .     .              .              .           .             .             .           .  {
              .      .     .              .              .           .             .             .           .      Vec& vec = occs[toInt(idx)];
              .      .     .              .              .           .             .             .           .      int  i, j;
    203,975,404      2     2      5,193,322      1,346,706     664,086             0             0           0      for (i = j = 0; i < vec.size(); i++)
    125,616,952      0     0        154,585          9,857       6,152             0             0           0          if (!deleted(vec[i]))
    419,635,095      1     1    120,165,256              1           0    60,146,781            86           0              vec[j++] = vec[i];
      1,300,652    407   400              0              0           0             0             0           0      vec.shrink(i - j);
      5,205,766      1     1      2,601,680        101,123           1     1,300,954        50,931           0      dirty[toInt(idx)] = 0;
              .      .     .              .              .           .             .             .           .  }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  //=================================================================================================
              .      .     .              .              .           .             .             .           .  // CMap -- a class for mapping clauses to values:
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .      .     .              .              .           .             .             .           .  |       p          - The literal p can be deleted from 'other'
              .      .     .              .              .           .             .             .           .  |________________________________________________________________________________________________@*/
              .      .     .              .              .           .             .             .           .  inline Lit Clause::subsumes(const Clause& other) const
              .      .     .              .              .           .             .             .           .  {
              .      .     .              .              .           .             .             .           .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .      .     .              .              .           .             .             .           .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .      .     .              .              .           .             .             .           .      assert(!header.learnt);   assert(!other.header.learnt);
              .      .     .              .              .           .             .             .           .      assert(header.has_extra); assert(other.header.has_extra);
    441,585,498      0     0    147,195,166     15,706,222     758,070             0             0           0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .      .     .              .              .           .             .             .           .          return lit_Error;
              .      .     .              .              .           .             .             .           .  
      5,975,997      0     0              0              0           0             0             0           0      Lit        ret = lit_Undef;
              .      .     .              .              .           .             .             .           .      const Lit* c   = (const Lit*)(*this);
              .      .     .              .              .           .             .             .           .      const Lit* d   = (const Lit*)other;
              .      .     .              .              .           .             .             .           .  
     32,671,084      1     1      5,182,250              0           0             0             0           0      for (unsigned i = 0; i < header.size; i++) {
              .      .     .              .              .           .             .             .           .          // search for c[i] or ~c[i]
  3,922,519,622      2     2      5,975,997        379,674         357     5,975,997             5           0          for (unsigned j = 0; j < other.header.size; j++)
  6,857,350,272      0     0  1,910,908,809     69,567,169      62,783             0             0           0              if (c[i] == d[j])
              .      .     .              .              .           .             .             .           .                  goto ok;
  2,155,625,346      0     0              0              0           0             0             0           0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .      .     .              .              .           .             .             .           .                  ret = c[i];
              .      .     .              .              .           .             .             .           .                  goto ok;
              .      .     .              .              .           .             .             .           .              }
              .      .     .              .              .           .             .             .           .  
              .      .     .              .              .           .             .             .           .          // did not find it
              .      .     .              .              .           .             .             .           .          return lit_Error;
              .      .     .              .              .           .             .             .           .  ok:;
              .      .     .              .              .           .             .             .           .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
Ir                I1mr      ILmr    Dr                D1mr            DLmr          Dw              D1mw           DLmw        
--------------------------------------------------------------------------------
4,288,057,225,355 1,793,099 204,318 1,336,302,758,378 161,618,222,944 3,677,894,834 405,555,655,620 29,574,412,571 511,503,687  events annotated

