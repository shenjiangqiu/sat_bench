--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/sha1r17m148ABCD_p.cnf
Data file:        sha1r17m148ABCD_p.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr       ILmr   Dr                D1mr            DLmr       Dw              D1mw           DLmw       
--------------------------------------------------------------------------------
6,532,934,360,958 10,293,090 63,120 2,129,806,777,169 114,371,254,827 53,228,628 785,610,589,918 23,023,679,361 68,021,435  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                I1mr      ILmr  Dr                D1mr           DLmr      Dw              D1mw           DLmw        file:function
--------------------------------------------------------------------------------
3,154,195,533,756    24,934   323 1,168,707,100,234 66,918,304,066 8,227,915 383,772,279,134     61,591,729          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
1,258,571,503,512        11     8   239,774,720,076 11,265,545,208 2,552,617 168,361,407,039              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
  739,277,593,809   392,918   297   181,897,666,248 10,037,796,784    44,678 109,528,611,257 14,853,581,880 10,320,539  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
  224,131,514,292       606   423    58,824,985,107  8,565,092,314   117,478  22,854,105,567    126,492,453        136  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
  149,543,860,079       150   109    38,034,320,240  1,626,760,637    73,121               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
  132,551,606,510         2     2   131,017,184,307    917,130,317         0   1,534,411,163              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
  105,533,397,571        84    56    26,084,359,023  1,809,166,441       302  19,471,458,954  2,793,782,075    708,264  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
   91,304,174,210         0     0    45,652,087,105        138,333         3               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
   64,927,791,516    51,375 1,336    23,693,538,075  1,253,860,106    12,552   4,295,791,207     27,889,782        697  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   52,237,354,479    22,001   715    20,319,269,679  2,177,701,827     6,226   6,269,981,444    587,011,131      1,544  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
   48,825,737,099         4     4    20,979,358,805  1,078,212,173    13,083  14,851,535,020  3,238,273,885     58,880  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   45,777,826,099    60,499   478    14,942,127,360    236,869,770     1,467   5,188,366,362      4,440,620          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   45,612,632,125 2,151,721 3,182     9,811,248,447    331,513,741     2,210   4,403,156,306     70,768,997        123  ???:__ieee754_pow_fma
   36,688,830,676    37,480   207    14,374,790,877  1,536,058,965    15,508   9,378,119,591    123,420,637      1,724  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
   35,427,309,979 1,989,450   375     9,781,538,443              0         0   6,320,932,243     21,288,964      4,262  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   33,286,756,801    13,616   556     7,846,386,527      8,960,662        54   3,250,509,853     69,170,033     46,255  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   28,764,821,429       400    54    13,898,937,338    501,091,788     5,674   1,633,149,886     36,002,807        183  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   25,438,108,103     2,143   381     6,770,243,926    658,354,027    73,636     263,246,955      1,707,401          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   19,110,233,639       191   126     3,720,477,093    203,817,051     9,361   1,936,165,231    142,873,368      5,658  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
   16,579,094,635       364   210     5,283,798,698    874,731,622     8,599               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   15,792,427,758       879   341     8,005,998,905    464,663,106    94,703   1,197,824,571            128          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   15,017,872,423        52    40     4,853,435,756    465,957,666     2,296   2,848,403,942    150,644,875      1,432  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
   14,183,766,964     7,927 1,000     3,403,971,662    236,880,535    24,222     378,263,835        212,946          4  ???:__exp1_fma
   13,858,153,768         0     0     6,929,076,884         39,718         0               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::simplePropagate()
   12,758,745,793     1,362   126     5,292,618,315     43,350,534     4,264               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   12,118,488,534     1,617   121     5,445,762,854    501,197,901    14,524   1,713,708,514     54,222,294      1,064  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   10,761,850,138        12    12     3,709,531,986     20,968,295        43   3,342,786,166    138,390,065     10,072  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   10,028,370,000         0     0     6,685,578,058     99,694,916       364   1,671,393,058    252,003,473      5,324  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    9,819,431,430         0     0     9,819,431,430             85         0               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::simplePropagate()
    9,057,152,543     1,502   110     2,835,261,515      1,656,487         0     196,208,880      7,450,735        704  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
    6,998,740,806    11,223   283     1,943,853,111          7,631       237   1,166,272,929            178          0  ???:pow
    6,685,572,332         0     0     1,671,393,083              0         0   1,671,393,083         91,759         43  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir              I1mr   ILmr Dr              D1mr          DLmr   Dw            D1mw    DLmw   

-- line 77 ----------------------------------------
              .      .    .               .             .      .             .       .      .  private:
              .      .    .               .             .      .             .       .      .      template<typename T>
              .      .    .               .             .      .             .       .      .      class MyQueue {
              .      .    .               .             .      .             .       .      .          int max_sz, q_sz;
              .      .    .               .             .      .             .       .      .          int ptr;
              .      .    .               .             .      .             .       .      .          int64_t sum;
              .      .    .               .             .      .             .       .      .          vec<T> q;
              .      .    .               .             .      .             .       .      .      public:
              4      1    1               0             0      0             3       0      0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
              .      .    .               .             .      .             .       .      .          inline bool   full () const { return q_sz == max_sz; }
              .      .    .               .             .      .             .       .      .  #ifdef INT_QUEUE_AVG
      5,185,296    130   10       1,296,324             0      0             0       0      0          inline T      avg  () const { assert(full()); return sum / max_sz; }
              .      .    .               .             .      .             .       .      .  #else
              .      .    .               .             .      .             .       .      .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
              .      .    .               .             .      .             .       .      .  #endif
         20,416     52   40               0             0      0        20,416   4,936      0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
              .      .    .               .             .      .             .       .      .          void push(T e) {
     17,377,758      0    0       8,447,829             0      0       241,050       0      0              if (q_sz < max_sz) q_sz++;
      7,724,679     15   14       2,574,893     2,572,974    173             0       0      0              else sum -= q[ptr];
      8,447,829     44   32               0             0      0     2,815,943       0      0              sum += e;
      8,447,829      0    0               0             0      0     5,631,886 240,568     54              q[ptr++] = e;
      8,502,742      0    0       5,631,886             0      0        54,913       0      0              if (ptr == max_sz) ptr = 0;
              .      .    .               .             .      .             .       .      .          }
              .      .    .               .             .      .             .       .      .      };
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  public:
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .      // Constructor/Destructor:
              .      .    .               .             .      .             .       .      .      //
              .      .    .               .             .      .             .       .      .      Solver();
              .      .    .               .             .      .             .       .      .      virtual ~Solver();
             10      2    2               0             0      0             4       0      0      void print_size(std::ostream &os)
              .      .    .               .             .      .             .       .      .      {
              4      2    2               0             0      0             4       1      0          program_end_time=std::chrono::steady_clock::now();
              2      0    0               0             0      0             2       0      0          total_work_time=program_end_time-program_start_time;
              4      0    0               2             1      0             0       0      0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
              2      0    0               2             1      0             0       0      0          os << "model " << model.size() * sizeof(model[0]) << "\n";
              4      0    0               2             0      0             0       0      0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
              4      0    0               2             1      0             0       0      0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
              4      0    0               2             0      0             0       0      0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
              4      0    0               2             1      0             0       0      0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
              .      .    .               .             .      .             .       .      .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
              .      .    .               .             .      .             .       .      .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
              2      0    0               2             2      0             0       0      0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
              2      0    0               2             0      0             0       0      0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
              2      0    0               2             0      0             0       0      0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
              4      0    0               2             0      0             0       0      0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
              4      0    0               2             2      0             0       0      0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
              4      0    0               2             0      0             0       0      0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
              4      0    0               2             0      0             0       0      0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
              .      .    .               .             .      .             .       .      .          os << "total_Watchers: " << total_Watchers << "\n";
              .      .    .               .             .      .             .       .      .          os << "total_act_watchers: " << total_act_watchers << "\n";
              .      .    .               .             .      .             .       .      .          os << "total_indexs: " << total_indexs << "\n";
              .      .    .               .             .      .             .       .      .          os << "time_find_conflict: " << time_find_conflict << "\n";
              .      .    .               .             .      .             .       .      .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
              .      .    .               .             .      .             .       .      .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
              .      .    .               .             .      .             .       .      .          os << "total_propagation_time: " << total_duration.count() << "\n";
              .      .    .               .             .      .             .       .      .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
              .      .    .               .             .      .             .       .      .          os<<"total_watch_access: "<<total_watch_access<<"\n";
              .      .    .               .             .      .             .       .      .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
              .      .    .               .             .      .             .       .      .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
              .      .    .               .             .      .             .       .      .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
              .      .    .               .             .      .             .       .      .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
              .      .    .               .             .      .             .       .      .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
              .      .    .               .             .      .             .       .      .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
              .      .    .               .             .      .             .       .      .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
              6      0    0               4             0      0             0       0      0      }
              .      .    .               .             .      .             .       .      .      using ull=unsigned long long;
              .      .    .               .             .      .             .       .      .      ull total_Watchers = 0;
              .      .    .               .             .      .             .       .      .      ull total_act_watchers = 0;
              .      .    .               .             .      .             .       .      .      ull total_indexs = 0;
              .      .    .               .             .      .             .       .      .      ull time_find_conflict = 0;
              .      .    .               .             .      .             .       .      .      ull total_find_conflict_length = 0;
              .      .    .               .             .      .             .       .      .      ull total_find_conflict_allsize = 0;
              .      .    .               .             .      .             .       .      .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
              .      .    .               .             .      .             .       .      .      {
              .      .    .               .             .      .             .       .      .          const ClauseAllocator& ca;
              .      .    .               .             .      .             .       .      .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
              .      .    .               .             .      .             .       .      .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
              .      .    .               .             .      .             .       .      .      };
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .      struct VarOrderLt {
              .      .    .               .             .      .             .       .      .          const vec<double>&  activity;
  8,573,245,213    795   88   5,972,379,224   667,371,550 16,259   277,718,055       0      0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
              .      .    .               .             .      .             .       .      .          VarOrderLt(const vec<double>&  act) : activity(act) { }
              .      .    .               .             .      .             .       .      .      };
              .      .    .               .             .      .             .       .      .      
              .      .    .               .             .      .             .       .      .      struct ConflictData
              .      .    .               .             .      .             .       .      .  	{
              .      .    .               .             .      .             .       .      .  		ConflictData() :
              .      .    .               .             .      .             .       .      .  			nHighestLevel(-1),
              .      .    .               .             .      .             .       .      .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
              .      .    .               .             .      .             .       .      .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
              .      .    .               .             .      .             .       .      .      void     newDecisionLevel ();                                                      // Begins a new decision level.
              .      .    .               .             .      .             .       .      .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
              .      .    .               .             .      .             .       .      .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
              .      .    .               .             .      .             .       .      .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
              .      .    .               .             .      .             .       .      .      std::chrono::nanoseconds total_duration;
              .      .    .               .             .      .             .       .      .      CRef     propagate(){
              .      .    .               .             .      .             .       .      .  
     25,927,370 11,042  217               0             0      0    12,963,685       0      0          auto start_time=std::chrono::steady_clock::now();
     38,891,055      0    0               0             0      0    12,963,685       0      0          auto ref= propagate_();
     12,963,685      0    0               0             0      0    12,963,685       0      0          auto end_time=std::chrono::steady_clock::now();
              .      .    .               .             .      .             .       .      .          auto duration=end_time-start_time;
              .      .    .               .             .      .             .       .      .          total_duration+=duration;
              .      .    .               .             .      .             .       .      .          return ref;
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .      }
              .      .    .               .             .      .             .       .      .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
              .      .    .               .             .      .             .       .      .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
              .      .    .               .             .      .             .       .      .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
              .      .    .               .             .      .             .       .      .      
              .      .    .               .             .      .             .       .      .  public:
              .      .    .               .             .      .             .       .      .      int      level            (Var x) const;
              .      .    .               .             .      .             .       .      .  protected:
              .      .    .               .             .      .             .       .      .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
              .      .    .               .             .      .             .       .      .      bool     withinBudget     ()      const;
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .      template<class V> int computeLBD(const V& c) {
    302,155,438     75   53               0             0      0             0       0      0          int lbd = 0;
              .      .    .               .             .      .             .       .      .  
     34,356,426     77   54      28,461,660     3,234,638     45             0       0      0          counter++;
  1,344,795,255      0    0       5,909,218             0      0             0       0      0          for (int i = 0; i < c.size(); i++){
              .      .    .               .             .      .             .       .      .              int l = level(var(c[i]));
  3,177,625,626      0    0   1,271,043,768    25,319,988    793             0       0      0              if (l != 0 && seen2[l] != counter){
    200,199,527      0    0               0             0      0   200,199,527       0      0                  seen2[l] = counter;
    432,580,651      0    0               0             0      0             0       0      0                  lbd++; } }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .          return lbd;
              .      .    .               .             .      .             .       .      .      }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  #ifdef BIN_DRUP
              .      .    .               .             .      .             .       .      .      static int buf_len;
              .      .    .               .             .      .             .       .      .      static unsigned char drup_buf[];
              .      .    .               .             .      .             .       .      .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
              .      .    .               .             .      .             .       .      .      }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .      template<class V>
              .      .    .               .             .      .             .       .      .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
              .      .    .               .             .      .             .       .      .          assert(op == 'a' || op == 'd');
              .      .    .               .             .      .             .       .      .          *buf_ptr++ = op; buf_len++;
              .      .    .               .             .      .             .       .      .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
              .      .    .               .             .      .             .       .      .          *buf_ptr++ = 0; buf_len++;
        522,021     68   52               0             0      0       522,021       0      0          if (buf_len > 1048576) binDRUP_flush(drup_file);
              .      .    .               .             .      .             .       .      .      }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
              .      .    .               .             .      .             .       .      .          *buf_ptr++ = 'a'; buf_len++;
              .      .    .               .             .      .             .       .      .          for (int i = 0; i < c.size(); i++)
              .      .    .               .             .      .             .       .      .              if (c[i] != l) byteDRUP(c[i]);
              .      .    .               .             .      .             .       .      .          *buf_ptr++ = 0; buf_len++;
              .      .    .               .             .      .             .       .      .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
              .      .    .               .             .      .             .       .      .      double    my_var_decay;
              .      .    .               .             .      .             .       .      .      bool   DISTANCE;
              .      .    .               .             .      .             .       .      .  };
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  //=================================================================================================
              .      .    .               .             .      .             .       .      .  // Implementation of inline methods:
              .      .    .               .             .      .             .       .      .  
  1,357,975,007      0    0   1,357,975,007    22,443,425 10,405             0       0      0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
  9,749,327,097     94   54   8,198,154,922 1,265,230,202  2,514 1,534,411,163       0      0  inline int  Solver::level (Var x) const { return vardata[x].level; }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  inline void Solver::insertVarOrder(Var x) {
              .      .    .               .             .      .             .       .      .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
 10,742,215,608  1,361  125   3,333,610,014     3,577,141      0             0       0      0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
    172,565,652      1    1     115,043,768    27,047,825  4,249             0       0      0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  inline void Solver::varDecayActivity() {
     11,263,772      0    0       5,631,886       712,195     15     2,815,943       0      0      var_inc *= (1 / var_decay); }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  inline void Solver::varBumpActivity(Var v, double mult) {
  4,691,733,217     21   20   2,852,573,142   270,742,863  6,933   711,669,594       0      0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
              .      .    .               .             .      .             .       .      .          // Rescale:
          6,562    207  111               1             0      0             0       0      0          for (int i = 0; i < nVars(); i++)
      3,571,264      0    0         893,472       186,317  3,482       892,816       0      0              activity_VSIDS[i] *= 1e-100;
          1,312      0    0             656             0      0           656       0      0          var_inc *= 1e-100; }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .      // Update order_heap with respect to new activity:
    487,851,068      0    0               0             0      0             0       0      0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
              .      .    .               .             .      .             .       .      .  
     23,579,064  1,940  111      11,789,532           448      9     5,894,766       0      0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
              .      .    .               .             .      .             .       .      .  inline void Solver::claBumpActivity (Clause& c) {
    138,007,704  1,085  264      40,958,758     6,271,726    244    14,022,547  44,993 10,127      if ( (c.activity() += cla_inc) > 1e20 ) {
              .      .    .               .             .      .             .       .      .          // Rescale:
      8,524,354    122  111             384             0      0             0       0      0          for (int i = 0; i < learnts_local.size(); i++)
     19,887,770     16    1       2,841,110     2,613,976 82,127     2,841,110       0      0              ca[learnts_local[i]].activity() *= 1e-20;
      2,218,150    519  152       1,108,883             0      0           128     128      0          cla_inc *= 1e-20; } }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
              .      .    .               .             .      .             .       .      .  inline void Solver::checkGarbage(double gf){
         29,862    270    2           9,954           482      1             0       0      0      if (ca.wasted() > ca.size() * gf)
          1,054      1    1             528           528    175             2       1      0          garbageCollect(); }
              .      .    .               .             .      .             .       .      .  
              .      .    .               .             .      .             .       .      .  // NOTE: enqueue does not set the ok flag! (only public methods do)
              .      .    .               .             .      .             .       .      .  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
              .      .    .               .             .      .             .       .      .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
              .      .    .               .             .      .             .       .      .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
              .      .    .               .             .      .             .       .      .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
              .      .    .               .             .      .             .       .      .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
              .      .    .               .             .      .             .       .      .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
              .      .    .               .             .      .             .       .      .  inline bool     Solver::locked          (const Clause& c) const {
     82,185,369    392  199      26,384,123       631,207      0             0       0      0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
     99,368,704    788  385      22,052,604       502,473      0             0       0      0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
              .      .    .               .             .      .             .       .      .  }
     14,096,826      1    1       7,048,407             0      0             0       0      0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
              .      .    .               .             .      .             .       .      .  
        506,254      2    2         263,252             0      0       243,002       0      0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
  3,870,205,704  4,065  150     471,340,819    33,637,290      0             0       0      0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
     57,557,373      1    1      57,557,357           943      0             0       0      0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
137,782,557,963     78   56 137,782,557,963         1,138      0             0       0      0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
              .      .    .               .             .      .             .       .      .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
              .      .    .               .             .      .             .       .      .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
              .      .    .               .             .      .             .       .      .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
              3      0    0               2             0      0             1       0      0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
              .      .    .               .             .      .             .       .      .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
      1,803,022      1    1           9,492             9      0             1       0      0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
              6      1    1               3             3      0             0       0      0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
              .      .    .               .             .      .             .       .      .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
              .      .    .               .             .      .             .       .      .  inline void     Solver::setDecisionVar(Var v, bool b) 
              .      .    .               .             .      .             .       .      .  { 
         16,326      0    0           8,163            21      0             0       0      0      if      ( b && !decision[v]) dec_vars++;
          1,482      0    0             988           151      0             0       0      0      else if (!b &&  decision[v]) dec_vars--;
              .      .    .               .             .      .             .       .      .  
          3,215      0    0               0             0      0         3,215       0      0      decision[v] = b;
              .      .    .               .             .      .             .       .      .      if (b && !order_heap_CHB.inHeap(v)){
              .      .    .               .             .      .             .       .      .          order_heap_CHB.insert(v);
              .      .    .               .             .      .             .       .      .          order_heap_VSIDS.insert(v);
              .      .    .               .             .      .             .       .      .          order_heap_distance.insert(v);}
              .      .    .               .             .      .             .       .      .  }
              .      .    .               .             .      .             .       .      .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
              .      .    .               .             .      .             .       .      .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
              .      .    .               .             .      .             .       .      .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir              I1mr    ILmr Dr              D1mr           DLmr      Dw             D1mw          DLmw   

-- line 51 ----------------------------------------
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  //=================================================================================================
              .       .    .               .              .         .              .             .      .  // Options:
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  static const char* _cat = "CORE";
              .       .    .               .              .         .              .             .      .  
              4       0    0               0              0         0              1             0      0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
              4       0    0               0              0         0              1             0      0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
              4       0    0               0              0         0              1             0      0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
              4       1    1               0              0         0              1             0      0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
              4       0    0               0              0         0              1             0      0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
              4       0    0               0              0         0              1             0      0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
              4       0    0               0              0         0              1             0      0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
              4       0    0               0              0         0              1             0      0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
              4       0    0               0              0         0              1             0      0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
              4       1    1               0              0         0              1             0      0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
              4       0    0               0              0         0              1             0      0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
              4       1    1               0              0         0              1             0      0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
              4       1    1               0              0         0              1             0      0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
              4       1    1               0              0         0              1             0      0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
              4       1    1               0              0         0              1             0      0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
              .       .    .               .              .         .              .             .      .  
              4       1    1               0              0         0              1             0      0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
              1       1    1               0              0         0              1             0      0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
              4       0    0               0              0         0              1             0      0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
              .       .    .               .              .         .              .             .      .  
              4       1    1               0              0         0              1             0      0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  //VSIDS_props_limit
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  //=================================================================================================
              .       .    .               .              .         .              .             .      .  // Constructor/Destructor:
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              4       1    1               0              0         0              2             0      0  Solver::Solver() :
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Parameters (user settable):
              .       .    .               .              .         .              .             .      .      //
              .       .    .               .              .         .              .             .      .      drup_file        (NULL)
              .       .    .               .              .         .              .             .      .    , verbosity        (0)
              .       .    .               .              .         .              .             .      .    , step_size        (opt_step_size)
              .       .    .               .              .         .              .             .      .    , step_size_dec    (opt_step_size_dec)
              .       .    .               .              .         .              .             .      .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
              .       .    .               .              .         .              .             .      .    , garbage_frac     (opt_garbage_frac)
              .       .    .               .              .         .              .             .      .    , restart_first    (opt_restart_first)
              .       .    .               .              .         .              .             .      .    , restart_inc      (opt_restart_inc)
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .    , min_number_of_learnts_copies(opt_min_dupl_app)  
              .       .    .               .              .         .              .             .      .    , max_lbd_dup(opt_max_lbd_dup)
              .       .    .               .              .         .              .             .      .    , dupl_db_init_size(opt_dupl_db_init_size)
              3       1    1               1              0         0              1             0      0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .    // Parameters (the rest):
              .       .    .               .              .         .              .             .      .    //
              .       .    .               .              .         .              .             .      .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .    // Parameters (experimental):
              .       .    .               .              .         .              .             .      .    //
              .       .    .               .              .         .              .             .      .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
              .       .    .               .              .         .              .             .      .    //
              .       .    .               .              .         .              .             .      .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
              .       .    .               .              .         .              .             .      .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
              .       .    .               .              .         .              .             .      .    , chrono_backtrack(0), non_chrono_backtrack(0)
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .    , ok                 (true)
              .       .    .               .              .         .              .             .      .    , cla_inc            (1)
              .       .    .               .              .         .              .             .      .    , var_inc            (1)
              1       0    0               0              0         0              0             0      0    , watches_bin        (WatcherDeleted(ca))
              .       .    .               .              .         .              .             .      .    , watches            (WatcherDeleted(ca))
              .       .    .               .              .         .              .             .      .    , qhead              (0)
              .       .    .               .              .         .              .             .      .    , simpDB_assigns     (-1)
              .       .    .               .              .         .              .             .      .    , simpDB_props       (0)
              .       .    .               .              .         .              .             .      .    , order_heap_CHB     (VarOrderLt(activity_CHB))
              .       .    .               .              .         .              .             .      .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
              .       .    .               .              .         .              .             .      .    , progress_estimate  (0)
              .       .    .               .              .         .              .             .      .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
              .       .    .               .              .         .              .             .      .    // simplifyAll adjust occasion
              .       .    .               .              .         .              .             .      .    , curSimplify(1)
              .       .    .               .              .         .              .             .      .    , nbconfbeforesimplify(1000)
              .       .    .               .              .         .              .             .      .    , incSimplify(1000)
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .    , my_var_decay       (0.6)
              .       .    .               .              .         .              .             .      .    , DISTANCE           (true)
              .       .    .               .              .         .              .             .      .    , var_iLevel_inc     (1)
             94       8    8              25              2         2             63             1      0    , order_heap_distance(VarOrderLt(activity_distance))
              .       .    .               .              .         .              .             .      .  
              4       0    0               3              0         0              0             0      0  {}
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  Solver::~Solver()
              .       .    .               .              .         .              .             .      .  {
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  // simplify All
              .       .    .               .              .         .              .             .      .  //
              .       .    .               .              .         .              .             .      .  CRef Solver::simplePropagate()
     92,328,200      12   10               0              0         0     69,246,150        30,352      0  {
     11,541,025       0    0               0              0         0     11,541,025             0      0      CRef    confl = CRef_Undef;
     11,541,025       0    0               0              0         0     11,541,025             0      0      int     num_props = 0;
     23,082,050       0    0               0              0         0     11,541,025        27,351      0      watches.cleanAll();
     34,623,075      75   53      11,541,025              3         0     11,541,025             0      0      watches_bin.cleanAll();
    270,103,186       0    0     135,051,593            203         0              0             0      0      while (qhead < trail.size())
              .       .    .               .              .         .              .             .      .      {
    617,649,575       4    3     247,059,830      7,468,758         0    247,059,830             0      0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .    .               .              .         .              .             .      .          vec<Watcher>&  ws = watches[p];
              .       .    .               .              .         .              .             .      .          Watcher        *i, *j, *end;
    123,510,568       0    0     123,510,568              0         0              0             0      0          num_props++;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          // First, Propagate binary clauses
              .       .    .               .              .         .              .             .      .          vec<Watcher>&  wbin = watches_bin[p];
              .       .    .               .              .         .              .             .      .  
    806,110,727       0    0     123,529,915    117,871,372       741              0             0      0          for (int k = 0; k<wbin.size(); k++)
              .       .    .               .              .         .              .             .      .          {
              .       .    .               .              .         .              .             .      .  
    218,669,314       0    0     163,133,696     58,639,957     2,030              0             0      0              Lit imp = wbin[k].blocker;
              .       .    .               .              .         .              .             .      .  
    218,669,314       0    0               0              0         0              0             0      0              if (value(imp) == l_False)
              .       .    .               .              .         .              .             .      .              {
         38,694       0    0          19,347              0         0         19,347             0      0                  return wbin[k].cref;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
    218,630,620      13   11               0              0         0              0             0      0              if (value(imp) == l_Undef)
              .       .    .               .              .         .              .             .      .              {
     44,124,491       0    0      44,124,491              0         0              0             0      0                  simpleUncheckEnqueue(imp, wbin[k].cref);
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
 20,765,830,733      54   44  10,012,653,527     88,168,422       526    243,491,564             0      0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
              .       .    .               .              .         .              .             .      .          {
              .       .    .               .              .         .              .             .      .              // Try to avoid inspecting the clause:
  9,765,632,391      49   26   9,765,632,391  1,295,190,536    63,409              0             0      0              Lit blocker = i->blocker;
 19,531,264,782       0    0   9,765,632,391    119,970,734         0              0             0      0              if (value(blocker) == l_True)
              .       .    .               .              .         .              .             .      .              {
              .       .    .               .              .         .              .             .      .                  *j++ = *i++; continue;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Make sure the false literal is data[1]:
 13,858,153,768       0    0   6,929,076,884              0         0              0             0      0              CRef     cr = i->cref;
              .       .    .               .              .         .              .             .      .              Clause&  c = ca[cr];
              .       .    .               .              .         .              .             .      .              Lit      false_lit = ~p;
 20,787,230,652       0    0   6,929,076,884  6,683,441,101    46,892              0             0      0              if (c[0] == false_lit)
  7,928,720,046       0    0   2,642,906,682    157,291,762     3,739  5,285,813,364             0      0                  c[0] = c[1], c[1] = false_lit;
              .       .    .               .              .         .              .             .      .              assert(c[1] == false_lit);
              .       .    .               .              .         .              .             .      .              //  i++;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // If 0th watch is true, then clause is already satisfied.
              .       .    .               .              .         .              .             .      .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
              .       .    .               .              .         .              .             .      .              // why not simply do i->blocker=first in this case?
              .       .    .               .              .         .              .             .      .              Lit     first = c[0];
              .       .    .               .              .         .              .             .      .              //  Watcher w     = Watcher(cr, first);
 17,512,610,792       0    0   1,827,228,512     20,224,610         0              0             0      0              if (first != blocker && value(first) == l_True)
              .       .    .               .              .         .              .             .      .              {
    484,128,841       0    0               0              0         0    484,128,841             0      0                  i->blocker = first;
 13,282,737,392       0    0   3,320,684,348              0         0  3,320,684,348    31,605,646      0                  *j++ = *i++; continue;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Look for new watch:
              .       .    .               .              .         .              .             .      .              //if (incremental)
              .       .    .               .              .         .              .             .      .              //{ // ----------------- INCREMENTAL MODE
              .       .    .               .              .         .              .             .      .              //	int choosenPos = -1;
              .       .    .               .              .         .              .             .      .              //	for (int k = 2; k < c.size(); k++)
              .       .    .               .              .         .              .             .      .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
              .       .    .               .              .         .              .             .      .              //		Watcher w = Watcher(cr, first); i++;
              .       .    .               .              .         .              .             .      .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
              .       .    .               .              .         .              .             .      .              //		watches[~c[1]].push(w);
              .       .    .               .              .         .              .             .      .              //		goto NextClause;
              .       .    .               .              .         .              .             .      .              //	}
              .       .    .               .              .         .              .             .      .              //}
              .       .    .               .              .         .              .             .      .              else
              .       .    .               .              .         .              .             .      .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
 20,751,976,184      75   51               0              0         0              0             0      0                  for (int k = 2; k < c.size(); k++)
              .       .    .               .              .         .              .             .      .                  {
              .       .    .               .              .         .              .             .      .  
 38,736,856,277       0    0               0              0         0              0             0      0                      if (value(c[k]) != l_False)
              .       .    .               .              .         .              .             .      .                      {
              .       .    .               .              .         .              .             .      .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
              .       .    .               .              .         .              .             .      .                          // the blocker is first in the watcher. However,
              .       .    .               .              .         .              .             .      .                          // the blocker in the corresponding watcher in ~first is not c[1]
              .       .    .               .              .         .              .             .      .                          Watcher w = Watcher(cr, first); i++;
 25,482,191,932       0    0   6,370,547,983              0         0 12,741,095,966             0      0                          c[1] = c[k]; c[k] = false_lit;
              .       .    .               .              .         .              .             .      .                          watches[~c[1]].push(w);
  6,370,547,983       0    0               0              0         0              0             0      0                          goto NextClause;
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Did not find watch -- clause is unit under assignment:
     74,400,060       0    0               0              0         0     74,400,060             0      0              i->blocker = first;
    297,600,240       5    0      74,400,060              0         0     74,400,060       421,537      0              *j++ = *i++;
    148,800,120      75   52               0              0         0              0             0      0              if (value(first) == l_False)
              .       .    .               .              .         .              .             .      .              {
      2,475,127      12    9               0              0         0        374,251           163      0                  confl = cr;
        748,502      70   51         374,251              0         0        374,251        10,440      0                  qhead = trail.size();
              .       .    .               .              .         .              .             .      .                  // Copy the remaining watches:
     63,293,324       7    2         719,576         25,681         0              0             0      0                  while (i < end)
     30,552,835       0    0      30,552,835      3,802,742       141     30,552,835       198,463      0                      *j++ = *i++;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              else
              .       .    .               .              .         .              .             .      .              {
              .       .    .               .              .         .              .             .      .                  simpleUncheckEnqueue(first, cr);
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  NextClause:;
              .       .    .               .              .         .              .             .      .          }
    239,961,992      75   54               0              0         0              0             0      0          ws.shrink(i - j);
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
     23,043,356       0    0      23,043,356      5,195,534         0              0             0      0      s_propagations += num_props;
              .       .    .               .              .         .              .             .      .  
     11,521,678       0    0      11,521,678              0         0              0             0      0      return confl;
  4,862,136,712      80   57      80,787,175      5,557,867         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
              .       .    .               .              .         .              .             .      .      assert(value(p) == l_Undef);
    118,150,300       0    0               0              0         0    118,150,300             0      0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
    259,382,650      75   57     129,691,325      2,275,406         0    129,691,325   104,854,932    136      vardata[var(p)].reason = from;
     85,566,834       0    0      85,566,834              0         0              0             0      0      trail.push_(p);
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::cancelUntilTrailRecord()
              .       .    .               .              .         .              .             .      .  {
    262,619,690       0    0       1,294,816          3,997         0              0             0      0      for (int c = trail.size() - 1; c >= trailRecord; c--)
              .       .    .               .              .         .              .             .      .      {
        647,408      75   54         647,408              0         0              0             0      0          Var x = var(trail[c]);
    131,633,549       0    0         647,408              0         0    129,691,325     2,146,628      0          assigns[x] = l_Undef;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      }
        647,408       0    0               0              0         0        647,408             0      0      qhead = trailRecord;
      1,294,816       0    0               0              0         0              0             0      0      trail.shrink(trail.size() - trailRecord);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::litsEnqueue(int cutP, Clause& c)
              .       .    .               .              .         .              .             .      .  {
              .       .    .               .              .         .              .             .      .      for (int i = cutP; i < c.size(); i++)
              .       .    .               .              .         .              .             .      .      {
              .       .    .               .              .         .              .             .      .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  bool Solver::removed(CRef cr) {
              .       .    .               .              .         .              .             .      .      return ca[cr].mark() == 1;
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
      7,077,499      68   52               0              0         0      3,860,454             0      0  {
        643,409       0    0               0              0         0              0             0      0      int pathC = 0;
        643,409       0    0               0              0         0              0             0      0      Lit p = lit_Undef;
      1,930,227       0    0         643,409              0         0              0             0      0      int index = trail.size() - 1;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      do{
     67,245,326      75   52               0              0         0              0             0      0          if (confl != CRef_Undef){
              .       .    .               .              .         .              .             .      .              reason_clause.push(confl);
              .       .    .               .              .         .              .             .      .              Clause& c = ca[confl];
              .       .    .               .              .         .              .             .      .              // Special case for binary clauses
              .       .    .               .              .         .              .             .      .              // The first one has to be SAT
    102,150,518      89   54               0              0         0              0             0      0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                  assert(value(c[1]) == l_True);
              .       .    .               .              .         .              .             .      .                  Lit tmp = c[0];
      2,739,504       0    0         913,168         51,682         3      1,826,336             0      0                  c[0] = c[1], c[1] = tmp;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              // if True_confl==true, then choose p begin with the 1th index of c;
    212,380,835       0    0      44,813,033        636,285         0              0             0      0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
              .       .    .               .              .         .              .             .      .                  Lit q = c[j];
    121,457,792       0    0      60,728,896      5,467,191         0              0             0      0                  if (!seen[var(q)]){
     32,979,276       0    0               0              0         0     32,979,276             0      0                      seen[var(q)] = 1;
     98,937,828       0    0      32,979,276              0         0              0             0      0                      pathC++;
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          else if (confl == CRef_Undef){
              .       .    .               .              .         .              .             .      .              out_learnt.push(~p);
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
    110,761,380      75   54      32,979,275              0         0              0             0      0          if (pathC == 0) break;
              .       .    .               .              .         .              .             .      .          // Select next clause to look at:
    870,625,242       0    0     290,208,421     16,137,018         0              0             0      0          while (!seen[var(trail[index--])]);
              .       .    .               .              .         .              .             .      .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
              .       .    .               .              .         .              .             .      .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
     65,958,550       0    0      32,979,275        636,460         0              0             0      0          if (trailRecord > index + 1) break;
              .       .    .               .              .         .              .             .      .          p = trail[index + 1];
              .       .    .               .              .         .              .             .      .          confl = reason(var(p));
     32,979,254       0    0               0              0         0     32,979,254             0      0          seen[var(p)] = 0;
     32,979,254       0    0               0              0         0              0             0      0          pathC--;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      } while (pathC >= 0);
      6,434,090      79   54       4,503,863         43,873         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::simplifyLearnt(Clause& c)
      5,826,672     150  107               0              0         0      3,884,448        21,284      0  {
              .       .    .               .              .         .              .             .      .      ////
        647,408       0    0         647,408         43,620         0              0             0      0      original_length_record += c.size();
              .       .    .               .              .         .              .             .      .  
      1,294,816       0    0         647,408         22,161         0        647,408       106,843      0      trailRecord = trail.size();// record the start pointer
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      vec<Lit> falseLit;
              .       .    .               .              .         .              .             .      .      falseLit.clear();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
              .       .    .               .              .         .              .             .      .  
        787,196      66   44               0              0         0              0             0      0      bool True_confl = false;
              .       .    .               .              .         .              .             .      .      int beforeSize, afterSize;
              .       .    .               .              .         .              .             .      .      beforeSize = c.size();
              .       .    .               .              .         .              .             .      .      int i, j;
              .       .    .               .              .         .              .             .      .      CRef confl;
              .       .    .               .              .         .              .             .      .  
     41,088,225      75   54               0              0         0              0             0      0      for (i = 0, j = 0; i < c.size(); i++){
     26,089,336       0    0               0              0         0              0             0      0          if (value(c[i]) == l_Undef){
              .       .    .               .              .         .              .             .      .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
              .       .    .               .              .         .              .             .      .              simpleUncheckEnqueue(~c[i]);
     45,770,502       0    0      11,541,025              0         0     11,541,025       207,117      0              c[j++] = c[i];
     34,623,075       0    0               0              0         0     11,541,025         3,522      0              confl = simplePropagate();
     34,623,075      75   54      11,541,025      5,328,631         0              0             0      0              if (confl != CRef_Undef){
              .       .    .               .              .         .              .             .      .                  break;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          else{
      3,007,286       0    0               0              0         0              0             0      0              if (value(c[i]) == l_True){
              .       .    .               .              .         .              .             .      .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
        999,244      47   31         249,811              0         0        249,811         7,294      0                  c[j++] = c[i];
        249,811      39   30               0              0         0              0             0      0                  True_confl = true;
              .       .    .               .              .         .              .             .      .                  confl = reason(var(c[i]));
              .       .    .               .              .         .              .             .      .                  break;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              else{
              .       .    .               .              .         .              .             .      .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
              .       .    .               .              .         .              .             .      .                  falseLit.push(c[i]);
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .      c.shrink(c.size() - j);
              .       .    .               .              .         .              .             .      .      afterSize = c.size();
              .       .    .               .              .         .              .             .      .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      if (confl != CRef_Undef || True_confl == true){
        643,409       0    0               0              0         0              0             0      0          simp_learnt_clause.clear();
        643,409       0    0               0              0         0              0             0      0          simp_reason_clause.clear();
      1,286,818       0    0               0              0         0              0             0      0          if (True_confl == true){
              .       .    .               .              .         .              .             .      .              simp_learnt_clause.push(c.last());
              .       .    .               .              .         .              .             .      .          }
      4,503,863      36   24               0              0         0        643,409             0      0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
              .       .    .               .              .         .              .             .      .  
      1,930,227       0    0         643,409              0         0              0             0      0          if (simp_learnt_clause.size() < c.size()){
      8,812,752      75   53       4,021,396              0         0              0             0      0              for (i = 0; i < simp_learnt_clause.size(); i++){
     15,315,624       0    0       3,828,906          2,113         0      3,828,906       130,974      0                  c[i] = simp_learnt_clause[i];
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              c.shrink(c.size() - i);
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      cancelUntilTrailRecord();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      ////
        647,408       0    0         647,408              0         0              0             0      0      simplified_length_record += c.size();
              .       .    .               .              .         .              .             .      .  
      5,179,264       0    0       4,531,856        639,155         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
              .       .    .               .              .         .              .             .      .  {
              .       .    .               .              .         .              .             .      .      int beforeSize, afterSize;
              .       .    .               .              .         .              .             .      .      int learnts_x_size_before = learnts_x.size();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      int ci, cj, li, lj;
              .       .    .               .              .         .              .             .      .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .               .              .         .              .             .      .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      return true;
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  bool Solver::simplifyLearnt_core()
            825       0    0               0              0         0            450             0      0  {
              .       .    .               .              .         .              .             .      .      int beforeSize, afterSize;
              .       .    .               .              .         .              .             .      .      int learnts_core_size_before = learnts_core.size();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      int ci, cj, li, lj;
              .       .    .               .              .         .              .             .      .      bool sat, false_lit;
              .       .    .               .              .         .              .             .      .      unsigned int nblevels;
              .       .    .               .              .         .              .             .      .      ////
              .       .    .               .              .         .              .             .      .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      ////
              .       .    .               .              .         .              .             .      .      int nbSimplified = 0;
              .       .    .               .              .         .              .             .      .      int nbSimplifing = 0;
              .       .    .               .              .         .              .             .      .  
     12,288,018      75   52              75              0         0              0             0      0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     18,431,592      75   55      12,287,728        384,051   162,773              0             0      0          CRef cr = learnts_core[ci];
              .       .    .               .              .         .              .             .      .          Clause& c = ca[cr];
              .       .    .               .              .         .              .             .      .  
     12,287,728       0    0               0              0         0              0             0      0          if (removed(cr)) continue;
     12,287,728       0    0       6,143,864        760,054    25,586              0             0      0          else if (c.simplified()){
     12,036,928       0    0               0              0         0      6,018,464             0      0              learnts_core[cj++] = learnts_core[ci];
              .       .    .               .              .         .              .             .      .              ////
     18,055,430       0    0       6,018,464              0         0              0             0      0              nbSimplified++;
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          else{
              .       .    .               .              .         .              .             .      .              int saved_size=c.size();
              .       .    .               .              .         .              .             .      .              //         if (drup_file){
              .       .    .               .              .         .              .             .      .              //                 add_oc.clear();
              .       .    .               .              .         .              .             .      .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .    .               .              .         .              .             .      .              ////
              .       .    .               .              .         .              .             .      .              nbSimplifing++;
        125,398       0    0               0              0         0              0             0      0              sat = false_lit = false;
      4,013,322       0    0               0              0         0              0             0      0              for (int i = 0; i < c.size(); i++){
      4,013,344       0    0               0              0         0              0             0      0                  if (value(c[i]) == l_True){
              .       .    .               .              .         .              .             .      .                      sat = true;
              .       .    .               .              .         .              .             .      .                      break;
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .                  else if (value(c[i]) == l_False){
      4,264,114      75   52               0              0         0        125,398             0      0                      false_lit = true;
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              if (sat){
             91       2    1              26              0         0             26             0      0                  removeClause(cr);
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              else{
        752,322       0    0               0              0         0        376,161             0      0                  detachClause(cr, true);
              .       .    .               .              .         .              .             .      .  
        501,548      75   54         250,774              0         0              0             0      0                  if (false_lit){
         15,318       0    0             816             31         0              0             0      0                      for (li = lj = 0; li < c.size(); li++){
         11,646       0    0               0              0         0              0             0      0                          if (value(c[li]) != l_False){
         16,179       0    0               0              0         0          5,393             0      0                              c[lj++] = c[li];
              .       .    .               .              .         .              .             .      .                          }
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                      c.shrink(li - lj);
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                  beforeSize = c.size();
              .       .    .               .              .         .              .             .      .                  assert(c.size() > 1);
              .       .    .               .              .         .              .             .      .                  // simplify a learnt clause c
        501,548       0    0               0              0         0        250,774             0      0                  simplifyLearnt(c);
              .       .    .               .              .         .              .             .      .                  assert(c.size() > 0);
              .       .    .               .              .         .              .             .      .                  afterSize = c.size();
              .       .    .               .              .         .              .             .      .                  
        648,302       0    0         376,161        120,443         0              0             0      0                  if(drup_file && saved_size !=c.size()){
              .       .    .               .              .         .              .             .      .  #ifdef BIN_DRUP
              .       .    .               .              .         .              .             .      .                      binDRUP('a', c , drup_file);
              .       .    .               .              .         .              .             .      .                      //                    binDRUP('d', add_oc, drup_file);
              .       .    .               .              .         .              .             .      .  #else
              .       .    .               .              .         .              .             .      .                      for (int i = 0; i < c.size(); i++)
              .       .    .               .              .         .              .             .      .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .               .              .         .              .             .      .                      fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
              .       .    .               .              .         .              .             .      .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .    .               .              .         .              .             .      .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .               .              .         .              .             .      .                      //                    fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .    .               .              .         .              .             .      .  
        250,774       0    0               0              0         0              0             0      0                  if (c.size() == 1){
              .       .    .               .              .         .              .             .      .                      // when unit clause occur, enqueue and propagate
             30       5    4               6              0         0              6             0      0                      uncheckedEnqueue(c[0]);
             18       0    0               6              0         0              0             0      0                      if (propagate() != CRef_Undef){
              .       .    .               .              .         .              .             .      .                          ok = false;
              .       .    .               .              .         .              .             .      .                          return false;
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                      // delete the clause memory in logic
              .       .    .               .              .         .              .             .      .                      c.mark(1);
              .       .    .               .              .         .              .             .      .                      ca.free(cr);
              .       .    .               .              .         .              .             .      .  //#ifdef BIN_DRUP
              .       .    .               .              .         .              .             .      .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
              .       .    .               .              .         .              .             .      .  //#else
              .       .    .               .              .         .              .             .      .  //                    fprintf(drup_file, "d ");
              .       .    .               .              .         .              .             .      .  //                    for (int i = 0; i < c.size(); i++)
              .       .    .               .              .         .              .             .      .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .               .              .         .              .             .      .  //                    fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  //#endif
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .                  else{
        376,143       0    0               0              0         0        125,381             0      0                      attachClause(cr);
        752,286      75   54         376,143        241,209         0        125,381         1,442      0                      learnts_core[cj++] = learnts_core[ci];
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                      nblevels = computeLBD(c);
        250,762      69   52               0              0         0              0             0      0                      if (nblevels < c.lbd()){
              .       .    .               .              .         .              .             .      .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .    .               .              .         .              .             .      .                          c.set_lbd(nblevels);
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                      c.setSimplified(true);
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
             75       0    0               0              0         0              0             0      0      learnts_core.shrink(ci - cj);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .               .              .         .              .             .      .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
              .       .    .               .              .         .              .             .      .  
             75      54   41               0              0         0              0             0      0      return true;
              .       .    .               .              .         .              .             .      .  
            600       0    0             525             75         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
     44,481,042       2    2               0              0         0     29,654,028             0      0  int Solver::is_duplicate(std::vector<uint32_t>&c){
      9,884,676       0    0               0              0         0      9,884,676        57,922      0     auto time_point_0 = std::chrono::high_resolution_clock::now();
      4,942,338       0    0       4,942,338      2,530,706        87              0             0      0      dupl_db_size++;
     11,278,919     825   37       1,642,589              0         0              0             0      0      int res = 0;    
              .       .    .               .              .         .              .             .      .      
      9,884,676       0    0       9,884,676              0         0              0             0      0      int sz = c.size();
              .       .    .               .              .         .              .             .      .      std::vector<uint32_t> tmp(c);    
              .       .    .               .              .         .              .             .      .      sort(tmp.begin(),tmp.end());
              .       .    .               .              .         .              .             .      .      
      4,942,338 548,442   39               0              0         0      4,942,338             0      0      uint64_t hash = 0;    
              .       .    .               .              .         .              .             .      .      
    381,535,816  10,063  126               0              0         0      4,942,338             0      0      for (int i =0; i<sz; i++) {
  1,709,985,560       0    0     170,998,556              0         0              0             0      0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
              .       .    .               .              .         .              .             .      .      }    
              .       .    .               .              .         .              .             .      .      
      4,942,338       0    0               0              0         0      4,942,338             0      0      int32_t head = tmp[0];
              .       .    .               .              .         .              .             .      .      auto it0 = ht.find(head);
     24,701,010       0    0       4,942,335              0         0              0             0      0      if (it0 != ht.end()){
              .       .    .               .              .         .              .             .      .          auto it1=ht[head].find(sz);
      9,877,560       0    0               0              0         0              0             0      0          if (it1 != ht[head].end()){
      4,798,856       0    0               0              0         0      4,798,856             0      0              auto it2 = ht[head][sz].find(hash);
     14,396,568       0    0               0              0         0      4,798,856             0      0              if (it2 != ht[head][sz].end()){
        372,519       0    0         124,173         29,499     7,925        124,173             0      0                  it2->second++;
        124,173       0    0               0              0         0              0             0      0                  res = it2->second;            
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              else{
      4,674,683       0    0               0              0         0      4,674,683             0      0                  ht[head][sz][hash]=1;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          else{            
        279,848      12    1               0              0         0        139,924             0      0              ht[head][sz][hash]=1;
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }else{        
      4,821,723   2,366  160               0              0         0      4,821,723           346      0          ht[head][sz][hash]=1;
              .       .    .               .              .         .              .             .      .      } 
      4,942,338      96    5               0              0         0      4,942,338             0      0      auto time_point_1 = std::chrono::high_resolution_clock::now();
              .       .    .               .              .         .              .             .      .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
              .       .    .               .              .         .              .             .      .      return res;
     44,481,042       0    0      34,596,366          4,068         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  bool Solver::simplifyLearnt_tier2()
            825      75   52               0              0         0            450             0      0  {
              .       .    .               .              .         .              .             .      .      int beforeSize, afterSize;
              .       .    .               .              .         .              .             .      .      int learnts_tier2_size_before = learnts_tier2.size();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      int ci, cj, li, lj;
              .       .    .               .              .         .              .             .      .      bool sat, false_lit;
              .       .    .               .              .         .              .             .      .      unsigned int nblevels;
              .       .    .               .              .         .              .             .      .      ////
              .       .    .               .              .         .              .             .      .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      ////
              .       .    .               .              .         .              .             .      .      int nbSimplified = 0;
              .       .    .               .              .         .              .             .      .      int nbSimplifing = 0;
              .       .    .               .              .         .              .             .      .  
      1,396,327      58   13              75              0         0              0             0      0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
      2,094,153       0    0       1,396,102         66,605     2,782              0             0      0          CRef cr = learnts_tier2[ci];
              .       .    .               .              .         .              .             .      .          Clause& c = ca[cr];
              .       .    .               .              .         .              .             .      .  
      1,396,102       0    0               0              0         0              0             0      0          if (removed(cr)) continue;
      1,396,102       0    0         698,051         86,216        11              0             0      0          else if (c.simplified()){
        352,060       0    0               0              0         0        176,030           645      0              learnts_tier2[cj++] = learnts_tier2[ci];
              .       .    .               .              .         .              .             .      .              ////
      1,572,132       0    0         176,030              0         0              0             0      0              nbSimplified++;
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          else{
              .       .    .               .              .         .              .             .      .              int saved_size=c.size();
              .       .    .               .              .         .              .             .      .              //            if (drup_file){
              .       .    .               .              .         .              .             .      .              //                    add_oc.clear();
              .       .    .               .              .         .              .             .      .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .    .               .              .         .              .             .      .              ////
              .       .    .               .              .         .              .             .      .              nbSimplifing++;
        522,021       0    0               0              0         0              0             0      0              sat = false_lit = false;
     26,880,946       0    0               0              0         0              0             0      0              for (int i = 0; i < c.size(); i++){
     26,880,946       0    0               0              0         0              0             0      0                  if (value(c[i]) == l_True){
              .       .    .               .              .         .              .             .      .                      sat = true;
              .       .    .               .              .         .              .             .      .                      break;
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .                  else if (value(c[i]) == l_False){
     27,924,988      19   14               0              0         0        522,021             0      0                      false_lit = true;
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              if (sat){
              .       .    .               .              .         .              .             .      .                  removeClause(cr);
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              else{
      3,132,126      56   42               0              0         0      1,566,063            73      0                  detachClause(cr, true);
              .       .    .               .              .         .              .             .      .  
      2,088,084       0    0       1,044,042         20,376         0              0             0      0                  if (false_lit){
         67,247      10    6           2,506            184         0              0             0      0                      for (li = lj = 0; li < c.size(); li++){
         55,970       0    0               0              0         0              0             0      0                          if (value(c[li]) != l_False){
         79,905       0    0               0              0         0         26,635             0      0                              c[lj++] = c[li];
              .       .    .               .              .         .              .             .      .                          }
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                      c.shrink(li - lj);
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                  beforeSize = c.size();
              .       .    .               .              .         .              .             .      .                  assert(c.size() > 1);
              .       .    .               .              .         .              .             .      .                  // simplify a learnt clause c
      2,610,105       0    0               0              0         0      1,566,063             0      0                  simplifyLearnt(c);
              .       .    .               .              .         .              .             .      .                  assert(c.size() > 0);
              .       .    .               .              .         .              .             .      .                  afterSize = c.size();
              .       .    .               .              .         .              .             .      .                  
      2,088,084      75   53       1,044,042        519,764         0              0             0      0                  if(drup_file && saved_size!=c.size()){
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  #ifdef BIN_DRUP
              .       .    .               .              .         .              .             .      .                      binDRUP('a', c , drup_file);
              .       .    .               .              .         .              .             .      .                      //                    binDRUP('d', add_oc, drup_file);
              .       .    .               .              .         .              .             .      .  #else
              .       .    .               .              .         .              .             .      .                      for (int i = 0; i < c.size(); i++)
              .       .    .               .              .         .              .             .      .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .               .              .         .              .             .      .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
              .       .    .               .              .         .              .             .      .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .    .               .              .         .              .             .      .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .               .              .         .              .             .      .                      //                    fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .    .               .              .         .              .             .      .  
      1,044,042       0    0               0              0         0              0             0      0                  if (c.size() == 1){
              .       .    .               .              .         .              .             .      .                      // when unit clause occur, enqueue and propagate
              .       .    .               .              .         .              .             .      .                      uncheckedEnqueue(c[0]);
              .       .    .               .              .         .              .             .      .                      if (propagate() != CRef_Undef){
              .       .    .               .              .         .              .             .      .                          ok = false;
              .       .    .               .              .         .              .             .      .                          return false;
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                      // delete the clause memory in logic
              .       .    .               .              .         .              .             .      .                      c.mark(1);
-- line 838 ----------------------------------------
-- line 845 ----------------------------------------
              .       .    .               .              .         .              .             .      .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .               .              .         .              .             .      .  //                    fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  //#endif
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .                  else{
              .       .    .               .              .         .              .             .      .                      
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                      nblevels = computeLBD(c);
      1,044,042       0    0               0              0         0              0             0      0                      if (nblevels < c.lbd()){
              .       .    .               .              .         .              .             .      .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .    .               .              .         .              .             .      .                          c.set_lbd(nblevels);
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                       //duplicate learnts 
              .       .    .               .              .         .              .             .      .                      int id = 0;                    
              .       .    .               .              .         .              .             .      .                      
              .       .    .               .              .         .              .             .      .                      std::vector<uint32_t> tmp;
     36,162,301       0    0      26,803,221              0         0              0             0      0                      for (int i = 0; i < c.size(); i++)                           
     18,564,842       0    0       9,282,421              2         0      9,282,421             0      0                          tmp.push_back(c[i].x);
      2,088,084       0    0               0              0         0        522,021             0      0                      id = is_duplicate(tmp);
              .       .    .               .              .         .              .             .      .                       
              .       .    .               .              .         .              .             .      .                                          
              .       .    .               .              .         .              .             .      .                      //duplicate learnts 
              .       .    .               .              .         .              .             .      .  
      2,088,084       9    8         522,021              0         0              0             0      0                      if (id < min_number_of_learnts_copies+2){
      1,492,809      24   19               0              0         0        497,603             0      0                          attachClause(cr);
      2,473,887       0    0       1,492,809        991,492         0        497,603       470,290      0                          learnts_tier2[cj++] = learnts_tier2[ci];                    
      1,990,412      75   52         497,603              0         0              0             0      0                          if (id == min_number_of_learnts_copies+1){                            
          1,579       6    6           1,579              0         0              0             0      0                              duplicates_added_minimization++;                                  
              .       .    .               .              .         .              .             .      .                          }
        992,048       0    0         496,024        494,301         0              0             0      0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
              .       .    .               .              .         .              .             .      .                          //if (id == min_number_of_learnts_copies+1){
              .       .    .               .              .         .              .             .      .                              cj--;
              2       2    1               0              0         0              0             0      0                              learnts_core.push(cr);
              .       .    .               .              .         .              .             .      .                              c.mark(CORE);
              .       .    .               .              .         .              .             .      .                          }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                          c.setSimplified(true);
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
             75      68   52               0              0         0              0             0      0      learnts_tier2.shrink(ci - cj);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .    .               .              .         .              .             .      .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
              .       .    .               .              .         .              .             .      .  
             75       0    0               0              0         0              0             0      0      return true;
              .       .    .               .              .         .              .             .      .  
            600       0    0             525             75         1              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  bool Solver::simplifyAll()
            375      17   12               0              0         0            225             0      0  {
              .       .    .               .              .         .              .             .      .      ////
            150       0    0               0              0         0             75             0      0      simplified_length_record = original_length_record = 0;
              .       .    .               .              .         .              .             .      .  
            300       0    0              75             72         0              0             0      0      if (!ok || propagate() != CRef_Undef)
              .       .    .               .              .         .              .             .      .          return ok = false;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      //// cleanLearnts(also can delete these code), here just for analyzing
              .       .    .               .              .         .              .             .      .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .    .               .              .         .              .             .      .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
              .       .    .               .              .         .              .             .      .      //local_learnts_dirty = tier2_learnts_dirty = false;
              .       .    .               .              .         .              .             .      .  
            300       0    0               0              0         0             75             0      0      if (!simplifyLearnt_core()) return ok = false;
            300      75   53               0              0         0             75             0      0      if (!simplifyLearnt_tier2()) return ok = false;
              .       .    .               .              .         .              .             .      .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      checkGarbage();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      ////
              .       .    .               .              .         .              .             .      .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
              .       .    .               .              .         .              .             .      .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      return true;
            375       0    0             300             75         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  //=================================================================================================
              .       .    .               .              .         .              .             .      .  // Minor methods:
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
              .       .    .               .              .         .              .             .      .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
              .       .    .               .              .         .              .             .      .  //
              .       .    .               .              .         .              .             .      .  Var Solver::newVar(bool sign, bool dvar)
         27,210       1    1               0              0         0         21,768             0      0  {
              .       .    .               .              .         .              .             .      .      int v = nVars();
              .       .    .               .              .         .              .             .      .      watches_bin.init(mkLit(v, false));
              .       .    .               .              .         .              .             .      .      watches_bin.init(mkLit(v, true ));
              .       .    .               .              .         .              .             .      .      watches  .init(mkLit(v, false));
              .       .    .               .              .         .              .             .      .      watches  .init(mkLit(v, true ));
             17       1    1               0              0         0              0             0      0      assigns  .push(l_Undef);
             17       1    1               0              0         0              0             0      0      vardata  .push(mkVarData(CRef_Undef, 0));
             17       0    0               0              0         0              0             0      0      activity_CHB  .push(0);
          8,197       0    0           2,721             92         0             17             0      0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
              .       .    .               .              .         .              .             .      .  
             17       1    1               0              0         0              0             0      0      picked.push(0);
             17       0    0               0              0         0              0             0      0      conflicted.push(0);
             17       0    0               0              0         0              0             0      0      almost_conflicted.push(0);
              .       .    .               .              .         .              .             .      .  #ifdef ANTI_EXPLORATION
             17       0    0               0              0         0              0             0      0      canceled.push(0);
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .  
             17       0    0               0              0         0              0             0      0      seen     .push(0);
             17       0    0               0              0         0              0             0      0      seen2    .push(0);
             17       0    0               0              0         0              0             0      0      polarity .push(sign);
             17       0    0               0              0         0              0             0      0      decision .push();
         13,605       1    1               0              0         0          5,442           165      0      trail    .capacity(v+1);
              .       .    .               .              .         .              .             .      .      setDecisionVar(v, dvar);
              .       .    .               .              .         .              .             .      .  
             17       0    0               0              0         0              0             0      0      activity_distance.push(0);
             17       1    1               0              0         0              0             0      0      var_iLevel.push(0);
             17       0    0               0              0         0              0             0      0      var_iLevel_tmp.push(0);
             17       0    0               0              0         0              0             0      0      pathCs.push(0);
              .       .    .               .              .         .              .             .      .      return v;
         24,489       0    0          19,047             15         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  bool Solver::addClause_(vec<Lit>& ps)
         86,401       2    1               0              0         0         74,058             0      0  {
              .       .    .               .              .         .              .             .      .      assert(decisionLevel() == 0);
         37,029       1    1          12,343              0         0              0             0      0      if (!ok) return false;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Check if clause is satisfied and remove false/duplicate literals:
              .       .    .               .              .         .              .             .      .      sort(ps);
              .       .    .               .              .         .              .             .      .      Lit p; int i, j;
              .       .    .               .              .         .              .             .      .  
         24,686       0    0          12,343             23         0              0             0      0      if (drup_file){
              .       .    .               .              .         .              .             .      .          add_oc.clear();
         12,343       2    1          12,343              0         0              0             0      0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
              .       .    .               .              .         .              .             .      .  
        149,645       0    0               0              0         0              0             0      0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
        257,637       0    0          41,653              0         0              0             0      0          if (value(ps[i]) == l_True || ps[i] == ~p)
              .       .    .               .              .         .              .             .      .              return true;
        166,612       4    2               0              0         0              0             0      0          else if (value(ps[i]) != l_False && ps[i] != p)
        124,959       0    0          41,653              0         0         41,653             0      0              ps[j++] = p = ps[i];
         98,744       0    0          12,343              0         0              0             0      0      ps.shrink(i - j);
              .       .    .               .              .         .              .             .      .  
         24,686       2    1               0              0         0              0             0      0      if (drup_file && i != j){
              .       .    .               .              .         .              .             .      .  #ifdef BIN_DRUP
              .       .    .               .              .         .              .             .      .          binDRUP('a', ps, drup_file);
         12,343       0    0          12,343              0         0              0             0      0          binDRUP('d', add_oc, drup_file);
              .       .    .               .              .         .              .             .      .  #else
              .       .    .               .              .         .              .             .      .          for (int i = 0; i < ps.size(); i++)
              .       .    .               .              .         .              .             .      .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
              .       .    .               .              .         .              .             .      .          fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          fprintf(drup_file, "d ");
              .       .    .               .              .         .              .             .      .          for (int i = 0; i < add_oc.size(); i++)
              .       .    .               .              .         .              .             .      .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .    .               .              .         .              .             .      .          fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .      
         24,686       0    0               0              0         0              0             0      0      if (ps.size() == 0)
              .       .    .               .              .         .              .             .      .          return ok = false;
         24,686       2    1               0              0         0              0             0      0      else if (ps.size() == 1){
              .       .    .               .              .         .              .             .      .          uncheckedEnqueue(ps[0]);
              .       .    .               .              .         .              .             .      .          return ok = (propagate() == CRef_Undef);
              .       .    .               .              .         .              .             .      .      }else{
         12,343       0    0               0              0         0         12,343             0      0          CRef cr = ca.alloc(ps, false);
              .       .    .               .              .         .              .             .      .          //auto ca_size=ca.size();
              .       .    .               .              .         .              .             .      .          //printf("ca size:%d\n",ca_size);
         37,029       0    0               0              0         0         12,343             0      0          clauses.push(cr);
         37,029       2    1          12,343              0         0         12,343             0      0          attachClause(cr);
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
         12,343       0    0               0              0         0              0             0      0      return true;
        135,773       0    0          86,401              4         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
     65,302,550      13    8               0              0         0     39,181,530             7      0  void Solver::attachClause(CRef cr) {
              .       .    .               .              .         .              .             .      .      const Clause& c = ca[cr];
              .       .    .               .              .         .              .             .      .      assert(c.size() > 1);
     26,118,357       0    0       6,530,255            482         0              0             0      0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .    .               .              .         .              .             .      .      ws[~c[0]].push(Watcher(cr, c[1]));
              .       .    .               .              .         .              .             .      .      ws[~c[1]].push(Watcher(cr, c[0]));
     19,578,254       0    0      13,047,999      4,156,211        43              0             0      0      if (c.learnt()) learnts_literals += c.size();
     52,254,551       1    0      45,724,296             10         0              0             0      0      else            clauses_literals += c.size(); }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
     37,884,522     475  225               0              0         0     25,256,348           481      0  void Solver::detachClause(CRef cr, bool strict) {
              .       .    .               .              .         .              .             .      .      const Clause& c = ca[cr];
              .       .    .               .              .         .              .             .      .      assert(c.size() > 1);
     25,256,348       0    0               0              0         0              0             0      0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .    .               .              .         .              .             .      .      
     25,256,348       0    0               0              0         0              0             0      0      if (strict){
              .       .    .               .              .         .              .             .      .          remove(ws[~c[0]], Watcher(cr, c[1]));
              .       .    .               .              .         .              .             .      .          remove(ws[~c[1]], Watcher(cr, c[0]));
              .       .    .               .              .         .              .             .      .      }else{
              .       .    .               .              .         .              .             .      .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
              .       .    .               .              .         .              .             .      .          ws.smudge(~c[0]);
              .       .    .               .              .         .              .             .      .          ws.smudge(~c[1]);
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
     18,938,922       9    2      12,624,835         56,866        73              0             0      0      if (c.learnt()) learnts_literals -= c.size();
     37,887,861       0    0      31,573,774         24,725         0              0             0      0      else            clauses_literals -= c.size(); }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
     45,332,088     805  437               0              0         0     22,666,044           377      0  void Solver::removeClause(CRef cr) {
              .       .    .               .              .         .              .             .      .      Clause& c = ca[cr];
              .       .    .               .              .         .              .             .      .  
     16,999,533       0    0       5,666,511            815         0              0             0      0      if (drup_file){
              .       .    .               .              .         .              .             .      .          if (c.mark() != 1){
              .       .    .               .              .         .              .             .      .  #ifdef BIN_DRUP
              .       .    .               .              .         .              .             .      .              binDRUP('d', c, drup_file);
              .       .    .               .              .         .              .             .      .  #else
              .       .    .               .              .         .              .             .      .              fprintf(drup_file, "d ");
              .       .    .               .              .         .              .             .      .              for (int i = 0; i < c.size(); i++)
              .       .    .               .              .         .              .             .      .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .    .               .              .         .              .             .      .              fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .          }else
              .       .    .               .              .         .              .             .      .              printf("c Bug. I don't expect this to happen.\n");
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
     22,666,044     382  236               0              0         0      5,666,511             0      0      detachClause(cr);
              .       .    .               .              .         .              .             .      .      // Don't leave pointers to free'd memory!
              .       .    .               .              .         .              .             .      .      if (locked(c)){
             42       0    0               8              0         0              0             0      0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
             26       0    0               0              0         0             13             0      0          vardata[var(implied)].reason = CRef_Undef; }
              .       .    .               .              .         .              .             .      .      c.mark(1);
              .       .    .               .              .         .              .             .      .      ca.free(cr);
     33,999,066       0    0      28,332,555              0         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  bool Solver::satisfied(const Clause& c) const {
     32,929,952      33   20               0              0         0              0             0      0      for (int i = 0; i < c.size(); i++)
     35,117,134       0    0      15,430,251          5,869         0              0             0      0          if (value(c[i]) == l_True)
              .       .    .               .              .         .              .             .      .              return true;
              .       .    .               .              .         .              .             .      .      return false; }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
              .       .    .               .              .         .              .             .      .  //
     53,144,829  12,224  255               0              0         0     35,429,886             0      0  void Solver::cancelUntil(int bLevel) {
              .       .    .               .              .         .              .             .      .  	
     23,640,348       7    2          10,215              0         0      5,904,981             0      0      if (decisionLevel() > bLevel){
              .       .    .               .              .         .              .             .      .  #ifdef PRINT_OUT
              .       .    .               .              .         .              .             .      .  		std::cout << "bt " << bLevel << "\n";
              .       .    .               .              .         .              .             .      .  #endif				
     11,809,962       0    0               0              0         0      5,904,981             0      0  		add_tmp.clear();
  8,439,664,154   7,718  173   1,700,923,789      9,567,400        53              0             0      0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
              .       .    .               .              .         .              .             .      .          {
              .       .    .               .              .         .              .             .      .              Var      x  = var(trail[c]);
              .       .    .               .              .         .              .             .      .  
  3,342,797,768       0    0   1,671,398,884    681,589,405       719              0             0      0  			if (level(x) <= bLevel)
              .       .    .               .              .         .              .             .      .  			{
              .       .    .               .              .         .              .             .      .  				add_tmp.push(trail[c]);
              .       .    .               .              .         .              .             .      .  			}
              .       .    .               .              .         .              .             .      .  			else
              .       .    .               .              .         .              .             .      .  			{
  3,342,786,116       0    0   1,671,393,058        709,436         0              0             0      0  				 if (!VSIDS){
  2,785,037,610       0    0   1,856,691,740        186,786         0              0             0      0  					uint32_t age = conflicts - picked[x];
  1,856,691,740       0    0     928,345,870    390,246,267     1,661              0             0      0  					if (age > 0){
  9,278,351,580   1,616  114   3,711,340,632    716,489,257     1,411              0             0      0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
    927,835,158       0    0     927,835,158    371,334,450     2,381              0             0      0  						double old_activity = activity_CHB[x];
  6,494,846,106      75   50   1,855,670,316      4,564,230         1    927,835,158             0      0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
              .       .    .               .              .         .              .             .      .  						if (order_heap_CHB.inHeap(x)){
  5,390,335,020     139   38               0              0         0  2,695,167,510           623      0  							if (activity_CHB[x] > old_activity)
              .       .    .               .              .         .              .             .      .  								order_heap_CHB.decrease(x);
              .       .    .               .              .         .              .             .      .  							else
              .       .    .               .              .         .              .             .      .  								order_heap_CHB.increase(x);
              .       .    .               .              .         .              .             .      .  						}
              .       .    .               .              .         .              .             .      .  					}
              .       .    .               .              .         .              .             .      .  #ifdef ANTI_EXPLORATION
  1,856,691,740       0    0     928,345,870              0         0    928,345,870   384,092,270  1,536  					canceled[x] = conflicts;
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .  				}
              .       .    .               .              .         .              .             .      .  				
  3,342,786,116     228   84   1,671,393,058              0         0  1,671,393,058   202,918,238      8  				assigns [x] = l_Undef;
              .       .    .               .              .         .              .             .      .  #ifdef PRINT_OUT
              .       .    .               .              .         .              .             .      .  				std::cout << "undo " << x << "\n";
              .       .    .               .              .         .              .             .      .  #endif				
  3,342,786,116       0    0   1,671,393,058              0         0              0             0      0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
  1,671,393,058       0    0   1,671,393,058              0         0              0             0      0  					polarity[x] = sign(trail[c]);
              .       .    .               .              .         .              .             .      .  				insertVarOrder(x);
              .       .    .               .              .         .              .             .      .  			}
              .       .    .               .              .         .              .             .      .          }
      5,904,981       0    0               0              0         0      5,904,981             0      0          qhead = trail_lim[bLevel];
     11,809,962       0    0               0              0         0              0             0      0          trail.shrink(trail.size() - trail_lim[bLevel]);
     17,714,943       0    0       5,904,981              0         0              0             0      0          trail_lim.shrink(trail_lim.size() - bLevel);
     17,726,595       1    1       5,904,981              0         0              0             0      0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
              .       .    .               .              .         .              .             .      .  		{
          1,077       0    0             359              0         0              0             0      0  			trail.push_(add_tmp[nLitId]);
              .       .    .               .              .         .              .             .      .  		}
              .       .    .               .              .         .              .             .      .  		
              .       .    .               .              .         .              .             .      .  		add_tmp.clear();
     47,239,848       0    0      41,334,867      3,014,596         0              0             0      0      } }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  //=================================================================================================
              .       .    .               .              .         .              .             .      .  // Major methods:
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  Lit Solver::pickBranchLit()
     56,387,264     332   24               0              0         0     42,290,448           719      0  {
              .       .    .               .              .         .              .             .      .      Var next = var_Undef;
              .       .    .               .              .         .              .             .      .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
     47,788,709   2,282  199      13,725,897      5,592,916       155              0             0      0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Random decision:
              .       .    .               .              .         .              .             .      .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
              .       .    .               .              .         .              .             .      .          next = order_heap[irand(random_seed,order_heap.size())];
              .       .    .               .              .         .              .             .      .          if (value(next) == l_Undef && decision[next])
              .       .    .               .              .         .              .             .      .              rnd_decisions++; }*/
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Activity based decision:
    286,475,727     385    1     136,189,455     11,949,075       868              0             0      0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    115,044,236       0    0               0              0         0              0             0      0          if (order_heap.empty())
              1       0    0               0              0         0              0             0      0              return lit_Undef;
              .       .    .               .              .         .              .             .      .          else{
              .       .    .               .              .         .              .             .      .  #ifdef ANTI_EXPLORATION
    115,044,234       0    0      57,522,117            112         0              0             0      0              if (!VSIDS){
              .       .    .               .              .         .              .             .      .                  Var v = order_heap_CHB[0];
     59,289,392       0    0      59,289,392        309,725        49              0             0      0                  uint32_t age = conflicts - canceled[v];
    122,038,612       0    0      51,408,129     25,990,818     2,172      9,611,177             0      0                  while (age > 0){
              .       .    .               .              .         .              .             .      .                      double decay = pow(0.95, age);
     43,526,866       0    0      21,763,433        230,401         8     21,763,433             0      0                      activity_CHB[v] *= decay;
              .       .    .               .              .         .              .             .      .                      if (order_heap_CHB.inHeap(v))
              .       .    .               .              .         .              .             .      .                          order_heap_CHB.increase(v);
     65,290,299       0    0      43,526,866              0         0     21,763,433             5      0                      canceled[v] = conflicts;
              .       .    .               .              .         .              .             .      .                      v = order_heap_CHB[0];
              .       .    .               .              .         .              .             .      .                      age = conflicts - canceled[v];
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .              next = order_heap.removeMin();
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .  
     28,193,628       0    0      14,096,814      6,644,610       284              0             0      0      return mkLit(next, polarity[next]);
     63,435,671       0    0      49,338,856        102,016         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
              .       .    .               .              .         .              .             .      .  {
              .       .    .               .              .         .              .             .      .  	ConflictData data;
              .       .    .               .              .         .              .             .      .  	Clause& conflCls = ca[cind];
              .       .    .               .              .         .              .             .      .  	data.nHighestLevel = level(var(conflCls[0]));
     23,578,980       0    0      11,789,490        161,091         0              0             0      0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
              .       .    .               .              .         .              .             .      .  	{
              .       .    .               .              .         .              .             .      .  		return data;
              .       .    .               .              .         .              .             .      .  	}
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  	int highestId = 0;
              .       .    .               .              .         .              .             .      .      data.bOnlyOneLitFromHighest = true;
              .       .    .               .              .         .              .             .      .  	// find the largest decision level in the clause
            758       2    1               0              0         0              0             0      0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
              .       .    .               .              .         .              .             .      .  	{
              .       .    .               .              .         .              .             .      .  		int nLevel = level(var(conflCls[nLitId]));
            309       0    0               0              0         0              0             0      0  		if (nLevel > data.nHighestLevel)
              .       .    .               .              .         .              .             .      .  		{
              .       .    .               .              .         .              .             .      .  			highestId = nLitId;
              .       .    .               .              .         .              .             .      .  			data.nHighestLevel = nLevel;
              5       0    0               0              0         0              0             0      0  			data.bOnlyOneLitFromHighest = true;
              .       .    .               .              .         .              .             .      .  		}
              .       .    .               .              .         .              .             .      .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
              .       .    .               .              .         .              .             .      .  		{
            284       0    0               0              0         0              0             0      0  			data.bOnlyOneLitFromHighest = false;
              .       .    .               .              .         .              .             .      .  		}
              .       .    .               .              .         .              .             .      .  	}
              .       .    .               .              .         .              .             .      .  
            116      33    1               0              0         0              0             0      0  	if (highestId != 0)
              .       .    .               .              .         .              .             .      .  	{
              .       .    .               .              .         .              .             .      .  		std::swap(conflCls[0], conflCls[highestId]);
              8       0    0               0              0         0              0             0      0  		if (highestId > 1)
              .       .    .               .              .         .              .             .      .  		{
              8       0    0               0              0         0              0             0      0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
              .       .    .               .              .         .              .             .      .  			//ws.smudge(~conflCls[highestId]);
              .       .    .               .              .         .              .             .      .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
              .       .    .               .              .         .              .             .      .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
              .       .    .               .              .         .              .             .      .  		}
              .       .    .               .              .         .              .             .      .  	}
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  	return data;
              .       .    .               .              .         .              .             .      .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
              .       .    .               .              .         .              .             .      .  |  
              .       .    .               .              .         .              .             .      .  |    Post-conditions:
              .       .    .               .              .         .              .             .      .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
              .       .    .               .              .         .              .             .      .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
              .       .    .               .              .         .              .             .      .  |        rest of literals. There may be others from the same level though.
              .       .    .               .              .         .              .             .      .  |  
              .       .    .               .              .         .              .             .      .  |________________________________________________________________________________________________@*/
              .       .    .               .              .         .              .             .      .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
     76,631,958     122   64               0              0         0     53,052,894             0      0  {
      5,894,766       0    0               0              0         0      5,894,766             0      0      int pathC = 0;
      5,894,766       0    0               0              0         0              0             0      0      Lit p     = lit_Undef;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Generate conflict clause:
              .       .    .               .              .         .              .             .      .      //
              .       .    .               .              .         .              .             .      .      out_learnt.push();      // (leave room for the asserting literal)
     11,789,532       0    0       5,894,766            308         0              0             0      0      int index   = trail.size() - 1;
      5,894,766       0    0       5,894,766              1         0              0             0      0      int nDecisionLevel = level(var(ca[confl][0]));
              .       .    .               .              .         .              .             .      .      assert(nDecisionLevel == level(var(ca[confl][0])));
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      do{
              .       .    .               .              .         .              .             .      .          assert(confl != CRef_Undef); // (otherwise should be UIP)
              .       .    .               .              .         .              .             .      .          Clause& c = ca[confl];
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
  2,076,512,872       0    0               0              0         0              0             0      0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
              .       .    .               .              .         .              .             .      .              assert(value(c[1]) == l_True);
              .       .    .               .              .         .              .             .      .              Lit tmp = c[0];
     10,868,091       0    0       3,622,697        223,057        88      7,245,394             0      0              c[0] = c[1], c[1] = tmp; }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          // Update LBD if improved.
  1,583,829,694       0    0      55,780,740              0         0              0             0      0          if (c.learnt() && c.mark() != CORE){
              .       .    .               .              .         .              .             .      .              int lbd = computeLBD(c);
     32,035,000       0    0               0              0         0              0             0      0              if (lbd < c.lbd()){
      2,471,614       0    0               0              0         0              0             0      0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
              .       .    .               .              .         .              .             .      .                  c.set_lbd(lbd);
      2,471,614       0    0       1,235,807        905,366         4              0             0      0                  if (lbd <= core_lbd_cut){
             16       2    0               0              0         0              8             0      0                      learnts_core.push(confl);
              .       .    .               .              .         .              .             .      .                      c.mark(CORE);
      3,745,169       0    0         564,490              0         0              0             0      0                  }else if (lbd <= 6 && c.mark() == LOCAL){
              .       .    .               .              .         .              .             .      .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
              .       .    .               .              .         .              .             .      .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     42,152,646      11    9               0              0         0     12,234,174     5,820,328     79                      learnts_tier2.push(confl);
              .       .    .               .              .         .              .             .      .                      c.mark(TIER2); }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
     31,392,764       0    0      15,696,382              0         0              0             0      0              if (c.mark() == TIER2)
     31,224,304      81   55       7,806,076        736,610         0      7,806,076       941,555    618                  c.touched() = conflicts;
     16,225,254       0    0       8,112,627              0         0              0             0      0              else if (c.mark() == LOCAL)
              .       .    .               .              .         .              .             .      .                  claBumpActivity(c);
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .  
  9,116,794,009      20    8   2,442,597,107             30         0    498,445,758           128      0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
  1,944,151,349       0    0   1,944,151,349    146,642,468       501              0             0      0              Lit q = c[j];
              .       .    .               .              .         .              .             .      .  
  6,798,544,669       1    1   2,914,232,006    468,777,991     3,371              0             0      0              if (!seen[var(q)] && level(var(q)) > 0){
  1,939,573,154       0    0     969,786,577          2,281         0              0             0      0                  if (VSIDS){
              .       .    .               .              .         .              .             .      .                      varBumpActivity(var(q), .5);
             24       1    1               0              0         0             12             0      0                      add_tmp.push(q);
              .       .    .               .              .         .              .             .      .                  }else
    553,965,690       0    0     553,965,690    188,433,060     2,016              0             0      0                      conflicted[var(q)]++;
    969,786,577       0    0               0              0         0    969,786,577             0      0                  seen[var(q)] = 1;
  1,939,573,154       0    0     969,786,577              0         0              0             0      0                  if (level(var(q)) >= nDecisionLevel){
    996,891,516       0    0     996,891,516              0         0              0             0      0                      pathC++;
              .       .    .               .              .         .              .             .      .                  }else
              .       .    .               .              .         .              .             .      .                      out_learnt.push(q);
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          
              .       .    .               .              .         .              .             .      .          // Select next clause to look at:
              .       .    .               .              .         .              .             .      .  		do {
  9,096,544,241       0    0   3,738,306,848    204,985,362     4,922              0             0      0  			while (!seen[var(trail[index--])]);
              .       .    .               .              .         .              .             .      .  			p  = trail[index+1];
    996,891,860       2    2     498,445,930     17,713,769         0              0             0      0  		} while (level(var(p)) < nDecisionLevel);
              .       .    .               .              .         .              .             .      .  		
    996,891,516       0    0     498,445,758              0         0    498,445,758           232      0          confl = reason(var(p));
    498,445,758       0    0               0              0         0    498,445,758             0      0          seen[var(p)] = 0;
    996,891,516       0    0     996,891,516              0         0              0             0      0          pathC--;
              .       .    .               .              .         .              .             .      .  
  2,967,095,484       0    0     985,101,984         24,162         0              0             0      0      }while (pathC > 0);
      5,894,766       0    0       5,894,766            146         0              0             0      0      out_learnt[0] = ~p;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Simplify conflict clause:
              .       .    .               .              .         .              .             .      .      //
              .       .    .               .              .         .              .             .      .      int i, j;
     11,789,532       0    0               0              0         0      5,894,766             0      0      out_learnt.copyTo(analyze_toclear);
     17,684,298       0    0       5,894,766              3         0              0             0      0      if (ccmin_mode == 2){
      5,894,761   1,073  156               0              0         0              0             0      0          uint32_t abstract_level = 0;
    954,471,170   1,157  111               0              0         0              0             0      0          for (i = 1; i < out_learnt.size(); i++)
    483,130,341       0    0       5,894,761              0         0              0             0      0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
              .       .    .               .              .         .              .             .      .  
  3,358,333,343      90   45   1,408,127,696            681         0      5,894,761             0      0          for (i = j = 1; i < out_learnt.size(); i++)
  3,449,090,324     105   72     654,413,027     20,943,752         0    428,052,854             0      0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
    679,080,519      16    6     226,360,173            275         0    226,360,173       102,231      0                  out_learnt[j++] = out_learnt[i];
              .       .    .               .              .         .              .             .      .          
              .       .    .               .              .         .              .             .      .      }else if (ccmin_mode == 1){
              .       .    .               .              .         .              .             .      .          for (i = j = 1; i < out_learnt.size(); i++){
              .       .    .               .              .         .              .             .      .              Var x = var(out_learnt[i]);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              if (reason(x) == CRef_Undef)
              .       .    .               .              .         .              .             .      .                  out_learnt[j++] = out_learnt[i];
              .       .    .               .              .         .              .             .      .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
              .       .    .               .              .         .              .             .      .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
              .       .    .               .              .         .              .             .      .                          out_learnt[j++] = out_learnt[i];
              .       .    .               .              .         .              .             .      .                          break; }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }else
              .       .    .               .              .         .              .             .      .          i = j = out_learnt.size();
              .       .    .               .              .         .              .             .      .  
     11,789,532       0    0       5,894,766      5,875,495        92              0             0      0      max_literals += out_learnt.size();
    380,173,390       1    1      93,569,656              0         0              0             0      0      out_learnt.shrink(i - j);
      5,894,766     260   12       5,894,766              0         0              0             0      0      tot_literals += out_learnt.size();
              .       .    .               .              .         .              .             .      .  
     11,789,532       0    0       5,894,766      1,542,905         0      5,894,766             0      0      out_lbd = computeLBD(out_learnt);
     66,774,427   8,614  335      29,994,423              0         0              0             0      0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
      3,644,319  19,733  143         520,617              0         0      1,041,234             0      0          if (binResMinimize(out_learnt))
         21,678       0    0           7,226              0         0          7,226             0      0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Find correct backtrack level:
              .       .    .               .              .         .              .             .      .      //
     11,419,334       0    0               0              0         0              0             0      0      if (out_learnt.size() == 1)
             18       0    0               6              0         0              6             0      0          out_btlevel = 0;
              .       .    .               .              .         .              .             .      .      else{
     11,788,274       0    0               0              0         0              0             0      0          int max_i = 1;
              .       .    .               .              .         .              .             .      .          // Find the first literal assigned at the next-highest level:
    896,546,119       0    0               0              0         0              0             0      0          for (int i = 2; i < out_learnt.size(); i++)
    696,827,389       0    0     220,457,931              0         0              0             0      0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
              .       .    .               .              .         .              .             .      .                  max_i = i;
              .       .    .               .              .         .              .             .      .          // Swap-in this literal at index 1:
              .       .    .               .              .         .              .             .      .          Lit p             = out_learnt[max_i];
     11,789,520       4    0       5,894,760              0         0      5,894,760             0      0          out_learnt[max_i] = out_learnt[1];
      5,894,760       0    0               0              0         0      5,894,760             0      0          out_learnt[1]     = p;
     11,789,520       0    0       5,894,760              0         0      5,894,760             0      0          out_btlevel       = level(var(p));
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
     11,789,532   2,456  131       5,894,766      1,493,939         0              0             0      0      if (VSIDS){
  1,439,069,615   7,304   97     424,268,716      1,928,000         0              0             0      0          for (int i = 0; i < add_tmp.size(); i++){
              .       .    .               .              .         .              .             .      .              Var v = var(add_tmp[i]);
  1,247,462,661       0    0     415,820,887     80,895,217         0              0             0      0              if (level(v) >= out_btlevel - 1)
              .       .    .               .              .         .              .             .      .                  varBumpActivity(v, 1);
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          add_tmp.clear();
              .       .    .               .              .         .              .             .      .      }else{
      6,157,646       0    0       3,078,823              0         0      3,078,823       124,055      0          seen[var(p)] = true;
    426,418,313       0    0       3,078,823              0         0              0             0      0          for(int i = out_learnt.size() - 1; i >= 0; i--){
              .       .    .               .              .         .              .             .      .              Var v = var(out_learnt[i]);
              .       .    .               .              .         .              .             .      .              CRef rea = reason(v);
    261,700,840       0    0               0              0         0              0             0      0              if (rea != CRef_Undef){
              .       .    .               .              .         .              .             .      .                  const Clause& reaC = ca[rea];
  1,615,138,262       0    0               0              0         0              0             0      0                  for (int i = 0; i < reaC.size(); i++){
              .       .    .               .              .         .              .             .      .                      Lit l = reaC[i];
  1,189,669,522       0    0     594,834,761      3,579,287        54              0             0      0                      if (!seen[var(l)]){
    195,467,190       0    0               0              0         0    195,467,190             0      0                          seen[var(l)] = true;
    195,467,190       0    0     195,467,190    105,504,101     1,504              0             0      0                          almost_conflicted[var(l)]++;
              .       .    .               .              .         .              .             .      .                          analyze_toclear.push(l); } } } } }
              .       .    .               .              .         .              .             .      .  
  3,449,705,642  10,322   87   1,716,010,672              0         0    855,057,953    20,901,253      0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
     47,158,128       0    0      41,263,362      3,651,840         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  // Try further learnt clause minimization by means of binary clause resolution.
              .       .    .               .              .         .              .             .      .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
      1,361,480       0    0               0              0         0      1,089,184           114      0  {
              .       .    .               .              .         .              .             .      .      // Preparation: remember which false variables we have in 'out_learnt'.
      1,561,851      32   27         520,617              0         0        520,617             0      0      counter++;
     20,332,554       0    0       1,041,234              0         0              0             0      0      for (int i = 1; i < out_learnt.size(); i++)
      8,605,655       0    0         520,612              0         0      8,085,043     6,897,540 35,861          seen2[var(out_learnt[i])] = counter;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Get the list of binary clauses containing 'out_learnt[0]'.
              .       .    .               .              .         .              .             .      .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
              .       .    .               .              .         .              .             .      .  
        272,296       0    0               0              0         0              0             0      0      int to_remove = 0;
      3,076,305       3    3         520,617        467,287         9          7,226             0      0      for (int i = 0; i < ws.size(); i++){
        896,889       0    0         896,889        279,520        65              0             0      0          Lit the_other = ws[i].blocker;
              .       .    .               .              .         .              .             .      .          // Does 'the_other' appear negatively in 'out_learnt'?
      3,602,520      21   13       1,536,446        484,426     5,320              0             0      0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
          7,482       0    0               0              0         0              0             0      0              to_remove++;
         22,446       0    0               0              0         0          7,482             0      0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Shrink.
        816,888      22   11               0              0         0              0             0      0      if (to_remove > 0){
          7,226       0    0               0              0         0              0             0      0          int last = out_learnt.size() - 1;
        904,064     199  107           7,225              0         0              0             0      0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
        251,916       0    0         125,958              0         0              0             0      0              if (seen2[var(out_learnt[i])] != counter)
         34,995       0    0          13,998              0         0          6,999             0      0                  out_learnt[i--] = out_learnt[last--];
              .       .    .               .              .         .              .             .      .          out_learnt.shrink(to_remove);
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .      return to_remove != 0;
      1,609,801       5    5       1,609,801              0         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
              .       .    .               .              .         .              .             .      .  // visiting literals at levels that cannot be removed later.
              .       .    .               .              .         .              .             .      .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
  4,280,528,540  57,615   43               0              0         0  2,568,317,124     4,440,464      0  {
    856,105,708       0    0               0              0         0    428,052,854             0      0      analyze_stack.clear(); analyze_stack.push(p);
  1,284,158,562       0    0     856,105,708              0         0    428,052,854             0      0      int top = analyze_toclear.size();
  2,487,978,844       0    0               0              0         0              0             0      0      while (analyze_stack.size() > 0){
              .       .    .               .              .         .              .             .      .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
              .       .    .               .              .         .              .             .      .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          // Special handling for binary clauses like in 'analyze()'.
  2,469,832,934      89   58               0              0         0              0             0      0          if (c.size() == 2 && value(c[0]) == l_False){
              .       .    .               .              .         .              .             .      .              assert(value(c[1]) == l_True);
              .       .    .               .              .         .              .             .      .              Lit tmp = c[0];
      3,808,584       0    0       1,269,528         79,042        47      2,539,056             0      0              c[0] = c[1], c[1] = tmp; }
              .       .    .               .              .         .              .             .      .  
  6,463,664,274       0    0               0              0         0              0             0      0          for (int i = 1; i < c.size(); i++){
  2,651,803,260     166   64   2,651,803,260    213,707,779     1,004              0             0      0              Lit p  = c[i];
 10,267,593,326       0    0   5,303,606,520     23,081,813       416              0             0      0              if (!seen[var(p)] && level(var(p)) > 0){
  4,320,350,178       0    0   1,154,952,034              0         0              0             0      0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
    971,879,826       0    0               0              0         0    971,879,826             0      0                      seen[var(p)] = 1;
              .       .    .               .              .         .              .             .      .                      analyze_stack.push(p);
              4       0    0               0              0         0              0             0      0                      analyze_toclear.push(p);
              .       .    .               .              .         .              .             .      .                  }else{
  3,827,717,603   2,532  263   1,155,669,064             80         0              0             0      0                      for (int j = top; j < analyze_toclear.size(); j++)
  1,428,803,708       0    0     639,279,060              0         0    789,524,648           156      0                          seen[var(analyze_toclear[j])] = 0;
    366,144,416      76   37     183,072,208              0         0              0             0      0                      analyze_toclear.shrink(analyze_toclear.size() - top);
    183,072,208       0    0               0              0         0              0             0      0                      return false;
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
    489,961,292       0    0               0              0         0              0             0      0      return true;
  3,424,422,832      21   13   2,996,369,978          1,056         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  /*_________________________________________________________________________________________________
              .       .    .               .              .         .              .             .      .  |
              .       .    .               .              .         .              .             .      .  |  analyzeFinal : (p : Lit)  ->  [void]
              .       .    .               .              .         .              .             .      .  |  
              .       .    .               .              .         .              .             .      .  |  Description:
              .       .    .               .              .         .              .             .      .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      seen[var(p)] = 0;
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 16,713,930,830       2    2               0              0         0  8,356,965,415             0      0  {
              .       .    .               .              .         .              .             .      .      assert(value(p) == l_Undef);
              .       .    .               .              .         .              .             .      .      Var x = var(p);
  3,342,786,166       0    0   1,671,393,083     45,198,216        43              0             0      0      if (!VSIDS){
  2,785,037,619       0    0   1,856,691,746     47,800,386        31    928,345,873   681,478,922 10,764          picked[x] = conflicts;
  1,856,691,746       0    0     928,345,873              0         0    928,345,873   673,659,887 11,555          conflicted[x] = 0;
  1,856,691,746       0    0     928,345,873              0         0    928,345,873   679,031,678 11,621          almost_conflicted[x] = 0;
              .       .    .               .              .         .              .             .      .  #ifdef ANTI_EXPLORATION
    928,345,873       0    0     928,345,873              0         0              0             0      0          uint32_t age = conflicts - canceled[var(p)];
  1,856,691,746       0    0     928,345,873    677,000,477     9,760              0             0      0          if (age > 0){
              .       .    .               .              .         .              .             .      .              double decay = pow(0.95, age);
    733,491,640       0    0     366,745,820    308,210,460     3,206    366,745,820             0      0              activity_CHB[var(p)] *= decay;
              .       .    .               .              .         .              .             .      .              if (order_heap_CHB.inHeap(var(p)))
    366,745,820       0    0               0              0         0              0             0      0                  order_heap_CHB.increase(var(p));
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
  1,671,393,083       1    1   1,671,393,083          2,634        43              0             0      0      assigns[x] = lbool(!sign(p));
  3,342,786,166       0    0               0              0         0  3,342,786,166 1,204,103,398 24,940      vardata[x] = mkVarData(from, level);
  1,671,393,083       1    1   1,671,393,083              0         0              0             0      0      trail.push_(p);
 11,699,751,581       0    0  10,028,358,498              0         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  unsigned number_watch_changed_total=0;
              .       .    .               .              .         .              .             .      .  unsigned number_clause_read_total=0;
              .       .    .               .              .         .              .             .      .  unsigned times_only_access_watch=0;
              .       .    .               .              .         .              .             .      .  /*_________________________________________________________________________________________________
              .       .    .               .              .         .              .             .      .  |
              .       .    .               .              .         .              .             .      .  |  propagate : [void]  ->  [Clause*]
              .       .    .               .              .         .              .             .      .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
              .       .    .               .              .         .              .             .      .  |  Description:
              .       .    .               .              .         .              .             .      .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
              .       .    .               .              .         .              .             .      .  |    otherwise CRef_Undef.
              .       .    .               .              .         .              .             .      .  |  
              .       .    .               .              .         .              .             .      .  |    Post-conditions:
              .       .    .               .              .         .              .             .      .  |      * the propagation queue is empty, even if there was a conflict.
              .       .    .               .              .         .              .             .      .  |________________________________________________________________________________________________@*/
              .       .    .               .              .         .              .             .      .  CRef Solver::propagate_()
    103,709,480       9    8               0              0         0     77,782,110             0      0  {
              .       .    .               .              .         .              .             .      .      //auto start_time=std::chrono::steady_clock::now();
     12,963,685       0    0               0              0         0     12,963,685             0      0      CRef    confl     = CRef_Undef;
     12,963,685       0    0               0              0         0     12,963,685           134      0      int     num_props = 0;
     25,927,370       0    0               0              0         0     12,963,685       168,426      0      watches.cleanAll();
     25,927,370       3    2               0              0         0     12,963,685             0      0      watches_bin.cleanAll();
              .       .    .               .              .         .              .             .      .      
  5,771,677,974       0    0   4,219,948,145     27,660,426        12              0             0      0      while (qhead < trail.size()){
  7,672,055,815       0    0   3,068,822,326     71,230,970         0  1,534,411,163             0      0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .    .               .              .         .              .             .      .          int currLevel = level(var(p));
              .       .    .               .              .         .              .             .      .          vec<Watcher>&  ws  = watches[p];
              .       .    .               .              .         .              .             .      .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          Watcher        *i, *j, *end;
  2,659,814,715       0    0   2,659,814,715     40,990,712         0              0             0      0          num_props++;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
              .       .    .               .              .         .              .             .      .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
  7,871,052,081       2    1   1,534,411,163  1,484,956,760    73,537              0             0      0          for (int k = 0; k < ws_bin.size(); k++){
  1,448,020,850       0    0   1,448,020,850    569,405,885    82,267              0             0      0              Lit the_other = ws_bin[k].blocker;
 95,085,882,681       0    0  90,577,345,857              0         0              0             0      0              if (value(the_other) == l_False){
        410,206       0    0         205,103              0         0        205,103             0      0                  confl = ws_bin[k].cref;
              .       .    .               .              .         .              .             .      .                  //auto end_time=std::chrono::steady_clock::now();
              .       .    .               .              .         .              .             .      .                  //auto duration=end_time-start_time;
              .       .    .               .              .         .              .             .      .  #ifdef LOOSE_PROP_STAT
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                  return confl;
              .       .    .               .              .         .              .             .      .  #else
              .       .    .               .              .         .              .             .      .                  goto ExitProp;
              .       .    .               .              .         .              .             .      .  #endif
  1,820,207,948       2    1               0              0         0              0             0      0              }else if(value(the_other) == l_Undef)
              .       .    .               .              .         .              .             .      .              {
  1,456,340,725       0    0     873,804,435              0         0    291,268,145             0      0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
              .       .    .               .              .         .              .             .      .  #ifdef  PRINT_OUT                
              .       .    .               .              .         .              .             .      .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
              .       .    .               .              .         .              .             .      .  #endif                
              .       .    .               .              .         .              .             .      .  			}
              .       .    .               .              .         .              .             .      .          }
  3,068,412,120       0    0   3,068,412,120  1,274,468,403    23,973              0             0      0          total_Watchers+=ws.size();
  1,534,206,060       0    0   1,534,206,060              0         0              0             0      0          total_indexs++;//number of rounds
              .       .    .               .              .         .              .             .      .          //int count=0;
  1,521,033,210       0    0               0              0         0              0             0      0          bool no_clause_access=true;
  1,521,033,210       0    0               0              0         0  1,521,033,210             0      0          bool no_implication_added=true;
  1,521,033,210       0    0               0              0         0  1,521,033,210             0      0          bool no_change_other_watch=true;
265,088,749,986       4    4 129,482,549,298              0         0  1,534,206,060             0      0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
              .       .    .               .              .         .              .             .      .              // Try to avoid inspecting the clause:
              .       .    .               .              .         .              .             .      .              //count++;
127,948,343,238       1    1 127,948,343,238 17,201,176,095 2,969,901              0             0      0              Lit blocker = i->blocker;
255,896,686,476       0    0 127,948,343,238      5,230,914       128              0             0      0              total_access_watches++;
255,896,686,476       0    0 127,948,343,238  1,039,225,761     3,822              0             0      0              if (value(blocker) == l_True){
              .       .    .               .              .         .              .             .      .                  
329,185,024,532       0    0  82,296,256,133              0         0 82,296,256,133    42,915,488      0                  *j++ = *i++; continue; }//no clause accessed
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Make sure the false literal is data[1]:
 45,684,287,254       0    0       5,302,096            437         0              0             0      0              no_clause_access=false;
136,956,261,315       2    2  91,304,174,210      5,187,665       129 45,652,087,105             0      0              total_clause_access_times++;
 91,304,174,210       0    0  45,652,087,105              0         0              0             0      0              CRef     cr        = i->cref;
              .       .    .               .              .         .              .             .      .              //std::cout<<"cr: "<<cr<<"\n";
              .       .    .               .              .         .              .             .      .              Clause&  c         = ca[cr];
              .       .    .               .              .         .              .             .      .              Lit      false_lit = ~p;
 45,652,087,105       0    0  45,652,087,105              0         0              0             0      0              total_clause_access_size+=2;
136,956,261,315       0    0  91,304,174,210 43,875,084,892 4,885,965              0             0      0              if (c[0] == false_lit)
 76,094,762,728       0    0  38,047,381,364  1,124,358,740   172,440 38,047,381,364             0      0                  c[0] = c[1], c[1] = false_lit;
              .       .    .               .              .         .              .             .      .              assert(c[1] == false_lit);
              .       .    .               .              .         .              .             .      .              i++;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // If 0th watch is true, then clause is already satisfied.
              .       .    .               .              .         .              .             .      .              Lit     first = c[0];
              .       .    .               .              .         .              .             .      .              Watcher w     = Watcher(cr, first);
112,985,517,214       0    0  10,840,671,502     86,517,298       144              0             0      0              if (first != blocker && value(first) == l_True){
 24,843,269,172       0    0               0              0         0 16,562,179,448    15,878,301      0                  *j++ = w; continue; }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Look for new watch:
209,264,148,327       1    1               0              0         0              0             0      0              for (int k = 2; k < c.size(); k++)
              .       .    .               .              .         .              .             .      .              {
377,411,363,413       0    0               0              0         0 80,838,843,808             0      0                  total_clause_access_size++;
257,752,216,507       0    0  21,332,534,129              0         0              0             0      0                  if (value(c[k]) != l_False){
143,992,503,812  17,316    4  71,996,251,906              0         0 71,996,251,906             0      0                      c[1] = c[k]; c[k] = false_lit;
 35,998,125,953       0    0  35,998,125,953              0         0              0             0      0                      total_change_other_watch++;
 35,998,125,953       0    0               0              0         0 35,998,125,953           473      0                      no_change_other_watch=false;
              .       .    .               .              .         .              .             .      .                      watches[~c[1]].push(w);
              .       .    .               .              .         .              .             .      .                      goto NextClause; }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Did not find watch -- clause is unit under assignment:
  4,124,303,953       0    0               0              0         0  2,745,742,856     1,952,886      0              *j++ = w;
  2,745,742,856       0    0               0              0         0              0             0      0              if (value(first) == l_False){
      5,689,669       0    0       5,689,669        101,636         0              0             0      0                  time_find_conflict++;
     34,138,014       1    1      22,758,676        108,204         0              0             0      0                  total_find_conflict_length+=i-(Watcher*)ws;
     11,379,338       0    0      11,379,338              0         0              0             0      0                  total_find_conflict_allsize+=ws.size();
              .       .    .               .              .         .              .             .      .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
      5,689,669       0    0               0              0         0      5,689,669             0      0                  confl = cr;
     11,379,338       0    0       5,689,669              0         0      5,689,669        33,595      0                  qhead = trail.size();
              .       .    .               .              .         .              .             .      .                  // Copy the remaining watches:
              .       .    .               .              .         .              .             .      .  
    743,419,771       9    8      10,991,765            440         0              0             0      0                  while (i < end)
    357,873,286       0    0     357,873,286     44,633,527    15,471    357,873,286       642,426      0                      *j++ = *i++;
              .       .    .               .              .         .              .             .      .              }else
              .       .    .               .              .         .              .             .      .              {//new implecate
  1,367,181,759       0    0               0              0         0  1,367,181,759             0      0                  no_implication_added=false;
  1,367,181,759       0    0   1,367,181,759     23,036,488       101              0             0      0                  total_push_new_implication++;
  4,101,545,277       0    0   2,734,363,518      8,413,547         0              0             0      0  				if (currLevel == decisionLevel())
              .       .    .               .              .         .              .             .      .  				{
  2,734,363,518       0    0               0              0         0              0             0      0  					uncheckedEnqueue(first, currLevel, cr);
              .       .    .               .              .         .              .             .      .  #ifdef PRINT_OUT					
              .       .    .               .              .         .              .             .      .  					std::cout << "i " << first << " l " << currLevel << "\n";
              .       .    .               .              .         .              .             .      .  #endif					
              .       .    .               .              .         .              .             .      .  				}
              .       .    .               .              .         .              .             .      .  				else
              .       .    .               .              .         .              .             .      .  				{
              .       .    .               .              .         .              .             .      .  					int nMaxLevel = currLevel;
         11,040       0    0               0              0         0              0             0      0  					int nMaxInd = 1;
              .       .    .               .              .         .              .             .      .  					// pass over all the literals in the clause and find the one with the biggest level
         37,486       0    0           5,520              0         0              0             0      0  					for (int nInd = 2; nInd < c.size(); ++nInd)
              .       .    .               .              .         .              .             .      .  					{
              .       .    .               .              .         .              .             .      .  						int nLevel = level(var(c[nInd]));
         16,862       0    0               0              0         0              0             0      0  						if (nLevel > nMaxLevel)
              .       .    .               .              .         .              .             .      .  						{
              .       .    .               .              .         .              .             .      .  							nMaxLevel = nLevel;
              .       .    .               .              .         .              .             .      .  							nMaxInd = nInd;
              .       .    .               .              .         .              .             .      .  						}
              .       .    .               .              .         .              .             .      .  					}
              .       .    .               .              .         .              .             .      .  
         11,040       2    1               0              0         0              0             0      0  					if (nMaxInd != 1)
              .       .    .               .              .         .              .             .      .  					{
              .       .    .               .              .         .              .             .      .  						std::swap(c[1], c[nMaxInd]);
              .       .    .               .              .         .              .             .      .  						*j--; // undo last watch
            678       0    0             678              0         0              0             0      0                          total_change_other_watch++;
            678       0    0               0              0         0            678             0      0                          no_change_other_watch=false;
              .       .    .               .              .         .              .             .      .  						watches[~c[1]].push(w);
              .       .    .               .              .         .              .             .      .  					}
              .       .    .               .              .         .              .             .      .  					
  6,835,914,315       0    0   1,367,181,759              0         0  1,367,181,759             0      0  					uncheckedEnqueue(first, nMaxLevel, cr);
              .       .    .               .              .         .              .             .      .  #ifdef PRINT_OUT					
              .       .    .               .              .         .              .             .      .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
              .       .    .               .              .         .              .             .      .  #endif	
              .       .    .               .              .         .              .             .      .  				}
              .       .    .               .              .         .              .             .      .  			}
              .       .    .               .              .         .              .             .      .  
      5,302,096     260  133               0              0         0              0             0      0  NextClause:;
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
  7,605,166,050       0    0   1,521,033,210              0         0              0             0      0          if(no_clause_access==true){
    208,434,762     135   21     208,434,762        914,097         1              0             0      0              total_no_clause_access++;
              .       .    .               .              .         .              .             .      .          }
  3,237,328,332      34   27   1,521,033,210              0         0              0             0      0          if(no_implication_added==true){
    773,630,028       1    1     760,457,178     19,060,076        14              0             0      0              total_no_implication_added++;
              .       .    .               .              .         .              .             .      .          }
  3,276,720,336       0    0   1,521,033,210              0         0              0             0      0          if(no_change_other_watch==true){
    408,597,405     794   84     408,597,405             70         0              0             0      0              total_no_change_other_watch++;
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          ws.shrink(i - j);
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  ExitProp:;
     25,517,164       2    1      25,517,164      5,646,169        10              0             0      0      propagations += num_props;
     12,758,582       0    0      12,758,582              0         0              0             0      0      simpDB_props -= num_props;
              .       .    .               .              .         .              .             .      .  
     12,758,582       0    0      12,758,582              0         0              0             0      0      return confl;
 16,142,172,732   6,356   22      90,745,795     10,894,854         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  /*_________________________________________________________________________________________________
              .       .    .               .              .         .              .             .      .  |
              .       .    .               .              .         .              .             .      .  |  reduceDB : ()  ->  [void]
              .       .    .               .              .         .              .             .      .  |  
              .       .    .               .              .         .              .             .      .  |  Description:
              .       .    .               .              .         .              .             .      .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
              .       .    .               .              .         .              .             .      .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
              .       .    .               .              .         .              .             .      .  |________________________________________________________________________________________________@*/
              .       .    .               .              .         .              .             .      .  struct reduceDB_lt { 
              .       .    .               .              .         .              .             .      .      ClauseAllocator& ca;
              .       .    .               .              .         .              .             .      .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    283,855,235     784  477     278,333,960     89,914,482   218,314              0             0      0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
              .       .    .               .              .         .              .             .      .  };
              .       .    .               .              .         .              .             .      .  void Solver::reduceDB()
          2,352     333  157               0              0         0          1,568             0      0  {
              .       .    .               .              .         .              .             .      .      int     i, j;
              .       .    .               .              .         .              .             .      .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .    .               .              .         .              .             .      .      //local_learnts_dirty = false;
              .       .    .               .              .         .              .             .      .  
            392       0    0               0              0         0              0             0      0      sort(learnts_local, reduceDB_lt(ca));
              .       .    .               .              .         .              .             .      .  
          1,960       0    0             392            392         0              0             0      0      int limit = learnts_local.size() / 2;
     22,754,964     392  209               0              0         0              0             0      0      for (i = j = 0; i < learnts_local.size(); i++){
     34,129,506     392  189      22,753,004        711,509         0              0             0      0          Clause& c = ca[learnts_local[i]];
     22,753,004       0    0      11,376,502     11,254,721    12,950              0             0      0          if (c.mark() == LOCAL)
     42,994,968       0    0      11,141,064              0         0              0             0      0              if (c.removable() && !locked(c) && i < limit)
     28,161,120       0    0       5,632,224              0         0      5,632,224             0      0                  removeClause(learnts_local[i]);
              .       .    .               .              .         .              .             .      .              else{
        782,258       0    0               0              0         0              0             0      0                  if (!c.removable()) limit++;
              .       .    .               .              .         .              .             .      .                  c.removable(true);
     28,015,076       0    0       5,508,840              0         0      5,508,840       344,967      0                  learnts_local[j++] = learnts_local[i]; }
              .       .    .               .              .         .              .             .      .      }
            392       0    0               0              0         0              0             0      0      learnts_local.shrink(i - j);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      checkGarbage();
          2,090       0    0           1,698            392         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  void Solver::reduceDB_Tier2()
          3,534     457  183               0              0         0          2,945             0      0  {
              .       .    .               .              .         .              .             .      .      int i, j;
     14,600,546     279  108             589            569         0              0             0      0      for (i = j = 0; i < learnts_tier2.size(); i++){
     18,325,365     437  187      12,216,910        382,057    34,238              0             0      0          Clause& c = ca[learnts_tier2[i]];
     12,216,910       0    0               0              0         0              0             0      0          if (c.mark() == TIER2)
     30,119,975     175   47      12,047,990      5,479,398   153,135              0             0      0              if (!locked(c) && c.touched() + 30000 < conflicts){
              .       .    .               .              .         .              .             .      .                  learnts_local.push(learnts_tier2[i]);
              .       .    .               .              .         .              .             .      .                  c.mark(LOCAL);
              .       .    .               .              .         .              .             .      .                  //c.removable(true);
              .       .    .               .              .         .              .             .      .                  c.activity() = 0;
              .       .    .               .              .         .              .             .      .                  claBumpActivity(c);
              .       .    .               .              .         .              .             .      .              }else
     24,592,020       0    0       4,918,404              0         0      4,918,404       209,853      0                  learnts_tier2[j++] = learnts_tier2[i];
              .       .    .               .              .         .              .             .      .      }
            589       0    0               0              0         0              0             0      0      learnts_tier2.shrink(i - j);
          3,534       0    0           3,534            589         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::removeSatisfied(vec<CRef>& cs)
            198       0    0               0              0         0             88             0      0  {
              .       .    .               .              .         .              .             .      .      int i, j;
      4,253,834      12    7         850,776              9         0              0             0      0      for (i = j = 0; i < cs.size(); i++){
      2,552,259       0    0       1,701,506         53,183    20,730              0             0      0          Clause& c = ca[cs[i]];
              .       .    .               .              .         .              .             .      .          if (satisfied(c))
         32,440       9    7               1              0         0         10,813           337      0              removeClause(cs[i]);
              .       .    .               .              .         .              .             .      .          else
      1,679,880       0    0               0              0         0        839,940        14,882      0              cs[j++] = cs[i];
              .       .    .               .              .         .              .             .      .      }
             22       0    0               0              0         0              0             0      0      cs.shrink(i - j);
            132       3    0             110              9         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
            144       0    0               0              0         0            120             0      0  {
              .       .    .               .              .         .              .             .      .      int i, j;
        487,815      11    7              24             12         0              0             0      0      for (i = j = 0; i < cs.size(); i++){
        657,888       0    0         438,592         13,721     3,234              0             0      0          Clause& c = ca[cs[i]];
        438,592       0    0               0              0         0              0             0      0          if (c.mark() == valid_mark)
              .       .    .               .              .         .              .             .      .              if (satisfied(c))
         81,688       1    1          20,422              0         0         20,422            20      0                  removeClause(cs[i]);
              .       .    .               .              .         .              .             .      .              else
        973,925       0    0         194,785              0         0        194,785         4,607      0                  cs[j++] = cs[i];
              .       .    .               .              .         .              .             .      .      }
             22       0    0               0              0         0              0             0      0      cs.shrink(i - j);
            144       8    3             144             15         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::rebuildOrderHeap()
            117       7    6               0              0         0             78             0      0  {
              .       .    .               .              .         .              .             .      .      vec<Var> vs;
         70,811       0    0              13              0         0             13             0      0      for (Var v = 0; v < nVars(); v++)
        200,382       0    0         100,191            917        28              0             0      0          if (decision[v] && value(v) == l_Undef)
              .       .    .               .              .         .              .             .      .              vs.push(v);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      order_heap_CHB  .build(vs);
              .       .    .               .              .         .              .             .      .      order_heap_VSIDS.build(vs);
              .       .    .               .              .         .              .             .      .      order_heap_distance.build(vs);
            104      13    7              91             13         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  /*_________________________________________________________________________________________________
              .       .    .               .              .         .              .             .      .  |
              .       .    .               .              .         .              .             .      .  |  simplify : [void]  ->  [bool]
              .       .    .               .              .         .              .             .      .  |  
              .       .    .               .              .         .              .             .      .  |  Description:
              .       .    .               .              .         .              .             .      .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
              .       .    .               .              .         .              .             .      .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
              .       .    .               .              .         .              .             .      .  |________________________________________________________________________________________________@*/
              .       .    .               .              .         .              .             .      .  bool Solver::simplify()
         61,296   1,892   54               0              0         0         40,864             0      0  {
              .       .    .               .              .         .              .             .      .      assert(decisionLevel() == 0);
              .       .    .               .              .         .              .             .      .  
         51,080       0    0          10,216         10,120         6              0             0      0      if (!ok || propagate() != CRef_Undef)
              .       .    .               .              .         .              .             .      .          return ok = false;
              .       .    .               .              .         .              .             .      .  
         30,672     543  170          20,444              0         0              0             0      0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
              .       .    .               .              .         .              .             .      .          return true;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Remove satisfied clauses:
             36       0    0               0              0         0             12             0      0      removeSatisfied(learnts_core); // Should clean core first.
             48       0    0               0              0         0             12             0      0      safeRemoveSatisfied(learnts_tier2, TIER2);
             48      12    7               0              0         0             12             0      0      safeRemoveSatisfied(learnts_local, LOCAL);
             24       0    0              12             12         0              0             0      0      if (remove_satisfied)        // Can be turned off.
             44      22   13               0              0         0             11             0      0          removeSatisfied(clauses);
              .       .    .               .              .         .              .             .      .      checkGarbage();
             24       1    1               0              0         0             12             0      0      rebuildOrderHeap();
              .       .    .               .              .         .              .             .      .  
             24       0    0              12             12         0             12            12      0      simpDB_assigns = nAssigns();
             36       0    0              24             24         1             12             0      0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
              .       .    .               .              .         .              .             .      .  
             12       0    0               0              0         0              0             0      0      return true;
         71,512       0    0          51,080             12         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  // pathCs[k] is the number of variables assigned at level k,
              .       .    .               .              .         .              .             .      .  // it is initialized to 0 at the begining and reset to 0 after the function execution
         80,336       5    1               0              0         0         60,252             0      0  bool Solver::collectFirstUIP(CRef confl){
         20,084       0    0               0              0         0         10,042             0      0      involved_lits.clear();
        715,482       4    1               0              0         0              0             0      0      int max_level=1;
              .       .    .               .              .         .              .             .      .      Clause& c=ca[confl]; int minLevel=decisionLevel();
        120,956       0    0          10,042              0         0              0             0      0      for(int i=0; i<c.size(); i++) {
              .       .    .               .              .         .              .             .      .          Var v=var(c[i]);
              .       .    .               .              .         .              .             .      .          //        assert(!seen[v]);
        106,062      43    1          35,354          6,701         0              0             0      0          if (level(v)>0) {
         70,618       0    0          35,309          8,662         0         35,309        21,565      0              seen[v]=1;
         80,660       0    0          45,351         17,539         0         35,309        30,911      0              var_iLevel_tmp[v]=1;
         35,309       0    0          35,309         17,707         0              0             0      0              pathCs[level(v)]++;
              .       .    .               .              .         .              .             .      .              if (minLevel>level(v)) {
              .       .    .               .              .         .              .             .      .                  minLevel=level(v);
              .       .    .               .              .         .              .             .      .                  assert(minLevel>0);
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              //    varBumpActivity(v);
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
         30,126       0    0          20,084          8,227         0              0             0      0      int limit=trail_lim[minLevel-1];
     26,746,492       0    0          10,042              0         0              0             0      0      for(int i=trail.size()-1; i>=limit; i--) {
     13,353,162     184    1      13,353,162        380,502         0              0             0      0          Lit p=trail[i]; Var v=var(p);
     13,353,162       0    0       6,676,581        349,072         0              0             0      0          if (seen[v]) {
              .       .    .               .              .         .              .             .      .              int currentDecLevel=level(v);
              .       .    .               .              .         .              .             .      .              //      if (currentDecLevel==decisionLevel())
              .       .    .               .              .         .              .             .      .              //      	varBumpActivity(v);
        495,426       0    0               0              0         0        495,426             0      0              seen[v]=0;
        990,852       0    0         495,426            961         0              0             0      0              if (--pathCs[currentDecLevel]!=0) {
              .       .    .               .              .         .              .             .      .                  Clause& rc=ca[reason(v)];
      1,360,670       5    1         982,845          1,125         0              0             0      0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
        655,230       0    0               0              0         0              0             0      0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
        809,178       0    0               0              0         0              0             0      0                  if (rc.size()==2 && value(rc[0])==l_False) {
              .       .    .               .              .         .              .             .      .                      // Special case for binary clauses
              .       .    .               .              .         .              .             .      .                      // The first one has to be SAT
              .       .    .               .              .         .              .             .      .                      assert(value(rc[1]) != l_False);
              .       .    .               .              .         .              .             .      .                      Lit tmp = rc[0];
         27,414       0    0           9,138            473         0         18,276             0      0                      rc[0] =  rc[1], rc[1] = tmp;
              .       .    .               .              .         .              .             .      .                  }
      1,971,830       0    0               0              0         0              0             0      0                  for (int j = 1; j < rc.size(); j++){
              .       .    .               .              .         .              .             .      .                      Lit q = rc[j]; Var v1=var(q);
      1,470,548       0    0               0              0         0              0             0      0                      if (level(v1) > 0) {
      1,465,290       0    0               0              0         0              0             0      0                          if (minLevel>level(v1)) {
         99,412       0    0          49,706         21,159         0              0             0      0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
              .       .    .               .              .         .              .             .      .                          }
      2,197,935       0    0       1,465,290         33,882         0              0             0      0                          if (seen[v1]) {
        545,056       0    0         272,528          1,254         0              0             0      0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
        353,046       0    0               0              0         0        176,523             0      0                                  var_iLevel_tmp[v1]=reasonVarLevel;
              .       .    .               .              .         .              .             .      .                          }
              .       .    .               .              .         .              .             .      .                          else {
        460,117       0    0               0              0         0        460,117       267,271      0                              var_iLevel_tmp[v1]=reasonVarLevel;
              .       .    .               .              .         .              .             .      .                              //   varBumpActivity(v1);
        460,117       0    0               0              0         0        460,117             0      0                              seen[v1] = 1;
      1,380,351       4    1         920,234         65,915         0              0             0      0                              pathCs[level(v1)]++;
              .       .    .               .              .         .              .             .      .                          }
              .       .    .               .              .         .              .             .      .                      }
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              involved_lits.push(p);
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
         30,126     948    1          10,042              0         0         10,042             0      0      double inc=var_iLevel_inc;
              .       .    .               .              .         .              .             .      .      vec<int> level_incs; level_incs.clear();
        653,506       0    0         249,352              0         0              0             0      0      for(int i=0;i<max_level;i++){
        269,436       4    1         134,718              0         0              0             0      0          level_incs.push(inc);
        404,154       0    0         269,436              0         0        134,718             0      0          inc = inc/my_var_decay;
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
      1,031,020       0    0         505,468              0         0              0             0      0      for(int i=0;i<involved_lits.size();i++){
         10,042       0    0          10,042              0         0              0             0      0          Var v =var(involved_lits[i]);
              .       .    .               .              .         .              .             .      .          //        double old_act=activity_distance[v];
              .       .    .               .              .         .              .             .      .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
      4,619,506   5,313    2       1,526,446        363,379         0        505,468             0      0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
              .       .    .               .              .         .              .             .      .  
        990,852       0    0               0              0         0              0             0      0          if(activity_distance[v]>1e100){
              .       .    .               .              .         .              .             .      .              for(int vv=0;vv<nVars();vv++)
         50,210     913    1          20,084         18,144         0         20,084             0      0                  activity_distance[vv] *= 1e-100;
              .       .    .               .              .         .              .             .      .              var_iLevel_inc*=1e-100;
         23,901      23    1               0              0         0              0             0      0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .          if (order_heap_distance.inHeap(v))
              .       .    .               .              .         .              .             .      .              order_heap_distance.decrease(v);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          //        var_iLevel_inc *= (1 / my_var_decay);
              .       .    .               .              .         .              .             .      .      }
         50,210      94    1          20,084              0         0         10,042           566      0      var_iLevel_inc=level_incs[level_incs.size()-1];
              .       .    .               .              .         .              .             .      .      return true;
         90,378       0    0          70,294          2,459         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  struct UIPOrderByILevel_Lt {
              .       .    .               .              .         .              .             .      .      Solver& solver;
              .       .    .               .              .         .              .             .      .      const vec<double>&  var_iLevel;
              .       .    .               .              .         .              .             .      .      bool operator () (Lit x, Lit y) const
              .       .    .               .              .         .              .             .      .      {
              .       .    .               .              .         .              .             .      .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
              .       .    .               .              .         .              .             .      .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
              .       .    .               .              .         .              .             .      .  |    Search for a model the specified number of conflicts. 
              .       .    .               .              .         .              .             .      .  |  
              .       .    .               .              .         .              .             .      .  |  Output:
              .       .    .               .              .         .              .             .      .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
              .       .    .               .              .         .              .             .      .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
              .       .    .               .              .         .              .             .      .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
              .       .    .               .              .         .              .             .      .  |________________________________________________________________________________________________@*/
              .       .    .               .              .         .              .             .      .  lbool Solver::search(int& nof_conflicts)
        112,299   8,490  137               0              0         0         71,463             0      0  {
              .       .    .               .              .         .              .             .      .      assert(ok);
              .       .    .               .              .         .              .             .      .      int         backtrack_level;
              .       .    .               .              .         .              .             .      .      int         lbd;
              .       .    .               .              .         .              .             .      .      vec<Lit>    learnt_clause;
              .       .    .               .              .         .              .             .      .      bool        cached = false;
         10,209       0    0          10,209            128         0              0             0      0      starts++;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // simplify
              .       .    .               .              .         .              .             .      .      //
         40,836       8    8          30,627         10,209       126              0             0      0      if (conflicts >= curSimplify * nbconfbeforesimplify){
              .       .    .               .              .         .              .             .      .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
              .       .    .               .              .         .              .             .      .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
              .       .    .               .              .         .              .             .      .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
              .       .    .               .              .         .              .             .      .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
             75      43   35              75             75        51              0             0      0          nbSimplifyAll++;
            225      75   52               0              0         0             75             0      0          if (!simplifyAll()){
              .       .    .               .              .         .              .             .      .              return l_False;
              .       .    .               .              .         .              .             .      .          }
            525       0    0             150            150         2             75             0      0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
            225       0    0              75              0         0             75             0      0          nbconfbeforesimplify += incSimplify;
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      for (;;){
              .       .    .               .              .         .              .             .      .          CRef confl = propagate();
              .       .    .               .              .         .              .             .      .  
     25,906,776       0    0               0              0         0              0             0      0          if (confl != CRef_Undef){
              .       .    .               .              .         .              .             .      .              // CONFLICT
     17,684,316       0    0       5,894,772        139,143         0              0             0      0              if (VSIDS){
      5,632,022       0    0       2,815,996      2,778,195         4             30             0      0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
              .       .    .               .              .         .              .             .      .              }else
     10,256,472      13    1       6,497,647      3,048,492         2        340,001             0      0                  if (step_size > min_step_size) step_size -= step_size_dec;
              .       .    .               .              .         .              .             .      .  
     23,579,088     183  118      11,789,544      5,920,270        75      5,894,772             0      0              conflicts++; nof_conflicts--;
              .       .    .               .              .         .              .             .      .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
              .       .    .               .              .         .              .             .      .              ConflictData data = FindConflictLevel(confl);
     11,789,544      33    1               0              0         0              0             0      0              if (data.nHighestLevel == 0) return l_False;
            220       0    0             104              0         0              0             0      0              if (data.bOnlyOneLitFromHighest)
              .       .    .               .              .         .              .             .      .              {
              6       1    0               0              0         0              0             0      0  				cancelUntil(data.nHighestLevel - 1);
              .       .    .               .              .         .              .             .      .  				continue;
              .       .    .               .              .         .              .             .      .  			}
              .       .    .               .              .         .              .             .      .  			
              .       .    .               .              .         .              .             .      .              learnt_clause.clear();
     11,789,532       0    0               0              0         0      5,894,766     5,756,042     27              if(conflicts>50000) DISTANCE=0;
              .       .    .               .              .         .              .             .      .              else DISTANCE=1;
     17,421,418       0    0               0              0         0              0             0      0              if(VSIDS && DISTANCE)
         40,168       4    1               0              0         0         10,042             0      0                  collectFirstUIP(confl);
              .       .    .               .              .         .              .             .      .  
     35,368,596     241  144               0              0         0      5,894,766             0      0              analyze(confl, learnt_clause, backtrack_level, lbd);
              .       .    .               .              .         .              .             .      .              // check chrono backtrack condition
     82,498,731      89   55      29,469,831      2,780,738         0              0             0      0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
              .       .    .               .              .         .              .             .      .              {
            109       0    0             109              0         0              0             0      0  				++chrono_backtrack;
            109       0    0               0              0         0              0             0      0  				cancelUntil(data.nHighestLevel -1);
              .       .    .               .              .         .              .             .      .  			}
              .       .    .               .              .         .              .             .      .  			else // default behavior
              .       .    .               .              .         .              .             .      .  			{
      5,894,657   1,123  130       5,894,657        603,934         0              0             0      0  				++non_chrono_backtrack;
              .       .    .               .              .         .              .             .      .  				cancelUntil(backtrack_level);
              .       .    .               .              .         .              .             .      .  			}
              .       .    .               .              .         .              .             .      .  
     17,684,298       0    0       5,894,766      2,806,578         0      5,894,766             0      0              lbd--;
     11,789,532       0    0       5,894,766              0         0              0             0      0              if (VSIDS){
      2,815,943      45   37               0              0         0      2,815,943             0      0                  cached = false;
      8,447,829     293   72       8,447,829      3,021,355        10              0             0      0                  conflicts_VSIDS++;
              .       .    .               .              .         .              .             .      .                  lbd_queue.push(lbd);
     22,527,544       0    0       8,447,829              0         0      2,815,943             0      0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
              .       .    .               .              .         .              .             .      .  
     17,684,298      78   51       5,894,766              0         0              0             0      0              if (learnt_clause.size() == 1){
             42       0    0              12              5         0              6             0      0                  uncheckedEnqueue(learnt_clause[0]);
              .       .    .               .              .         .              .             .      .              }else{
              .       .    .               .              .         .              .             .      .                  CRef cr = ca.alloc(learnt_clause, true);
      5,894,760       0    0       5,894,760              0         0              0             0      0                  ca[cr].set_lbd(lbd);
              .       .    .               .              .         .              .             .      .                  //duplicate learnts 
              .       .    .               .              .         .              .             .      .                  int  id = 0;
     11,789,520       0    0       5,894,760      5,886,427       121              0             0      0                  if (lbd <= max_lbd_dup){                        
              .       .    .               .              .         .              .             .      .                      std::vector<uint32_t> tmp;
    673,681,785       0    0     476,307,771              0         0      4,420,317             0      0                      for (int i = 0; i < learnt_clause.size(); i++)
    485,148,405      11    4     323,432,270              8         0    161,716,135             0      0                          tmp.push_back(learnt_clause[i].x);
     13,260,951       5    2       4,420,317              0         0      4,420,317             0      0                      id = is_duplicate(tmp);             
     22,101,585       0    0       4,420,317              0         0              0             0      0                      if (id == min_number_of_learnts_copies +1){
            376       0    0             376             98         0              0             0      0                          duplicates_added_conflicts++;                        
              .       .    .               .              .         .              .             .      .                      }                    
      8,840,634       0    0               0              0         0              0             0      0                      if (id == min_number_of_learnts_copies){
          3,065       0    0           3,065            835         0              0             0      0                          duplicates_added_tier2++;
              .       .    .               .              .         .              .             .      .                      }                                        
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .                  //duplicate learnts
              .       .    .               .              .         .              .             .      .  
     35,102,872       0    0      11,723,098      3,067,875        54              0             0      0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
             17       4    3               0              0         0              0             0      0                      learnts_core.push(cr);
              .       .    .               .              .         .              .             .      .                      ca[cr].mark(CORE);
     21,259,182   1,816   72               0              0         0              0             0      0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
             22       2    1               0              0         0              0             0      0                      learnts_tier2.push(cr);
              .       .    .               .              .         .              .             .      .                      ca[cr].mark(TIER2);
      4,107,792       0    0       1,026,948            676         9      1,026,948           414      0                      ca[cr].touched() = conflicts;
              .       .    .               .              .         .              .             .      .                  }else{
             23      21    1               0              0         0              0             0      0                      learnts_local.push(cr);
              .       .    .               .              .         .              .             .      .                      claBumpActivity(ca[cr]); }
     17,684,280   9,178  143               0              0         0      5,894,760             0      0                  attachClause(cr);
              .       .    .               .              .         .              .             .      .  
     35,368,560       0    0      17,684,280          2,813         0      5,894,760             0      0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
              .       .    .               .              .         .              .             .      .  #ifdef PRINT_OUT
              .       .    .               .              .         .              .             .      .                  std::cout << "new " << ca[cr] << "\n";
              .       .    .               .              .         .              .             .      .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
              .       .    .               .              .         .              .             .      .  #endif                
              .       .    .               .              .         .              .             .      .              }
     17,684,298       0    0       5,894,766      1,996,917        43              0             0      0              if (drup_file){
              .       .    .               .              .         .              .             .      .  #ifdef BIN_DRUP
              .       .    .               .              .         .              .             .      .                  binDRUP('a', learnt_clause, drup_file);
              .       .    .               .              .         .              .             .      .  #else
              .       .    .               .              .         .              .             .      .                  for (int i = 0; i < learnt_clause.size(); i++)
              .       .    .               .              .         .              .             .      .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
              .       .    .               .              .         .              .             .      .                  fprintf(drup_file, "0\n");
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
     17,684,298   1,102  132      11,789,532      2,810,753        84              0             0      0              if (VSIDS) varDecayActivity();
              .       .    .               .              .         .              .             .      .              claDecayActivity();
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              /*if (--learntsize_adjust_cnt == 0){
              .       .    .               .              .         .              .             .      .                  learntsize_adjust_confl *= learntsize_adjust_inc;
              .       .    .               .              .         .              .             .      .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
              .       .    .               .              .         .              .             .      .                  max_learnts             *= learntsize_inc;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
              .       .    .               .              .         .              .             .      .                             (int)conflicts,
              .       .    .               .              .         .              .             .      .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
              .       .    .               .              .         .              .             .      .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
              .       .    .               .              .         .              .             .      .              }*/
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .          }else{
              .       .    .               .              .         .              .             .      .              // NO CONFLICT
              .       .    .               .              .         .              .             .      .              bool restart = false;
     21,175,848      76   34       7,058,616        707,780         0              0             0      0              if (!VSIDS)
              .       .    .               .              .         .              .             .      .                  restart = nof_conflicts <= 0;
      7,037,790       1    1       3,518,895              0         0              0             0      0              else if (!cached){
     23,830,552       4    0       6,729,980      2,594,434         9      1,420,504             0      0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
              .       .    .               .              .         .              .             .      .                  cached = true;
              .       .    .               .              .         .              .             .      .              }
     10,619,163       0    0       3,539,721      2,901,183        33              0             0      0              if (restart /*|| !withinBudget()*/){
              .       .    .               .              .         .              .             .      .                  lbd_queue.clear();
              .       .    .               .              .         .              .             .      .                  cached = false;
              .       .    .               .              .         .              .             .      .                  // Reached bound on number of conflicts:
         30,624       0    0               0              0         0         20,416         9,672     79                  progress_estimate = progressEstimate();
              .       .    .               .              .         .              .             .      .                  cancelUntil(0);
         20,416       0    0               0              0         0              0             0      0                  return l_Undef; }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Simplify the set of problem clauses:
     22,477,590     414   86       7,048,408              0         0      1,301,718             0      0              if (decisionLevel() == 0 && !simplify())
              .       .    .               .              .         .              .             .      .                  return l_False;
              .       .    .               .              .         .              .             .      .  
     21,145,224     207   30      14,096,816      4,209,916        45              0             0      0              if (conflicts >= next_T2_reduce){
          1,178       0    0               0              0         0            589             0      0                  next_T2_reduce = conflicts + 10000;
          2,356       0    0             589              0         0            589             0      0                  reduceDB_Tier2(); }
     14,096,816      77   36       7,048,408          9,694         0              0             0      0              if (conflicts >= next_L_reduce){
            784       0    0               0              0         0            392             0      0                  next_L_reduce = conflicts + 15000;
            784       0    0               0              0         0            392             0      0                  reduceDB(); }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              Lit next = lit_Undef;
              .       .    .               .              .         .              .             .      .              /*while (decisionLevel() < assumptions.size()){
              .       .    .               .              .         .              .             .      .                  // Perform user provided assumption:
              .       .    .               .              .         .              .             .      .                  Lit p = assumptions[decisionLevel()];
              .       .    .               .              .         .              .             .      .                  if (value(p) == l_True){
              .       .    .               .              .         .              .             .      .                      // Dummy decision level:
              .       .    .               .              .         .              .             .      .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
              .       .    .               .              .         .              .             .      .                  }else{
              .       .    .               .              .         .              .             .      .                      next = p;
              .       .    .               .              .         .              .             .      .                      break;
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              if (next == lit_Undef)*/{
              .       .    .               .              .         .              .             .      .                  // New variable decision:
      7,048,408       0    0       7,048,408            392        85              0             0      0                  decisions++;
     21,145,224   1,009  128               0              0         0      7,048,408             0      0                  next = pickBranchLit();
              .       .    .               .              .         .              .             .      .  
     14,096,816       0    0               0              0         0              0             0      0                  if (next == lit_Undef)
              .       .    .               .              .         .              .             .      .                      // Model found:
              2       0    0               0              0         0              0             0      0                      return l_True;
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .              // Increase decision level and enqueue 'next'
              .       .    .               .              .         .              .             .      .              newDecisionLevel();
     42,290,442      79   56       7,048,407              0         0      7,048,407             0      0              uncheckedEnqueue(next, decisionLevel());
              .       .    .               .              .         .              .             .      .  #ifdef PRINT_OUT            
              .       .    .               .              .         .              .             .      .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
              .       .    .               .              .         .              .             .      .  #endif            
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
         91,881     217   87          71,463         10,209       118              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  double Solver::progressEstimate() const
         61,248      10    8               0              0         0         51,040             0      0  {
         20,416       0    0               0              0         0              0             0      0      double  progress = 0;
         51,040       0    0          20,416          7,129         0         10,208             0      0      double  F = 1.0 / nVars();
              .       .    .               .              .         .              .             .      .  
        780,046       6    5               0              0         0              0             0      0      for (int i = 0; i <= decisionLevel(); i++){
        718,798       0    0         465,588              0         0              0             0      0          int beg = i == 0 ? 0 : trail_lim[i - 1];
        961,800       0    0         475,796         18,336         7              0             0      0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
      1,488,636      38   18         253,210              0         0              0             0      0          progress += pow(F, i) * (end - beg);
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
         20,416       0    0               0              0         0              0             0      0      return progress / nVars();
         71,456       0    0          61,248              0         0              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  /*
              .       .    .               .              .         .              .             .      .    Finite subsequences of the Luby-sequence:
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .    0: 1
              .       .    .               .              .         .              .             .      .    1: 1 1 2
              .       .    .               .              .         .              .             .      .    2: 1 1 2 1 1 2 4
              .       .    .               .              .         .              .             .      .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .   */
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  static double luby(double y, int x){
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Find the finite subsequence that contains index 'x', and the
              .       .    .               .              .         .              .             .      .      // size of that subsequence:
              .       .    .               .              .         .              .             .      .      int size, seq;
        309,328       0    0               0              0         0              0             0      0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
              .       .    .               .              .         .              .             .      .  
        174,898       8    8               0              0         0              0             0      0      while (size-1 != x){
        102,248       0    0               0              0         0              0             0      0          size = (size-1)>>1;
         51,124       0    0               0              0         0              0             0      0          seq--;
        153,372       0    0               0              0         0              0             0      0          x = x % size;
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      return pow(y, seq);
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  static bool switch_mode = false;
              .       .    .               .              .         .              .             .      .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
              .       .    .               .              .         .              .             .      .  
             56       7    7               0              0         0             42             0      0  uint32_t Solver::reduceduplicates(){
              .       .    .               .              .         .              .             .      .      uint32_t removed_duplicates = 0;
              .       .    .               .              .         .              .             .      .      std::vector<std::vector<uint64_t>> tmp;
              .       .    .               .              .         .              .             .      .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
         23,771       0    0              14              0         0              0             0      0      for (auto & outer_mp: ht){//variables
        404,741       0    0               0              0         0              0             0      0          for (auto &inner_mp:outer_mp.second){//sizes
      9,667,478       0    0               0              0         0              0             0      0              for (auto &in_in_mp: inner_mp.second){
     13,947,480       7    7       4,649,160      4,385,145 2,006,311              0             0      0                  if (in_in_mp.second >= 2){
              .       .    .               .              .         .              .             .      .                  //min_number_of_learnts_copies
      4,427,670       7    7       1,771,068          2,691     1,674      1,771,068           133      0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
              .       .    .               .              .         .              .             .      .                  }
              .       .    .               .              .         .              .             .      .              }                    
              .       .    .               .              .         .              .             .      .           }
              .       .    .               .              .         .              .             .      .      }          
             21       0    0               7              7         4              7             0      0      removed_duplicates = dupl_db_size-tmp.size();  
              .       .    .               .              .         .              .             .      .      ht.clear();
      3,099,404       7    7       1,328,308             79        10              0             0      0      for (auto i=0;i<tmp.size();i++){
      4,427,670       0    0       2,213,835        498,266   417,192      1,328,301            35      7          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .      return removed_duplicates;
             63       0    0              56             14         6              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  // NOTE: assumptions passed in member-variable 'assumptions'.
              .       .    .               .              .         .              .             .      .  lbool Solver::solve_()
              8       0    0               0              0         0              6             0      0  {
              .       .    .               .              .         .              .             .      .      //signal(SIGALRM, SIGALRM_switch);
              .       .    .               .              .         .              .             .      .      //alarm(2500);
              .       .    .               .              .         .              .             .      .  
              1       1    1               0              0         0              0             0      0      model.clear();
              .       .    .               .              .         .              .             .      .      conflict.clear();
              2       1    1               1              0         0              0             0      0      if (!ok) return l_False;
              .       .    .               .              .         .              .             .      .  
              1       1    1               1              0         0              0             0      0      solves++;
              .       .    .               .              .         .              .             .      .  
              5       0    0               2              1         0              1             0      0      max_learnts               = nClauses() * learntsize_factor;
              3       0    0               1              1         0              0             0      0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
              1       0    0               0              0         0              1             1      0      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
              .       .    .               .              .         .              .             .      .      lbool   status            = l_Undef;
              .       .    .               .              .         .              .             .      .  
              3       0    0               1              0         0              0             0      0      if (verbosity >= 1){
              2       0    0               0              0         0              1             0      0          printf("c ============================[ Search Statistics ]==============================\n");
              2       1    1               0              0         0              1             0      0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
              2       0    0               0              0         0              1             0      0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
              2       0    0               0              0         0              1             0      0          printf("c ===============================================================================\n");
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      add_tmp.clear();
              .       .    .               .              .         .              .             .      .  
              1       0    0               0              0         0              1             0      0      VSIDS = true;
              1       1    1               0              0         0              1             0      0      int init = 10000;
            645       0    0             129            129         0              0             0      0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
            516       3    0               0              0         0            129             0      0          status = search(init);
              1       0    0               0              0         0              1             0      0      VSIDS = false;
              .       .    .               .              .         .              .             .      .  
              3       1    1               0              0         0              2             2      0      duplicates_added_conflicts = 0;
              .       .    .               .              .         .              .             .      .      duplicates_added_minimization=0;
              .       .    .               .              .         .              .             .      .      duplicates_added_tier2 =0;    
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      dupl_db_size=0;
              1       0    0               1              1         0              0             0      0      size_t dupl_db_size_limit = dupl_db_init_size;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // Search:
              1       0    0               0              0         0              0             0      0      int curr_restarts = 0;
              1       0    0               0              0         0              0             0      0      uint64_t curr_props = 0;
              .       .    .               .              .         .              .             .      .      uint32_t removed_duplicates =0;
         20,160   2,740  143               0              0         0              0             0      0      while (status == l_Undef /*&& withinBudget()*/){
         20,160       1    1          10,080          4,676         0              0             0      0          if (dupl_db_size >= dupl_db_size_limit){    
             28       7    7               7              7         0              7             0      0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             28       0    0               7              0         0              7             0      0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             28       0    0               7              0         0              7             0      0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             28       7    7               7              7         0              7             0      0              printf("c Duptime: %i\n",duptime.count());
             28       0    0               7              3         0              7             0      0              printf("c Number of conflicts: %i\n",conflicts);
             28       0    0               7              7         0              7             0      0              printf("c Core size: %i\n",learnts_core.size());
              .       .    .               .              .         .              .             .      .              
             14       0    0               0              0         0              7             0      0              removed_duplicates = reduceduplicates();
             56       7    7              14             14        11              0             0      0              dupl_db_size_limit*=1.1;
             14       0    0               7              7         6              0             0      0              dupl_db_size -= removed_duplicates;
             35       0    0               0              0         0              7             0      0              printf("c removed duplicates %i\n",removed_duplicates);
              .       .    .               .              .         .              .             .      .          }   
         60,480     330  149          20,160         13,108        12              0             0      0          if (propagations - curr_props >  VSIDS_props_limit){
             18       0    0               0              0         0              0             0      0              curr_props = propagations;
             18       0    0               0              0         0             18             0      0              switch_mode = true;
             91       0    0               0              0         0             18             0      0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
              .       .    .               .              .         .              .             .      .          }     
         20,160       0    0          10,080              7         6              0             0      0          if (VSIDS){
          4,692       0    0               0              0         0          4,692         4,692      4              int weighted = INT32_MAX;
         18,768   4,692   66               0              0         0          4,692             0      0              status = search(weighted);
              .       .    .               .              .         .              .             .      .          }else{
         32,328   3,810   81          10,776              0         0          5,388         5,374      2              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          5,388       0    0               0              0         0              0             0      0              curr_restarts++;
         26,940   5,382   70               0              0         0          5,388             0      0              status = search(nof_conflicts);
              .       .    .               .              .         .              .             .      .          }
         20,160   5,382   76          10,080         10,080       186              0             0      0          if (switch_mode){ 
             18       0    0               0              0         0             18             0      0              switch_mode = false;
              .       .    .               .              .         .              .             .      .              VSIDS = !VSIDS;
             36       0    0              18              0         0              0             0      0              if (VSIDS){
             18       9    9               0              0         0              9             0      0                  printf("c Switched to VSIDS.\n");
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              else{
             27       9    9               0              0         0              9             0      0                 printf("c Switched to LRB.\n");
              .       .    .               .              .         .              .             .      .              }
              .       .    .               .              .         .              .             .      .              //            reduceduplicates();            
             36       9    9              18             18        16             18             0      0              fflush(stdout);
              .       .    .               .              .         .              .             .      .              picked.clear();
              .       .    .               .              .         .              .             .      .              conflicted.clear();
              .       .    .               .              .         .              .             .      .              almost_conflicted.clear();
              .       .    .               .              .         .              .             .      .  #ifdef ANTI_EXPLORATION
              .       .    .               .              .         .              .             .      .              canceled.clear();
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              3       1    1               1              1         0              0             0      0      if (verbosity >= 1)
              2       0    0               0              0         0              1             0      0          printf("c ===============================================================================\n");
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  #ifdef BIN_DRUP
              3       0    0               1              0         0              0             0      0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
              .       .    .               .              .         .              .             .      .  #endif
              .       .    .               .              .         .              .             .      .  
              2       1    1               0              0         0              0             0      0      if (status == l_True){
              .       .    .               .              .         .              .             .      .          // Extend & copy model:
              .       .    .               .              .         .              .             .      .          model.growTo(nVars());
            347       0    0             171             15         0            171             0      0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
              .       .    .               .              .         .              .             .      .      }else if (status == l_False && conflict.size() == 0)
              .       .    .               .              .         .              .             .      .          ok = false;
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      cancelUntil(0);
              1       0    0               0              0         0              0             0      0      return status;
              8       1    1               7              2         1              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  //=================================================================================================
              .       .    .               .              .         .              .             .      .  // Writing CNF to DIMACS:
              .       .    .               .              .         .              .             .      .  // 
              .       .    .               .              .         .              .             .      .  // FIXME: this needs to be rewritten completely.
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  static Var mapVar(Var x, vec<Var>& map, Var& max)
              .       .    .               .              .         .              .             .      .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
              .       .    .               .              .         .              .             .      .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
              .       .    .               .              .         .              .             .      .  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  //=================================================================================================
              .       .    .               .              .         .              .             .      .  // Garbage Collection methods:
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::relocAll(ClauseAllocator& to)
          2,650     164  125               0              0         0          2,120             0      0  {
              .       .    .               .              .         .              .             .      .      // All watchers:
              .       .    .               .              .         .              .             .      .      //
              .       .    .               .              .         .              .             .      .      // for (int i = 0; i < watches.size(); i++)
            530       0    0               0              0         0            265             1      0      watches.cleanAll();
            530       0    0               0              0         0            265             0      0      watches_bin.cleanAll();
      7,212,240      15    9       5,047,720         74,277         0        721,595           264      0      for (int v = 0; v < nVars(); v++)
      2,884,260       0    0       1,442,130              0         0              0             0      0          for (int s = 0; s < 2; s++){
              .       .    .               .              .         .              .             .      .              Lit p = mkLit(v, s);
              .       .    .               .              .         .              .             .      .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
              .       .    .               .              .         .              .             .      .              vec<Watcher>& ws = watches[p];
    251,428,275      82   61     138,879,046        360,661    69,734              0             0      0              for (int j = 0; j < ws.size(); j++)
              .       .    .               .              .         .              .             .      .                  ca.reloc(ws[j].cref, to);
              .       .    .               .              .         .              .             .      .              vec<Watcher>& ws_bin = watches_bin[p];
     14,522,626       6    5       5,925,966        416,240    64,765              0             0      0              for (int j = 0; j < ws_bin.size(); j++)
              .       .    .               .              .         .              .             .      .                  ca.reloc(ws_bin[j].cref, to);
              .       .    .               .              .         .              .             .      .          }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // All reasons:
              .       .    .               .              .         .              .             .      .      //
        296,612       0    0             795            265        81              0             0      0      for (int i = 0; i < trail.size(); i++){
              .       .    .               .              .         .              .             .      .          Var v = var(trail[i]);
              .       .    .               .              .         .              .             .      .  
        574,190       0    0         139,585        127,512        47              0             0      0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
        698,455       0    0         139,585              0         0        139,585             0      0              ca.reloc(vardata[v].reason, to);
              .       .    .               .              .         .              .             .      .      }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // All learnt:
              .       .    .               .              .         .              .             .      .      //
     52,297,623     257  187      26,148,678            467       118              0             0      0      for (int i = 0; i < learnts_core.size(); i++)
              .       .    .               .              .         .              .             .      .          ca.reloc(learnts_core[i], to);
      4,963,296     793  565       2,481,647            527        18              0             0      0      for (int i = 0; i < learnts_tier2.size(); i++)
              .       .    .               .              .         .              .             .      .          ca.reloc(learnts_tier2[i], to);
      7,429,450     265  180       3,714,196            266        70              0             0      0      for (int i = 0; i < learnts_local.size(); i++)
     11,140,998       0    0               0              0         0      3,713,666           262      0          ca.reloc(learnts_local[i], to);
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      // All original:
              .       .    .               .              .         .              .             .      .      //
              .       .    .               .              .         .              .             .      .      int i, j;
      4,896,825     265  189           1,060            525         0              0             0      0      for (i = j = 0; i < clauses.size(); i++)
      4,894,440       0    0               0              0         0              0             0      0          if (ca[clauses[i]].mark() != 1){
      7,342,190     265  181       2,447,220              1         0      2,447,220             1      0              ca.reloc(clauses[i], to);
     24,471,935     255  176       9,788,615              0         0      2,447,220             0      0              clauses[j++] = clauses[i]; }
            265     264  197               0              0         0              0             0      0      clauses.shrink(i - j);
          2,120     264  191           1,855            265        59              0             0      0  }
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .  void Solver::garbageCollect()
              .       .    .               .              .         .              .             .      .  {
              .       .    .               .              .         .              .             .      .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
              .       .    .               .              .         .              .             .      .      // is not precise but should avoid some unnecessary reallocations for the new region:
              .       .    .               .              .         .              .             .      .      ClauseAllocator to(ca.size() - ca.wasted());
              .       .    .               .              .         .              .             .      .  
              .       .    .               .              .         .              .             .      .      relocAll(to);
              .       .    .               .              .         .              .             .      .      if (verbosity >= 2)
              .       .    .               .              .         .              .             .      .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
              .       .    .               .              .         .              .             .      .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
              .       .    .               .              .         .              .             .      .      to.moveTo(ca);
            155      18   18              47              4         4             61             0      0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir              I1mr      ILmr  Dr              D1mr           DLmr   Dw              D1mw           DLmw       

-- line 40 ----------------------------------------
              .         .     .               .              .      .               .              .          .      int sz;
              .         .     .               .              .      .               .              .          .      int cap;
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .      // Don't allow copying (error prone):
              .         .     .               .              .      .               .              .          .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              .         .     .               .              .      .               .              .          .               vec        (vec<T>& other) { assert(0); }
              .         .     .               .              .      .               .              .          .               
              .         .     .               .              .      .               .              .          .      // Helpers for calculating next capacity:
      6,626,152        16    13               0              0      0               0              0          0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
              .         .     .               .              .      .               .              .          .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .         .     .               .              .      .               .              .          .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  public:
              .         .     .               .              .      .               .              .          .      // Constructors:
      1,401,236        32    29               2              0      0       1,387,627          4,022      3,349      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
             46         0     0               0              0      0              46              0          0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
              .         .     .               .              .      .               .              .          .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
              .         .     .               .              .      .               .              .          .     ~vec()                                                          { clear(true); }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .      // Pointer to first element:
              .         .     .               .              .      .               .              .          .      operator T*       (void)           { return data; }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .      // Size operations:
              .         .     .               .              .      .               .              .          .      int      size     (void) const     { return sz; }
  4,373,354,811     4,389   149     317,015,581     19,728,662      0     168,826,363              1          0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
              .         .     .               .              .      .               .              .          .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
              .         .     .               .              .      .               .              .          .      int      capacity (void) const     { return cap; }
              .         .     .               .              .      .               .              .          .      void     capacity (int min_cap);
              .         .     .               .              .      .               .              .          .      void     growTo   (int size);
              .         .     .               .              .      .               .              .          .      void     growTo   (int size, const T& pad);
              .         .     .               .              .      .               .              .          .      void     clear    (bool dealloc = false);
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .      // Stack interface:
     23,661,479       781    16      11,818,130          2,691      0       5,915,201              0          0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
487,948,308,106   407,767 1,349 176,385,832,670 11,782,972,647 45,250 134,272,781,762 17,760,932,012 11,292,537      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
  7,322,522,888         0     0   1,845,220,551             33      0   3,602,180,468    152,127,225     10,072      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
  2,172,535,315         6     0      57,524,955              0      0   1,057,829,053             10          0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
              .         .     .               .              .      .               .              .          .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
              .         .     .               .              .      .               .              .          .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
              .         .     .               .              .      .               .              .          .      // happen given the way capacities are calculated (below). Essentially, all capacities are
              .         .     .               .              .      .               .              .          .      // even, but INT_MAX is odd.
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .      const T& last  (void) const        { return data[sz-1]; }
    999,021,119         0     0               0              0      0               0              0          0      T&       last  (void)              { return data[sz-1]; }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .      // Vector interface:
256,666,146,368     1,599   275   1,156,249,081              0      0      57,641,205              0          0      const T& operator [] (int index) const { return data[index]; }
175,643,022,268     1,508   945  51,378,154,599     84,361,577  1,591   2,276,597,130        117,274          0      T&       operator [] (int index)       { return data[index]; }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .      // Duplicatation (preferred instead):
  2,904,676,872        31    11     972,155,468      5,594,833      0     477,235,585              0          0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
         46,248         0     0          46,182              3      0              44              0          0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
              .         .     .               .              .      .               .              .          .  };
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  template<class T>
      1,656,420         0     0               0              0      0         828,210              0          0  void vec<T>::capacity(int min_cap) {
     20,290,887        60    17       6,763,629              0      0               0              0          0      if (cap >= min_cap) return;
      5,797,940        14    11               0              0      0              28              0          0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     10,770,201       108    34         828,337              2      0       2,484,817          1,421          0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
              .         .     .               .              .      .               .              .          .          throw OutOfMemoryException();
      7,580,955         7     7       7,580,955             18      0               0              0          0   }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  template<class T>
              .         .     .               .              .      .               .              .          .  void vec<T>::growTo(int size, const T& pad) {
    172,623,144        13    13      57,538,327             66      0               0              0          0      if (sz >= size) return;
         54,420         4     4           5,442              0      0          24,489              0          0      capacity(size);
        307,475         7     7          48,979              0      0          24,490            525          0      for (int i = sz; i < size; i++) data[i] = pad;
     92,591,260        16    11           3,628              0      0          24,489              0          0      sz = size; }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  template<class T>
         54,420         1     1               0              0      0          21,768              0          0  void vec<T>::growTo(int size) {
     11,854,887         1     1          19,050             64      0          10,884              0          0      if (sz >= size) return;
     23,584,580     4,050   124               0              0      0      11,792,279              0          0      capacity(size);
     82,744,694        79    39      23,606,326              0      0      11,789,557              0          0      for (int i = sz; i < size; i++) new (&data[i]) T();
     17,741,534         0     0       5,927,485             12      0       5,908,397              2          0      sz = size; }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  template<class T>
              .         .     .               .              .      .               .              .          .  void vec<T>::clear(bool dealloc) {
  1,446,212,847 1,990,721   574     447,728,021      5,922,998     79           2,838              0          0      if (data != NULL){
          5,447         0     0               1              0      0               0              0          0          for (int i = 0; i < sz; i++) data[i].~T();
  3,413,821,662        14     9      49,009,524              0      0     504,782,720        876,543         25          sz = 0;
        378,061         5     5          13,510              0      0         362,307            441          0          if (dealloc) free(data), data = NULL, cap = 0; } }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  //=================================================================================================
              .         .     .               .              .      .               .              .          .  }
              .         .     .               .              .      .               .              .          .  
              .         .     .               .              .      .               .              .          .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr          DLmr      Dw              D1mw        DLmw       

-- line 54 ----------------------------------------
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  struct Lit {
              .     .    .              .             .         .               .           .          .      int     x;
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      // Use this as a constructor:
              .     .    .              .             .         .               .           .          .      friend Lit mkLit(Var var, bool sign );
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      bool operator == (Lit p) const { return x == p.x; }
  2,016,838,037     0    0  1,019,946,521   534,903,258    33,053               0           0          0      bool operator != (Lit p) const { return x != p.x; }
              .     .    .              .             .         .               .           .          .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .     .    .              .             .         .               .           .          .  };
              .     .    .              .             .         .               .           .          .  
        137,702     0    0              0             0         0             494           1          0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
106,290,499,552    64   46 49,304,586,700       348,720     9,894   3,047,961,186   1,707,401          0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .     .    .              .             .         .               .           .          .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
406,246,885,267    26   23  6,697,113,282             0         0   3,354,327,166 252,095,232      5,367  inline  bool sign      (Lit p)              { return p.x & 1; }
653,613,382,953 7,757  549  9,440,098,503   176,770,906     3,598 127,948,354,154           0          0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  // Mapping Literals to and from compact integers suitable for array indexing:
              .     .    .              .             .         .               .           .          .  inline  int  toInt     (Var v)              { return v; } 
          2,840     0    0            124             0         0             124           3          0  inline  int  toInt     (Lit p)              { return p.x; } 
              .     .    .              .             .         .               .           .          .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .     .    .              .             .         .               .           .          .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .     .    .              .             .         .               .           .          .  const Lit lit_Error = { -1 };  // }
              .     .    .              .             .         .               .           .          .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .     .    .              .             .         .               .           .          .  #define l_Undef (lbool((uint8_t)2))
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  class lbool {
              .     .    .              .             .         .               .           .          .      uint8_t value;
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  public:
              .     .    .              .             .         .               .           .          .      explicit lbool(uint8_t v) : value(v) { }
              .     .    .              .             .         .               .           .          .  
            692     1    1              0             0         0             171          41         41      lbool()       : value(0) { }
              .     .    .              .             .         .               .           .          .      explicit lbool(bool x) : value(!x) { }
              .     .    .              .             .         .               .           .          .  
 14,872,583,296     1    1              0             0         0               0           0          0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
          8,163     0    0          5,442            43         0               0           0          0      bool  operator != (lbool b) const { return !(*this == b); }
100,485,456,069    75   52 93,812,937,462   548,343,862       951               0           0          0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      lbool operator && (lbool b) const {
              .     .    .              .             .         .               .           .          .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .     .    .              .             .         .               .           .          .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .     .    .              .             .         .               .           .          .          return lbool(v); }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      lbool operator || (lbool b) const {
              .     .    .              .             .         .               .           .          .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .     .    .              .             .         .               .           .          .          unsigned simplified : 1;}                            header;
              .     .    .              .             .         .               .           .          .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      friend class ClauseAllocator;
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .     .    .              .             .         .               .           .          .      template<class V>
              .     .    .              .             .         .               .           .          .      Clause(const V& ps, bool use_extra, bool learnt) {
    144,981,737     0    0     34,771,744             0         0      40,666,504     335,873          0          header.mark      = 0;
    104,278,200     1    1     34,759,400     2,175,172 1,247,407               0           0          0          header.learnt    = learnt;
    208,642,808     4    4     34,784,088             1         0      34,771,744           0          0          header.has_extra = learnt | use_extra;
              .     .    .              .             .         .               .           .          .          header.reloced   = 0;
     46,573,606     0    0      5,907,103           173        43      40,666,503   5,580,052    590,402          header.size      = ps.size();
              .     .    .              .             .         .               .           .          .          header.lbd       = 0;
              .     .    .              .             .         .               .           .          .          header.removable = 1;
              .     .    .              .             .         .               .           .          .          //simplify
              .     .    .              .             .         .               .           .          .          //
     40,666,504    12    9     40,666,504     4,717,117 2,789,466               0           0          0          header.simplified = 0;
              .     .    .              .             .         .               .           .          .  
  1,539,720,939   362  266      5,948,757             0         0               0           0          0          for (int i = 0; i < ps.size(); i++)
    977,853,533   394  260    341,939,544    42,856,001 2,752,441     403,624,885  45,781,076 28,436,357              data[i].lit = ps[i];
              .     .    .              .             .         .               .           .          .  
    121,999,511   191  149     40,666,503             0         0               0           0          0          if (header.has_extra){
     76,457,174     0    0              0             0         0               0           0          0              if (header.learnt){
     76,413,878     3    3     32,311,903             0         0      38,206,939   2,387,817  1,464,509                  data[header.size].act = 0;
     76,414,155     0    0              0             0         0      38,206,939   2,387,636  1,465,793                  data[header.size+1].touched = 0;
              .     .    .              .             .         .               .           .          .              }else
              .     .    .              .             .         .               .           .          .                  calcAbstraction(); }
              .     .    .              .             .         .               .           .          .      }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  public:
              .     .    .              .             .         .               .           .          .      void calcAbstraction() {
              .     .    .              .             .         .               .           .          .          assert(header.has_extra);
         21,816     0    0              0             0         0               0           0          0          uint32_t abstraction = 0;
        340,554     4    3          9,362             0         0               0           0          0          for (int i = 0; i < size(); i++)
        506,614     3    2              0             0         0               1           0          0              abstraction |= 1 << (var(data[i].lit) & 31);
         71,376     0    0          9,304             0         0          31,121       1,376      1,376          data[header.size].abs = abstraction;  }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
 89,316,679,929   321  234 45,967,135,400 5,993,665,853   472,553  37,406,007,291          73          0      int          size        ()      const   { return header.size; }
      6,732,047    58   43      1,683,454       434,077        85       1,683,454     105,013          0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .     .    .              .             .         .               .           .          .      void         pop         ()              { shrink(1); }
    526,380,693     7    7      5,675,821             0         0               0           0          0      bool         learnt      ()      const   { return header.learnt; }
          6,342     0    0              0             0         0               0           0          0      bool         has_extra   ()      const   { return header.has_extra; }
    822,572,484   420  218    120,581,747   115,372,952 2,284,848     255,894,061           0          0      uint32_t     mark        ()      const   { return header.mark; }
    169,360,583   491  292     43,932,403       153,217         0      41,704,520           0          0      void         mark        (uint32_t m)    { header.mark = m; }
        499,622     0    0              0             0         0         249,811      50,778          0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .     .    .              .             .         .               .           .          .  
    104,477,757     0    0    104,477,757    90,297,926   542,691               0           0          0      bool         reloced     ()      const   { return header.reloced; }
              .     .    .              .             .         .               .           .          .      CRef         relocation  ()      const   { return data[0].rel; }
    139,037,600    83   68     34,759,400             0         0      69,518,800           0          0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .     .    .              .             .         .               .           .          .  
     50,042,096     0    0     16,638,905             0         0               0           0          0      int          lbd         ()      const   { return header.lbd; }
    251,646,821   306  209     71,874,466             0         0      39,564,680           0          0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .     .    .              .             .         .               .           .          .      bool         removable   ()      const   { return header.removable; }
    200,600,953     4    4     71,352,237             0         0      32,312,179           0          0      void         removable   (bool b)        { header.removable = b; }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .     .    .              .             .         .               .           .          .      //       subsumption operations to behave correctly.
 92,796,959,333   250  164 90,152,711,143 7,287,508,633 2,236,022               0           0          0      Lit&         operator [] (int i)         { return data[i].lit; }
    775,627,198   734  356    707,098,561    24,437,000   320,830               0           0          0      Lit          operator [] (int i) const   { return data[i].lit; }
              .     .    .              .             .         .               .           .          .      operator const Lit* (void) const         { return (Lit*)data; }
              .     .    .              .             .         .               .           .          .  
     33,339,127     0    0     33,339,127            31         0               0           0          0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     25,384,631     0    0      7,642,147     2,012,211    39,249               0           0          0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .     .    .              .             .         .               .           .          .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      Lit          subsumes    (const Clause& other) const;
              .     .    .              .             .         .               .           .          .      void         strengthen  (Lit p);
              .     .    .              .             .         .               .           .          .      // simplify
              .     .    .              .             .         .               .           .          .      //
    227,681,983     0    0     65,372,723             0         0      32,312,179           0          0      void setSimplified(bool b) { header.simplified = b; }
              .     .    .              .             .         .               .           .          .      bool simplified() { return header.simplified; }
              .     .    .              .             .         .               .           .          .  };
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  //=================================================================================================
              .     .    .              .             .         .               .           .          .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .     .    .              .             .         .               .           .          .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .     .    .              .             .         .               .           .          .  {
              .     .    .              .             .         .               .           .          .      static int clauseWord32Size(int size, int extras){
     81,092,702     6    5     40,425,923     2,019,282   146,289               0           0          0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .     .    .              .             .         .               .           .          .  public:
              .     .    .              .             .         .               .           .          .      bool extra_clause_field;
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1     0    0              0             0         0               1           0          0      ClauseAllocator() : extra_clause_field(false){}
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      void moveTo(ClauseAllocator& to){
            530    95   65            265           264         0             265           0          0          to.extra_clause_field = extra_clause_field;
              .     .    .              .             .         .               .           .          .          RegionAllocator<uint32_t>::moveTo(to); }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      template<class Lits>
              .     .    .              .             .         .               .           .          .      CRef alloc(const Lits& ps, bool learnt = false)
              .     .    .              .             .         .               .           .          .      {
              .     .    .              .             .         .               .           .          .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .     .    .              .             .         .               .           .          .          assert(sizeof(float)    == sizeof(uint32_t));
     71,978,364   401  289      2,459,564           385         5               0           0          0          int extras = learnt ? 2 : (int)extra_clause_field;
              .     .    .              .             .         .               .           .          .  
      5,919,446     0    0              0             0         0          12,343           0          0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .     .    .              .             .         .               .           .          .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .          return cid;
              .     .    .              .             .         .               .           .          .      }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    265,514,759   392  242    243,987,858       108,266         0          20,180           0          0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
          4,228     0    0          2,114             1         0               0           0          0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
     34,759,400     0    0     34,759,400             0         0               0           0          0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .         .               .           .          .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .     .    .              .             .         .               .           .          .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      void free(CRef cid)
              .     .    .              .             .         .               .           .          .      {
              .     .    .              .             .         .               .           .          .          Clause& c = operator[](cid);
     17,005,893     8    4              0             0         0               0           0          0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .     .    .              .             .         .               .           .          .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .     .    .              .             .         .               .           .          .      }
              .     .    .              .             .         .               .           .          .  
     44,103,297   264  185              0             0         0      37,802,826           2          0      void reloc(CRef& cr, ClauseAllocator& to)
              .     .    .              .             .         .               .           .          .      {
              .     .    .              .             .         .               .           .          .          Clause& c = operator[](cr);
              .     .    .              .             .         .               .           .          .          
    377,020,698     0    0     69,718,357    12,203,144    31,955      69,718,357           0          0          if (c.reloced()) { cr = c.relocation(); return; }
              .     .    .              .             .         .               .           .          .          
     34,759,401     0    0              1             0         0      34,759,400           0          0          cr = to.alloc(c, c.learnt());
              .     .    .              .             .         .               .           .          .          c.relocate(cr);
              .     .    .              .             .         .               .           .          .          
              .     .    .              .             .         .               .           .          .          // Copy extra data-fields:
              .     .    .              .             .         .               .           .          .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .     .    .              .             .         .               .           .          .          to[cr].mark(c.mark());
     69,518,800     3    3              0             0         0               0           0          0          if (to[cr].learnt()){
    129,248,716     0    0     32,312,179     1,811,924    79,024      32,312,179           0          0              to[cr].touched() = c.touched();
    129,248,440     0    0     64,624,358     1,819,052    79,851      32,312,179           0          0              to[cr].activity() = c.activity();
              .     .    .              .             .         .               .           .          .              to[cr].set_lbd(c.lbd());
              .     .    .              .             .         .               .           .          .              to[cr].removable(c.removable());
              .     .    .              .             .         .               .           .          .              // simplify
              .     .    .              .             .         .               .           .          .              //
              .     .    .              .             .         .               .           .          .              to[cr].setSimplified(c.simplified());
              .     .    .              .             .         .               .           .          .          }
      4,894,442   530  369              0             0         0               0           0          0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
     50,403,768     0    0     44,103,297             0         0               0           0          0      }
              .     .    .              .             .         .               .           .          .  };
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .     .    .              .             .         .               .           .          .  {
              .     .    .              .             .         .               .           .          .      for (int i = 0; i < cls.size(); ++i)
              .     .    .              .             .         .               .           .          .      {
              .     .    .              .             .         .               .           .          .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .     .    .              .             .         .               .           .          .  class OccLists
              .     .    .              .             .         .               .           .          .  {
              .     .    .              .             .         .               .           .          .      vec<Vec>  occs;
              .     .    .              .             .         .               .           .          .      vec<char> dirty;
              .     .    .              .             .         .               .           .          .      vec<Idx>  dirties;
              .     .    .              .             .         .               .           .          .      Deleted   deleted;
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  public:
              3     0    0              0             0         0               3           0          0      OccLists(const Deleted& d) : deleted(d) {}
              .     .    .              .             .         .               .           .          .      unsigned int size(){
              .     .    .              .             .         .               .           .          .          auto m_size=0;
             40     2    2              4             3         0               0           0          0          for(int i=0;i<occs.size();i++){
         59,936    14   14         21,772         5,444       340               0           0          0              m_size+=occs[i].size();
              .     .    .              .             .         .               .           .          .          }
              .     .    .              .             .         .               .           .          .          
              .     .    .              .             .         .               .           .          .          return m_size;
              .     .    .              .             .         .               .           .          .      }
         29,931     1    1              0             0         0           5,442           0          0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .     .    .              .             .         .               .           .          .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
  1,665,119,899    46   16  1,665,119,899     5,140,712        43               0           0          0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
         49,943     1    1         25,217         2,060         0           2,838           0          0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      void  cleanAll  ();
              .     .    .              .             .         .               .           .          .      void  clean     (const Idx& idx);
              .     .    .              .             .         .               .           .          .      void  smudge    (const Idx& idx){
     34,020,898     0    0     22,676,960       278,513    17,931               0           0          0          if (dirty[toInt(idx)] == 0){
        659,001   406  227              0             0         0         659,001           0          0              dirty[toInt(idx)] = 1;
             45     1    1              0             0         0               0           0          0              dirties.push(idx);
              .     .    .              .             .         .               .           .          .          }
              .     .    .              .             .         .               .           .          .      }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .      void  clear(bool free = true){
              .     .    .              .             .         .               .           .          .          occs   .clear(free);
              .     .    .              .             .         .               .           .          .          dirty  .clear(free);
              .     .    .              .             .         .               .           .          .          dirties.clear(free);
              .     .    .              .             .         .               .           .          .      }
              .     .    .              .             .         .               .           .          .  };
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  template<class Idx, class Vec, class Deleted>
          1,708     0    0              0             0         0           1,281          12          0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .     .    .              .             .         .               .           .          .  {
    197,359,673 1,942   77     98,019,902     5,117,335        40               0           0          0      for (int i = 0; i < dirties.size(); i++)
              .     .    .              .             .         .               .           .          .          // Dirties may contain duplicates so check here if a variable is already cleaned:
      1,977,003     0    0      1,318,002       570,498         0               0           0          0          if (dirty[toInt(dirties[i])])
              .     .    .              .             .         .               .           .          .              clean(dirties[i]);
              .     .    .              .             .         .               .           .          .      dirties.clear();
          1,708     0    0          1,708           407         0               0           0          0  }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  template<class Idx, class Vec, class Deleted>
              .     .    .              .             .         .               .           .          .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .     .    .              .             .         .               .           .          .  {
              .     .    .              .             .         .               .           .          .      Vec& vec = occs[toInt(idx)];
              .     .    .              .             .         .               .           .          .      int  i, j;
    332,753,732     2    2      2,627,383       701,549       124               0           0          0      for (i = j = 0; i < vec.size(); i++)
    209,924,514     0    0         27,417         1,184         0               0           0          0          if (!deleted(vec[i]))
    654,023,424     1    1    187,191,669            47         0      93,601,590     302,960          0              vec[j++] = vec[i];
        657,450   407  211              0             0         0               0           0          0      vec.shrink(i - j);
      2,637,441     2    2      1,318,002        50,567         0         659,641      50,906          0      dirty[toInt(idx)] = 0;
              .     .    .              .             .         .               .           .          .  }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  //=================================================================================================
              .     .    .              .             .         .               .           .          .  // CMap -- a class for mapping clauses to values:
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .     .    .              .             .         .               .           .          .  |       p          - The literal p can be deleted from 'other'
              .     .    .              .             .         .               .           .          .  |________________________________________________________________________________________________@*/
              .     .    .              .             .         .               .           .          .  inline Lit Clause::subsumes(const Clause& other) const
              .     .    .              .             .         .               .           .          .  {
              .     .    .              .             .         .               .           .          .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .     .    .              .             .         .               .           .          .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .     .    .              .             .         .               .           .          .      assert(!header.learnt);   assert(!other.header.learnt);
              .     .    .              .             .         .               .           .          .      assert(header.has_extra); assert(other.header.has_extra);
      1,136,988     0    0        378,996         4,302         0               0           0          0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .     .    .              .             .         .               .           .          .          return lit_Error;
              .     .    .              .             .         .               .           .          .  
         42,371     0    0              0             0         0               0           0          0      Lit        ret = lit_Undef;
              .     .    .              .             .         .               .           .          .      const Lit* c   = (const Lit*)(*this);
              .     .    .              .             .         .               .           .          .      const Lit* d   = (const Lit*)other;
              .     .    .              .             .         .               .           .          .  
        405,428     1    1         80,312             0         0               0           0          0      for (unsigned i = 0; i < header.size; i++) {
              .     .    .              .             .         .               .           .          .          // search for c[i] or ~c[i]
      1,020,102     2    2         42,371             0         0          42,371           0          0          for (unsigned j = 0; j < other.header.size; j++)
      1,380,438     0    0        295,609             0         0               0           0          0              if (c[i] == d[j])
              .     .    .              .             .         .               .           .          .                  goto ok;
        179,669     0    0              0             0         0               0           0          0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .     .    .              .             .         .               .           .          .                  ret = c[i];
              .     .    .              .             .         .               .           .          .                  goto ok;
              .     .    .              .             .         .               .           .          .              }
              .     .    .              .             .         .               .           .          .  
              .     .    .              .             .         .               .           .          .          // did not find it
              .     .    .              .             .         .               .           .          .          return lit_Error;
              .     .    .              .             .         .               .           .          .  ok:;
              .     .    .              .             .         .               .           .          .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr             D1mr          DLmr   Dw            D1mw        DLmw  

-- line 31 ----------------------------------------
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  template<class Comp>
             .      .    .              .             .      .             .           .     .  class Heap {
             .      .    .              .             .      .             .           .     .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
             .      .    .              .             .      .             .           .     .      vec<int> heap;     // Heap of integers
             .      .    .              .             .      .             .           .     .      vec<int> indices;  // Each integers position (index) in the Heap
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .      // Index "traversal" functions
 1,976,613,703     21   15              0             0      0             0           0     0      static inline int left  (int i) { return i*2+1; }
 7,367,540,716     29   20  2,946,922,331 1,107,230,210 20,604             0           0     0      static inline int right (int i) { return (i+1)*2; }
 3,838,331,714     16   11    504,713,997             0      0             0           0     0      static inline int parent(int i) { return (i-1) >> 1; }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
 1,009,427,994     37   31              0             0      0 1,009,427,994           0     0      void percolateUp(int i)
             .      .    .              .             .      .             .           .     .      {
 2,689,458,887      0    0  1,625,856,905   164,769,812  5,499   558,887,985           0     0          int x  = heap[i];
             .      .    .              .             .      .             .           .     .          int p  = parent(i);
             .      .    .              .             .      .             .           .     .          
11,704,574,242     43   21  3,953,046,690   651,857,424  9,359    95,247,386           0     0          while (i != 0 && lt(x, heap[p])){
   825,109,413     61   39              0             0      0   825,109,413           0     0              heap[i]          = heap[p];
   825,109,413      0    0              0             0      0   825,109,413 240,766,888 2,679              indices[heap[p]] = i;
             .      .    .              .             .      .             .           .     .              i                = p;
   838,613,244      0    0              0             0      0             0           0     0              p                = parent(p);
             .      .    .              .             .      .             .           .     .          }
 1,121,142,908     13   10    279,448,013             0      0   841,694,895           0     0          heap   [i] = x;
 1,179,202,850      2    2    279,455,964             0      0   841,702,885           1     0          indices[x] = i;
 2,017,291,811      0    0  1,514,141,991             0      0             0           0     0      }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
 7,030,425,689      0    0  1,004,346,527             0      0 6,026,079,162           0     0      void percolateDown(int i)
             .      .    .              .             .      .             .           .     .      {
 3,193,695,830  6,116  130  2,088,116,217   554,821,526  4,576 1,105,535,669           0     0          int x = heap[i];
 7,925,099,246 31,422  112  1,938,195,652            62      0             0           0     0          while (left(i) < heap.size()){
10,530,269,907     14    7  1,469,379,437    59,291,443    865             0           0     0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
 3,842,537,355     35   21              0             0      0             0           0     0              if (!lt(heap[child], x)) break;
   892,813,899      0    0              0             0      0   892,813,899           0     0              heap[i]          = heap[child];
   892,859,658      0    0         45,759             0      0   892,813,899 234,216,699 5,837              indices[heap[i]] = i;
   723,228,343      0    0              0             0      0             0           0     0              i                = child;
             .      .    .              .             .      .             .           .     .          }
 2,167,456,740     49   33  1,083,728,448             0      0 1,083,728,292           0     0          heap   [i] = x;
 1,242,398,151      4    2     79,373,436             0      0 1,083,728,292       2,267     0          indices[x] = i;
 7,101,003,975      0    0  7,030,425,689             0      0             0           0     0      }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .    public:
             .      .    .              .             .      .             .           .     .      Heap(const Comp& c) : lt(c) { }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .      int  size      ()          const { return heap.size(); }
    57,524,956      0    0     57,524,956     4,124,061    101             0           0     0      bool empty     ()          const { return heap.size() == 0; }
26,297,795,215  2,631  145 13,526,516,764   965,672,558 12,390             0           0     0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
   132,460,954     13   12     81,052,825     2,741,194     68             0           0     0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
 2,540,432,914      0    0  1,774,930,454            17      0   504,713,997       7,692     0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
 5,292,587,523     13   12  3,283,894,468             0      0 1,004,346,527     110,398     0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .      // Safe variant of insert/decrease/increase:
             .      .    .              .             .      .             .           .     .      void update(int n)
             .      .    .              .             .      .             .           .     .      {
             .      .    .              .             .      .             .           .     .          if (!inHeap(n))
             .      .    .              .             .      .             .           .     .              insert(n);
             .      .    .              .             .      .             .           .     .          else {
             .      .    .              .             .      .             .           .     .              percolateUp(indices[n]);
        16,082      0    0          8,041             0      0             0           0     0              percolateDown(indices[n]); }
             .      .    .              .             .      .             .           .     .      }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .      void insert(int n)
             .      .    .              .             .      .             .           .     .      {
    57,532,885      2    2              0             0      0             0           0     0          indices.growTo(n+1, -1);
             .      .    .              .             .      .             .           .     .          assert(!inHeap(n));
             .      .    .              .             .      .             .           .     .  
   115,065,770      1    1     57,532,885       498,163      0    57,532,885           0     0          indices[n] = heap.size();
         9,185      1    1              0             0      0         6,078           0     0          heap.push(n);
   115,065,770      0    0     57,532,885             0      0             0           0     0          percolateUp(indices[n]); 
             .      .    .              .             .      .             .           .     .      }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .      int  removeMin()
             .      .    .              .             .      .             .           .     .      {
   172,574,865      1    1    115,049,910     2,750,944     57    57,524,955           0     0          int x            = heap[0];
   115,049,910      0    0     57,524,955     6,108,105    139    57,524,955           0     0          heap[0]          = heap.last();
   115,049,910     39   27     57,524,955     2,601,677     52    57,524,955  26,910,352 1,449          indices[heap[0]] = 0;
    57,524,955      1    1              0             0      0    57,524,955   5,176,222    96          indices[x]       = -1;
             .      .    .              .             .      .             .           .     .          heap.pop();
   115,049,910      0    0              0             0      0             0           0     0          if (heap.size() > 1) percolateDown(0);
             .      .    .              .             .      .             .           .     .          return x; 
             .      .    .              .             .      .             .           .     .      }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .      // Rebuild the heap from scratch, using the elements in 'ns':
             .      .    .              .             .      .             .           .     .      void build(const vec<int>& ns) {
       178,616     24   13         89,308            26      1             0           0     0          for (int i = 0; i < heap.size(); i++)
        89,347     13    7             39            13      1        89,230       6,625 1,958              indices[heap[i]] = -1;
            39      0    0              0             0      0             0           0     0          heap.clear();
             .      .    .              .             .      .             .           .     .  
       176,007     10    7         87,945             0      0             0           0     0          for (int i = 0; i < ns.size(); i++){
       175,812      0    0         87,906             0      0        87,906          37     0              indices[ns[i]] = i;
             .      .    .              .             .      .             .           .     .              heap.push(ns[i]); }
             .      .    .              .             .      .             .           .     .  
       308,011     37   21         43,983             0      0            39           0     0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
             .      .    .              .             .      .             .           .     .              percolateDown(i);
             .      .    .              .             .      .             .           .     .      }
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .      void clear(bool dealloc = false) 
             .      .    .              .             .      .             .           .     .      { 
             4      0    0              2             0      0             0           0     0          for (int i = 0; i < heap.size(); i++)
             .      .    .              .             .      .             .           .     .              indices[heap[i]] = -1;
             .      .    .              .             .      .             .           .     .          heap.clear(dealloc); 
             .      .    .              .             .      .             .           .     .      }
             .      .    .              .             .      .             .           .     .  };
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  
             .      .    .              .             .      .             .           .     .  //=================================================================================================
             .      .    .              .             .      .             .           .     .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir              I1mr  ILmr Dr             D1mr       DLmr      Dw          D1mw DLmw 

-- line 40 ----------------------------------------
              .     .    .              .          .         .           .    .    .      void capacity(uint32_t min_cap);
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .   public:
              .     .    .              .          .         .           .    .    .      // TODO: make this a class for better type-checking?
              .     .    .              .          .         .           .    .    .      typedef uint32_t Ref;
              .     .    .              .          .         .           .    .    .      enum { Ref_Undef = UINT32_MAX };
              .     .    .              .          .         .           .    .    .      enum { Unit_Size = sizeof(uint32_t) };
              .     .    .              .          .         .           .    .    .  
          1,331     1    1              0          0         0       1,064  263    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
              .     .    .              .          .         .           .    .    .      ~RegionAllocator()
              .     .    .              .          .         .           .    .    .      {
              .     .    .              .          .         .           .    .    .          if (memory != NULL)
              .     .    .              .          .         .           .    .    .              ::free(memory);
              .     .    .              .          .         .           .    .    .      }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .      uint32_t size      () const      { return sz; }
              .     .    .              .          .         .           .    .    .      uint32_t wasted    () const      { return wasted_; }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .      Ref      alloc     (int size); 
     16,999,557     0    0      5,666,517          0         0   5,666,517    0    0      void     free      (int size)    { wasted_ += size; }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
109,721,003,315   927  536 54,920,027,156 12,511,731 2,953,931     698,052    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
    104,919,297     0    0    104,919,297 13,646,508   410,434           0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
              .     .    .              .          .         .           .    .    .  
    127,894,272 5,991   57      5,907,104          0         0           0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     11,089,034     0    0              0          0         0           0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
              .     .    .              .          .         .           .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
              .     .    .              .          .         .           .    .    .          return  (Ref)(t - &memory[0]); }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .      void     moveTo(RegionAllocator& to) {
          1,060     0    0            265          0         0         265    0    0          if (to.memory != NULL) ::free(to.memory);
            530     0    0            265          0         0         265    0    0          to.memory = memory;
            530     0    0            265          0         0         265    0    0          to.sz = sz;
              .     .    .              .          .         .           .    .    .          to.cap = cap;
            530     0    0            265          0         0         265    0    0          to.wasted_ = wasted_;
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .          memory = NULL;
              .     .    .              .          .         .           .    .    .          sz = cap = wasted_ = 0;
              .     .    .              .          .         .           .    .    .      }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  };
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  template<class T>
          2,646   147  113              0          0         0         882    0    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
              .     .    .              .          .         .           .    .    .  {
    122,000,310     1    0     40,666,770          0         0           0    0    0      if (cap >= min_cap) return;
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .      uint32_t prev_cap = cap;
         16,243     0    0              0          0         0         441    0    0      while (cap < min_cap){
              .     .    .              .          .         .           .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
              .     .    .              .          .         .           .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
              .     .    .              .          .         .           .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
              .     .    .              .          .         .           .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
         47,406     0    0              0          0         0           0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
          7,901     0    0              0          0         0           0    0    0          cap += delta;
              .     .    .              .          .         .           .    .    .  
         15,802     0    0              0          0         0           0    0    0          if (cap <= prev_cap)
              .     .    .              .          .         .           .    .    .              throw OutOfMemoryException();
              .     .    .              .          .         .           .    .    .      }
              .     .    .              .          .         .           .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .      assert(cap > 0);
            882     2    1              0          0         0         441  174   43      memory = (T*)xrealloc(memory, sizeof(T)*cap);
          1,764     0    0          1,323          0         0           0    0    0  }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  template<class T>
              .     .    .              .          .         .           .    .    .  typename RegionAllocator<T>::Ref
         49,372     2    1              0          0         0      37,029    0    0  RegionAllocator<T>::alloc(int size)
              .     .    .              .          .         .           .    .    .  { 
              .     .    .              .          .         .           .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
              .     .    .              .          .         .           .    .    .      assert(size > 0);
    226,265,369     0    0     40,666,504  4,238,083        65 110,172,684  462   26      capacity(sz + size);
              .     .    .              .          .         .           .    .    .  
    127,856,969     0    0     75,413,285          0         0           0    0    0      uint32_t prev_sz = sz;
     40,666,504     2    1              0          0         0  40,666,504    0    0      sz += size;
              .     .    .              .          .         .           .    .    .      
              .     .    .              .          .         .           .    .    .      // Handle overflow:
    185,611,204   273  204     34,759,399          0         0           0    0    0      if (sz < prev_sz)
              2     1    1              1          1         0           0    0    0          throw OutOfMemoryException();
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .      return prev_sz;
         49,372     0    0         49,372          0         0           0    0    0  }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  //=================================================================================================
              .     .    .              .          .         .           .    .    .  }
              .     .    .              .          .         .           .    .    .  
              .     .    .              .          .         .           .    .    .  #endif

--------------------------------------------------------------------------------
Ir                I1mr      ILmr   Dr                D1mr            DLmr       Dw              D1mw           DLmw       
--------------------------------------------------------------------------------
6,430,172,876,099 3,290,736 25,092 2,105,746,096,118 113,119,519,374 28,272,001 774,465,691,727 22,805,416,139 43,389,334  events annotated

