--------------------------------------------------------------------------------
I1 cache:         32768 B, 64 B, 8-way associative
D1 cache:         32768 B, 64 B, 8-way associative
LL cache:         31457280 B, 64 B, 30-way associative
Command:          ./glucose_release ./cnfs/b1904P1-8x8c6h5SAT.cnf
Data file:        b1904P1-8x8c6h5SAT.cnf.out.cache
Events recorded:  Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Events shown:     Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Event sort order: Ir I1mr ILmr Dr D1mr DLmr Dw D1mw DLmw
Thresholds:       0.1 100 100 100 100 100 100 100 100
Include dirs:     
User annotated:   
Auto-annotation:  on

--------------------------------------------------------------------------------
Ir                I1mr      ILmr    Dr                D1mr            DLmr        Dw              D1mw           DLmw        
--------------------------------------------------------------------------------
3,698,774,868,001 7,083,730 206,323 1,208,168,713,012 118,140,814,002 664,513,097 433,250,579,983 30,145,279,521 244,041,018  PROGRAM TOTALS

--------------------------------------------------------------------------------
Ir                I1mr    ILmr   Dr              D1mr           DLmr        Dw              D1mw           DLmw        file:function
--------------------------------------------------------------------------------
1,212,516,494,393  42,509    703 427,137,414,221 38,025,019,748 250,419,960 126,198,634,021      8,348,344          1  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::propagate_()
  470,560,801,886      18     18  88,951,223,838 11,660,122,901  40,635,820  60,692,571,564              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::propagate_()
  223,176,075,370 221,353  1,330  42,259,461,201  3,932,954,161   3,473,864  24,653,026,690  4,346,700,341 53,512,594  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::propagate_()
  176,907,153,836 921,339 14,046  37,827,483,259    260,842,204       8,422  16,762,918,364     33,067,268        547  ???:__ieee754_pow_fma
  150,979,106,939  26,213  2,237  58,916,522,341 14,501,685,535   1,440,272  17,844,716,183  5,904,479,207    369,496  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::cancelUntil(int) [clone .part.108]
  147,489,703,193      13     13  62,803,605,991  3,699,393,579   1,323,477  44,891,378,657 12,206,811,026  4,239,087  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
  123,802,724,617  31,504    732  50,544,896,926  7,753,485,741     972,031  33,155,699,164    226,804,715    113,741  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
  113,107,295,187  74,927  1,976  34,419,366,957  1,635,120,887     367,290  11,881,571,805     26,569,015          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
  101,660,347,624 432,882  1,399  30,673,891,713        285,860           0  18,372,886,368     64,922,120     55,776  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   92,246,231,826 137,531  6,845  33,090,921,021  5,700,824,601     976,511   6,203,028,995    369,595,796      6,117  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   78,117,018,133     405    117  39,558,924,865  4,816,613,516   1,002,900   3,622,823,026    161,803,697     17,159  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   58,167,627,551  22,152  2,603  15,115,312,908     39,860,383         474   5,282,889,565    119,516,517    333,872  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   57,550,728,987  79,940  4,357  13,803,749,874    381,440,507      98,498   1,536,632,988     22,200,101        277  ???:__exp1_fma
   56,941,572,696      45     45  52,260,648,850  3,458,288,540       1,178   4,676,604,112              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::propagate_()
   51,282,595,604     264    240  19,053,958,063  3,073,534,505   3,995,977               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   45,599,815,214     675    664  12,053,518,471  2,394,743,648  15,946,428   4,865,443,442    300,442,312     63,605  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc:Minisat::Solver::simplePropagate()
   42,749,287,532   5,117  1,451  11,423,116,141  1,037,960,243   2,601,343     136,891,681      3,339,104          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   39,030,538,339     869    458   7,354,548,467  1,069,732,578     657,235   3,818,577,131    747,351,918    180,336  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::pickBranchLit()
   38,939,565,615  12,927  1,008  15,847,158,328    156,196,684     645,643               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   33,423,828,314      19     19  11,578,295,574      9,261,023         164  10,267,237,166    317,751,098    376,828  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   30,809,398,724       0      0  20,538,305,640    322,236,930      80,105   5,133,606,278  3,551,070,559    505,972  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   25,493,423,641   8,563    605   8,107,076,212      2,530,239           0     334,470,837     19,337,767     21,089  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::cancelUntil(int) [clone .part.108]
   24,908,898,231     180    180   6,373,393,637    647,277,708   1,947,874               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::simplePropagate()
   24,335,145,204  60,829  1,158   6,744,071,179        120,178       1,138   4,043,913,351         43,830          0  ???:pow
   24,048,289,589  26,646  1,021  10,971,907,396  2,226,562,196   2,005,260   1,322,262,003            129          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   20,534,474,332       0      0   5,133,618,583              0           0   5,133,618,583      1,002,079        163  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   20,403,882,910       0      0  10,201,941,455      2,007,123           0               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::propagate_()
   20,256,896,497     126    126   5,113,831,449    530,671,975     159,767   3,754,181,919    615,198,144  3,955,327  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::simplePropagate()
   15,732,700,896       0      0   9,177,408,856  1,280,428,485     565,954   1,311,058,408              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
   14,440,015,782   2,715  2,715   3,589,935,824    405,008,547 126,401,407   1,994,253,448     70,981,595 70,066,181  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h:Minisat::Solver::relocAll(Minisat::ClauseAllocator&)
   14,008,715,642   7,022  1,164   5,445,720,039  1,169,196,001     559,224   2,221,786,289    258,353,031     70,013  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Solver::analyze(unsigned int, Minisat::vec<Minisat::Lit>&, int&, int&)
   13,842,321,171   3,645    694   6,502,771,599  2,106,619,934     177,747               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
   13,190,857,529     127    115   3,973,933,214  1,130,810,888     102,475   2,489,156,888    367,394,614    103,303  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateUp(int)
   12,628,288,424       0      0   8,347,268,434  2,168,151,104     581,492               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
   11,754,252,208       0      0               0              0           0               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Heap<Minisat::Solver::VarOrderLt>::percolateDown(int)
    9,177,408,856       0      0   1,311,058,408     11,811,437         128   3,933,175,224     13,160,999          0  /usr/include/c++/8/cmath:Minisat::Solver::uncheckedEnqueue(Minisat::Lit, int, unsigned int)
    8,384,346,156       0      0   5,589,564,104     13,126,009           0               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h:Minisat::Solver::litRedundant(Minisat::Lit, unsigned int)
    4,165,726,468   2,002    474   2,055,911,610    729,355,592     650,190               0              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h:Minisat::Solver::pickBranchLit()
    3,755,391,073       0      0     129,061,304         67,776           0     196,619,092              0          0  /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h:Minisat::Solver::pickBranchLit()

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/Solver.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr  Dr             D1mr          DLmr      Dw            D1mw      DLmw  

-- line 77 ----------------------------------------
             .      .     .              .             .         .             .         .     .  private:
             .      .     .              .             .         .             .         .     .      template<typename T>
             .      .     .              .             .         .             .         .     .      class MyQueue {
             .      .     .              .             .         .             .         .     .          int max_sz, q_sz;
             .      .     .              .             .         .             .         .     .          int ptr;
             .      .     .              .             .         .             .         .     .          int64_t sum;
             .      .     .              .             .         .             .         .     .          vec<T> q;
             .      .     .              .             .         .             .         .     .      public:
             4      1     1              0             0         0             3         0     0          MyQueue(int sz) : max_sz(sz), q_sz(0), ptr(0), sum(0) { assert(sz > 0); q.growTo(sz); }
             .      .     .              .             .         .             .         .     .          inline bool   full () const { return q_sz == max_sz; }
             .      .     .              .             .         .             .         .     .  #ifdef INT_QUEUE_AVG
     3,867,280  1,780   300        966,820             0         0             0         0     0          inline T      avg  () const { assert(full()); return sum / max_sz; }
             .      .     .              .             .         .             .         .     .  #else
             .      .     .              .             .         .             .         .     .          inline double avg  () const { assert(full()); return sum / (double) max_sz; }
             .      .     .              .             .         .             .         .     .  #endif
        69,764    233   225              0             0         0        69,764     3,478     0          inline void   clear()       { sum = 0; q_sz = 0; ptr = 0; }
             .      .     .              .             .         .             .         .     .          void push(T e) {
    23,745,922      0     0     10,343,811             0         0     1,529,150         0     0              if (q_sz < max_sz) q_sz++;
     5,756,361     37    35      1,918,787     1,910,658       395             0         0     0              else sum -= q[ptr];
    10,343,811     58    55              0             0         0     3,447,937         0     0              sum += e;
    10,343,811      0     0              0             0         0     6,895,874 1,524,971   495              q[ptr++] = e;
    10,404,943      0     0      6,895,874             0         0        61,132         0     0              if (ptr == max_sz) ptr = 0;
             .      .     .              .             .         .             .         .     .          }
             .      .     .              .             .         .             .         .     .      };
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  public:
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .      // Constructor/Destructor:
             .      .     .              .             .         .             .         .     .      //
             .      .     .              .             .         .             .         .     .      Solver();
             .      .     .              .             .         .             .         .     .      virtual ~Solver();
            10      2     2              0             0         0             4         0     0      void print_size(std::ostream &os)
             .      .     .              .             .         .             .         .     .      {
             4      2     2              0             0         0             4         1     1          program_end_time=std::chrono::steady_clock::now();
             2      0     0              0             0         0             2         0     0          total_work_time=program_end_time-program_start_time;
             4      0     0              2             1         0             0         0     0          os << "clause_allocate_size " << ca.size() * sizeof(int) << "\n";
             2      0     0              2             1         0             0         0     0          os << "model " << model.size() * sizeof(model[0]) << "\n";
             4      0     0              2             1         0             0         0     0          os << "conflict " << conflict.size() * sizeof(conflict[0]) << "\n";
             4      0     0              2             1         0             0         0     0          os << "clauses " << clauses.size() * sizeof(clauses[0]) << "\n";
             4      0     0              2             0         0             0         0     0          os << "learnts_core " << learnts_core.size() * sizeof(learnts_core[0]) << "\n";
             4      0     0              2             2         1             0         0     0          os << "activity_CHB " << activity_CHB.size() * sizeof(activity_CHB[0]) << "\n";
             .      .     .              .             .         .             .         .     .          os << "watches_bin " << watches_bin.size() * sizeof(Watcher) << "\n";
             .      .     .              .             .         .             .         .     .          os << "watches " << watches.size() * sizeof(Watcher) << "\n";
             2      0     0              2             2         0             0         0     0          os << "assigns " << assigns.size() * sizeof(assigns[0]) << "\n";
             2      0     0              2             0         0             0         0     0          os << "polarity " << polarity.size() * sizeof(polarity[0]) << "\n";
             2      0     0              2             0         0             0         0     0          os << "decision " << decision.size() * sizeof(decision[0]) << "\n";
             4      0     0              2             2         0             0         0     0          os << "trail " << trail.size() * sizeof(trail[0]) << "\n";
             4      0     0              2             0         0             0         0     0          os << "trail_lim " << trail_lim.size() * sizeof(trail_lim[0]) << "\n";
             4      0     0              2             0         0             0         0     0          os << "vardata " << vardata.size() * sizeof(vardata[0]) << "\n";
             4      0     0              2             2         1             0         0     0          os << "assumptions " << assumptions.size() * sizeof(assumptions[0]) << "\n";
             .      .     .              .             .         .             .         .     .          os << "total_Watchers: " << total_Watchers << "\n";
             .      .     .              .             .         .             .         .     .          os << "total_act_watchers: " << total_act_watchers << "\n";
             .      .     .              .             .         .             .         .     .          os << "total_indexs: " << total_indexs << "\n";
             .      .     .              .             .         .             .         .     .          os << "time_find_conflict: " << time_find_conflict << "\n";
             .      .     .              .             .         .             .         .     .          os << "total_find_conflict_length: " << total_find_conflict_length << "\n";
             .      .     .              .             .         .             .         .     .          os << "total_find_conflict_allsize: " << total_find_conflict_allsize << "\n";
             .      .     .              .             .         .             .         .     .          os << "total_propagation_time: " << total_duration.count() << "\n";
             .      .     .              .             .         .             .         .     .          os << "total_work_time: "<< total_work_time.count()<<"\n";
-- line 134 ----------------------------------------
-- line 137 ----------------------------------------
             .      .     .              .             .         .             .         .     .          os<<"total_watch_access: "<<total_watch_access<<"\n";
             .      .     .              .             .         .             .         .     .          os<<"total_clause_access_times: "<<total_clause_access_times<<"\n";
             .      .     .              .             .         .             .         .     .          os<<"total_clause_access_size: "<<total_clause_access_size<<"\n";
             .      .     .              .             .         .             .         .     .          os<<"total_change_other_watch: "<<total_change_other_watch<<"\n";
             .      .     .              .             .         .             .         .     .          os<<"total_push_new_implication: "<<total_push_new_implication<<"\n";
             .      .     .              .             .         .             .         .     .          os<<"total_no_clause_access: "<<total_no_clause_access<<"\n";
             .      .     .              .             .         .             .         .     .          os<<"total_no_implication_added: "<<total_no_implication_added<<"\n";
             .      .     .              .             .         .             .         .     .          os<<"total_no_change_other_watch: "<<total_no_change_other_watch<<"\n";
             6      0     0              4             0         0             0         0     0      }
             .      .     .              .             .         .             .         .     .      using ull=unsigned long long;
             .      .     .              .             .         .             .         .     .      ull total_Watchers = 0;
             .      .     .              .             .         .             .         .     .      ull total_act_watchers = 0;
             .      .     .              .             .         .             .         .     .      ull total_indexs = 0;
             .      .     .              .             .         .             .         .     .      ull time_find_conflict = 0;
             .      .     .              .             .         .             .         .     .      ull total_find_conflict_length = 0;
             .      .     .              .             .         .             .         .     .      ull total_find_conflict_allsize = 0;
             .      .     .              .             .         .             .         .     .      ull total_access_clause=0;
-- line 153 ----------------------------------------
-- line 310 ----------------------------------------
             .      .     .              .             .         .             .         .     .      {
             .      .     .              .             .         .             .         .     .          const ClauseAllocator& ca;
             .      .     .              .             .         .             .         .     .          WatcherDeleted(const ClauseAllocator& _ca) : ca(_ca) {}
             .      .     .              .             .         .             .         .     .          bool operator()(const Watcher& w) const { return ca[w.cref].mark() == 1; }
             .      .     .              .             .         .             .         .     .      };
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .      struct VarOrderLt {
             .      .     .              .             .         .             .         .     .          const vec<double>&  activity;
19,372,811,421  3,288   632 12,666,189,457 2,983,261,269 2,293,843   306,452,580         0     0          bool operator () (Var x, Var y) const { return activity[x] > activity[y]; }
             .      .     .              .             .         .             .         .     .          VarOrderLt(const vec<double>&  act) : activity(act) { }
             .      .     .              .             .         .             .         .     .      };
             .      .     .              .             .         .             .         .     .      
             .      .     .              .             .         .             .         .     .      struct ConflictData
             .      .     .              .             .         .             .         .     .  	{
             .      .     .              .             .         .             .         .     .  		ConflictData() :
             .      .     .              .             .         .             .         .     .  			nHighestLevel(-1),
             .      .     .              .             .         .             .         .     .  			bOnlyOneLitFromHighest(false)
-- line 326 ----------------------------------------
-- line 404 ----------------------------------------
             .      .     .              .             .         .             .         .     .      Lit      pickBranchLit    ();                                                      // Return the next decision variable.
             .      .     .              .             .         .             .         .     .      void     newDecisionLevel ();                                                      // Begins a new decision level.
             .      .     .              .             .         .             .         .     .      void     uncheckedEnqueue (Lit p, int level = 0, CRef from = CRef_Undef);                         // Enqueue a literal. Assumes value of literal is undefined.
             .      .     .              .             .         .             .         .     .      bool     enqueue          (Lit p, CRef from = CRef_Undef);                         // Test if fact 'p' contradicts current state, enqueue otherwise.
             .      .     .              .             .         .             .         .     .      CRef     propagate_        ();                                                      // Perform unit propagation. Returns possibly conflicting clause.
             .      .     .              .             .         .             .         .     .      std::chrono::nanoseconds total_duration;
             .      .     .              .             .         .             .         .     .      CRef     propagate(){
             .      .     .              .             .         .             .         .     .  
    52,115,016 37,876   803              0             0         0    26,057,508         1     0          auto start_time=std::chrono::steady_clock::now();
    78,172,524      0     0              0             0         0    26,057,508         0     0          auto ref= propagate_();
    26,057,508      1     1              0             0         0    26,057,508         0     0          auto end_time=std::chrono::steady_clock::now();
             .      .     .              .             .         .             .         .     .          auto duration=end_time-start_time;
             .      .     .              .             .         .             .         .     .          total_duration+=duration;
             .      .     .              .             .         .             .         .     .          return ref;
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .      }
             .      .     .              .             .         .             .         .     .      void     cancelUntil      (int level);                                             // Backtrack until a certain level.
             .      .     .              .             .         .             .         .     .      void     analyze          (CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd);    // (bt = backtrack)
             .      .     .              .             .         .             .         .     .      void     analyzeFinal     (Lit p, vec<Lit>& out_conflict);                         // COULD THIS BE IMPLEMENTED BY THE ORDINARIY "analyze" BY SOME REASONABLE GENERALIZATION?
-- line 422 ----------------------------------------
-- line 461 ----------------------------------------
             .      .     .              .             .         .             .         .     .      
             .      .     .              .             .         .             .         .     .  public:
             .      .     .              .             .         .             .         .     .      int      level            (Var x) const;
             .      .     .              .             .         .             .         .     .  protected:
             .      .     .              .             .         .             .         .     .      double   progressEstimate ()      const; // DELETE THIS ?? IT'S NOT VERY USEFUL ...
             .      .     .              .             .         .             .         .     .      bool     withinBudget     ()      const;
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .      template<class V> int computeLBD(const V& c) {
   579,133,830     75    73              0             0         0             0         0     0          int lbd = 0;
             .      .     .              .             .         .             .         .     .  
    35,398,480     81    80     29,423,655    12,774,032       460             0         0     0          counter++;
 2,945,351,875      0     0      5,998,541             0         0             0         0     0          for (int i = 0; i < c.size(); i++){
             .      .     .              .             .         .             .         .     .              int l = level(var(c[i]));
 7,172,031,836      0     0  2,868,805,980   104,621,514    15,273             0         0     0              if (l != 0 && seen2[l] != counter){
   426,958,115      0     0              0             0         0   426,958,115         0     0                  seen2[l] = counter;
   934,287,391      0     0              0             0         0             0         0     0                  lbd++; } }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .          return lbd;
             .      .     .              .             .         .             .         .     .      }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  #ifdef BIN_DRUP
             .      .     .              .             .         .             .         .     .      static int buf_len;
             .      .     .              .             .         .             .         .     .      static unsigned char drup_buf[];
             .      .     .              .             .         .             .         .     .      static unsigned char* buf_ptr;
-- line 484 ----------------------------------------
-- line 493 ----------------------------------------
             .      .     .              .             .         .             .         .     .      }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .      template<class V>
             .      .     .              .             .         .             .         .     .      static inline void binDRUP(unsigned char op, const V& c, FILE* drup_file){
             .      .     .              .             .         .             .         .     .          assert(op == 'a' || op == 'd');
             .      .     .              .             .         .             .         .     .          *buf_ptr++ = op; buf_len++;
             .      .     .              .             .         .             .         .     .          for (int i = 0; i < c.size(); i++) byteDRUP(c[i]);
             .      .     .              .             .         .             .         .     .          *buf_ptr++ = 0; buf_len++;
       370,451     75    75              0             0         0       370,451         0     0          if (buf_len > 1048576) binDRUP_flush(drup_file);
             .      .     .              .             .         .             .         .     .      }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .      static inline void binDRUP_strengthen(const Clause& c, Lit l, FILE* drup_file){
             .      .     .              .             .         .             .         .     .          *buf_ptr++ = 'a'; buf_len++;
             .      .     .              .             .         .             .         .     .          for (int i = 0; i < c.size(); i++)
             .      .     .              .             .         .             .         .     .              if (c[i] != l) byteDRUP(c[i]);
             .      .     .              .             .         .             .         .     .          *buf_ptr++ = 0; buf_len++;
             .      .     .              .             .         .             .         .     .          if (buf_len > 1048576) binDRUP_flush(drup_file);
-- line 509 ----------------------------------------
-- line 571 ----------------------------------------
             .      .     .              .             .         .             .         .     .      double    my_var_decay;
             .      .     .              .             .         .             .         .     .      bool   DISTANCE;
             .      .     .              .             .         .             .         .     .  };
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  //=================================================================================================
             .      .     .              .             .         .             .         .     .  // Implementation of inline methods:
             .      .     .              .             .         .             .         .     .  
 3,522,635,080      0     0  3,522,635,080   190,639,903 1,905,343             0         0     0  inline CRef Solver::reason(Var x) const { return vardata[x].reason; }
26,368,669,650    126   119 21,670,019,467 6,595,456,549   235,446 4,676,604,112         0     0  inline int  Solver::level (Var x) const { return vardata[x].level; }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  inline void Solver::insertVarOrder(Var x) {
             .      .     .              .             .         .             .         .     .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
33,212,279,178 12,926 1,007 10,218,171,830     4,943,776         0             0         0     0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
   294,899,817      1     1    196,599,878    74,396,730   596,533             0         0     0      if (!order_heap.inHeap(x) && decision[x]) order_heap.insert(x); }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  inline void Solver::varDecayActivity() {
    13,791,748      0     0      6,895,874     2,943,508        39     3,447,937         0     0      var_inc *= (1 / var_decay); }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  inline void Solver::varBumpActivity(Var v, double mult) {
 3,687,939,940     30    29  2,216,484,849   425,776,177   417,282   552,627,506         0     0      if ( (activity_VSIDS[v] += var_inc * mult) > 1e100 ) {
             .      .     .              .             .         .             .         .     .          // Rescale:
         7,962    384   370              1             0         0             0         0     0          for (int i = 0; i < nVars(); i++)
   100,722,656      0     0     25,180,664     6,288,355   846,936    25,180,664         0     0              activity_VSIDS[i] *= 1e-100;
         1,592      0     0            796           796         0           796         0     0          var_inc *= 1e-100; }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .      // Update order_heap with respect to new activity:
   342,425,306      0     0              0             0         0             0         0     0      if (order_heap_VSIDS.inHeap(v)) order_heap_VSIDS.decrease(v); }
             .      .     .              .             .         .             .         .     .  
    23,899,300  1,579   235     11,949,650         5,183         1     5,974,825         0     0  inline void Solver::claDecayActivity() { cla_inc *= (1 / clause_decay); }
             .      .     .              .             .         .             .         .     .  inline void Solver::claBumpActivity (Clause& c) {
   171,414,138 26,647 1,043     51,141,887    13,856,865     3,337    17,282,591     9,286 5,314      if ( (c.activity() += cla_inc) > 1e20 ) {
             .      .     .              .             .         .             .         .     .          // Rescale:
     8,427,129    129   129            387             0         0             0         0     0          for (int i = 0; i < learnts_local.size(); i++)
    19,660,893      6     2      2,808,699     2,604,599   666,264     2,808,699         0     0              ca[learnts_local[i]].activity() *= 1e-20;
     1,412,159    591   588        705,886             0         0           129       129     0          cla_inc *= 1e-20; } }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  inline void Solver::checkGarbage(void){ return checkGarbage(garbage_frac); }
             .      .     .              .             .         .             .         .     .  inline void Solver::checkGarbage(double gf){
       511,488    222     1        170,496           830        47             0         0     0      if (ca.wasted() > ca.size() * gf)
         1,115      1     1            558           558       280             1         0     0          garbageCollect(); }
             .      .     .              .             .         .             .         .     .  
             .      .     .              .             .         .             .         .     .  // NOTE: enqueue does not set the ok flag! (only public methods do)
         4,133      0     0              0             0         0           205         0     0  inline bool     Solver::enqueue         (Lit p, CRef from)      { return value(p) != l_Undef ? value(p) != l_False : (uncheckedEnqueue(p, decisionLevel(), from), true); }
             .      .     .              .             .         .             .         .     .  inline bool     Solver::addClause       (const vec<Lit>& ps)    { ps.copyTo(add_tmp); return addClause_(add_tmp); }
             .      .     .              .             .         .             .         .     .  inline bool     Solver::addEmptyClause  ()                      { add_tmp.clear(); return addClause_(add_tmp); }
             .      .     .              .             .         .             .         .     .  inline bool     Solver::addClause       (Lit p)                 { add_tmp.clear(); add_tmp.push(p); return addClause_(add_tmp); }
             .      .     .              .             .         .             .         .     .  inline bool     Solver::addClause       (Lit p, Lit q)          { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); return addClause_(add_tmp); }
             .      .     .              .             .         .             .         .     .  inline bool     Solver::addClause       (Lit p, Lit q, Lit r)   { add_tmp.clear(); add_tmp.push(p); add_tmp.push(q); add_tmp.push(r); return addClause_(add_tmp); }
             .      .     .              .             .         .             .         .     .  inline bool     Solver::locked          (const Clause& c) const {
    80,369,528    398   397     26,430,251       645,409        36             0         0     0      int i = c.size() != 2 ? 0 : (value(c[0]) == l_True ? 0 : 1);
    74,496,587    498   497     21,272,024     6,563,341     2,300             0         0     0      return value(c[i]) == l_True && reason(var(c[i])) != CRef_Undef && ca.lea(reason(var(c[i]))) == &c;
             .      .     .              .             .         .             .         .     .  }
    40,007,329      1     1     20,003,655             0         0             0         0     0  inline void     Solver::newDecisionLevel()                      { trail_lim.push(trail.size()); }
             .      .     .              .             .         .             .         .     .  
    12,375,597      2     2      6,218,945            70         0     6,156,652         0     0  inline int      Solver::decisionLevel ()      const   { return trail_lim.size(); }
 9,662,770,776  3,645   694    768,432,610   469,253,512         0             0         0     0  inline uint32_t Solver::abstractLevel (Var x) const   { return 1 << (level(x) & 31); }
   103,202,698      1     1    103,202,682       117,272       282             0         0     0  inline lbool    Solver::value         (Var x) const   { return assigns[x]; }
44,659,117,978     75    75 44,659,117,978        99,569         0             0         0     0  inline lbool    Solver::value         (Lit p) const   { return assigns[var(p)] ^ sign(p); }
             .      .     .              .             .         .             .         .     .  inline lbool    Solver::modelValue    (Var x) const   { return model[x]; }
             .      .     .              .             .         .             .         .     .  inline lbool    Solver::modelValue    (Lit p) const   { return model[var(p)] ^ sign(p); }
             .      .     .              .             .         .             .         .     .  inline int      Solver::nAssigns      ()      const   { return trail.size(); }
             3      0     0              2             0         0             1         1     0  inline int      Solver::nClauses      ()      const   { return clauses.size(); }
             .      .     .              .             .         .             .         .     .  inline int      Solver::nLearnts      ()      const   { return learnts_core.size() + learnts_tier2.size() + learnts_local.size(); }
    56,124,050      2     1        191,537         1,502         0             1         0     0  inline int      Solver::nVars         ()      const   { return vardata.size(); }
             6      1     1              3             2         1             0         0     0  inline int      Solver::nFreeVars     ()      const   { return (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]); }
             .      .     .              .             .         .             .         .     .  inline void     Solver::setPolarity   (Var v, bool b) { polarity[v] = b; }
             .      .     .              .             .         .             .         .     .  inline void     Solver::setDecisionVar(Var v, bool b) 
             .      .     .              .             .         .             .         .     .  { 
       379,608      0     0        189,804         1,068         0             0         0     0      if      ( b && !decision[v]) dec_vars++;
        86,088      0     0         57,392        16,392     1,011             0         0     0      else if (!b &&  decision[v]) dec_vars--;
             .      .     .              .             .         .             .         .     .  
        91,964      0     0              0             0         0        91,964         0     0      decision[v] = b;
             .      .     .              .             .         .             .         .     .      if (b && !order_heap_CHB.inHeap(v)){
             .      .     .              .             .         .             .         .     .          order_heap_CHB.insert(v);
             .      .     .              .             .         .             .         .     .          order_heap_VSIDS.insert(v);
             .      .     .              .             .         .             .         .     .          order_heap_distance.insert(v);}
             .      .     .              .             .         .             .         .     .  }
             .      .     .              .             .         .             .         .     .  inline void     Solver::setConfBudget(int64_t x){ conflict_budget    = conflicts    + x; }
             .      .     .              .             .         .             .         .     .  inline void     Solver::setPropBudget(int64_t x){ propagation_budget = propagations + x; }
             .      .     .              .             .         .             .         .     .  inline void     Solver::interrupt(){ asynch_interrupt = true; }
-- line 651 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../core/SolverTypes.h
--------------------------------------------------------------------------------
Ir              I1mr   ILmr  Dr             D1mr          DLmr       Dw             D1mw          DLmw       

-- line 54 ----------------------------------------
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  struct Lit {
              .      .     .              .             .          .              .             .          .      int     x;
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      // Use this as a constructor:
              .      .     .              .             .          .              .             .          .      friend Lit mkLit(Var var, bool sign );
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      bool operator == (Lit p) const { return x == p.x; }
  1,335,663,752      0     0    672,606,402   333,871,347  2,310,695              0             0          0      bool operator != (Lit p) const { return x != p.x; }
              .      .     .              .             .          .              .             .          .      bool operator <  (Lit p) const { return x < p.x;  } // '<' makes p, ~p adjacent in the ordering.
              .      .     .              .             .          .              .             .          .  };
              .      .     .              .             .          .              .             .          .  
      3,324,605      1     1              0             0          0         28,696             0          0  inline  Lit  mkLit     (Var var, bool sign= false) { Lit p; p.x = var + var + (int)sign; return p; }
 37,933,310,267    100    83  8,646,376,510       354,557     64,525  8,230,503,817     3,339,104          0  inline  Lit  operator ~(Lit p)              { Lit q; q.x = p.x ^ 1; return q; }
              .      .     .              .             .          .              .             .          .  inline  Lit  operator ^(Lit p, bool b)      { Lit q; q.x = p.x ^ (unsigned int)b; return q; }
173,733,676,169     85    66 20,539,165,676         3,894          0 10,271,953,120 3,552,072,638    506,135  inline  bool sign      (Lit p)              { return p.x & 1; }
310,714,924,463 16,778 1,735 24,769,529,494   594,179,101    443,541 42,899,983,635             0          0  inline  int  var       (Lit p)              { return p.x >> 1; }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  // Mapping Literals to and from compact integers suitable for array indexing:
              .      .     .              .             .          .              .             .          .  inline  int  toInt     (Var v)              { return v; } 
         36,486      1     1          2,240             0          0          2,240            72         67  inline  int  toInt     (Lit p)              { return p.x; } 
              .      .     .              .             .          .              .             .          .  inline  Lit  toLit     (int i)              { Lit p; p.x = i; return p; } 
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  //const Lit lit_Undef = mkLit(var_Undef, false);  // }- Useful special constants.
              .      .     .              .             .          .              .             .          .  //const Lit lit_Error = mkLit(var_Undef, true );  // }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  const Lit lit_Undef = { -2 };  // }- Useful special constants.
              .      .     .              .             .          .              .             .          .  const Lit lit_Error = { -1 };  // }
              .      .     .              .             .          .              .             .          .  
-- line 82 ----------------------------------------
-- line 101 ----------------------------------------
              .      .     .              .             .          .              .             .          .  #define l_Undef (lbool((uint8_t)2))
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  class lbool {
              .      .     .              .             .          .              .             .          .      uint8_t value;
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  public:
              .      .     .              .             .          .              .             .          .      explicit lbool(uint8_t v) : value(v) { }
              .      .     .              .             .          .              .             .          .  
         15,831      1     1              0             0          0          3,958           988        987      lbool()       : value(0) { }
              .      .     .              .             .          .              .             .          .      explicit lbool(bool x) : value(!x) { }
              .      .     .              .             .          .              .             .          .  
  2,462,372,997      1     1              0             0          0              0             0          0      bool  operator == (lbool b) const { return ((b.value&2) & (value&2)) | (!(b.value&2)&(value == b.value)); }
        189,804      0     0        126,536           990          0              0             0          0      bool  operator != (lbool b) const { return !(*this == b); }
 48,798,152,008     75    73 47,253,413,788 9,870,297,763    223,229              0             0          0      lbool operator ^  (bool  b) const { return lbool((uint8_t)(value^(uint8_t)b)); }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      lbool operator && (lbool b) const {
              .      .     .              .             .          .              .             .          .          uint8_t sel = (this->value << 1) | (b.value << 3);
              .      .     .              .             .          .              .             .          .          uint8_t v   = (0xF7F755F4 >> sel) & 3;
              .      .     .              .             .          .              .             .          .          return lbool(v); }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      lbool operator || (lbool b) const {
              .      .     .              .             .          .              .             .          .          uint8_t sel = (this->value << 1) | (b.value << 3);
-- line 122 ----------------------------------------
-- line 148 ----------------------------------------
              .      .     .              .             .          .              .             .          .          unsigned simplified : 1;}                            header;
              .      .     .              .             .          .              .             .          .      union { Lit lit; float act; uint32_t abs; uint32_t touched; CRef rel; } data[0];
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      friend class ClauseAllocator;
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      // NOTE: This constructor cannot be used directly (doesn't allocate enough memory).
              .      .     .              .             .          .              .             .          .      template<class V>
              .      .     .              .             .          .              .             .          .      Clause(const V& ps, bool use_extra, bool learnt) {
    516,442,248      0     0    127,616,951             0          0    133,591,394       368,790          9          header.mark      = 0;
    381,415,716      1     1    127,138,572     7,946,009  7,862,391              0             0          0          header.learnt    = learnt;
    766,180,085      2     2    128,095,330            12          0    127,616,951             0          0          header.has_extra = learnt | use_extra;
              .      .     .              .             .          .              .             .          .          header.reloced   = 0;
    140,044,214      0     0      6,452,821           165        163    133,591,393     5,982,635    806,763          header.size      = ps.size();
              .      .     .              .             .          .              .             .          .          header.lbd       = 0;
              .      .     .              .             .          .              .             .          .          header.removable = 1;
              .      .     .              .             .          .              .             .          .          //simplify
              .      .     .              .             .          .              .             .          .          //
    133,591,394     10    10    133,591,394    16,295,137 16,131,414              0             0          0          header.simplified = 0;
              .      .     .              .             .          .              .             .          .  
  4,708,273,393    430   430      8,486,538             0          0              0             0          0          for (int i = 0; i < ps.size(); i++)
  2,188,349,036    639   410    699,203,929    83,152,951 31,190,805    979,901,770    96,867,968 95,997,848              data[i].lit = ps[i];
              .      .     .              .             .          .              .             .          .  
    400,774,181    255   255    133,591,393             0          0              0             0          0          if (header.has_extra){
    110,013,644      0     0              0             0          0              0             0          0              if (header.learnt){
    108,484,212      1     1     48,267,616             0          0     54,242,106     3,386,479  3,363,977                  data[header.size].act = 0;
    108,484,259      0     0              0             0          0     54,242,106     3,389,976  3,367,164                  data[header.size+1].touched = 0;
              .      .     .              .             .          .              .             .          .              }else
              .      .     .              .             .          .              .             .          .                  calcAbstraction(); }
              .      .     .              .             .          .              .             .          .      }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  public:
              .      .     .              .             .          .              .             .          .      void calcAbstraction() {
              .      .     .              .             .          .              .             .          .          assert(header.has_extra);
        819,967      0     0              0             0          0              0             0          0          uint32_t abstraction = 0;
     14,722,315      4     4        291,437             0          0              0             0          0          for (int i = 0; i < size(); i++)
     23,320,327      3     3              0             0          0              1             0          0              abstraction |= 1 << (var(data[i].lit) & 31);
      2,432,358      0     0        286,337             0          0      1,094,969        47,278     47,278          data[header.size].abs = abstraction;  }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
 35,013,530,057    440   407 14,499,628,216 3,595,494,836 20,144,594  9,696,147,718            73          0      int          size        ()      const   { return header.size; }
      5,302,352     68    66      1,329,752       199,642      1,103      1,329,752        12,577          0      void         shrink      (int i)         { assert(i <= size()); if (header.has_extra) data[header.size-i] = data[header.size]; header.size -= i; }
              .      .     .              .             .          .              .             .          .      void         pop         ()              { shrink(1); }
    484,466,103      4     4      6,192,153           315          0              0             0          0      bool         learnt      ()      const   { return header.learnt; }
        395,280      0     0              0             0          0              0             0          0      bool         has_extra   ()      const   { return header.has_extra; }
  1,035,456,808    596   510    261,510,256   224,646,475 35,881,781    128,868,332             0          0      uint32_t     mark        ()      const   { return header.mark; }
    542,475,126    658   591    136,088,676       119,103          0    135,238,352             0          0      void         mark        (uint32_t m)    { header.mark = m; }
        570,604      0     0              0             0          0        285,302             0          0      const Lit&   last        ()      const   { return data[header.size-1].lit; }
              .      .     .              .             .          .              .             .          .  
    384,949,944      0     0    384,949,944   213,836,689 40,763,215              0             0          0      bool         reloced     ()      const   { return header.reloced; }
              .      .     .              .             .          .              .             .          .      CRef         relocation  ()      const   { return data[0].rel; }
    508,554,288    145   145    127,138,572             0          0    254,277,144             0          0      void         relocate    (CRef c)        { header.reloced = 1; data[0].rel = c; }
              .      .     .              .             .          .              .             .          .  
     52,553,586      0     0     17,456,536        87,734          0              0             0          0      int          lbd         ()      const   { return header.lbd; }
    353,054,797    365   352    104,478,371             0          0     56,216,139             0          0      void         set_lbd     (int lbd)       { header.lbd = lbd; }
              .      .     .              .             .          .              .             .          .      bool         removable   ()      const   { return header.removable; }
    296,806,128      2     2    103,735,476             0          0     48,267,663             0          0      void         removable   (bool b)        { header.removable = b; }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      // NOTE: somewhat unsafe to change the clause in-place! Must manually call 'calcAbstraction' afterwards for
              .      .     .              .             .          .              .             .          .      //       subsumption operations to behave correctly.
 29,448,502,739    331   296 29,196,473,307 2,306,263,304 31,363,667              0             0          0      Lit&         operator [] (int i)         { return data[i].lit; }
  2,671,372,189  1,859 1,365  2,436,189,265   158,632,528 17,331,640              0             0          0      Lit          operator [] (int i) const   { return data[i].lit; }
              .      .     .              .             .          .              .             .          .      operator const Lit* (void) const         { return (Lit*)data; }
              .      .     .              .             .          .              .             .          .  
     48,958,431      0     0     48,958,431             0          0              0             0          0      uint32_t&    touched     ()              { assert(header.has_extra && header.learnt); return data[header.size+1].touched; }
     26,106,250      0     0      7,983,894     1,973,381    298,163              0             0          0      float&       activity    ()              { assert(header.has_extra); return data[header.size].act; }
              .      .     .              .             .          .              .             .          .      uint32_t     abstraction () const        { assert(header.has_extra); return data[header.size].abs; }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      Lit          subsumes    (const Clause& other) const;
              .      .     .              .             .          .              .             .          .      void         strengthen  (Lit p);
              .      .     .              .             .          .              .             .          .      // simplify
              .      .     .              .             .          .              .             .          .      //
    339,343,247     43    43     97,270,129             0          0     48,267,663             0          0      void setSimplified(bool b) { header.simplified = b; }
              .      .     .              .             .          .              .             .          .      bool simplified() { return header.simplified; }
              .      .     .              .             .          .              .             .          .  };
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  //=================================================================================================
              .      .     .              .             .          .              .             .          .  // ClauseAllocator -- a simple class for allocating memory for clauses:
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  const CRef CRef_Undef = RegionAllocator<uint32_t>::Ref_Undef;
              .      .     .              .             .          .              .             .          .  class ClauseAllocator : public RegionAllocator<uint32_t>
              .      .     .              .             .          .              .             .          .  {
              .      .     .              .             .          .              .             .          .      static int clauseWord32Size(int size, int extras){
    266,635,967     54    52    133,044,527     6,858,964  3,866,526              0             0          0          return (sizeof(Clause) + (sizeof(Lit) * (size + extras))) / sizeof(uint32_t); }
              .      .     .              .             .          .              .             .          .  public:
              .      .     .              .             .          .              .             .          .      bool extra_clause_field;
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      ClauseAllocator(uint32_t start_cap) : RegionAllocator<uint32_t>(start_cap), extra_clause_field(false){}
              1      0     0              0             0          0              1             0          0      ClauseAllocator() : extra_clause_field(false){}
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      void moveTo(ClauseAllocator& to){
            560    244   244            280             1          0            280             0          0          to.extra_clause_field = extra_clause_field;
              .      .     .              .             .          .              .             .          .          RegionAllocator<uint32_t>::moveTo(to); }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      template<class Lits>
              .      .     .              .             .          .              .             .          .      CRef alloc(const Lits& ps, bool learnt = false)
              .      .     .              .             .          .              .             .          .      {
              .      .     .              .             .          .              .             .          .          assert(sizeof(Lit)      == sizeof(uint32_t));
              .      .     .              .             .          .              .             .          .          assert(sizeof(float)    == sizeof(uint32_t));
    333,626,431    484   484     79,349,287         1,173         37              0             0          0          int extras = learnt ? 2 : (int)extra_clause_field;
              .      .     .              .             .          .              .             .          .  
      6,931,199      0     0              0             0          0        478,378             0          0          CRef cid = RegionAllocator<uint32_t>::alloc(clauseWord32Size(ps.size(), extras));
              .      .     .              .             .          .              .             .          .          new (lea(cid)) Clause(ps, extra_clause_field, learnt);
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .          return cid;
              .      .     .              .             .          .              .             .          .      }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
    733,057,772    398   398    710,238,556       142,171        278        488,256             0          0      Clause&       operator[](Ref r)       { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
        372,704      2     2        186,352           166          0              0             0          0      const Clause& operator[](Ref r) const { return (Clause&)RegionAllocator<uint32_t>::operator[](r); }
    127,138,572      0     0    127,138,572             0          0              0             0          0      Clause*       lea       (Ref r)       { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .      .     .              .             .          .              .             .          .      const Clause* lea       (Ref r) const { return (Clause*)RegionAllocator<uint32_t>::lea(r); }
              .      .     .              .             .          .              .             .          .      Ref           ael       (const Clause* t){ return RegionAllocator<uint32_t>::ael((uint32_t*)t); }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      void free(CRef cid)
              .      .     .              .             .          .              .             .          .      {
              .      .     .              .             .          .              .             .          .          Clause& c = operator[](cid);
     18,112,728    112    95              0             0          0              0             0          0          int extras = c.learnt() ? 2 : (int)c.has_extra();
              .      .     .              .             .          .              .             .          .          RegionAllocator<uint32_t>::free(clauseWord32Size(c.size(), extras));
              .      .     .              .             .          .              .             .          .      }
              .      .     .              .             .          .              .             .          .  
    594,633,697    279   279              0             0          0    509,686,026           554        278      void reloc(CRef& cr, ClauseAllocator& to)
              .      .     .              .             .          .              .             .          .      {
              .      .     .              .             .          .              .             .          .          Clause& c = operator[](cr);
              .      .     .              .             .          .              .             .          .          
  1,329,826,933      0     0    257,811,372    42,060,968  6,185,562    257,811,372             0          0          if (c.reloced()) { cr = c.relocation(); return; }
              .      .     .              .             .          .              .             .          .          
    127,138,573      0     0              1             0          0    127,138,572             0          0          cr = to.alloc(c, c.learnt());
              .      .     .              .             .          .              .             .          .          c.relocate(cr);
              .      .     .              .             .          .              .             .          .          
              .      .     .              .             .          .              .             .          .          // Copy extra data-fields:
              .      .     .              .             .          .              .             .          .          // (This could be cleaned-up. Generalize Clause-constructor to be applicable here instead?)
              .      .     .              .             .          .              .             .          .          to[cr].mark(c.mark());
    254,277,144      1     1              0             0          0              0             0          0          if (to[cr].learnt()){
    193,070,652      0     0     48,267,663     2,422,753  1,154,442     48,267,663             0          0              to[cr].touched() = c.touched();
    193,070,605      0     0     96,535,326     2,430,065  1,172,009     48,267,663             0          0              to[cr].activity() = c.activity();
              .      .     .              .             .          .              .             .          .              to[cr].set_lbd(c.lbd());
              .      .     .              .             .          .              .             .          .              to[cr].removable(c.removable());
              .      .     .              .             .          .              .             .          .              // simplify
              .      .     .              .             .          .              .             .          .              //
              .      .     .              .             .          .              .             .          .              to[cr].setSimplified(c.simplified());
              .      .     .              .             .          .              .             .          .          }
    157,741,818    560   560              0             0          0              0             0          0          else if (to[cr].has_extra()) to[cr].calcAbstraction();
    679,581,368      0     0    594,633,697             0          0              0             0          0      }
              .      .     .              .             .          .              .             .          .  };
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  inline std::ostream& operator<<(std::ostream& out, const Clause& cls) 
              .      .     .              .             .          .              .             .          .  {
              .      .     .              .             .          .              .             .          .      for (int i = 0; i < cls.size(); ++i)
              .      .     .              .             .          .              .             .          .      {
              .      .     .              .             .          .              .             .          .  		out << cls[i] << " ";
-- line 300 ----------------------------------------
-- line 310 ----------------------------------------
              .      .     .              .             .          .              .             .          .  class OccLists
              .      .     .              .             .          .              .             .          .  {
              .      .     .              .             .          .              .             .          .      vec<Vec>  occs;
              .      .     .              .             .          .              .             .          .      vec<char> dirty;
              .      .     .              .             .          .              .             .          .      vec<Idx>  dirties;
              .      .     .              .             .          .              .             .          .      Deleted   deleted;
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  public:
              3      0     0              0             0          0              3             0          0      OccLists(const Deleted& d) : deleted(d) {}
              .      .     .              .             .          .              .             .          .      unsigned int size(){
              .      .     .              .             .          .              .             .          .          auto m_size=0;
             64      2     2              4             3          0              0             0          0          for(int i=0;i<occs.size();i++){
      1,391,964     14    14        506,148       126,540     64,453              0             0          0              m_size+=occs[i].size();
              .      .     .              .             .          .              .             .          .          }
              .      .     .              .             .          .              .             .          .          
              .      .     .              .             .          .              .             .          .          return m_size;
              .      .     .              .             .          .              .             .          .      }
        695,948      1     1              0             0          0        126,536             0          0      void  init      (const Idx& idx){ occs.growTo(toInt(idx)+1); dirty.growTo(toInt(idx)+1, 0); }
              .      .     .              .             .          .              .             .          .      // Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
  4,986,994,602     65    50  4,986,994,602     6,433,414        163              0             0          0      Vec&  operator[](const Idx& idx){ return occs[toInt(idx)]; }
      2,054,038      1     1      1,048,613       516,943     19,302         56,222             6          0      Vec&  lookup    (const Idx& idx){ if (dirty[toInt(idx)]) clean(idx); return occs[toInt(idx)]; }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      void  cleanAll  ();
              .      .     .              .             .          .              .             .          .      void  clean     (const Idx& idx);
              .      .     .              .             .          .              .             .          .      void  smudge    (const Idx& idx){
     36,598,008      0     0     24,204,681     4,652,003    612,313              0             0          0          if (dirty[toInt(idx)] == 0){
      2,806,649    560   491              0             0          0      2,806,649             0          0              dirty[toInt(idx)] = 1;
             75      1     1              0             0          0              0             0          0              dirties.push(idx);
              .      .     .              .             .          .              .             .          .          }
              .      .     .              .             .          .              .             .          .      }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .      void  clear(bool free = true){
              .      .     .              .             .          .              .             .          .          occs   .clear(free);
              .      .     .              .             .          .              .             .          .          dirty  .clear(free);
              .      .     .              .             .          .              .             .          .          dirties.clear(free);
              .      .     .              .             .          .              .             .          .      }
              .      .     .              .             .          .              .             .          .  };
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  template<class Idx, class Vec, class Deleted>
         12,948      0     0              0             0          0          9,711            91          0  void OccLists<Idx,Vec,Deleted>::cleanAll()
              .      .     .              .             .          .              .             .          .  {
    252,011,500  1,565   191    123,144,190     1,020,949         11              0             0          0      for (int i = 0; i < dirties.size(); i++)
              .      .     .              .             .          .              .             .          .          // Dirties may contain duplicates so check here if a variable is already cleaned:
      8,419,947      0     0      5,613,298     2,523,525      3,995              0             0          0          if (dirty[toInt(dirties[i])])
              .      .     .              .             .          .              .             .          .              clean(dirties[i]);
              .      .     .              .             .          .              .             .          .      dirties.clear();
         12,948      0     0         12,948           829          1              0             0          0  }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  template<class Idx, class Vec, class Deleted>
              .      .     .              .             .          .              .             .          .  void OccLists<Idx,Vec,Deleted>::clean(const Idx& idx)
              .      .     .              .             .          .              .             .          .  {
              .      .     .              .             .          .              .             .          .      Vec& vec = occs[toInt(idx)];
              .      .     .              .             .          .              .             .          .      int  i, j;
    526,553,726      2     2     10,630,452     2,727,659    171,055              0             0          0      for (i = j = 0; i < vec.size(); i++)
    338,100,497      0     0      5,873,074       295,308    140,768              0             0          0          if (!deleted(vec[i]))
  1,059,204,834      6     4    299,613,623            17          0    151,786,396         7,719          0              vec[j++] = vec[i];
      2,730,700    555   488              0             0          0              0             0          0      vec.shrink(i - j);
     11,333,178      0     0      5,613,298        77,748          0      2,824,462        39,555          0      dirty[toInt(idx)] = 0;
              .      .     .              .             .          .              .             .          .  }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  //=================================================================================================
              .      .     .              .             .          .              .             .          .  // CMap -- a class for mapping clauses to values:
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .  template<class T>
-- line 377 ----------------------------------------
-- line 426 ----------------------------------------
              .      .     .              .             .          .              .             .          .  |       p          - The literal p can be deleted from 'other'
              .      .     .              .             .          .              .             .          .  |________________________________________________________________________________________________@*/
              .      .     .              .             .          .              .             .          .  inline Lit Clause::subsumes(const Clause& other) const
              .      .     .              .             .          .              .             .          .  {
              .      .     .              .             .          .              .             .          .      //if (other.size() < size() || (extra.abst & ~other.extra.abst) != 0)
              .      .     .              .             .          .              .             .          .      //if (other.size() < size() || (!learnt() && !other.learnt() && (extra.abst & ~other.extra.abst) != 0))
              .      .     .              .             .          .              .             .          .      assert(!header.learnt);   assert(!other.header.learnt);
              .      .     .              .             .          .              .             .          .      assert(header.has_extra); assert(other.header.has_extra);
    736,181,223      0     0    245,393,741    31,208,730      1,352              0             0          0      if (other.header.size < header.size || (data[header.size].abs & ~other.data[other.header.size].abs) != 0)
              .      .     .              .             .          .              .             .          .          return lit_Error;
              .      .     .              .             .          .              .             .          .  
      2,166,850      0     0              0             0          0              0             0          0      Lit        ret = lit_Undef;
              .      .     .              .             .          .              .             .          .      const Lit* c   = (const Lit*)(*this);
              .      .     .              .             .          .              .             .          .      const Lit* d   = (const Lit*)other;
              .      .     .              .             .          .              .             .          .  
     11,026,816      1     1      1,705,151             0          0              0             0          0      for (unsigned i = 0; i < header.size; i++) {
              .      .     .              .             .          .              .             .          .          // search for c[i] or ~c[i]
    131,748,286      2     2      2,166,850             0          0      2,166,850         7,548          0          for (unsigned j = 0; j < other.header.size; j++)
     67,381,239      0     0     14,348,240             0          0              0             0          0              if (c[i] == d[j])
              .      .     .              .             .          .              .             .          .                  goto ok;
     18,060,047      0     0              0             0          0              0             0          0              else if (ret == lit_Undef && c[i] == ~d[j]){
              .      .     .              .             .          .              .             .          .                  ret = c[i];
              .      .     .              .             .          .              .             .          .                  goto ok;
              .      .     .              .             .          .              .             .          .              }
              .      .     .              .             .          .              .             .          .  
              .      .     .              .             .          .              .             .          .          // did not find it
              .      .     .              .             .          .              .             .          .          return lit_Error;
              .      .     .              .             .          .              .             .          .  ok:;
              .      .     .              .             .          .              .             .          .      }
-- line 454 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/..//core/Solver.cc
--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr             D1mr          DLmr        Dw             D1mw          DLmw      

-- line 51 ----------------------------------------
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  //=================================================================================================
              .       .     .              .             .           .              .             .         .  // Options:
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  static const char* _cat = "CORE";
              .       .     .              .             .           .              .             .         .  
              4       0     0              0             0           0              1             0         0  static DoubleOption  opt_step_size         (_cat, "step-size",   "Initial step size",                             0.40,     DoubleRange(0, false, 1, false));
              4       0     0              0             0           0              1             0         0  static DoubleOption  opt_step_size_dec     (_cat, "step-size-dec","Step size decrement",                          0.000001, DoubleRange(0, false, 1, false));
              4       0     0              0             0           0              1             0         0  static DoubleOption  opt_min_step_size     (_cat, "min-step-size","Minimal step size",                            0.06,     DoubleRange(0, false, 1, false));
              4       1     1              0             0           0              1             0         0  static DoubleOption  opt_var_decay         (_cat, "var-decay",   "The variable activity decay factor",            0.80,     DoubleRange(0, false, 1, false));
              4       0     0              0             0           0              1             0         0  static DoubleOption  opt_clause_decay      (_cat, "cla-decay",   "The clause activity decay factor",              0.999,    DoubleRange(0, false, 1, false));
              4       0     0              0             0           0              1             0         0  static DoubleOption  opt_random_var_freq   (_cat, "rnd-freq",    "The frequency with which the decision heuristic tries to choose a random variable", 0, DoubleRange(0, true, 1, true));
              4       0     0              0             0           0              1             0         0  static DoubleOption  opt_random_seed       (_cat, "rnd-seed",    "Used by the random variable selection",         91648253, DoubleRange(0, false, HUGE_VAL, false));
              4       0     0              0             0           0              1             0         0  static IntOption     opt_ccmin_mode        (_cat, "ccmin-mode",  "Controls conflict clause minimization (0=none, 1=basic, 2=deep)", 2, IntRange(0, 2));
              4       0     0              0             0           0              1             0         0  static IntOption     opt_phase_saving      (_cat, "phase-saving", "Controls the level of phase saving (0=none, 1=limited, 2=full)", 2, IntRange(0, 2));
              4       1     1              0             0           0              1             0         0  static BoolOption    opt_rnd_init_act      (_cat, "rnd-init",    "Randomize the initial activity", false);
              4       0     0              0             0           0              1             0         0  static IntOption     opt_restart_first     (_cat, "rfirst",      "The base restart interval", 100, IntRange(1, INT32_MAX));
              4       1     1              0             0           0              1             0         0  static DoubleOption  opt_restart_inc       (_cat, "rinc",        "Restart interval increase factor", 2, DoubleRange(1, false, HUGE_VAL, false));
              4       1     1              0             0           0              1             0         0  static DoubleOption  opt_garbage_frac      (_cat, "gc-frac",     "The fraction of wasted memory allowed before a garbage collection is triggered",  0.20, DoubleRange(0, false, HUGE_VAL, false));
              4       1     1              0             0           0              1             0         0  static IntOption     opt_chrono            (_cat, "chrono",  "Controls if to perform chrono backtrack", 100, IntRange(-1, INT32_MAX));
              4       1     1              0             0           0              1             0         0  static IntOption     opt_conf_to_chrono    (_cat, "confl-to-chrono",  "Controls number of conflicts to perform chrono backtrack", 4000, IntRange(-1, INT32_MAX));
              .       .     .              .             .           .              .             .         .  
              4       1     1              0             0           0              1             0         0  static IntOption     opt_max_lbd_dup       ("DUP-LEARNTS", "lbd-limit",  "specifies the maximum lbd of learnts to be screened for duplicates.", 12, IntRange(0, INT32_MAX));
              1       1     1              0             0           0              1             0         0  static IntOption     opt_min_dupl_app      ("DUP-LEARNTS", "min-dup-app",  "specifies the minimum number of learnts to be included into db.", 3, IntRange(2, INT32_MAX));
              4       0     0              0             0           0              1             0         0  static IntOption     opt_dupl_db_init_size ("DUP-LEARNTS", "dupdb-init",  "specifies the initial maximal duplicates DB size.", 500000, IntRange(1, INT32_MAX));
              .       .     .              .             .           .              .             .         .  
              4       1     1              0             0           0              1             0         0  static IntOption     opt_VSIDS_props_limit ("DUP-LEARNTS", "VSIDS-lim",  "specifies the number of propagations after which the solver switches between LRB and VSIDS(in millions).", 30, IntRange(1, INT32_MAX));
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  //VSIDS_props_limit
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  //=================================================================================================
              .       .     .              .             .           .              .             .         .  // Constructor/Destructor:
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              4       1     1              0             0           0              2             0         0  Solver::Solver() :
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Parameters (user settable):
              .       .     .              .             .           .              .             .         .      //
              .       .     .              .             .           .              .             .         .      drup_file        (NULL)
              .       .     .              .             .           .              .             .         .    , verbosity        (0)
              .       .     .              .             .           .              .             .         .    , step_size        (opt_step_size)
              .       .     .              .             .           .              .             .         .    , step_size_dec    (opt_step_size_dec)
              .       .     .              .             .           .              .             .         .    , min_step_size    (opt_min_step_size)
-- line 95 ----------------------------------------
-- line 106 ----------------------------------------
              .       .     .              .             .           .              .             .         .    , garbage_frac     (opt_garbage_frac)
              .       .     .              .             .           .              .             .         .    , restart_first    (opt_restart_first)
              .       .     .              .             .           .              .             .         .    , restart_inc      (opt_restart_inc)
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .    , min_number_of_learnts_copies(opt_min_dupl_app)  
              .       .     .              .             .           .              .             .         .    , max_lbd_dup(opt_max_lbd_dup)
              .       .     .              .             .           .              .             .         .    , dupl_db_init_size(opt_dupl_db_init_size)
              3       1     1              1             0           0              1             0         0    , VSIDS_props_limit(opt_VSIDS_props_limit*1000000)
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .    // Parameters (the rest):
              .       .     .              .             .           .              .             .         .    //
              .       .     .              .             .           .              .             .         .    , learntsize_factor((double)1/(double)3), learntsize_inc(1.1)
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .    // Parameters (experimental):
              .       .     .              .             .           .              .             .         .    //
              .       .     .              .             .           .              .             .         .    , learntsize_adjust_start_confl (100)
-- line 122 ----------------------------------------
-- line 126 ----------------------------------------
              .       .     .              .             .           .              .             .         .    //
              .       .     .              .             .           .              .             .         .    , solves(0), starts(0), decisions(0), rnd_decisions(0), propagations(0), conflicts(0), conflicts_VSIDS(0)
              .       .     .              .             .           .              .             .         .    , dec_vars(0), clauses_literals(0), learnts_literals(0), max_literals(0), tot_literals(0)
              .       .     .              .             .           .              .             .         .    , chrono_backtrack(0), non_chrono_backtrack(0)
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .    , ok                 (true)
              .       .     .              .             .           .              .             .         .    , cla_inc            (1)
              .       .     .              .             .           .              .             .         .    , var_inc            (1)
              1       0     0              0             0           0              0             0         0    , watches_bin        (WatcherDeleted(ca))
              .       .     .              .             .           .              .             .         .    , watches            (WatcherDeleted(ca))
              .       .     .              .             .           .              .             .         .    , qhead              (0)
              .       .     .              .             .           .              .             .         .    , simpDB_assigns     (-1)
              .       .     .              .             .           .              .             .         .    , simpDB_props       (0)
              .       .     .              .             .           .              .             .         .    , order_heap_CHB     (VarOrderLt(activity_CHB))
              .       .     .              .             .           .              .             .         .    , order_heap_VSIDS   (VarOrderLt(activity_VSIDS))
              .       .     .              .             .           .              .             .         .    , progress_estimate  (0)
              .       .     .              .             .           .              .             .         .    , remove_satisfied   (true)
-- line 142 ----------------------------------------
-- line 164 ----------------------------------------
              .       .     .              .             .           .              .             .         .    // simplifyAll adjust occasion
              .       .     .              .             .           .              .             .         .    , curSimplify(1)
              .       .     .              .             .           .              .             .         .    , nbconfbeforesimplify(1000)
              .       .     .              .             .           .              .             .         .    , incSimplify(1000)
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .    , my_var_decay       (0.6)
              .       .     .              .             .           .              .             .         .    , DISTANCE           (true)
              .       .     .              .             .           .              .             .         .    , var_iLevel_inc     (1)
             94       8     8             25             2           2             63             1         0    , order_heap_distance(VarOrderLt(activity_distance))
              .       .     .              .             .           .              .             .         .  
              4       0     0              3             0           0              0             0         0  {}
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  Solver::~Solver()
              .       .     .              .             .           .              .             .         .  {
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  // simplify All
              .       .     .              .             .           .              .             .         .  //
              .       .     .              .             .           .              .             .         .  CRef Solver::simplePropagate()
     37,826,072       0     0              0             0           0     28,369,554        27,874         0  {
      4,728,259       0     0              0             0           0      4,728,259             0         0      CRef    confl = CRef_Undef;
      4,728,259       0     0              0             0           0      4,728,259             0         0      int     num_props = 0;
      9,456,518       0     0              0             0           0      4,728,259       104,602         0      watches.cleanAll();
     14,184,777      75    73      4,728,259             0           0      4,728,259             0         0      watches_bin.cleanAll();
    614,785,882       0     0    307,392,941             0           0              0             0         0      while (qhead < trail.size())
              .       .     .              .             .           .              .             .         .      {
  1,513,562,820      13    13    605,425,128     9,755,313           0    605,425,128             0         0          Lit            p = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .     .              .             .           .              .             .         .          vec<Watcher>&  ws = watches[p];
              .       .     .              .             .           .              .             .         .          Watcher        *i, *j, *end;
    302,664,682       3     2    302,664,682             0           0              0             0         0          num_props++;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          // First, Propagate binary clauses
              .       .     .              .             .           .              .             .         .          vec<Watcher>&  wbin = watches_bin[p];
              .       .     .              .             .           .              .             .         .  
  2,554,996,975       0     0    302,712,564   300,986,540     546,729              0             0         0          for (int k = 0; k<wbin.size(); k++)
              .       .     .              .             .           .              .             .         .          {
              .       .     .              .             .           .              .             .         .  
    893,761,362       0     0    600,080,229   182,843,488     913,933              0             0         0              Lit imp = wbin[k].blocker;
              .       .     .              .             .           .              .             .         .  
    893,761,362       0     0              0             0           0              0             0         0              if (value(imp) == l_False)
              .       .     .              .             .           .              .             .         .              {
         95,764       0     0         47,882             0           0         47,882             0         0                  return wbin[k].cref;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
    893,665,598      56    56              0             0           0              0             0         0              if (value(imp) == l_Undef)
              .       .     .              .             .           .              .             .         .              {
    245,236,979       0     0    245,236,979             0           0              0             0         0                  simpleUncheckEnqueue(imp, wbin[k].cref);
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
  5,971,311,204      71    69  2,150,753,215   292,846,742     227,830    521,545,887             0         0          for (i = j = (Watcher*)ws, end = i + ws.size(); i != end;)
              .       .     .              .             .           .              .             .         .          {
              .       .     .              .             .           .              .             .         .              // Try to avoid inspecting the clause:
  1,545,423,851      75    75  1,545,423,851   362,007,370   5,646,539              0             0         0              Lit blocker = i->blocker;
  3,090,847,702       0     0  1,545,423,851   295,010,405         244              0             0         0              if (value(blocker) == l_True)
              .       .     .              .             .           .              .             .         .              {
              .       .     .              .             .           .              .             .         .                  *j++ = *i++; continue;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Make sure the false literal is data[1]:
  2,075,523,900       0     0  1,037,761,950             0           0              0             0         0              CRef     cr = i->cref;
              .       .     .              .             .           .              .             .         .              Clause&  c = ca[cr];
              .       .     .              .             .           .              .             .         .              Lit      false_lit = ~p;
  3,113,285,850       0     0  1,037,761,950   914,319,305   8,396,376              0             0         0              if (c[0] == false_lit)
    719,810,769       0     0    239,936,923    12,797,329     190,989    479,873,846             0         0                  c[0] = c[1], c[1] = false_lit;
              .       .     .              .             .           .              .             .         .              assert(c[1] == false_lit);
              .       .     .              .             .           .              .             .         .              //  i++;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // If 0th watch is true, then clause is already satisfied.
              .       .     .              .             .           .              .             .         .              // However, 0th watch is not the blocker, make it blocker using a new watcher w
              .       .     .              .             .           .              .             .         .              // why not simply do i->blocker=first in this case?
              .       .     .              .             .           .              .             .         .              Lit     first = c[0];
              .       .     .              .             .           .              .             .         .              //  Watcher w     = Watcher(cr, first);
  2,380,694,580       0     0    152,585,340    20,744,418           4              0             0         0              if (first != blocker && value(first) == l_True)
              .       .     .              .             .           .              .             .         .              {
     28,230,286       0     0              0             0           0     28,230,286             0         0                  i->blocker = first;
  2,143,568,748       0     0    535,892,187             0           0    535,892,187       552,059         0                  *j++ = *i++; continue;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Look for new watch:
              .       .     .              .             .           .              .             .         .              //if (incremental)
              .       .     .              .             .           .              .             .         .              //{ // ----------------- INCREMENTAL MODE
              .       .     .              .             .           .              .             .         .              //	int choosenPos = -1;
              .       .     .              .             .           .              .             .         .              //	for (int k = 2; k < c.size(); k++)
              .       .     .              .             .           .              .             .         .              //	{
-- line 250 ----------------------------------------
-- line 274 ----------------------------------------
              .       .     .              .             .           .              .             .         .              //		Watcher w = Watcher(cr, first); i++;
              .       .     .              .             .           .              .             .         .              //		c[1] = c[choosenPos]; c[choosenPos] = false_lit;
              .       .     .              .             .           .              .             .         .              //		watches[~c[1]].push(w);
              .       .     .              .             .           .              .             .         .              //		goto NextClause;
              .       .     .              .             .           .              .             .         .              //	}
              .       .     .              .             .           .              .             .         .              //}
              .       .     .              .             .           .              .             .         .              else
              .       .     .              .             .           .              .             .         .              {  // ----------------- DEFAULT  MODE (NOT INCREMENTAL)
  3,042,308,944      75    73              0             0           0              0             0         0                  for (int k = 2; k < c.size(); k++)
              .       .     .              .             .           .              .             .         .                  {
              .       .     .              .             .           .              .             .         .  
  6,007,201,395       0     0              0             0           0              0             0         0                      if (value(c[k]) != l_False)
              .       .     .              .             .           .              .             .         .                      {
              .       .     .              .             .           .              .             .         .                          // watcher i is abandonned using i++, because cr watches now ~c[k] instead of p
              .       .     .              .             .           .              .             .         .                          // the blocker is first in the watcher. However,
              .       .     .              .             .           .              .             .         .                          // the blocker in the corresponding watcher in ~first is not c[1]
              .       .     .              .             .           .              .             .         .                          Watcher w = Watcher(cr, first); i++;
  3,769,622,740       0     0    942,405,685             0           0  1,884,811,370             0         0                          c[1] = c[k]; c[k] = false_lit;
              .       .     .              .             .           .              .             .         .                          watches[~c[1]].push(w);
    942,405,685       0     0              0             0           0              0             0         0                          goto NextClause;
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Did not find watch -- clause is unit under assignment:
     67,125,979       0     0              0             0           0     67,125,979             0         0              i->blocker = first;
    268,503,916       0     0     67,125,979             0           0     67,125,979        36,565         0              *j++ = *i++;
    134,251,958      75    73              0             0           0              0             0         0              if (value(first) == l_False)
              .       .     .              .             .           .              .             .         .              {
      1,310,513       3     3              0             0           0        218,749             0         0                  confl = cr;
        437,498      65    63        218,749           834           0        218,749             0         0                  qhead = trail.size();
              .       .     .              .             .           .              .             .         .                  // Copy the remaining watches:
      7,936,986       7     7        393,352           741           0              0             0         0                  while (i < end)
      3,356,392       0     0      3,356,392       405,912      23,784      3,356,392         6,873         0                      *j++ = *i++;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              else
              .       .     .              .             .           .              .             .         .              {
              .       .     .              .             .           .              .             .         .                  simpleUncheckEnqueue(first, cr);
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  NextClause:;
              .       .     .              .             .           .              .             .         .          }
    437,762,410      72    72              0             0           0              0             0         0          ws.shrink(i - j);
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
      9,360,754       0     0      9,360,754     1,439,369           0              0             0         0      s_propagations += num_props;
              .       .     .              .             .           .              .             .         .  
      4,680,377       0     0      4,680,377             0           0              0             0         0      return confl;
    848,057,611      85    85     33,097,813     1,514,233           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::simpleUncheckEnqueue(Lit p, CRef from){
              .       .     .              .             .           .              .             .         .      assert(value(p) == l_Undef);
    312,144,209       0     0              0             0           0    312,144,209             0         0      assigns[var(p)] = lbool(!sign(p)); // this makes a lbool object whose value is sign(p)
    633,744,936      75    74    316,872,468        71,649           0    316,872,468   304,072,035    67,018      vardata[var(p)].reason = from;
     71,635,489       0     0     71,635,489             0           0              0             0         0      trail.push_(p);
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::cancelUntilTrailRecord()
              .       .     .              .             .           .              .             .         .  {
    636,517,746       0     0      1,109,124             0           0              0             0         0      for (int c = trail.size() - 1; c >= trailRecord; c--)
              .       .     .              .             .           .              .             .         .      {
        554,562      75    73        554,562             0           0              0             0         0          Var x = var(trail[c]);
    318,536,154       0     0        554,562        10,384           0    316,872,468   132,991,738         0          assigns[x] = l_Undef;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      }
        554,562       0     0              0             0           0        554,562        60,943         0      qhead = trailRecord;
      1,109,124       0     0              0             0           0              0             0         0      trail.shrink(trail.size() - trailRecord);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::litsEnqueue(int cutP, Clause& c)
              .       .     .              .             .           .              .             .         .  {
              .       .     .              .             .           .              .             .         .      for (int i = cutP; i < c.size(); i++)
              .       .     .              .             .           .              .             .         .      {
              .       .     .              .             .           .              .             .         .          simpleUncheckEnqueue(~c[i]);
-- line 347 ----------------------------------------
-- line 348 ----------------------------------------
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  bool Solver::removed(CRef cr) {
              .       .     .              .             .           .              .             .         .      return ca[cr].mark() == 1;
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::simpleAnalyze(CRef confl, vec<Lit>& out_learnt, vec<CRef>& reason_clause, bool True_confl)
      6,071,263      68    66              0             0           0      3,311,598             0         0  {
        551,933       0     0              0             0           0              0             0         0      int pathC = 0;
        551,933       0     0              0             0           0              0             0         0      Lit p = lit_Undef;
      1,655,799       0     0        551,933             0           0              0             0         0      int index = trail.size() - 1;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      do{
     28,165,260      75    73              0             0           0              0             0         0          if (confl != CRef_Undef){
              .       .     .              .             .           .              .             .         .              reason_clause.push(confl);
              .       .     .              .             .           .              .             .         .              Clause& c = ca[confl];
              .       .     .              .             .           .              .             .         .              // Special case for binary clauses
              .       .     .              .             .           .              .             .         .              // The first one has to be SAT
     44,454,112      91    75              0             0           0              0             0         0              if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False) {
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                  assert(value(c[1]) == l_True);
              .       .     .              .             .           .              .             .         .                  Lit tmp = c[0];
      2,758,833       0     0        919,611        51,505       3,715      1,839,222             0         0                  c[0] = c[1], c[1] = tmp;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              // if True_confl==true, then choose p begin with the 1th index of c;
     79,336,073       0     0     17,558,279       541,565           0              0             0         0              for (int j = (p == lit_Undef && True_confl == false) ? 0 : 1; j < c.size(); j++){
              .       .     .              .             .           .              .             .         .                  Lit q = c[j];
     42,679,690       0     0     21,339,845     4,974,520         287              0             0         0                  if (!seen[var(q)]){
     13,531,574       0     0              0             0           0     13,531,574             0         0                      seen[var(q)] = 1;
     40,594,722       0     0     13,531,574             0           0              0             0         0                      pathC++;
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          else if (confl == CRef_Undef){
              .       .     .              .             .           .              .             .         .              out_learnt.push(~p);
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          // if not break, while() will come to the index of trail blow 0, and fatal error occur;
     44,183,456      75    73     13,531,445             0           0              0             0         0          if (pathC == 0) break;
              .       .     .              .             .           .              .             .         .          // Select next clause to look at:
  1,931,215,277       0     0    643,738,675   160,164,436       2,126              0             0         0          while (!seen[var(trail[index--])]);
              .       .     .              .             .           .              .             .         .          // if the reason cr from the 0-level assigned var, we must break avoid move forth further;
              .       .     .              .             .           .              .             .         .          // but attention that maybe seen[x]=1 and never be clear. However makes no matter;
     27,062,890       0     0     13,531,445         7,495           0              0             0         0          if (trailRecord > index + 1) break;
              .       .     .              .             .           .              .             .         .          p = trail[index + 1];
              .       .     .              .             .           .              .             .         .          confl = reason(var(p));
     13,530,697       0     0              0             0           0     13,530,697             0         0          seen[var(p)] = 0;
     13,530,697       0     0              0             0           0              0             0         0          pathC--;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      } while (pathC >= 0);
      5,519,330      87    75      3,863,531       334,017           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::simplifyLearnt(Clause& c)
      4,991,058     150   148              0             0           0      3,327,372            85         0  {
              .       .     .              .             .           .              .             .         .      ////
        554,562       0     0        554,562           826           0              0             0         0      original_length_record += c.size();
              .       .     .              .             .           .              .             .         .  
      1,109,124       0     0        554,562           263           0        554,562             0         0      trailRecord = trail.size();// record the start pointer
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      vec<Lit> falseLit;
              .       .     .              .             .           .              .             .         .      falseLit.clear();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      //sort(&c[0], c.size(), VarOrderLevelLt(vardata));
              .       .     .              .             .           .              .             .         .  
        533,262      71    70              0             0           0              0             0         0      bool True_confl = false;
              .       .     .              .             .           .              .             .         .      int beforeSize, afterSize;
              .       .     .              .             .           .              .             .         .      beforeSize = c.size();
              .       .     .              .             .           .              .             .         .      int i, j;
              .       .     .              .             .           .              .             .         .      CRef confl;
              .       .     .              .             .           .              .             .         .  
     17,679,687      75    74              0             0           0              0             0         0      for (i = 0, j = 0; i < c.size(); i++){
     10,672,076       0     0              0             0           0              0             0         0          if (value(c[i]) == l_Undef){
              .       .     .              .             .           .              .             .         .              //printf("///@@@ uncheckedEnqueue:index = %d. l_Undef\n", i);
              .       .     .              .             .           .              .             .         .              simpleUncheckEnqueue(~c[i]);
     18,646,405       0     0      4,728,259             0           0      4,728,259         7,942         0              c[j++] = c[i];
     14,184,777       0     0              0             0           0      4,728,259             0         0              confl = simplePropagate();
     14,184,777      75    74      4,728,259     1,481,752           0              0             0         0              if (confl != CRef_Undef){
              .       .     .              .             .           .              .             .         .                  break;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          else{
      1,215,558       0     0              0             0           0              0             0         0              if (value(c[i]) == l_True){
              .       .     .              .             .           .              .             .         .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_True\n", i);
      1,141,208      69    67        285,302             0           0        285,302         2,055         0                  c[j++] = c[i];
        285,302      49    47              0             0           0              0             0         0                  True_confl = true;
              .       .     .              .             .           .              .             .         .                  confl = reason(var(c[i]));
              .       .     .              .             .           .              .             .         .                  break;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              else{
              .       .     .              .             .           .              .             .         .                  //printf("///@@@ uncheckedEnqueue:index = %d. l_False\n", i);
              .       .     .              .             .           .              .             .         .                  falseLit.push(c[i]);
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .      c.shrink(c.size() - j);
              .       .     .              .             .           .              .             .         .      afterSize = c.size();
              .       .     .              .             .           .              .             .         .      //printf("\nbefore : %d, after : %d ", beforeSize, afterSize);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      if (confl != CRef_Undef || True_confl == true){
        551,933       0     0              0             0           0              0             0         0          simp_learnt_clause.clear();
        551,933       0     0              0             0           0              0             0         0          simp_reason_clause.clear();
      1,103,866       0     0              0             0           0              0             0         0          if (True_confl == true){
              .       .     .              .             .           .              .             .         .              simp_learnt_clause.push(c.last());
              .       .     .              .             .           .              .             .         .          }
      3,863,531      26    26              0             0           0        551,933             0         0          simpleAnalyze(confl, simp_learnt_clause, simp_reason_clause, True_confl);
              .       .     .              .             .           .              .             .         .  
      1,655,799       0     0        551,933             0           0              0             0         0          if (simp_learnt_clause.size() < c.size()){
      2,226,136      75    73        959,274             0           0              0             0         0              for (i = 0; i < simp_learnt_clause.size(); i++){
      3,529,508       0     0        882,377         7,841           0        882,377        31,788         0                  c[i] = simp_learnt_clause[i];
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              c.shrink(c.size() - i);
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      cancelUntilTrailRecord();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      ////
        554,562       0     0        554,562        95,958           0              0             0         0      simplified_length_record += c.size();
              .       .     .              .             .           .              .             .         .  
      4,436,496       0     0      3,881,934       532,304           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  bool Solver::simplifyLearnt_x(vec<CRef>& learnts_x)
              .       .     .              .             .           .              .             .         .  {
              .       .     .              .             .           .              .             .         .      int beforeSize, afterSize;
              .       .     .              .             .           .              .             .         .      int learnts_x_size_before = learnts_x.size();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      int ci, cj, li, lj;
              .       .     .              .             .           .              .             .         .      bool sat, false_lit;
-- line 476 ----------------------------------------
-- line 574 ----------------------------------------
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      //   printf("c nbLearnts_x %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .     .              .             .           .              .             .         .      //          learnts_x_size_before, learnts_x.size(), nbSimplified, nbSimplifing);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      return true;
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  bool Solver::simplifyLearnt_core()
            825       0     0              0             0           0            450             0         0  {
              .       .     .              .             .           .              .             .         .      int beforeSize, afterSize;
              .       .     .              .             .           .              .             .         .      int learnts_core_size_before = learnts_core.size();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      int ci, cj, li, lj;
              .       .     .              .             .           .              .             .         .      bool sat, false_lit;
              .       .     .              .             .           .              .             .         .      unsigned int nblevels;
              .       .     .              .             .           .              .             .         .      ////
              .       .     .              .             .           .              .             .         .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      ////
              .       .     .              .             .           .              .             .         .      int nbSimplified = 0;
              .       .     .              .             .           .              .             .         .      int nbSimplifing = 0;
              .       .     .              .             .           .              .             .         .  
     16,517,533      75    73             75             0           0              0             0         0      for (ci = 0, cj = 0; ci < learnts_core.size(); ci++){
     24,775,857      75    73     16,517,238       516,309     481,186              0             0         0          CRef cr = learnts_core[ci];
              .       .     .              .             .           .              .             .         .          Clause& c = ca[cr];
              .       .     .              .             .           .              .             .         .  
     16,517,238       0     0              0             0           0              0             0         0          if (removed(cr)) continue;
     16,517,238       0     0      8,258,619     1,004,277     171,222              0             0         0          else if (c.simplified()){
     16,148,892       0     0              0             0           0      8,074,446            46         0              learnts_core[cj++] = learnts_core[ci];
              .       .     .              .             .           .              .             .         .              ////
     24,223,728       0     0      8,074,446             0           0              0             0         0              nbSimplified++;
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          else{
              .       .     .              .             .           .              .             .         .              int saved_size=c.size();
              .       .     .              .             .           .              .             .         .              //         if (drup_file){
              .       .     .              .             .           .              .             .         .              //                 add_oc.clear();
              .       .     .              .             .           .              .             .         .              //                 for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .     .              .             .           .              .             .         .              ////
              .       .     .              .             .           .              .             .         .              nbSimplifing++;
        184,159       0     0              0             0           0              0             0         0              sat = false_lit = false;
      2,556,256       0     0              0             0           0              0             0         0              for (int i = 0; i < c.size(); i++){
      2,556,352       0     0              0             0           0              0             0         0                  if (value(c[i]) == l_True){
              .       .     .              .             .           .              .             .         .                      sat = true;
              .       .     .              .             .           .              .             .         .                      break;
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .                  else if (value(c[i]) == l_False){
      2,924,546      75    73              0             0           0        184,159            73         0                      false_lit = true;
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              if (sat){
            434      19    18            124             0           0            124             0         0                  removeClause(cr);
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              else{
      1,104,666       0     0              0             0           0        552,333             0         0                  detachClause(cr, true);
              .       .     .              .             .           .              .             .         .  
        736,444      75    73        368,222             7           0              0             0         0                  if (false_lit){
          4,070       0     0            284             0           0              0             0         0                      for (li = lj = 0; li < c.size(); li++){
          2,792       0     0              0             0           0              0             0         0                          if (value(c[li]) != l_False){
          3,756       0     0              0             0           0          1,252             0         0                              c[lj++] = c[li];
              .       .     .              .             .           .              .             .         .                          }
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                      c.shrink(li - lj);
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                  beforeSize = c.size();
              .       .     .              .             .           .              .             .         .                  assert(c.size() > 1);
              .       .     .              .             .           .              .             .         .                  // simplify a learnt clause c
        736,444       0     0              0             0           0        368,222             0         0                  simplifyLearnt(c);
              .       .     .              .             .           .              .             .         .                  assert(c.size() > 0);
              .       .     .              .             .           .              .             .         .                  afterSize = c.size();
              .       .     .              .             .           .              .             .         .                  
        855,538       0     0        552,333       335,075           0              0             0         0                  if(drup_file && saved_size !=c.size()){
              .       .     .              .             .           .              .             .         .  #ifdef BIN_DRUP
              .       .     .              .             .           .              .             .         .                      binDRUP('a', c , drup_file);
              .       .     .              .             .           .              .             .         .                      //                    binDRUP('d', add_oc, drup_file);
              .       .     .              .             .           .              .             .         .  #else
              .       .     .              .             .           .              .             .         .                      for (int i = 0; i < c.size(); i++)
              .       .     .              .             .           .              .             .         .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .              .             .           .              .             .         .                      fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  
-- line 653 ----------------------------------------
-- line 655 ----------------------------------------
              .       .     .              .             .           .              .             .         .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .     .              .             .           .              .             .         .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .     .              .             .           .              .             .         .                      //                    fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .     .              .             .           .              .             .         .  
        368,222       0     0              0             0           0              0             0         0                  if (c.size() == 1){
              .       .     .              .             .           .              .             .         .                      // when unit clause occur, enqueue and propagate
            665      46    44            133             4           0            133             0         0                      uncheckedEnqueue(c[0]);
            399       0     0            133             0           0              0             0         0                      if (propagate() != CRef_Undef){
              .       .     .              .             .           .              .             .         .                          ok = false;
              .       .     .              .             .           .              .             .         .                          return false;
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                      // delete the clause memory in logic
              .       .     .              .             .           .              .             .         .                      c.mark(1);
              .       .     .              .             .           .              .             .         .                      ca.free(cr);
              .       .     .              .             .           .              .             .         .  //#ifdef BIN_DRUP
              .       .     .              .             .           .              .             .         .  //                    binDRUP('d', c, drup_file);
-- line 674 ----------------------------------------
-- line 675 ----------------------------------------
              .       .     .              .             .           .              .             .         .  //#else
              .       .     .              .             .           .              .             .         .  //                    fprintf(drup_file, "d ");
              .       .     .              .             .           .              .             .         .  //                    for (int i = 0; i < c.size(); i++)
              .       .     .              .             .           .              .             .         .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .              .             .           .              .             .         .  //                    fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  //#endif
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .                  else{
        551,934       0     0              0             0           0        183,978             0         0                      attachClause(cr);
      1,103,868      73    73        551,934       334,651           0        183,978        11,640         0                      learnts_core[cj++] = learnts_core[ci];
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                      nblevels = computeLBD(c);
        367,956      75    73              0             0           0              0             0         0                      if (nblevels < c.lbd()){
              .       .     .              .             .           .              .             .         .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .     .              .             .           .              .             .         .                          c.set_lbd(nblevels);
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                      c.setSimplified(true);
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
             75       0     0              0             0           0              0             0         0      learnts_core.shrink(ci - cj);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      //    printf("c nbLearnts_core %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .     .              .             .           .              .             .         .      //           learnts_core_size_before, learnts_core.size(), nbSimplified, nbSimplifing);
              .       .     .              .             .           .              .             .         .  
             75      27    27              0             0           0              0             0         0      return true;
              .       .     .              .             .           .              .             .         .  
            600       0     0            525            75           4              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
     21,691,296       2     2              0             0           0     14,460,864             0         0  int Solver::is_duplicate(std::vector<uint32_t>&c){
      4,820,288       0     0              0             0           0      4,820,288       311,900         0     auto time_point_0 = std::chrono::high_resolution_clock::now();
      2,410,144       0     0      2,410,144     1,943,717         189              0             0         0      dupl_db_size++;
      5,857,570   1,967   276      1,344,532             0           0              0             0         0      int res = 0;    
              .       .     .              .             .           .              .             .         .      
      4,820,288       0     0      4,820,288             0           0              0             0         0      int sz = c.size();
              .       .     .              .             .           .              .             .         .      std::vector<uint32_t> tmp(c);    
              .       .     .              .             .           .              .             .         .      sort(tmp.begin(),tmp.end());
              .       .     .              .             .           .              .             .         .      
      2,410,144 230,028   293              0             0           0      2,410,144             0         0      uint64_t hash = 0;    
              .       .     .              .             .           .              .             .         .      
    108,539,626  33,858   450              0             0           0      2,410,144             0         0      for (int i =0; i<sz; i++) {
    446,292,370       0     0     44,629,237             0           0              0             0         0          hash ^= tmp[i] + 0x9e3779b9 + (hash << 6) + (hash>> 2);     
              .       .     .              .             .           .              .             .         .      }    
              .       .     .              .             .           .              .             .         .      
      2,410,144       0     0              0             0           0      2,410,144             0         0      int32_t head = tmp[0];
              .       .     .              .             .           .              .             .         .      auto it0 = ht.find(head);
     11,942,052       0     0      2,410,134             0           0              0             0         0      if (it0 != ht.end()){
              .       .     .              .             .           .              .             .         .          auto it1=ht[head].find(sz);
      4,747,856       0     0              0             0           0              0             0         0          if (it1 != ht[head].end()){
      2,015,268       0     0              0             0           0      2,015,268             0         0              auto it2 = ht[head][sz].find(hash);
      6,045,804       0     0              0             0           0      2,015,268             0         0              if (it2 != ht[head][sz].end()){
        460,875       0     0        153,625        34,661      25,496        153,625             0         0                  it2->second++;
        153,625       0     0              0             0           0              0             0         0                  res = it2->second;            
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              else{
      1,861,643       0     0              0             0           0      1,861,643             0         0                  ht[head][sz][hash]=1;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          else{            
        717,320      55     4              0             0           0        358,660             2         0              ht[head][sz][hash]=1;
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }else{        
      2,292,735  22,223   686              0             0           0      2,292,735             2         0          ht[head][sz][hash]=1;
              .       .     .              .             .           .              .             .         .      } 
      2,410,144     413    54              0             0           0      2,410,144             0         0      auto time_point_1 = std::chrono::high_resolution_clock::now();
              .       .     .              .             .           .              .             .         .      duptime += std::chrono::duration_cast<std::chrono::microseconds>(time_point_1-time_point_0);    
              .       .     .              .             .           .              .             .         .      return res;
     21,691,296       0     0     16,871,008            25           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  bool Solver::simplifyLearnt_tier2()
            825      75    74              0             0           0            450             0         0  {
              .       .     .              .             .           .              .             .         .      int beforeSize, afterSize;
              .       .     .              .             .           .              .             .         .      int learnts_tier2_size_before = learnts_tier2.size();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      int ci, cj, li, lj;
              .       .     .              .             .           .              .             .         .      bool sat, false_lit;
              .       .     .              .             .           .              .             .         .      unsigned int nblevels;
              .       .     .              .             .           .              .             .         .      ////
              .       .     .              .             .           .              .             .         .      //printf("learnts_x size : %d\n", learnts_x.size());
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      ////
              .       .     .              .             .           .              .             .         .      int nbSimplified = 0;
              .       .     .              .             .           .              .             .         .      int nbSimplifing = 0;
              .       .     .              .             .           .              .             .         .  
      1,247,459      66    55             75            75          40              0             0         0      for (ci = 0, cj = 0; ci < learnts_tier2.size(); ci++){
      1,870,851       0     0      1,247,234        41,069      33,042              0             0         0          CRef cr = learnts_tier2[ci];
              .       .     .              .             .           .              .             .         .          Clause& c = ca[cr];
              .       .     .              .             .           .              .             .         .  
      1,247,234       0     0              0             0           0              0             0         0          if (removed(cr)) continue;
      1,247,234       0     0        623,617        76,272       3,313              0             0         0          else if (c.simplified()){
        506,272       0     0              0             0           0        253,136           640         1              learnts_tier2[cj++] = learnts_tier2[ci];
              .       .     .              .             .           .              .             .         .              ////
      1,500,358       0     0        253,136             0           0              0             0         0              nbSimplified++;
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          else{
              .       .     .              .             .           .              .             .         .              int saved_size=c.size();
              .       .     .              .             .           .              .             .         .              //            if (drup_file){
              .       .     .              .             .           .              .             .         .              //                    add_oc.clear();
              .       .     .              .             .           .              .             .         .              //                    for (int i = 0; i < c.size(); i++) add_oc.push(c[i]); }
              .       .     .              .             .           .              .             .         .              ////
              .       .     .              .             .           .              .             .         .              nbSimplifing++;
        370,477       0     0              0             0           0              0             0         0              sat = false_lit = false;
     10,042,604       0     0              0             0           0              0             0         0              for (int i = 0; i < c.size(); i++){
     10,042,656       0     0              0             0           0              0             0         0                  if (value(c[i]) == l_True){
              .       .     .              .             .           .              .             .         .                      sat = true;
              .       .     .              .             .           .              .             .         .                      break;
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .                  else if (value(c[i]) == l_False){
     10,783,550      10    10              0             0           0        370,477             0         0                      false_lit = true;
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              if (sat){
            150       0     0             30             0           0             30             0         0                  removeClause(cr);
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              else{
      2,222,706      65    65              0             0           0      1,111,353            73         0                  detachClause(cr, true);
              .       .     .              .             .           .              .             .         .  
      1,481,804       0     0        740,902            10           0              0             0         0                  if (false_lit){
         31,796      44    44          1,392             0           0              0             0         0                      for (li = lj = 0; li < c.size(); li++){
         25,532       0     0              0             0           0              0             0         0                          if (value(c[li]) != l_False){
         36,144       0     0              0             0           0         12,048             0         0                              c[lj++] = c[li];
              .       .     .              .             .           .              .             .         .                          }
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                      c.shrink(li - lj);
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                  beforeSize = c.size();
              .       .     .              .             .           .              .             .         .                  assert(c.size() > 1);
              .       .     .              .             .           .              .             .         .                  // simplify a learnt clause c
      1,852,255       0     0              0             0           0      1,111,353             0         0                  simplifyLearnt(c);
              .       .     .              .             .           .              .             .         .                  assert(c.size() > 0);
              .       .     .              .             .           .              .             .         .                  afterSize = c.size();
              .       .     .              .             .           .              .             .         .                  
      1,481,804      73    73        740,902       728,347           0              0             0         0                  if(drup_file && saved_size!=c.size()){
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  #ifdef BIN_DRUP
              .       .     .              .             .           .              .             .         .                      binDRUP('a', c , drup_file);
              .       .     .              .             .           .              .             .         .                      //                    binDRUP('d', add_oc, drup_file);
              .       .     .              .             .           .              .             .         .  #else
              .       .     .              .             .           .              .             .         .                      for (int i = 0; i < c.size(); i++)
              .       .     .              .             .           .              .             .         .                          fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .              .             .           .              .             .         .                      fprintf(drup_file, "0\n");
-- line 819 ----------------------------------------
-- line 822 ----------------------------------------
              .       .     .              .             .           .              .             .         .                      //                    for (int i = 0; i < add_oc.size(); i++)
              .       .     .              .             .           .              .             .         .                      //                        fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .     .              .             .           .              .             .         .                      //                    fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                  //printf("beforeSize: %2d, afterSize: %2d\n", beforeSize, afterSize);
              .       .     .              .             .           .              .             .         .  
        740,902       0     0              0             0           0              0             0         0                  if (c.size() == 1){
              .       .     .              .             .           .              .             .         .                      // when unit clause occur, enqueue and propagate
             30       0     0              6             0           0              6             0         0                      uncheckedEnqueue(c[0]);
             18       0     0              6             0           0              0             0         0                      if (propagate() != CRef_Undef){
              .       .     .              .             .           .              .             .         .                          ok = false;
              .       .     .              .             .           .              .             .         .                          return false;
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                      // delete the clause memory in logic
              .       .     .              .             .           .              .             .         .                      c.mark(1);
              .       .     .              .             .           .              .             .         .                      ca.free(cr);
              .       .     .              .             .           .              .             .         .  //#ifdef BIN_DRUP
              .       .     .              .             .           .              .             .         .  //                    binDRUP('d', c, drup_file);
-- line 841 ----------------------------------------
-- line 845 ----------------------------------------
              .       .     .              .             .           .              .             .         .  //                        fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .              .             .           .              .             .         .  //                    fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  //#endif
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .                  else{
              .       .     .              .             .           .              .             .         .                      
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                      nblevels = computeLBD(c);
        740,890       0     0              0             0           0              0             0         0                      if (nblevels < c.lbd()){
              .       .     .              .             .           .              .             .         .                          //printf("lbd-before: %d, lbd-after: %d\n", c.lbd(), nblevels);
              .       .     .              .             .           .              .             .         .                          c.set_lbd(nblevels);
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                       //duplicate learnts 
              .       .     .              .             .           .              .             .         .                      int id = 0;                    
              .       .     .              .             .           .              .             .         .                      
              .       .     .              .             .           .              .             .         .                      std::vector<uint32_t> tmp;
     14,820,492       0     0     10,870,418             1           0              0             0         0                      for (int i = 0; i < c.size(); i++)                           
      7,740,872       0     0      3,870,436             0           0      3,870,436             0         0                          tmp.push_back(c[i].x);
      1,481,780       0     0              0             0           0        370,445             0         0                      id = is_duplicate(tmp);
              .       .     .              .             .           .              .             .         .                       
              .       .     .              .             .           .              .             .         .                                          
              .       .     .              .             .           .              .             .         .                      //duplicate learnts 
              .       .     .              .             .           .              .             .         .  
      1,481,780       9     9        370,445       364,594          13              0             0         0                      if (id < min_number_of_learnts_copies+2){
      1,100,541      33    32              0             0           0        366,847             0         0                          attachClause(cr);
      1,818,736       0     0      1,100,541       724,455           0        366,847       345,493        28                          learnts_tier2[cj++] = learnts_tier2[ci];                    
      1,467,388      75    74        366,847             0           0              0             0         0                          if (id == min_number_of_learnts_copies+1){                            
          2,013      10    10          2,013             0           0              0             0         0                              duplicates_added_minimization++;                                  
              .       .     .              .             .           .              .             .         .                          }
        729,668       0     0        364,834       360,989          14              0             0         0                          if ((c.lbd() <= core_lbd_cut)||(id == min_number_of_learnts_copies+1)){
              .       .     .              .             .           .              .             .         .                          //if (id == min_number_of_learnts_copies+1){
              .       .     .              .             .           .              .             .         .                              cj--;
              .       .     .              .             .           .              .             .         .                              learnts_core.push(cr);
              .       .     .              .             .           .              .             .         .                              c.mark(CORE);
              .       .     .              .             .           .              .             .         .                          }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                          c.setSimplified(true);
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
             75      69    67              0             0           0              0             0         0      learnts_tier2.shrink(ci - cj);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      //    printf("c nbLearnts_tier2 %d / %d, nbSimplified: %d, nbSimplifing: %d\n",
              .       .     .              .             .           .              .             .         .      //           learnts_tier2_size_before, learnts_tier2.size(), nbSimplified, nbSimplifing);
              .       .     .              .             .           .              .             .         .  
             75       0     0              0             0           0              0             0         0      return true;
              .       .     .              .             .           .              .             .         .  
            600       0     0            525            75          14              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  bool Solver::simplifyAll()
            375      61    61              0             0           0            225             0         0  {
              .       .     .              .             .           .              .             .         .      ////
            150       0     0              0             0           0             75             0         0      simplified_length_record = original_length_record = 0;
              .       .     .              .             .           .              .             .         .  
            300       0     0             75            43           0              0             0         0      if (!ok || propagate() != CRef_Undef)
              .       .     .              .             .           .              .             .         .          return ok = false;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      //// cleanLearnts(also can delete these code), here just for analyzing
              .       .     .              .             .           .              .             .         .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .     .              .             .           .              .             .         .      //if (tier2_learnts_dirty) cleanLearnts(learnts_tier2, TIER2);
              .       .     .              .             .           .              .             .         .      //local_learnts_dirty = tier2_learnts_dirty = false;
              .       .     .              .             .           .              .             .         .  
            300       0     0              0             0           0             75             0         0      if (!simplifyLearnt_core()) return ok = false;
            300      75    74              0             0           0             75             0         0      if (!simplifyLearnt_tier2()) return ok = false;
              .       .     .              .             .           .              .             .         .      //if (!simplifyLearnt_x(learnts_local)) return ok = false;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      checkGarbage();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      ////
              .       .     .              .             .           .              .             .         .      //  printf("c size_reduce_ratio     : %4.2f%%\n",
              .       .     .              .             .           .              .             .         .      //         original_length_record == 0 ? 0 : (original_length_record - simplified_length_record) * 100 / (double)original_length_record);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      return true;
            375       0     0            300             0           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  //=================================================================================================
              .       .     .              .             .           .              .             .         .  // Minor methods:
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  // Creates a new SAT variable in the solver. If 'decision' is cleared, variable will not be
              .       .     .              .             .           .              .             .         .  // used as a decision variable (NOTE! This has effects on the meaning of a SATISFIABLE result).
              .       .     .              .             .           .              .             .         .  //
              .       .     .              .             .           .              .             .         .  Var Solver::newVar(bool sign, bool dvar)
        632,680       1     1              0             0           0        506,144             0         0  {
              .       .     .              .             .           .              .             .         .      int v = nVars();
              .       .     .              .             .           .              .             .         .      watches_bin.init(mkLit(v, false));
              .       .     .              .             .           .              .             .         .      watches_bin.init(mkLit(v, true ));
              .       .     .              .             .           .              .             .         .      watches  .init(mkLit(v, false));
              .       .     .              .             .           .              .             .         .      watches  .init(mkLit(v, true ));
             25       1     1              0             0           0              0             0         0      assigns  .push(l_Undef);
             25       1     1              0             0           0              0             0         0      vardata  .push(mkVarData(CRef_Undef, 0));
             25       0     0              0             0           0              0             0         0      activity_CHB  .push(0);
        189,854       0     0         63,268         1,175           0             25             0         0      activity_VSIDS.push(rnd_init_act ? drand(random_seed) * 0.00001 : 0);
              .       .     .              .             .           .              .             .         .  
             25       1     1              0             0           0              0             0         0      picked.push(0);
             25       0     0              0             0           0              0             0         0      conflicted.push(0);
             25       0     0              0             0           0              0             0         0      almost_conflicted.push(0);
              .       .     .              .             .           .              .             .         .  #ifdef ANTI_EXPLORATION
             25       0     0              0             0           0              0             0         0      canceled.push(0);
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .  
             25       0     0              0             0           0              0             0         0      seen     .push(0);
             25       0     0              0             0           0              0             0         0      seen2    .push(0);
             25       0     0              0             0           0              0             0         0      polarity .push(sign);
             25       0     0              0             0           0              0             0         0      decision .push();
        316,340       1     1              0             0           0        126,536         2,168         0      trail    .capacity(v+1);
              .       .     .              .             .           .              .             .         .      setDecisionVar(v, dvar);
              .       .     .              .             .           .              .             .         .  
             25       0     0              0             0           0              0             0         0      activity_distance.push(0);
             25       1     1              0             0           0              0             0         0      var_iLevel.push(0);
             25       0     0              0             0           0              0             0         0      var_iLevel_tmp.push(0);
             25       0     0              0             0           0              0             0         0      pathCs.push(0);
              .       .     .              .             .           .              .             .         .      return v;
        569,412       0     0        442,876           558           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  bool Solver::addClause_(vec<Lit>& ps)
      3,890,936       2     2              0             0           0      3,335,088           195         0  {
              .       .     .              .             .           .              .             .         .      assert(decisionLevel() == 0);
      1,667,544       2     2        555,848             0           0              0             0         0      if (!ok) return false;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Check if clause is satisfied and remove false/duplicate literals:
              .       .     .              .             .           .              .             .         .      sort(ps);
              .       .     .              .             .           .              .             .         .      Lit p; int i, j;
              .       .     .              .             .           .              .             .         .  
      1,111,696       0     0        555,848           229           0              0             0         0      if (drup_file){
              .       .     .              .             .           .              .             .         .          add_oc.clear();
        555,848       2     2        555,848             0           0              0             0         0          for (int i = 0; i < ps.size(); i++) add_oc.push(ps[i]); }
              .       .     .              .             .           .              .             .         .  
      7,610,383       0     0              0             0           0              0             0         0      for (i = j = 0, p = lit_Undef; i < ps.size(); i++)
     13,184,886       0     0      2,239,160             0           0              0             0         0          if (value(ps[i]) == l_True || ps[i] == ~p)
              .       .     .              .             .           .              .             .         .              return true;
      8,578,752       4     4              0             0           0              0             0         0          else if (value(ps[i]) != l_False && ps[i] != p)
      6,369,441       0     0      2,123,147             0           0      2,123,147             0         0              ps[j++] = p = ps[i];
      3,863,336       0     0        482,917             0           0              0             0         0      ps.shrink(i - j);
              .       .     .              .             .           .              .             .         .  
        965,834       2     2              0             0           0              0             0         0      if (drup_file && i != j){
              .       .     .              .             .           .              .             .         .  #ifdef BIN_DRUP
              .       .     .              .             .           .              .             .         .          binDRUP('a', ps, drup_file);
        482,917       0     0        482,917             0           0              0             0         0          binDRUP('d', add_oc, drup_file);
              .       .     .              .             .           .              .             .         .  #else
              .       .     .              .             .           .              .             .         .          for (int i = 0; i < ps.size(); i++)
              .       .     .              .             .           .              .             .         .              fprintf(drup_file, "%i ", (var(ps[i]) + 1) * (-2 * sign(ps[i]) + 1));
              .       .     .              .             .           .              .             .         .          fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          fprintf(drup_file, "d ");
              .       .     .              .             .           .              .             .         .          for (int i = 0; i < add_oc.size(); i++)
              .       .     .              .             .           .              .             .         .              fprintf(drup_file, "%i ", (var(add_oc[i]) + 1) * (-2 * sign(add_oc[i]) + 1));
              .       .     .              .             .           .              .             .         .          fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .      
        965,834       0     0              0             0           0              0             0         0      if (ps.size() == 0)
              .       .     .              .             .           .              .             .         .          return ok = false;
        965,834       2     2              0             0           0              0             0         0      else if (ps.size() == 1){
         27,234       0     0          9,078             0           0          4,539             0         0          uncheckedEnqueue(ps[0]);
         18,156       0     0              0             0           0          4,539             0         0          return ok = (propagate() == CRef_Undef);
              .       .     .              .             .           .              .             .         .      }else{
        478,378       0     0              0             0           0        478,378             0         0          CRef cr = ca.alloc(ps, false);
              .       .     .              .             .           .              .             .         .          //auto ca_size=ca.size();
              .       .     .              .             .           .              .             .         .          //printf("ca size:%d\n",ca_size);
      1,435,134       0     0              0             0           0        478,378             0         0          clauses.push(cr);
      1,435,134       2     2        478,378             0           0        478,378             0         0          attachClause(cr);
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
        478,378       0     0              0             0           0              0             0         0      return true;
      6,114,328       0     0      3,890,936            22           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
     70,344,660      11     8              0             0           0     42,206,796             0         0  void Solver::attachClause(CRef cr) {
              .       .     .              .             .           .              .             .         .      const Clause& c = ca[cr];
              .       .     .              .             .           .              .             .         .      assert(c.size() > 1);
     27,993,267       0     0      7,034,466            22           0              0             0         0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .     .              .             .           .              .             .         .      ws[~c[0]].push(Watcher(cr, c[1]));
              .       .     .              .             .           .              .             .         .      ws[~c[1]].push(Watcher(cr, c[0]));
     20,594,200       0     0     13,559,734     5,866,805         163              0             0         0      if (c.learnt()) learnts_literals += c.size();
     56,784,926       0     0     49,750,460           304           0              0             0         0      else            clauses_literals += c.size(); }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
     38,946,354     574   493              0             0           0     25,964,236         1,792         0  void Solver::detachClause(CRef cr, bool strict) {
              .       .     .              .             .           .              .             .         .      const Clause& c = ca[cr];
              .       .     .              .             .           .              .             .         .      assert(c.size() > 1);
     25,964,236       0     0              0             0           0              0             0         0      OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = c.size() == 2 ? watches_bin : watches;
              .       .     .              .             .           .              .             .         .      
     25,964,236       0     0              0             0           0              0             0         0      if (strict){
              .       .     .              .             .           .              .             .         .          remove(ws[~c[0]], Watcher(cr, c[1]));
              .       .     .              .             .           .              .             .         .          remove(ws[~c[1]], Watcher(cr, c[0]));
              .       .     .              .             .           .              .             .         .      }else{
              .       .     .              .             .           .              .             .         .          // Lazy detaching: (NOTE! Must clean all watcher lists before garbage collecting this clause)
              .       .     .              .             .           .              .             .         .          ws.smudge(~c[0]);
              .       .     .              .             .           .              .             .         .          ws.smudge(~c[1]);
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
     19,244,717      27    20     12,753,658        10,875         338              0             0         0      if (c.learnt()) learnts_literals -= c.size();
     39,174,814       0     0     32,683,755         4,221           0              0             0         0      else            clauses_literals -= c.size(); }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
     47,245,416   1,057   929              0             0           0     23,622,708         1,725         0  void Solver::removeClause(CRef cr) {
              .       .     .              .             .           .              .             .         .      Clause& c = ca[cr];
              .       .     .              .             .           .              .             .         .  
     17,717,031       0     0      5,905,677         2,714           0              0             0         0      if (drup_file){
              .       .     .              .             .           .              .             .         .          if (c.mark() != 1){
              .       .     .              .             .           .              .             .         .  #ifdef BIN_DRUP
              .       .     .              .             .           .              .             .         .              binDRUP('d', c, drup_file);
              .       .     .              .             .           .              .             .         .  #else
              .       .     .              .             .           .              .             .         .              fprintf(drup_file, "d ");
              .       .     .              .             .           .              .             .         .              for (int i = 0; i < c.size(); i++)
              .       .     .              .             .           .              .             .         .                  fprintf(drup_file, "%i ", (var(c[i]) + 1) * (-2 * sign(c[i]) + 1));
              .       .     .              .             .           .              .             .         .              fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .          }else
              .       .     .              .             .           .              .             .         .              printf("c Bug. I don't expect this to happen.\n");
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
     23,622,708     551   469              0             0           0      5,905,677             0         0      detachClause(cr);
              .       .     .              .             .           .              .             .         .      // Don't leave pointers to free'd memory!
              .       .     .              .             .           .              .             .         .      if (locked(c)){
         25,336       0     0          5,628             0           0              0             0         0          Lit implied = c.size() != 2 ? c[0] : (value(c[0]) == l_True ? c[0] : c[1]);
         14,080       0     0              0             0           0          7,040             0         0          vardata[var(implied)].reason = CRef_Undef; }
              .       .     .              .             .           .              .             .         .      c.mark(1);
              .       .     .              .             .           .              .             .         .      ca.free(cr);
     35,434,062       0     0     29,528,385             8           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  bool Solver::satisfied(const Clause& c) const {
    953,975,728     396   330              0             0           0              0             0         0      for (int i = 0; i < c.size(); i++)
  1,061,985,760       0     0    423,031,514    28,587,677         988              0             0         0          if (value(c[i]) == l_True)
         18,138       1     1              0             0           0              0             0         0              return true;
      1,330,550       0     0        674,344             0           0              0             0         0      return false; }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  // Revert to the state at given level (keeping all assignment at 'level' but not beyond).
              .       .     .              .             .           .              .             .         .  //
     54,110,016   8,733 1,015              0             0           0     36,073,344             1         0  void Solver::cancelUntil(int bLevel) {
              .       .     .              .             .           .              .             .         .  	
     24,121,180      10     2         37,400             2           0      6,012,224             2         0      if (decisionLevel() > bLevel){
              .       .     .              .             .           .              .             .         .  #ifdef PRINT_OUT
              .       .     .              .             .           .              .             .         .  		std::cout << "bt " << bLevel << "\n";
              .       .     .              .             .           .              .             .         .  #endif				
     12,024,448       0     0              0             0           0      6,012,224     2,535,064         0  		add_tmp.clear();
 25,771,605,166  14,397   617  5,167,547,926    11,267,497         485              0             0         0          for (int c = trail.size()-1; c >= trail_lim[bLevel]; c--)
              .       .     .              .             .           .              .             .         .          {
              .       .     .              .             .           .              .             .         .              Var      x  = var(trail[c]);
              .       .     .              .             .           .              .             .         .  
 10,274,973,612       0     0  5,137,486,806 4,799,533,999     295,870              0             0         0  			if (level(x) <= bLevel)
              .       .     .              .             .           .              .             .         .  			{
              .       .     .              .             .           .              .             .         .  				add_tmp.push(trail[c]);
              .       .     .              .             .           .              .             .         .  			}
              .       .     .              .             .           .              .             .         .  			else
              .       .     .              .             .           .              .             .         .  			{
 10,267,212,556       0     0  5,133,606,278     2,437,782           0              0             0         0  				 if (!VSIDS){
  7,644,955,548       0     0  5,096,637,032       431,619           0              0             0         0  					uint32_t age = conflicts - picked[x];
  5,096,637,032       0     0  2,548,318,516 2,419,222,934     362,086              0             0         0  					if (age > 0){
 25,470,942,340   1,550   251 10,188,376,936 4,832,612,435     456,182              0             0         0  						double adjusted_reward = ((double) (conflicted[x] + almost_conflicted[x])) / ((double) age);
  2,547,094,234       0     0  2,547,094,234 2,421,646,529     325,639              0             0         0  						double old_activity = activity_CHB[x];
 17,829,659,638      98    60  5,094,188,468     4,644,281          10  2,547,094,234             0         0  						activity_CHB[x] = step_size * adjusted_reward + ((1 - step_size) * old_activity);
              .       .     .              .             .           .              .             .         .  						if (order_heap_CHB.inHeap(x)){
 15,135,198,726     440   149              0             0           0  7,567,599,363         2,553         0  							if (activity_CHB[x] > old_activity)
              .       .     .              .             .           .              .             .         .  								order_heap_CHB.decrease(x);
              .       .     .              .             .           .              .             .         .  							else
              .       .     .              .             .           .              .             .         .  								order_heap_CHB.increase(x);
              .       .     .              .             .           .              .             .         .  						}
              .       .     .              .             .           .              .             .         .  					}
              .       .     .              .             .           .              .             .         .  #ifdef ANTI_EXPLORATION
  5,096,637,032       0     0  2,548,318,516     2,269,295           0  2,548,318,516 2,379,328,440   345,622  					canceled[x] = conflicts;
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .  				}
              .       .     .              .             .           .              .             .         .  				
 10,267,212,556     994   144  5,133,606,278     2,240,799           0  5,133,606,278 3,522,613,149    23,874  				assigns [x] = l_Undef;
              .       .     .              .             .           .              .             .         .  #ifdef PRINT_OUT
              .       .     .              .             .           .              .             .         .  				std::cout << "undo " << x << "\n";
              .       .     .              .             .           .              .             .         .  #endif				
 10,267,212,556       0     0  5,133,606,278            20           0              0             0         0  	            if (phase_saving > 1 || (phase_saving == 1) && c > trail_lim.last())
  5,133,606,278       0     0  5,133,606,278             0           0              0             0         0  					polarity[x] = sign(trail[c]);
              .       .     .              .             .           .              .             .         .  				insertVarOrder(x);
              .       .     .              .             .           .              .             .         .  			}
              .       .     .              .             .           .              .             .         .          }
      6,012,224       0     0              0             0           0      6,012,224             0         0          qhead = trail_lim[bLevel];
     12,024,448       0     0              0             0           0              0             0         0          trail.shrink(trail.size() - trail_lim[bLevel]);
     18,036,672       0     0      6,012,224             0           0              0             0         0          trail_lim.shrink(trail_lim.size() - bLevel);
     25,797,728       1     1      6,012,224             0           0              0             0         0          for (int nLitId = add_tmp.size() - 1; nLitId >= 0; --nLitId)
              .       .     .              .             .           .              .             .         .  		{
         56,337       0     0         18,779             0           0              0             0         0  			trail.push_(add_tmp[nLitId]);
              .       .     .              .             .           .              .             .         .  		}
              .       .     .              .             .           .              .             .         .  		
              .       .     .              .             .           .              .             .         .  		add_tmp.clear();
     48,097,792       0     0     42,085,568     5,378,345           0              0             0         0      } }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  //=================================================================================================
              .       .     .              .             .           .              .             .         .  // Major methods:
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  Lit Solver::pickBranchLit()
    160,029,248   1,227   112              0             0           0    120,021,936             0         0  {
              .       .     .              .             .           .              .             .         .      Var next = var_Undef;
              .       .     .              .             .           .              .             .         .      //    Heap<VarOrderLt>& order_heap = VSIDS ? order_heap_VSIDS : order_heap_CHB;
    120,303,481  23,114 1,095     33,789,893     8,839,203         677              0             0         0      Heap<VarOrderLt>& order_heap = DISTANCE ? order_heap_distance : ((!VSIDS)? order_heap_CHB:order_heap_VSIDS);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Random decision:
              .       .     .              .             .           .              .             .         .      /*if (drand(random_seed) < random_var_freq && !order_heap.empty()){
              .       .     .              .             .           .              .             .         .          next = order_heap[irand(random_seed,order_heap.size())];
              .       .     .              .             .           .              .             .         .          if (value(next) == l_Undef && decision[next])
              .       .     .              .             .           .              .             .         .              rnd_decisions++; }*/
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Activity based decision:
    553,267,431   4,266     5    256,630,059    87,142,298     121,837              0             0         0      while (next == var_Undef || value(next) != l_Undef || !decision[next])
    196,619,096       0     0              0             0           0              0             0         0          if (order_heap.empty())
              1       0     0              0             0           0              0             0         0              return lit_Undef;
              .       .     .              .             .           .              .             .         .          else{
              .       .     .              .             .           .              .             .         .  #ifdef ANTI_EXPLORATION
    196,619,094       0     0     98,309,547       137,526           2              0             0         0              if (!VSIDS){
              .       .     .              .             .           .              .             .         .                  Var v = order_heap_CHB[0];
     51,339,380       0     0     51,339,380        10,066           0              0             0         0                  uint32_t age = conflicts - canceled[v];
    131,571,606       0     0     56,421,447    50,278,458      75,900      9,364,356            25         0                  while (age > 0){
              .       .     .              .             .           .              .             .         .                      double decay = pow(0.95, age);
     61,503,514       0     0     30,751,757       535,368          22     30,751,757             0         0                      activity_CHB[v] *= decay;
              .       .     .              .             .           .              .             .         .                      if (order_heap_CHB.inHeap(v))
              .       .     .              .             .           .              .             .         .                          order_heap_CHB.increase(v);
     92,255,271       0     0     61,503,514           119           0     30,751,757           233         0                      canceled[v] = conflicts;
              .       .     .              .             .           .              .             .         .                      v = order_heap_CHB[0];
              .       .     .              .             .           .              .             .         .                      age = conflicts - canceled[v];
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .              next = order_heap.removeMin();
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .  
     80,014,620       0     0     40,007,310    18,673,441       5,440              0             0         0      return mkLit(next, polarity[next]);
    180,032,903       0     0    140,025,592     1,005,887           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  inline Solver::ConflictData Solver::FindConflictLevel(CRef cind)
              .       .     .              .             .           .              .             .         .  {
              .       .     .              .             .           .              .             .         .  	ConflictData data;
              .       .     .              .             .           .              .             .         .  	Clause& conflCls = ca[cind];
              .       .     .              .             .           .              .             .         .  	data.nHighestLevel = level(var(conflCls[0]));
     23,887,882       0     0     11,943,941       252,757           0              0             0         0  	if (data.nHighestLevel == decisionLevel() && level(var(conflCls[1])) == decisionLevel())
              .       .     .              .             .           .              .             .         .  	{
              .       .     .              .             .           .              .             .         .  		return data;
              .       .     .              .             .           .              .             .         .  	}
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  	int highestId = 0;
              .       .     .              .             .           .              .             .         .      data.bOnlyOneLitFromHighest = true;
              .       .     .              .             .           .              .             .         .  	// find the largest decision level in the clause
        206,306      92    77              0             0           0              0             0         0  	for (int nLitId = 1; nLitId < conflCls.size(); ++nLitId)
              .       .     .              .             .           .              .             .         .  	{
              .       .     .              .             .           .              .             .         .  		int nLevel = level(var(conflCls[nLitId]));
        124,064       0     0              0             0           0              0             0         0  		if (nLevel > data.nHighestLevel)
              .       .     .              .             .           .              .             .         .  		{
              .       .     .              .             .           .              .             .         .  			highestId = nLitId;
              .       .     .              .             .           .              .             .         .  			data.nHighestLevel = nLevel;
          1,706       0     0              0             0           0              0             0         0  			data.bOnlyOneLitFromHighest = true;
              .       .     .              .             .           .              .             .         .  		}
              .       .     .              .             .           .              .             .         .  		else if (nLevel == data.nHighestLevel && data.bOnlyOneLitFromHighest == true)
              .       .     .              .             .           .              .             .         .  		{
        115,534       0     0              0             0           0              0             0         0  			data.bOnlyOneLitFromHighest = false;
              .       .     .              .             .           .              .             .         .  		}
              .       .     .              .             .           .              .             .         .  	}
              .       .     .              .             .           .              .             .         .  
         21,840     750    80              0             0           0              0             0         0  	if (highestId != 0)
              .       .     .              .             .           .              .             .         .  	{
              .       .     .              .             .           .              .             .         .  		std::swap(conflCls[0], conflCls[highestId]);
          3,104       0     0              0             0           0              0             0         0  		if (highestId > 1)
              .       .     .              .             .           .              .             .         .  		{
          2,744       0     0              0             0           0              0             0         0  			OccLists<Lit, vec<Watcher>, WatcherDeleted>& ws = conflCls.size() == 2 ? watches_bin : watches;
              .       .     .              .             .           .              .             .         .  			//ws.smudge(~conflCls[highestId]);
              .       .     .              .             .           .              .             .         .  			remove(ws[~conflCls[highestId]], Watcher(cind, conflCls[1]));
              .       .     .              .             .           .              .             .         .  			ws[~conflCls[0]].push(Watcher(cind, conflCls[1]));
              .       .     .              .             .           .              .             .         .  		}
              .       .     .              .             .           .              .             .         .  	}
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  	return data;
              .       .     .              .             .           .              .             .         .  }
-- line 1218 ----------------------------------------
-- line 1231 ----------------------------------------
              .       .     .              .             .           .              .             .         .  |  
              .       .     .              .             .           .              .             .         .  |    Post-conditions:
              .       .     .              .             .           .              .             .         .  |      * 'out_learnt[0]' is the asserting literal at level 'out_btlevel'.
              .       .     .              .             .           .              .             .         .  |      * If out_learnt.size() > 1 then 'out_learnt[1]' has the greatest decision level of the 
              .       .     .              .             .           .              .             .         .  |        rest of literals. There may be others from the same level though.
              .       .     .              .             .           .              .             .         .  |  
              .       .     .              .             .           .              .             .         .  |________________________________________________________________________________________________@*/
              .       .     .              .             .           .              .             .         .  void Solver::analyze(CRef confl, vec<Lit>& out_learnt, int& out_btlevel, int& out_lbd)
     77,672,725     868   507              0             0           0     53,773,425             1         0  {
      5,974,825       0     0              0             0           0      5,974,825        12,034         0      int pathC = 0;
      5,974,825       0     0              0             0           0              0             0         0      Lit p     = lit_Undef;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Generate conflict clause:
              .       .     .              .             .           .              .             .         .      //
              .       .     .              .             .           .              .             .         .      out_learnt.push();      // (leave room for the asserting literal)
     11,949,650       0     0      5,974,825             0           0              0             0         0      int index   = trail.size() - 1;
      5,974,825       0     0      5,974,825             1           0              0             0         0      int nDecisionLevel = level(var(ca[confl][0]));
              .       .     .              .             .           .              .             .         .      assert(nDecisionLevel == level(var(ca[confl][0])));
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      do{
              .       .     .              .             .           .              .             .         .          assert(confl != CRef_Undef); // (otherwise should be UIP)
              .       .     .              .             .           .              .             .         .          Clause& c = ca[confl];
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          // For binary clauses, we don't rearrange literals in propagate(), so check and make sure the first is an implied lit.
  1,529,228,788       0     0              0             0           0              0             0         0          if (p != lit_Undef && c.size() == 2 && value(c[0]) == l_False){
              .       .     .              .             .           .              .             .         .              assert(value(c[1]) == l_True);
              .       .     .              .             .           .              .             .         .              Lit tmp = c[0];
     35,241,255       0     0     11,747,085       687,254      22,017     23,494,170             0         0              c[0] = c[1], c[1] = tmp; }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          // Update LBD if improved.
  1,122,286,894       1     1    187,922,022         9,572           0              0             0         0          if (c.learnt() && c.mark() != CORE){
              .       .     .              .             .           .              .             .         .              int lbd = computeLBD(c);
     33,815,448       0     0              0             0           0              0             0         0              if (lbd < c.lbd()){
      3,814,508       0     0              0             0           0              0             0         0                  if (c.lbd() <= 30) c.removable(false); // Protect once from reduction.
              .       .     .              .             .           .              .             .         .                  c.set_lbd(lbd);
      3,814,508       0     0      1,907,254     1,576,604          43              0             0         0                  if (lbd <= core_lbd_cut){
              8       2     2              0             0           0              4             0         0                      learnts_core.push(confl);
              .       .     .              .             .           .              .             .         .                      c.mark(CORE);
      4,610,136       0     0        386,562             0           0              0             0         0                  }else if (lbd <= 6 && c.mark() == LOCAL){
              .       .     .              .             .           .              .             .         .                      // Bug: 'cr' may already be in 'learnts_tier2', e.g., if 'cr' was demoted from TIER2
              .       .     .              .             .           .              .             .         .                      // to LOCAL previously and if that 'cr' is not cleaned from 'learnts_tier2' yet.
     42,388,855      17    17              0             0           0     12,232,190     5,743,840       281                      learnts_tier2.push(confl);
              .       .     .              .             .           .              .             .         .                      c.mark(TIER2); }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
     33,310,120       0     0     16,655,060        71,128           0              0             0         0              if (c.mark() == TIER2)
     21,579,280      79    77      5,394,820     2,215,677           0      5,394,820       636,713     5,836                  c.touched() = conflicts;
     22,803,020       0     0     11,401,510             0           0              0             0         0              else if (c.mark() == LOCAL)
              .       .     .              .             .           .              .             .         .                  claBumpActivity(c);
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .  
  6,722,589,534      31    31  2,053,214,886       583,961           0    331,528,675           129         0          for (int j = (p == lit_Undef) ? 0 : 1; j < c.size(); j++){
  1,721,686,211       0     0  1,721,686,211    76,963,319      80,364              0             0         0              Lit q = c[j];
              .       .     .              .             .           .              .             .         .  
  6,743,345,650       2     2  2,821,677,287 1,038,954,196      81,965              0             0         0              if (!seen[var(q)] && level(var(q)) > 0){
  2,199,922,570       0     0  1,099,961,285       281,453           0              0             0         0                  if (VSIDS){
              .       .     .              .             .           .              .             .         .                      varBumpActivity(var(q), .5);
             14       0     0              0             0           0              7             0         0                      add_tmp.push(q);
              .       .     .              .             .           .              .             .         .                  }else
    733,761,206       0     0    733,761,206   604,716,648     173,999              0             0         0                      conflicted[var(q)]++;
  1,099,961,285       0     0              0             0           0  1,099,961,285           282         0                  seen[var(q)] = 1;
  2,199,922,570       0     0  1,099,961,285           364           0              0             0         0                  if (level(var(q)) >= nDecisionLevel){
    663,057,350       0     0    663,057,350        52,744           0              0             0         0                      pathC++;
              .       .     .              .             .           .              .             .         .                  }else
              .       .     .              .             .           .              .             .         .                      out_learnt.push(q);
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          
              .       .     .              .             .           .              .             .         .          // Select next clause to look at:
              .       .     .              .             .           .              .             .         .  		do {
 21,636,200,565       0     0  8,720,785,961 2,076,281,915     424,845              0             0         0  			while (!seen[var(trail[index--])]);
              .       .     .              .             .           .              .             .         .  			p  = trail[index+1];
    663,088,576      10    10    331,544,288    64,018,469           0              0             0         0  		} while (level(var(p)) < nDecisionLevel);
              .       .     .              .             .           .              .             .         .  		
    663,057,350       0     0    331,528,675             0           0    331,528,675        25,011         0          confl = reason(var(p));
    331,528,675       0     0              0             0           0    331,528,675             0         0          seen[var(p)] = 0;
    663,057,350       0     0    663,057,350        29,669           0              0             0         0          pathC--;
              .       .     .              .             .           .              .             .         .  
  1,965,272,750       0     0    651,107,700     1,352,718           0              0             0         0      }while (pathC > 0);
      5,974,825       0     0      5,974,825        13,877           0              0             0         0      out_learnt[0] = ~p;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Simplify conflict clause:
              .       .     .              .             .           .              .             .         .      //
              .       .     .              .             .           .              .             .         .      int i, j;
     11,949,650       0     0              0             0           0      5,974,825             0         0      out_learnt.copyTo(analyze_toclear);
     17,924,475       0     0      5,974,825         2,520           0              0             0         0      if (ccmin_mode == 2){
      5,974,458   3,174 1,038              0             0           0              0             0         0          uint32_t abstract_level = 0;
  1,548,814,870   2,188   311              0             0           0              0             0         0          for (i = 1; i < out_learnt.size(); i++)
    780,381,526       0     0      5,974,458             0           0              0             0         0              abstract_level |= abstractLevel(var(out_learnt[i])); // (maintain an abstraction of levels involved in conflict)
              .       .     .              .             .           .              .             .         .  
  5,438,772,850      46    44  2,299,323,372       437,491           0      5,974,458       351,302         0          for (i = j = 1; i < out_learnt.size(); i++)
  6,041,383,822      88    85  1,221,089,011   488,455,058           0    719,841,160             0         0              if (reason(var(out_learnt[i])) == CRef_Undef || !litRedundant(out_learnt[i], abstract_level))
  1,503,743,553      12     8    501,247,851       630,310           0    501,247,851     8,625,036         0                  out_learnt[j++] = out_learnt[i];
              .       .     .              .             .           .              .             .         .          
              .       .     .              .             .           .              .             .         .      }else if (ccmin_mode == 1){
              .       .     .              .             .           .              .             .         .          for (i = j = 1; i < out_learnt.size(); i++){
              .       .     .              .             .           .              .             .         .              Var x = var(out_learnt[i]);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              if (reason(x) == CRef_Undef)
              .       .     .              .             .           .              .             .         .                  out_learnt[j++] = out_learnt[i];
              .       .     .              .             .           .              .             .         .              else{
-- line 1331 ----------------------------------------
-- line 1334 ----------------------------------------
              .       .     .              .             .           .              .             .         .                      if (!seen[var(c[k])] && level(var(c[k])) > 0){
              .       .     .              .             .           .              .             .         .                          out_learnt[j++] = out_learnt[i];
              .       .     .              .             .           .              .             .         .                          break; }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }else
              .       .     .              .             .           .              .             .         .          i = j = out_learnt.size();
              .       .     .              .             .           .              .             .         .  
     11,949,650       0     0      5,974,825     5,917,823         283              0             0         0      max_literals += out_learnt.size();
    610,665,473       1     1    151,172,662             0           0              0             0         0      out_learnt.shrink(i - j);
      5,974,825     558   166      5,974,825             0           0              0             0         0      tot_literals += out_learnt.size();
              .       .     .              .             .           .              .             .         .  
     11,949,650       0     0      5,974,825     3,232,645           0      5,974,825        88,188         0      out_lbd = computeLBD(out_learnt);
     67,524,142  16,977 1,105     30,467,158       224,135           0              0             0         0      if (out_lbd <= 6 && out_learnt.size() <= 30) // Try further minimization?
      4,161,927  88,116 1,601        594,561             0           0      1,189,122             0         0          if (binResMinimize(out_learnt))
         35,574       0     0         11,858             0           0         11,858             0         0              out_lbd = computeLBD(out_learnt); // Recompute LBD if minimized.
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Find correct backtrack level:
              .       .     .              .             .           .              .             .         .      //
     11,929,210       0     0              0             0           0              0             0         0      if (out_learnt.size() == 1)
          1,146       0     0            382             0           0            382             0         0          out_btlevel = 0;
              .       .     .              .             .           .              .             .         .      else{
     11,925,874       0     0              0             0           0              0             0         0          int max_i = 1;
              .       .     .              .             .           .              .             .         .          // Find the first literal assigned at the next-highest level:
  1,992,892,180       0     0              0             0           0              0             0         0          for (int i = 2; i < out_learnt.size(); i++)
  1,533,884,285       0     0    495,260,735     1,869,989           0              0             0         0              if (level(var(out_learnt[i])) > level(var(out_learnt[max_i])))
              .       .     .              .             .           .              .             .         .                  max_i = i;
              .       .     .              .             .           .              .             .         .          // Swap-in this literal at index 1:
              .       .     .              .             .           .              .             .         .          Lit p             = out_learnt[max_i];
     11,948,886     169     0      5,974,443        62,661           0      5,974,443        18,217         0          out_learnt[max_i] = out_learnt[1];
      5,974,443       0     0              0             0           0      5,974,443             0         0          out_learnt[1]     = p;
     11,948,886       0     0      5,974,443        53,111           0      5,974,443        84,264         0          out_btlevel       = level(var(p));
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
     11,949,650   3,676   548      5,974,825     3,053,097           0              0             0         0      if (VSIDS){
  1,317,723,222  16,889   985    376,543,890     2,615,536           0              0             0         0          for (int i = 0; i < add_tmp.size(); i++){
              .       .     .              .             .           .              .             .         .              Var v = var(add_tmp[i]);
  1,098,600,237       0     0    366,200,079   156,512,213           0              0             0         0              if (level(v) >= out_btlevel - 1)
              .       .     .              .             .           .              .             .         .                  varBumpActivity(v, 1);
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          add_tmp.clear();
              .       .     .              .             .           .              .             .         .      }else{
      5,053,776       3     1      2,526,888        58,298           0      2,526,888       801,016         0          seen[var(p)] = true;
  1,038,351,054       0     0      2,526,888             0           0              0             0         0          for(int i = out_learnt.size() - 1; i >= 0; i--){
              .       .     .              .             .           .              .             .         .              Var v = var(out_learnt[i]);
              .       .     .              .             .           .              .             .         .              CRef rea = reason(v);
    673,703,524       0     0              0             0           0              0             0         0              if (rea != CRef_Undef){
              .       .     .              .             .           .              .             .         .                  const Clause& reaC = ca[rea];
  4,601,245,442       0     0              0             0           0              0             0         0                  for (int i = 0; i < reaC.size(); i++){
              .       .     .              .             .           .              .             .         .                      Lit l = reaC[i];
  3,391,633,554       0     0  1,695,816,777   493,669,840      13,635              0             0         0                      if (!seen[var(l)]){
    786,034,524       0     0              0             0           0    786,034,524             0         0                          seen[var(l)] = true;
    786,034,524       0     0    786,034,524   670,826,804     179,360              0             0         0                          almost_conflicted[var(l)]++;
              .       .     .              .             .           .              .             .         .                          analyze_toclear.push(l); } } } } }
              .       .     .              .             .           .              .             .         .  
  7,873,526,213   4,624   305  3,927,800,869       521,221           0  1,960,913,022   353,209,763         0      for (int j = 0; j < analyze_toclear.size(); j++) seen[var(analyze_toclear[j])] = 0;    // ('seen[]' is now cleared)
     47,798,600       0     0     41,823,775     4,872,280           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  // Try further learnt clause minimization by means of binary clause resolution.
              .       .     .              .             .           .              .             .         .  bool Solver::binResMinimize(vec<Lit>& out_learnt)
      2,253,455       0     0              0             0           0      1,802,764             0         0  {
              .       .     .              .             .           .              .             .         .      // Preparation: remember which false variables we have in 'out_learnt'.
      1,783,683      60    55        594,561             0           0        594,561             0         0      counter++;
     13,401,468       0     0      1,189,122             0           0              0             0         0      for (int i = 1; i < out_learnt.size(); i++)
      4,940,262       0     0        594,194             0           0      4,346,068     4,257,166 1,361,282          seen2[var(out_learnt[i])] = counter;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Get the list of binary clauses containing 'out_learnt[0]'.
              .       .     .              .             .           .              .             .         .      const vec<Watcher>& ws = watches_bin[~out_learnt[0]];
              .       .     .              .             .           .              .             .         .  
        450,691       0     0              0             0           0              0             0         0      int to_remove = 0;
      6,042,806       1     1        594,561       492,423          13         11,858             0         0      for (int i = 0; i < ws.size(); i++){
      2,494,735       0     0      2,494,735       530,723          25              0             0         0          Lit the_other = ws[i].blocker;
              .       .     .              .             .           .              .             .         .          // Does 'the_other' appear negatively in 'out_learnt'?
     10,004,286      92    87      4,564,125     1,909,693     708,614              0             0         0          if (seen2[var(the_other)] == counter && value(the_other) == l_True){
         12,673       0     0              0             0           0              0             0         0              to_remove++;
         38,019       0     0              0             0           0         12,673             0         0              seen2[var(the_other)] = counter - 1; // Remember to remove this variable.
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Shrink.
      1,352,073      64    48              0             0           0              0             0         0      if (to_remove > 0){
         11,858       0     0              0             0           0              0             0         0          int last = out_learnt.size() - 1;
        778,915   3,909 1,013         11,843             0           0              0             0         0          for (int i = 1; i < out_learnt.size() - to_remove; i++)
        211,778       0     0        105,889             0           0              0             0         0              if (seen2[var(out_learnt[i])] != counter)
         55,735       0     0         22,294             0           0         11,147             0         0                  out_learnt[i--] = out_learnt[last--];
              .       .     .              .             .           .              .             .         .          out_learnt.shrink(to_remove);
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .      return to_remove != 0;
      2,397,325       5     5      2,397,325             0           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  // Check if 'p' can be removed. 'abstract_levels' is used to abort early if the algorithm is
              .       .     .              .             .           .              .             .         .  // visiting literals at levels that cannot be removed later.
              .       .     .              .             .           .              .             .         .  bool Solver::litRedundant(Lit p, uint32_t abstract_levels)
  7,198,411,600  67,089    90              0             0           0  4,319,046,960     5,233,304         0  {
  1,439,682,320       0     0              0             0           0    719,841,160             0         0      analyze_stack.clear(); analyze_stack.push(p);
  2,159,523,480       0     0  1,439,682,320             0           0    719,841,160             0         0      int top = analyze_toclear.size();
  6,123,933,622       0     0              0             0           0              0             0         0      while (analyze_stack.size() > 0){
              .       .     .              .             .           .              .             .         .          assert(reason(var(analyze_stack.last())) != CRef_Undef);
              .       .     .              .             .           .              .             .         .          Clause& c = ca[reason(var(analyze_stack.last()))]; analyze_stack.pop();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          // Special handling for binary clauses like in 'analyze()'.
  8,896,371,972     121   103              0             0           0              0             0         0          if (c.size() == 2 && value(c[0]) == l_False){
              .       .     .              .             .           .              .             .         .              assert(value(c[1]) == l_True);
              .       .     .              .             .           .              .             .         .              Lit tmp = c[0];
     19,457,037       0     0      6,485,679       390,590      22,860     12,971,358             0         0              c[0] = c[1], c[1] = tmp; }
              .       .     .              .             .           .              .             .         .  
 13,082,117,014       0     0              0             0           0              0             0         0          for (int i = 1; i < c.size(); i++){
  5,852,336,790   2,719   564  5,852,336,790   399,647,936     293,798              0             0         0              Lit p  = c[i];
 24,972,989,464       0     0 11,704,673,580 1,233,465,851      50,632              0             0         0              if (!seen[var(p)] && level(var(p)) > 0){
 14,035,363,444       0     0  3,707,827,516             0           0              0             0         0                  if (reason(var(p)) != CRef_Undef && (abstractLevel(var(p)) & abstract_levels) != 0){
  3,255,171,115       0     0              0             0           0  3,255,171,115             0         0                      seen[var(p)] = 1;
              .       .     .              .             .           .              .             .         .                      analyze_stack.push(p);
              9       0     0              0             0           0              0             0         0                      analyze_toclear.push(p);
              .       .     .              .             .           .              .             .         .                  }else{
 13,109,365,570   4,972 1,198  3,760,012,854       662,532           0              0             0         0                      for (int j = top; j < analyze_toclear.size(); j++)
  5,311,503,749       0     0  2,456,803,697             0           0  2,854,700,052    21,335,711         0                          seen[var(analyze_toclear[j])] = 0;
    905,312,802      24    19    452,656,401         2,131           0              0             0         0                      analyze_toclear.shrink(analyze_toclear.size() - top);
    452,656,401       0     0              0             0           0              0             0         0                      return false;
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
    534,369,518       0     0              0             0           0              0             0         0      return true;
  5,758,729,280       2     2  5,038,888,120       951,847           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  /*_________________________________________________________________________________________________
              .       .     .              .             .           .              .             .         .  |
              .       .     .              .             .           .              .             .         .  |  analyzeFinal : (p : Lit)  ->  [void]
              .       .     .              .             .           .              .             .         .  |  
              .       .     .              .             .           .              .             .         .  |  Description:
              .       .     .              .             .           .              .             .         .  |    Specialized analysis procedure to express the final conflict in terms of assumptions.
-- line 1468 ----------------------------------------
-- line 1495 ----------------------------------------
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      seen[var(p)] = 0;
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::uncheckedEnqueue(Lit p, int level, CRef from)
 51,336,185,830       6     6              0             0           0 25,668,092,915             5         0  {
              .       .     .              .             .           .              .             .         .      assert(value(p) == l_Undef);
              .       .     .              .             .           .              .             .         .      Var x = var(p);
 10,267,237,166       0     0  5,133,618,583     1,946,847         173              0             0         0      if (!VSIDS){
  7,644,990,168       0     0  5,096,660,112     2,149,775         406  2,548,330,056 2,447,064,960   888,811          picked[x] = conflicts;
  5,096,660,112       0     0  2,548,330,056             0           0  2,548,330,056 2,445,825,278   861,569          conflicted[x] = 0;
  5,096,660,112       2     2  2,548,330,056             0           0  2,548,330,056 2,447,055,396   829,941          almost_conflicted[x] = 0;
              .       .     .              .             .           .              .             .         .  #ifdef ANTI_EXPLORATION
  2,548,330,056       0     0  2,548,330,056     1,010,253         123              0             0         0          uint32_t age = conflicts - canceled[var(p)];
  5,096,660,112       0     0  2,548,330,056 2,417,146,417     815,791              0             0         0          if (age > 0){
              .       .     .              .             .           .              .             .         .              double decay = pow(0.95, age);
  2,622,116,816       0     0  1,311,058,408 1,277,138,280     506,821  1,311,058,408             0         0              activity_CHB[var(p)] *= decay;
              .       .     .              .             .           .              .             .         .              if (order_heap_CHB.inHeap(var(p)))
  1,311,058,408       0     0              0             0           0              0             0         0                  order_heap_CHB.increase(var(p));
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
  5,133,618,583       1     1  5,133,618,583         2,007         163              0             0         0      assigns[x] = lbool(!sign(p));
 10,267,237,166       0     0              0             0           0 10,267,237,166 4,866,865,387 1,658,766      vardata[x] = mkVarData(from, level);
  5,133,618,583       4     4  5,133,618,583             0           0              0             0         0      trail.push_(p);
 35,935,330,081       0     0 30,801,711,498             0           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  unsigned number_watch_changed_total=0;
              .       .     .              .             .           .              .             .         .  unsigned number_clause_read_total=0;
              .       .     .              .             .           .              .             .         .  unsigned times_only_access_watch=0;
              .       .     .              .             .           .              .             .         .  /*_________________________________________________________________________________________________
              .       .     .              .             .           .              .             .         .  |
              .       .     .              .             .           .              .             .         .  |  propagate : [void]  ->  [Clause*]
              .       .     .              .             .           .              .             .         .  |  
-- line 1532 ----------------------------------------
-- line 1533 ----------------------------------------
              .       .     .              .             .           .              .             .         .  |  Description:
              .       .     .              .             .           .              .             .         .  |    Propagates all enqueued facts. If a conflict arises, the conflicting clause is returned,
              .       .     .              .             .           .              .             .         .  |    otherwise CRef_Undef.
              .       .     .              .             .           .              .             .         .  |  
              .       .     .              .             .           .              .             .         .  |    Post-conditions:
              .       .     .              .             .           .              .             .         .  |      * the propagation queue is empty, even if there was a conflict.
              .       .     .              .             .           .              .             .         .  |________________________________________________________________________________________________@*/
              .       .     .              .             .           .              .             .         .  CRef Solver::propagate_()
    208,460,064       7     7              0             0           0    156,345,048             0         0  {
              .       .     .              .             .           .              .             .         .      //auto start_time=std::chrono::steady_clock::now();
     26,057,508       0     0              0             0           0     26,057,508             0         0      CRef    confl     = CRef_Undef;
     26,057,508       0     0              0             0           0     26,057,508           216         0      int     num_props = 0;
     52,115,016       0     0              0             0           0     26,057,508     2,675,990         1      watches.cleanAll();
     52,115,016       4     4              0             0           0     26,057,508             0         0      watches_bin.cleanAll();
              .       .     .              .             .           .              .             .         .      
 15,494,342,710       2     2 10,775,124,987     1,068,757           4              0             0         0      while (qhead < trail.size()){
 23,383,020,560       0     0  9,353,208,224   196,342,330           0  4,676,604,112             0         0          Lit            p   = trail[qhead++];     // 'p' is enqueued fact to propagate.
              .       .     .              .             .           .              .             .         .          int currLevel = level(var(p));
              .       .     .              .             .           .              .             .         .          vec<Watcher>&  ws  = watches[p];
              .       .     .              .             .           .              .             .         .          //std::cout<<"size of ws: "<<watches.size()<<"\n";
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          Watcher        *i, *j, *end;
  6,047,442,575       0     0  6,047,442,575     4,123,451           0              0             0         0          num_props++;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          vec<Watcher>& ws_bin = watches_bin[p];  // Propagate binary clauses first.
              .       .     .              .             .           .              .             .         .          //std::cout<<"size of ws_bin: "<<watches_bin.size()<<"\n";
 35,481,994,265       4     4  4,676,604,112 4,657,909,936  10,923,878              0             0         0          for (int k = 0; k < ws_bin.size(); k++){
  8,584,499,837       0     0  8,584,499,837 2,601,392,437  14,351,112              0             0         0              Lit the_other = ws_bin[k].blocker;
 56,943,301,523       0     0 33,330,760,752             0           0              0             0         0              if (value(the_other) == l_False){
      2,073,432       5     0      1,036,716             0           0      1,036,716             0         0                  confl = ws_bin[k].cref;
              .       .     .              .             .           .              .             .         .                  //auto end_time=std::chrono::steady_clock::now();
              .       .     .              .             .           .              .             .         .                  //auto duration=end_time-start_time;
              .       .     .              .             .           .              .             .         .  #ifdef LOOSE_PROP_STAT
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                  return confl;
              .       .     .              .             .           .              .             .         .  #else
              .       .     .              .             .           .              .             .         .                  goto ExitProp;
              .       .     .              .             .           .              .             .         .  #endif
 12,869,755,524       5     5              0             0           0              0             0         0              }else if(value(the_other) == l_Undef)
              .       .     .              .             .           .              .             .         .              {
 11,014,552,125       3     3  6,608,731,275         1,954           0  2,202,910,425     1,119,492         0                  uncheckedEnqueue(the_other, currLevel, ws_bin[k].cref);
              .       .     .              .             .           .              .             .         .  #ifdef  PRINT_OUT                
              .       .     .              .             .           .              .             .         .                  std::cout << "i " << the_other << " l " << currLevel << "\n";
              .       .     .              .             .           .              .             .         .  #endif                
              .       .     .              .             .           .              .             .         .  			}
              .       .     .              .             .           .              .             .         .          }
  9,351,134,792       0     0  9,351,134,792 4,616,584,274   6,396,712              0             0         0          total_Watchers+=ws.size();
  4,675,567,396       0     0  4,675,567,396             0           0              0             0         0          total_indexs++;//number of rounds
              .       .     .              .             .           .              .             .         .          //int count=0;
  4,112,264,496       0     0              0             0           0              0             0         0          bool no_clause_access=true;
  4,112,264,496       0     0              0             0           0  4,112,264,496             0         0          bool no_implication_added=true;
  4,112,264,496       0     0              0             0           0  4,112,264,496             0         0          bool no_change_other_watch=true;
113,288,904,800      10    10 47,574,969,058             0           0  4,675,567,396             0         0          for (i = j = (Watcher*)ws, end = i + ws.size();  i != end;){
              .       .     .              .             .           .              .             .         .              // Try to avoid inspecting the clause:
              .       .     .              .             .           .              .             .         .              //count++;
 42,899,401,662       3     3 42,899,401,662 8,704,330,353  86,185,223              0             0         0              Lit blocker = i->blocker;
 85,798,803,324       0     0 42,899,401,662     7,388,134         492              0             0         0              total_access_watches++;
 85,798,803,324       0     0 42,899,401,662 7,569,536,513     188,407              0             0         0              if (value(blocker) == l_True){
              .       .     .              .             .           .              .             .         .                  
130,789,840,828       0     0 32,697,460,207             0           0 32,697,460,207     2,375,177         0                  *j++ = *i++; continue; }//no clause accessed
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Make sure the false literal is data[1]:
 10,227,734,841       0     0      4,170,552             0           0              0             0         0              no_clause_access=false;
 30,605,824,365       4     4 20,403,882,910    15,618,046         965 10,201,941,455             0         0              total_clause_access_times++;
 20,403,882,910       0     0 10,201,941,455             0           0              0             0         0              CRef     cr        = i->cref;
              .       .     .              .             .           .              .             .         .              //std::cout<<"cr: "<<cr<<"\n";
              .       .     .              .             .           .              .             .         .              Clause&  c         = ca[cr];
              .       .     .              .             .           .              .             .         .              Lit      false_lit = ~p;
 10,201,941,455       0     0 10,201,941,455             0           0              0             0         0              total_clause_access_size+=2;
 30,605,824,365       0     0 20,403,882,910 9,315,558,380 129,140,738              0             0         0              if (c[0] == false_lit)
  8,312,624,888       0     0  4,156,312,444   114,533,311   2,726,789  4,156,312,444             0         0                  c[0] = c[1], c[1] = false_lit;
              .       .     .              .             .           .              .             .         .              assert(c[1] == false_lit);
              .       .     .              .             .           .              .             .         .              i++;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // If 0th watch is true, then clause is already satisfied.
              .       .     .              .             .           .              .             .         .              Lit     first = c[0];
              .       .     .              .             .           .              .             .         .              Watcher w     = Watcher(cr, first);
 22,997,902,334       0     0  1,297,009,712   188,615,772       3,544              0             0         0              if (first != blocker && value(first) == l_True){
  1,899,901,635       0     0              0             0           0  1,266,601,090       372,521         0                  *j++ = w; continue; }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Look for new watch:
 77,552,863,386       3     3              0             0           0              0             0         0              for (int k = 2; k < c.size(); k++)
              .       .     .              .             .           .              .             .         .              {
125,404,080,761       0     0              0             0           0 26,130,836,011             0         0                  total_clause_access_size++;
 77,262,909,701       0     0  5,863,955,859             0           0              0             0         0                  if (value(c[k]) != l_False){
 26,635,901,956  20,510    22 13,317,950,978         6,675           0 13,317,950,978         2,392         0                      c[1] = c[k]; c[k] = false_lit;
  6,658,975,489       0     0  6,658,975,489             0           0              0             0         0                      total_change_other_watch++;
  6,658,975,489       0     0              0             0           0  6,658,975,489             0         0                      no_change_other_watch=false;
              .       .     .              .             .           .              .             .         .                      watches[~c[1]].push(w);
              .       .     .              .             .           .              .             .         .                      goto NextClause; }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Did not find watch -- clause is unit under assignment:
  8,733,936,889       0     0              0             0           0  5,819,330,842        98,495         0              *j++ = w;
  5,819,330,842       0     0              0             0           0              0             0         0              if (value(first) == l_False){
      4,940,626       0     0      4,940,626           201           0              0             0         0                  time_find_conflict++;
     29,643,756       1     1     19,762,504        27,638           0              0             0         0                  total_find_conflict_length+=i-(Watcher*)ws;
      9,881,252       0     0      9,881,252             0           0              0             0         0                  total_find_conflict_allsize+=ws.size();
              .       .     .              .             .           .              .             .         .                  //std::cout<<"count: "<<count<<", length: "<<i-ws<<"\n";
      4,940,626       0     0              0             0           0      4,940,626             0         0                  confl = cr;
      9,881,252       0     0      4,940,626         3,386           0      4,940,626             0         0                  qhead = trail.size();
              .       .     .              .             .           .              .             .         .                  // Copy the remaining watches:
              .       .     .              .             .           .              .             .         .  
    200,271,470      41    37      9,111,178             0           0              0             0         0                  while (i < end)
     88,554,244       0     0     88,554,244    10,986,721     502,050     88,554,244        16,177         0                      *j++ = *i++;
              .       .     .              .             .           .              .             .         .              }else
              .       .     .              .             .           .              .             .         .              {//new implecate
  2,904,724,795       0     0              0             0           0  2,904,724,795            54         0                  no_implication_added=false;
  2,904,724,795       0     0  2,904,724,795             0           0              0             0         0                  total_push_new_implication++;
  8,714,174,385       0     0  5,809,449,590       292,387           0              0             0         0  				if (currLevel == decisionLevel())
              .       .     .              .             .           .              .             .         .  				{
  5,809,449,590       0     0              0             0           0              0             0         0  					uncheckedEnqueue(first, currLevel, cr);
              .       .     .              .             .           .              .             .         .  #ifdef PRINT_OUT					
              .       .     .              .             .           .              .             .         .  					std::cout << "i " << first << " l " << currLevel << "\n";
              .       .     .              .             .           .              .             .         .  #endif					
              .       .     .              .             .           .              .             .         .  				}
              .       .     .              .             .           .              .             .         .  				else
              .       .     .              .             .           .              .             .         .  				{
              .       .     .              .             .           .              .             .         .  					int nMaxLevel = currLevel;
      4,319,734       0     0              0             0           0              0             0         0  					int nMaxInd = 1;
              .       .     .              .             .           .              .             .         .  					// pass over all the literals in the clause and find the one with the biggest level
     16,077,928       0     0      2,159,867             0           0              0             0         0  					for (int nInd = 2; nInd < c.size(); ++nInd)
              .       .     .              .             .           .              .             .         .  					{
              .       .     .              .             .           .              .             .         .  						int nLevel = level(var(c[nInd]));
      7,689,678       0     0              0             0           0              0             0         0  						if (nLevel > nMaxLevel)
              .       .     .              .             .           .              .             .         .  						{
              .       .     .              .             .           .              .             .         .  							nMaxLevel = nLevel;
              .       .     .              .             .           .              .             .         .  							nMaxInd = nInd;
              .       .     .              .             .           .              .             .         .  						}
              .       .     .              .             .           .              .             .         .  					}
              .       .     .              .             .           .              .             .         .  
      4,319,734      33    33              0             0           0              0             0         0  					if (nMaxInd != 1)
              .       .     .              .             .           .              .             .         .  					{
              .       .     .              .             .           .              .             .         .  						std::swap(c[1], c[nMaxInd]);
              .       .     .              .             .           .              .             .         .  						*j--; // undo last watch
        117,698       0     0        117,698            54           0              0             0         0                          total_change_other_watch++;
        117,698       0     0              0             0           0        117,698            43         0                          no_change_other_watch=false;
              .       .     .              .             .           .              .             .         .  						watches[~c[1]].push(w);
              .       .     .              .             .           .              .             .         .  					}
              .       .     .              .             .           .              .             .         .  					
 14,525,783,842       0     0  2,904,724,795             0           0  2,904,724,795     1,687,787         0  					uncheckedEnqueue(first, nMaxLevel, cr);
              .       .     .              .             .           .              .             .         .  #ifdef PRINT_OUT					
              .       .     .              .             .           .              .             .         .  					std::cout << "i " << first << " l " << nMaxLevel << "\n";
              .       .     .              .             .           .              .             .         .  #endif	
              .       .     .              .             .           .              .             .         .  				}
              .       .     .              .             .           .              .             .         .  			}
              .       .     .              .             .           .              .             .         .  
      4,170,552     176   141              0             0           0              0             0         0  NextClause:;
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          //after process all watches, I need to decide if this round of propagation change the assignment queue, or access clause.
 20,561,322,480       0     0  4,112,264,496             0           0              0             0         0          if(no_clause_access==true){
  1,900,691,016     225   177  1,900,691,016       156,216          15              0             0         0              total_no_clause_access++;
              .       .     .              .             .           .              .             .         .          }
  9,561,917,108     147   140  4,112,264,496             0           0              0             0         0          if(no_implication_added==true){
  3,233,918,820       1     1  2,670,615,920            22           0              0             0         0              total_no_implication_added++;
              .       .     .              .             .           .              .             .         .          }
  9,590,292,231       0     0  4,112,264,496             0           0              0             0         0          if(no_change_other_watch==true){
  3,303,692,217      73    61  3,303,692,217            60           0              0             0         0              total_no_change_other_watch++;
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          ws.shrink(i - j);
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  ExitProp:;
     50,041,584       4     4     50,041,584     7,512,800          31              0             0         0      propagations += num_props;
     25,020,792       0     0     25,020,792             0           0              0             0         0      simpDB_props -= num_props;
              .       .     .              .             .           .              .             .         .  
     25,020,792       0     0     25,020,792             0           0              0             0         0      return confl;
  3,913,145,115  21,248    41    182,402,556    13,029,940           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  /*_________________________________________________________________________________________________
              .       .     .              .             .           .              .             .         .  |
              .       .     .              .             .           .              .             .         .  |  reduceDB : ()  ->  [void]
              .       .     .              .             .           .              .             .         .  |  
              .       .     .              .             .           .              .             .         .  |  Description:
              .       .     .              .             .           .              .             .         .  |    Remove half of the learnt clauses, minus the clauses locked by the current assignment. Locked
              .       .     .              .             .           .              .             .         .  |    clauses are clauses that are reason to some assignment. Binary clauses are never removed.
              .       .     .              .             .           .              .             .         .  |________________________________________________________________________________________________@*/
              .       .     .              .             .           .              .             .         .  struct reduceDB_lt { 
              .       .     .              .             .           .              .             .         .      ClauseAllocator& ca;
              .       .     .              .             .           .              .             .         .      reduceDB_lt(ClauseAllocator& ca_) : ca(ca_) {}
    288,173,822     796   796    282,366,458    94,424,546   1,339,844              0             0         0      bool operator () (CRef x, CRef y) const { return ca[x].activity() < ca[y].activity(); }
              .       .     .              .             .           .              .             .         .  };
              .       .     .              .             .           .              .             .         .  void Solver::reduceDB()
          2,388     373   373              0             0           0          1,592             0         0  {
              .       .     .              .             .           .              .             .         .      int     i, j;
              .       .     .              .             .           .              .             .         .      //if (local_learnts_dirty) cleanLearnts(learnts_local, LOCAL);
              .       .     .              .             .           .              .             .         .      //local_learnts_dirty = false;
              .       .     .              .             .           .              .             .         .  
            398       0     0              0             0           0              0             0         0      sort(learnts_local, reduceDB_lt(ca));
              .       .     .              .             .           .              .             .         .  
          1,990       0     0            398           398           0              0             0         0      int limit = learnts_local.size() / 2;
     22,923,004     398   398              0             0           0              0             0         0      for (i = j = 0; i < learnts_local.size(); i++){
     34,381,521     398   398     22,921,014       716,466           0              0             0         0          Clause& c = ca[learnts_local[i]];
     22,921,014       0     0     11,460,507    11,431,699      48,215              0             0         0          if (c.mark() == LOCAL)
     43,168,418       0     0     11,327,083             0           0              0             0         0              if (c.removable() && !locked(c) && i < limit)
     28,469,380       0     0      5,693,876             0           0      5,693,876             0         0                  removeClause(learnts_local[i]);
              .       .     .              .             .           .              .             .         .              else{
      1,064,796       0     0              0             0           0              0             0         0                  if (!c.removable()) limit++;
              .       .     .              .             .           .              .             .         .                  c.removable(true);
     28,432,883       0     0      5,633,207             0           0      5,633,207       352,912         0                  learnts_local[j++] = learnts_local[i]; }
              .       .     .              .             .           .              .             .         .      }
            398       0     0              0             0           0              0             0         0      learnts_local.shrink(i - j);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      checkGarbage();
          2,110       0     0          1,712           398           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  void Solver::reduceDB_Tier2()
          3,582     597   589              0             0           0          2,985             0         0  {
              .       .     .              .             .           .              .             .         .      int i, j;
     11,931,514     590   574            597           247           0              0             0         0      for (i = j = 0; i < learnts_tier2.size(); i++){
     15,543,210     597   589     10,362,140       324,525     244,634              0             0         0          Clause& c = ca[learnts_tier2[i]];
     10,362,140       0     0              0             0           0              0             0         0          if (c.mark() == TIER2)
     25,470,900     494   486     10,188,360     3,742,093   1,075,389              0             0         0              if (!locked(c) && c.touched() + 30000 < conflicts){
              .       .     .              .             .           .              .             .         .                  learnts_local.push(learnts_tier2[i]);
              .       .     .              .             .           .              .             .         .                  c.mark(LOCAL);
              .       .     .              .             .           .              .             .         .                  //c.removable(true);
              .       .     .              .             .           .              .             .         .                  c.activity() = 0;
              .       .     .              .             .           .              .             .         .                  claBumpActivity(c);
              .       .     .              .             .           .              .             .         .              }else
     21,990,870       0     0      4,398,174             0           0      4,398,174       134,938         0                  learnts_tier2[j++] = learnts_tier2[i];
              .       .     .              .             .           .              .             .         .      }
            597       0     0              0             0           0              0             0         0      learnts_tier2.shrink(i - j);
          3,582       0     0          3,582           597           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::removeSatisfied(vec<CRef>& cs)
          2,430       0     0              0             0           0          1,080             0         0  {
              .       .     .              .             .           .              .             .         .      int i, j;
    248,933,758     123   106     49,786,860           136           0              0             0         0      for (i = j = 0; i < cs.size(); i++){
    149,359,767       0     0     99,573,178     3,111,900   2,510,886              0             0         0          Clause& c = ca[cs[i]];
              .       .     .              .             .           .              .             .         .          if (satisfied(c))
         20,815      71    58              1             0           0          6,938         1,660         0              removeClause(cs[i]);
              .       .     .              .             .           .              .             .         .          else
     99,559,302       0     0              0             0           0     49,779,651        10,796         0              cs[j++] = cs[i];
              .       .     .              .             .           .              .             .         .      }
            270       0     0              0             0           0              0             0         0      cs.shrink(i - j);
          1,620      65    54          1,350           520           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::safeRemoveSatisfied(vec<CRef>& cs, unsigned valid_mark)
          1,632       0     0              0             0           0          1,360             0         0  {
              .       .     .              .             .           .              .             .         .      int i, j;
      7,262,648     135   114            272           136           0              0             0         0      for (i = j = 0; i < cs.size(); i++){
     10,725,912       0     0      7,150,608       224,575     151,589              0             0         0          Clause& c = ca[cs[i]];
      7,150,608       0     0              0             0           0              0             0         0          if (c.mark() == valid_mark)
              .       .     .              .             .           .              .             .         .              if (satisfied(c))
         50,920       2     2         12,730             0           0         12,730            51         0                  removeClause(cs[i]);
              .       .     .              .             .           .              .             .         .              else
     17,602,465       0     0      3,520,493           174           0      3,520,493        62,414         0                  cs[j++] = cs[i];
              .       .     .              .             .           .              .             .         .      }
            270       0     0              0             0           0              0             0         0      cs.shrink(i - j);
          1,632      56    54          1,632           521           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::rebuildOrderHeap()
          1,233      24    24              0             0           0            822             0         0  {
              .       .     .              .             .           .              .             .         .      vec<Var> vs;
     17,335,981       0     0            137             0           0            137           136         0      for (Var v = 0; v < nVars(); v++)
     44,200,984       0     0     22,100,492       267,431      65,317              0             0         0          if (decision[v] && value(v) == l_Undef)
              .       .     .              .             .           .              .             .         .              vs.push(v);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      order_heap_CHB  .build(vs);
              .       .     .              .             .           .              .             .         .      order_heap_VSIDS.build(vs);
              .       .     .              .             .           .              .             .         .      order_heap_distance.build(vs);
          1,096     137   118            959           273           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  /*_________________________________________________________________________________________________
              .       .     .              .             .           .              .             .         .  |
              .       .     .              .             .           .              .             .         .  |  simplify : [void]  ->  [bool]
              .       .     .              .             .           .              .             .         .  |  
              .       .     .              .             .           .              .             .         .  |  Description:
              .       .     .              .             .           .              .             .         .  |    Simplify the clause database according to the current top-level assigment. Currently, the only
              .       .     .              .             .           .              .             .         .  |    thing done here is the removal of satisfied clauses, but more things can be put here.
              .       .     .              .             .           .              .             .         .  |________________________________________________________________________________________________@*/
              .       .     .              .             .           .              .             .         .  bool Solver::simplify()
        210,696   3,075   344              0             0           0        140,464             0         0  {
              .       .     .              .             .           .              .             .         .      assert(decisionLevel() == 0);
              .       .     .              .             .           .              .             .         .  
        175,580       0     0         35,116        30,783          28              0             0         0      if (!ok || propagate() != CRef_Undef)
              .       .     .              .             .           .              .             .         .          return ok = false;
              .       .     .              .             .           .              .             .         .  
        107,762     938   398         71,439             0           0              0             0         0      if (nAssigns() == simpDB_assigns || (simpDB_props > 0))
              .       .     .              .             .           .              .             .         .          return true;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Remove satisfied clauses:
            408       0     0              0             0           0            136             0         0      removeSatisfied(learnts_core); // Should clean core first.
            544       0     0              0             0           0            136             0         0      safeRemoveSatisfied(learnts_tier2, TIER2);
            544     136   121              0             0           0            136             0         0      safeRemoveSatisfied(learnts_local, LOCAL);
            272       0     0            136           136           1              0             0         0      if (remove_satisfied)        // Can be turned off.
            540     270   235              0             0           0            135             0         0          removeSatisfied(clauses);
              .       .     .              .             .           .              .             .         .      checkGarbage();
            272       1     1              0             0           0            136             0         0      rebuildOrderHeap();
              .       .     .              .             .           .              .             .         .  
            272       0     0            136           136           0            136             0         0      simpDB_assigns = nAssigns();
            408       0     0            272           136           0            136             0         0      simpDB_props   = clauses_literals + learnts_literals;   // (shouldn't depend on stats really, but it will do for now)
              .       .     .              .             .           .              .             .         .  
            136       0     0              0             0           0              0             0         0      return true;
        245,812       0     0        175,580             0           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  // pathCs[k] is the number of variables assigned at level k,
              .       .     .              .             .           .              .             .         .  // it is initialized to 0 at the begining and reset to 0 after the function execution
        217,648      10     5              0             0           0        163,236             0         0  bool Solver::collectFirstUIP(CRef confl){
         54,412       0     0              0             0           0         27,206             0         0      involved_lits.clear();
      2,256,284      13     4              0             0           0              0             0         0      int max_level=1;
              .       .     .              .             .           .              .             .         .      Clause& c=ca[confl]; int minLevel=decisionLevel();
        382,144       0     0         27,206             0           0              0             0         0      for(int i=0; i<c.size(); i++) {
              .       .     .              .             .           .              .             .         .          Var v=var(c[i]);
              .       .     .              .             .           .              .             .         .          //        assert(!seen[v]);
        368,508     255     4        122,836        46,796          29              0             0         0          if (level(v)>0) {
        240,474       0     0        120,237        25,745           3        120,237       106,965        29              seen[v]=1;
        267,680       0     0        147,443        52,499           4        120,237       118,692     4,448              var_iLevel_tmp[v]=1;
        120,237       0     0        120,237        67,439         615              0             0         0              pathCs[level(v)]++;
              .       .     .              .             .           .              .             .         .              if (minLevel>level(v)) {
              .       .     .              .             .           .              .             .         .                  minLevel=level(v);
              .       .     .              .             .           .              .             .         .                  assert(minLevel>0);
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              //    varBumpActivity(v);
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
         81,618       0     0         54,412        25,907          34              0             0         0      int limit=trail_lim[minLevel-1];
  1,056,304,180       0     0         27,206             0           0              0             0         0      for(int i=trail.size()-1; i>=limit; i--) {
    528,097,678     159     3    528,097,678    16,408,433         782              0             0         0          Lit p=trail[i]; Var v=var(p);
    528,097,678       0     0    264,048,839   103,314,139       2,814              0             0         0          if (seen[v]) {
              .       .     .              .             .           .              .             .         .              int currentDecLevel=level(v);
              .       .     .              .             .           .              .             .         .              //      if (currentDecLevel==decisionLevel())
              .       .     .              .             .           .              .             .         .              //      	varBumpActivity(v);
      1,824,274       0     0              0             0           0      1,824,274             0         0              seen[v]=0;
      3,648,548       0     0      1,824,274       541,411           0              0             0         0              if (--pathCs[currentDecLevel]!=0) {
              .       .     .              .             .           .              .             .         .                  Clause& rc=ca[reason(v)];
      4,322,126      16     5      3,139,572       266,376           0              0             0         0                  int reasonVarLevel=var_iLevel_tmp[v]+1;
      2,093,048       0     0              0             0           0              0             0         0                  if(reasonVarLevel>max_level) max_level=reasonVarLevel;
      3,005,652       0     0              0             0           0              0             0         0                  if (rc.size()==2 && value(rc[0])==l_False) {
              .       .     .              .             .           .              .             .         .                      // Special case for binary clauses
              .       .     .              .             .           .              .             .         .                      // The first one has to be SAT
              .       .     .              .             .           .              .             .         .                      assert(value(rc[1]) != l_False);
              .       .     .              .             .           .              .             .         .                      Lit tmp = rc[0];
        205,281       0     0         68,427         3,944          71        136,854             0         0                      rc[0] =  rc[1], rc[1] = tmp;
              .       .     .              .             .           .              .             .         .                  }
      5,954,800       0     0              0             0           0              0             0         0                  for (int j = 1; j < rc.size(); j++){
              .       .     .              .             .           .              .             .         .                      Lit q = rc[j]; Var v1=var(q);
      4,774,356       0     0              0             0           0              0             0         0                      if (level(v1) > 0) {
      4,704,008       0     0              0             0           0              0             0         0                          if (minLevel>level(v1)) {
        281,020       0     0        140,510        67,862          82              0             0         0                              minLevel=level(v1); limit=trail_lim[minLevel-1]; 	assert(minLevel>0);
              .       .     .              .             .           .              .             .         .                          }
      7,056,012       0     0      4,704,008       792,130          36              0             0         0                          if (seen[v1]) {
      1,295,934       0     0        647,967       178,293           0              0             0         0                              if (var_iLevel_tmp[v1]<reasonVarLevel)
        812,278       0     0              0             0           0        406,139             0         0                                  var_iLevel_tmp[v1]=reasonVarLevel;
              .       .     .              .             .           .              .             .         .                          }
              .       .     .              .             .           .              .             .         .                          else {
      1,704,037       0     0              0             0           0      1,704,037     1,623,656    34,752                              var_iLevel_tmp[v1]=reasonVarLevel;
              .       .     .              .             .           .              .             .         .                              //   varBumpActivity(v1);
      1,704,037       0     0              0             0           0      1,704,037             0         0                              seen[v1] = 1;
      5,112,111      13     2      3,408,074       645,296       1,439              0             0         0                              pathCs[level(v1)]++;
              .       .     .              .             .           .              .             .         .                          }
              .       .     .              .             .           .              .             .         .                      }
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              involved_lits.push(p);
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
         81,618   2,952     4         27,206           316           0         27,206             0         0      double inc=var_iLevel_inc;
              .       .     .              .             .           .              .             .         .      vec<int> level_incs; level_incs.clear();
      1,641,043       0     0        623,770             0           0              0             0         0      for(int i=0;i<max_level;i++){
        678,182       7     2        339,091             0           0              0             0         0          level_incs.push(inc);
      1,017,273       0     0        678,182             0           0        339,091             0         0          inc = inc/my_var_decay;
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
      3,757,372       0     0      1,851,480             0           0              0             0         0      for(int i=0;i<involved_lits.size();i++){
         27,206       0     0         27,206             0           0              0             0         0          Var v =var(involved_lits[i]);
              .       .     .              .             .           .              .             .         .          //        double old_act=activity_distance[v];
              .       .     .              .             .           .              .             .         .          //        activity_distance[v] +=var_iLevel_inc * var_iLevel_tmp[v];
     16,853,762  13,860     8      5,581,646     3,501,680       3,405      1,851,480             0         0          activity_distance[v]+=var_iLevel_tmp[v]*level_incs[var_iLevel_tmp[v]-1];
              .       .     .              .             .           .              .             .         .  
      3,648,548       0     0              0             0           0              0             0         0          if(activity_distance[v]>1e100){
              .       .     .              .             .           .              .             .         .              for(int vv=0;vv<nVars();vv++)
        136,030   1,737     4         54,412        54,286           5         54,412             0         0                  activity_distance[vv] *= 1e-100;
              .       .     .              .             .           .              .             .         .              var_iLevel_inc*=1e-100;
         19,977     205     4              0             0           0              0             0         0              for(int j=0; j<max_level; j++) level_incs[j]*=1e-100;
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .          if (order_heap_distance.inHeap(v))
              .       .     .              .             .           .              .             .         .              order_heap_distance.decrease(v);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          //        var_iLevel_inc *= (1 / my_var_decay);
              .       .     .              .             .           .              .             .         .      }
        136,030     910     5         54,412           171           0         27,206             0         0      var_iLevel_inc=level_incs[level_incs.size()-1];
              .       .     .              .             .           .              .             .         .      return true;
        244,854       0     0        190,442        26,447           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  struct UIPOrderByILevel_Lt {
              .       .     .              .             .           .              .             .         .      Solver& solver;
              .       .     .              .             .           .              .             .         .      const vec<double>&  var_iLevel;
              .       .     .              .             .           .              .             .         .      bool operator () (Lit x, Lit y) const
              .       .     .              .             .           .              .             .         .      {
              .       .     .              .             .           .              .             .         .          return var_iLevel[var(x)] < var_iLevel[var(y)] ||
              .       .     .              .             .           .              .             .         .                  (var_iLevel[var(x)]==var_iLevel[var(y)]&& solver.level(var(x))>solver.level(var(y)));
-- line 1927 ----------------------------------------
-- line 1954 ----------------------------------------
              .       .     .              .             .           .              .             .         .  |    Search for a model the specified number of conflicts. 
              .       .     .              .             .           .              .             .         .  |  
              .       .     .              .             .           .              .             .         .  |  Output:
              .       .     .              .             .           .              .             .         .  |    'l_True' if a partial assigment that is consistent with respect to the clauseset is found. If
              .       .     .              .             .           .              .             .         .  |    all variables are decision variables, this means that the clause set is satisfiable. 'l_False'
              .       .     .              .             .           .              .             .         .  |    if the clause set is unsatisfiable. 'l_Undef' if the bound on number of conflicts is reached.
              .       .     .              .             .           .              .             .         .  |________________________________________________________________________________________________@*/
              .       .     .              .             .           .              .             .         .  lbool Solver::search(int& nof_conflicts)
        383,713  31,631   531              0             0           0        244,181            75        36  {
              .       .     .              .             .           .              .             .         .      assert(ok);
              .       .     .              .             .           .              .             .         .      int         backtrack_level;
              .       .     .              .             .           .              .             .         .      int         lbd;
              .       .     .              .             .           .              .             .         .      vec<Lit>    learnt_clause;
              .       .     .              .             .           .              .             .         .      bool        cached = false;
         34,883       0     0         34,883           140           0              0             0         0      starts++;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // simplify
              .       .     .              .             .           .              .             .         .      //
        139,532       5     5        104,649        34,883         376              0             0         0      if (conflicts >= curSimplify * nbconfbeforesimplify){
              .       .     .              .             .           .              .             .         .          //        printf("c ### simplifyAll on conflict : %lld\n", conflicts);
              .       .     .              .             .           .              .             .         .          //printf("nbClauses: %d, nbLearnts_core: %d, nbLearnts_tier2: %d, nbLearnts_local: %d, nbLearnts: %d\n",
              .       .     .              .             .           .              .             .         .          //	clauses.size(), learnts_core.size(), learnts_tier2.size(), learnts_local.size(),
              .       .     .              .             .           .              .             .         .          //	learnts_core.size() + learnts_tier2.size() + learnts_local.size());
             75      68    66             75            74           0              0             0         0          nbSimplifyAll++;
            225      75    73              0             0           0             75             0         0          if (!simplifyAll()){
              .       .     .              .             .           .              .             .         .              return l_False;
              .       .     .              .             .           .              .             .         .          }
            525       0     0            150            33           0             75             0         0          curSimplify = (conflicts / nbconfbeforesimplify) + 1;
            225       0     0             75             0           0             75             0         0          nbconfbeforesimplify += incSimplify;
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      for (;;){
              .       .     .              .             .           .              .             .         .          CRef confl = propagate();
              .       .     .              .             .           .              .             .         .  
     52,031,760       0     0              0             0           0              0             0         0          if (confl != CRef_Undef){
              .       .     .              .             .           .              .             .         .              // CONFLICT
     17,932,026       0     0      5,977,342         7,759           0              0             0         0              if (VSIDS){
      6,899,688       0     0      3,449,829     3,276,620           1             30             0         0                  if (--timer == 0 && var_decay < 0.95) timer = 5000, var_decay += 0.01;
              .       .     .              .             .           .              .             .         .              }else
      8,602,683     212    34      5,395,121     2,477,537           3        340,001             0         0                  if (step_size > min_step_size) step_size -= step_size_dec;
              .       .     .              .             .           .              .             .         .  
     23,909,368   1,064   581     11,954,684     6,478,838         312      5,977,342             0         0              conflicts++; nof_conflicts--;
              .       .     .              .             .           .              .             .         .              //if (conflicts == 100000 && learnts_core.size() < 100) core_lbd_cut = 5;
              .       .     .              .             .           .              .             .         .              ConflictData data = FindConflictLevel(confl);
     11,954,684     394    70              0             0           0              0             0         0              if (data.nHighestLevel == 0) return l_False;
         38,646       0     0         16,806             7           0              0             0         0              if (data.bOnlyOneLitFromHighest)
              .       .     .              .             .           .              .             .         .              {
          2,517     358     1              0             0           0              0             0         0  				cancelUntil(data.nHighestLevel - 1);
              .       .     .              .             .           .              .             .         .  				continue;
              .       .     .              .             .           .              .             .         .  			}
              .       .     .              .             .           .              .             .         .  			
              .       .     .              .             .           .              .             .         .              learnt_clause.clear();
     11,949,650       0     0              0             0           0      5,974,825     5,645,166        86              if(conflicts>50000) DISTANCE=0;
              .       .     .              .             .           .              .             .         .              else DISTANCE=1;
     18,845,524       0     0              0             0           0              0             0         0              if(VSIDS && DISTANCE)
        108,824      13     5              0             0           0         27,206             0         0                  collectFirstUIP(confl);
              .       .     .              .             .           .              .             .         .  
     35,848,950     161   144              0             0           0      5,974,825             0         0              analyze(confl, learnt_clause, backtrack_level, lbd);
              .       .     .              .             .           .              .             .         .              // check chrono backtrack condition
     83,619,557     141   115     29,870,126     5,649,296           0              0             0         0              if ((confl_to_chrono < 0 || confl_to_chrono <= conflicts) && chrono > -1 && (decisionLevel() - backtrack_level) >= chrono)
              .       .     .              .             .           .              .             .         .              {
         15,309       0     0         15,309         1,135           0              0             0         0  				++chrono_backtrack;
         15,309       0     0              0             0           0              0             0         0  				cancelUntil(data.nHighestLevel -1);
              .       .     .              .             .           .              .             .         .  			}
              .       .     .              .             .           .              .             .         .  			else // default behavior
              .       .     .              .             .           .              .             .         .  			{
      5,959,516  13,435 1,002      5,959,516     2,166,806           0              0             0         0  				++non_chrono_backtrack;
              .       .     .              .             .           .              .             .         .  				cancelUntil(backtrack_level);
              .       .     .              .             .           .              .             .         .  			}
              .       .     .              .             .           .              .             .         .  
     17,924,475       0     0      5,974,825     5,296,309           0      5,974,825             0         0              lbd--;
     11,949,650       0     0      5,974,825             0           0              0             0         0              if (VSIDS){
      3,447,937     680   468              0             0           0      3,447,937             0         0                  cached = false;
     10,343,811   7,173   598     10,343,811     6,217,013         110              0             0         0                  conflicts_VSIDS++;
              .       .     .              .             .           .              .             .         .                  lbd_queue.push(lbd);
     27,583,496       0     0     10,343,811             0           0      3,447,937             0         0                  global_lbd_sum += (lbd > 50 ? 50 : lbd); }
              .       .     .              .             .           .              .             .         .  
     17,924,475      85    69      5,974,825             0           0              0             0         0              if (learnt_clause.size() == 1){
          2,674      56     1            764           332           0            382             0         0                  uncheckedEnqueue(learnt_clause[0]);
              .       .     .              .             .           .              .             .         .              }else{
              .       .     .              .             .           .              .             .         .                  CRef cr = ca.alloc(learnt_clause, true);
      5,974,443       0     0      5,974,443             0           0              0             0         0                  ca[cr].set_lbd(lbd);
              .       .     .              .             .           .              .             .         .                  //duplicate learnts 
              .       .     .              .             .           .              .             .         .                  int  id = 0;
     11,948,886       0     0      5,974,443     5,949,570         454              0             0         0                  if (lbd <= max_lbd_dup){                        
              .       .     .              .             .           .              .             .         .                      std::vector<uint32_t> tmp;
    175,561,241       0     0    118,197,005             0           0      2,039,699             0         0                      for (int i = 0; i < learnt_clause.size(); i++)
    122,276,403      31    31     81,517,602             6           0     40,758,801             0         0                          tmp.push_back(learnt_clause[i].x);
      6,119,097      25    19      2,039,699             0           0      2,039,699             0         0                      id = is_duplicate(tmp);             
     10,198,495       0     0      2,039,699            33           0              0             0         0                      if (id == min_number_of_learnts_copies +1){
            526       0     0            526           376           0              0             0         0                          duplicates_added_conflicts++;                        
              .       .     .              .             .           .              .             .         .                      }                    
      4,079,398       0     0              0             0           0              0             0         0                      if (id == min_number_of_learnts_copies){
          4,959       0     0          4,959             0           0              0             0         0                          duplicates_added_tier2++;
              .       .     .              .             .           .              .             .         .                      }                                        
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .                  //duplicate learnts
              .       .     .              .             .           .              .             .         .  
     35,414,578       0     0     11,840,866     2,505,202         289              0             0         0                  if ((lbd <= core_lbd_cut) || (id == min_number_of_learnts_copies+1)){
             24       9     7              0             0           0              0             0         0                      learnts_core.push(cr);
              .       .     .              .             .           .              .             .         .                      ca[cr].mark(CORE);
     22,083,172  11,323 1,041              0             0           0              0             0         0                  }else if ((lbd <= 6)||(id == min_number_of_learnts_copies)){
             20       1     1              0             0           0              0             0         0                      learnts_tier2.push(cr);
              .       .     .              .             .           .              .             .         .                      ca[cr].mark(TIER2);
      2,763,072       0     0        690,768             5           0        690,768            18         0                      ca[cr].touched() = conflicts;
              .       .     .              .             .           .              .             .         .                  }else{
             23      22     4              0             0           0              0             0         0                      learnts_local.push(cr);
              .       .     .              .             .           .              .             .         .                      claBumpActivity(ca[cr]); }
     17,923,329   5,874   914              0             0           0      5,974,443             0         0                  attachClause(cr);
              .       .     .              .             .           .              .             .         .  
     35,846,658       0     0     17,923,329            86           0      5,974,443             0         0                  uncheckedEnqueue(learnt_clause[0], backtrack_level, cr);
              .       .     .              .             .           .              .             .         .  #ifdef PRINT_OUT
              .       .     .              .             .           .              .             .         .                  std::cout << "new " << ca[cr] << "\n";
              .       .     .              .             .           .              .             .         .                  std::cout << "ci " << learnt_clause[0] << " l " << backtrack_level << "\n";
              .       .     .              .             .           .              .             .         .  #endif                
              .       .     .              .             .           .              .             .         .              }
     17,924,475       1     1      5,974,825     3,270,339         163              0             0         0              if (drup_file){
              .       .     .              .             .           .              .             .         .  #ifdef BIN_DRUP
              .       .     .              .             .           .              .             .         .                  binDRUP('a', learnt_clause, drup_file);
              .       .     .              .             .           .              .             .         .  #else
              .       .     .              .             .           .              .             .         .                  for (int i = 0; i < learnt_clause.size(); i++)
              .       .     .              .             .           .              .             .         .                      fprintf(drup_file, "%i ", (var(learnt_clause[i]) + 1) * (-2 * sign(learnt_clause[i]) + 1));
              .       .     .              .             .           .              .             .         .                  fprintf(drup_file, "0\n");
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
     17,924,475   2,877   471     11,949,650     3,436,646         316              0             0         0              if (VSIDS) varDecayActivity();
              .       .     .              .             .           .              .             .         .              claDecayActivity();
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              /*if (--learntsize_adjust_cnt == 0){
              .       .     .              .             .           .              .             .         .                  learntsize_adjust_confl *= learntsize_adjust_inc;
              .       .     .              .             .           .              .             .         .                  learntsize_adjust_cnt    = (int)learntsize_adjust_confl;
              .       .     .              .             .           .              .             .         .                  max_learnts             *= learntsize_inc;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .                  if (verbosity >= 1)
-- line 2088 ----------------------------------------
-- line 2090 ----------------------------------------
              .       .     .              .             .           .              .             .         .                             (int)conflicts,
              .       .     .              .             .           .              .             .         .                             (int)dec_vars - (trail_lim.size() == 0 ? trail.size() : trail_lim[0]), nClauses(), (int)clauses_literals,
              .       .     .              .             .           .              .             .         .                             (int)max_learnts, nLearnts(), (double)learnts_literals/nLearnts(), progressEstimate()*100);
              .       .     .              .             .           .              .             .         .              }*/
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .          }else{
              .       .     .              .             .           .              .             .         .              // NO CONFLICT
              .       .     .              .             .           .              .             .         .              bool restart = false;
     60,115,614      79    67     20,038,538        46,656           0              0             0         0              if (!VSIDS)
              .       .     .              .             .           .              .             .         .                  restart = nof_conflicts <= 0;
     29,721,830       1     1     14,860,915     5,017,107          79              0             0         0              else if (!cached){
     20,617,888       4     3      6,441,664     2,125,101          10      1,770,602             0         0                  restart = lbd_queue.full() && (lbd_queue.avg() * 0.8 > global_lbd_sum / conflicts_VSIDS);
              .       .     .              .             .           .              .             .         .                  cached = true;
              .       .     .              .             .           .              .             .         .              }
     15,532,869       0     0      5,177,623     3,500,086         166              0             0         0              if (restart /*|| !withinBudget()*/){
              .       .     .              .             .           .              .             .         .                  lbd_queue.clear();
              .       .     .              .             .           .              .             .         .                  cached = false;
              .       .     .              .             .           .              .             .         .                  // Reached bound on number of conflicts:
        104,646       0     0              0             0           0         69,764           443         0                  progress_estimate = progressEstimate();
              .       .     .              .             .           .              .             .         .                  cancelUntil(0);
         69,764       0     0              0             0           0              0             0         0                  return l_Undef; }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Simplify the set of problem clauses:
     61,087,767   1,382   209     20,003,656             0           0        971,352             0         0              if (decisionLevel() == 0 && !simplify())
              .       .     .              .             .           .              .             .         .                  return l_False;
              .       .     .              .             .           .              .             .         .  
     60,010,968     218    90     40,007,312        65,752          14              0             0         0              if (conflicts >= next_T2_reduce){
          1,194       0     0              0             0           0            597             0         0                  next_T2_reduce = conflicts + 10000;
          2,388       0     0            597             0           0            597             0         0                  reduceDB_Tier2(); }
     40,007,312     104    66     20,003,656             0           0              0             0         0              if (conflicts >= next_L_reduce){
            796       0     0              0             0           0            398             0         0                  next_L_reduce = conflicts + 15000;
            796       0     0              0             0           0            398             0         0                  reduceDB(); }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              Lit next = lit_Undef;
              .       .     .              .             .           .              .             .         .              /*while (decisionLevel() < assumptions.size()){
              .       .     .              .             .           .              .             .         .                  // Perform user provided assumption:
              .       .     .              .             .           .              .             .         .                  Lit p = assumptions[decisionLevel()];
              .       .     .              .             .           .              .             .         .                  if (value(p) == l_True){
              .       .     .              .             .           .              .             .         .                      // Dummy decision level:
              .       .     .              .             .           .              .             .         .                      newDecisionLevel();
-- line 2129 ----------------------------------------
-- line 2133 ----------------------------------------
              .       .     .              .             .           .              .             .         .                  }else{
              .       .     .              .             .           .              .             .         .                      next = p;
              .       .     .              .             .           .              .             .         .                      break;
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              if (next == lit_Undef)*/{
              .       .     .              .             .           .              .             .         .                  // New variable decision:
     20,003,656       0     0     20,003,656           398         278              0             0         0                  decisions++;
     60,010,968   3,008   548              0             0           0     20,003,656             0         0                  next = pickBranchLit();
              .       .     .              .             .           .              .             .         .  
     40,007,312       0     0              0             0           0              0             0         0                  if (next == lit_Undef)
              .       .     .              .             .           .              .             .         .                      // Model found:
              2       0     0              0             0           0              0             0         0                      return l_True;
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .              // Increase decision level and enqueue 'next'
              .       .     .              .             .           .              .             .         .              newDecisionLevel();
    120,021,930      97    89     20,003,655             0           0     20,003,655             0         0              uncheckedEnqueue(next, decisionLevel());
              .       .     .              .             .           .              .             .         .  #ifdef PRINT_OUT            
              .       .     .              .             .           .              .             .         .              std::cout << "d " << next << " l " << decisionLevel() << "\n";
              .       .     .              .             .           .              .             .         .  #endif            
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
        313,947     588   263        244,181        69,764           5              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  double Solver::progressEstimate() const
        209,292       6     5              0             0           0        174,410             0         0  {
         69,764       0     0              0             0           0              0             0         0      double  progress = 0;
        174,410       0     0         69,764        24,100           0         34,882             0         0      double  F = 1.0 / nVars();
              .       .     .              .             .           .              .             .         .  
     18,644,366       6     6              0             0           0              0             0         0      for (int i = 0; i <= decisionLevel(); i++){
     18,435,074       0     0     12,243,540             0           0              0             0         0          int beg = i == 0 ? 0 : trail_lim[i - 1];
     24,591,726       0     0     12,278,422       393,511       2,099              0             0         0          int end = i == decisionLevel() ? trail.size() : trail_lim[i];
     37,044,558      63    60      6,191,534             0           0              0             0         0          progress += pow(F, i) * (end - beg);
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
         69,764       0     0              0             0           0              0             0         0      return progress / nVars();
        244,174       0     0        209,292             0           0              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  /*
              .       .     .              .             .           .              .             .         .    Finite subsequences of the Luby-sequence:
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .    0: 1
              .       .     .              .             .           .              .             .         .    1: 1 1 2
              .       .     .              .             .           .              .             .         .    2: 1 1 2 1 1 2 4
              .       .     .              .             .           .              .             .         .    3: 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8
-- line 2180 ----------------------------------------
-- line 2183 ----------------------------------------
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .   */
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  static double luby(double y, int x){
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Find the finite subsequence that contains index 'x', and the
              .       .     .              .             .           .              .             .         .      // size of that subsequence:
              .       .     .              .             .           .              .             .         .      int size, seq;
        238,608       0     0              0             0           0              0             0         0      for (size = 1, seq = 0; size < x+1; seq++, size = 2*size+1);
              .       .     .              .             .           .              .             .         .  
        134,627      12    12              0             0           0              0             0         0      while (size-1 != x){
         78,302       0     0              0             0           0              0             0         0          size = (size-1)>>1;
         39,151       0     0              0             0           0              0             0         0          seq--;
        117,453       0     0              0             0           0              0             0         0          x = x % size;
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      return pow(y, seq);
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  static bool switch_mode = false;
              .       .     .              .             .           .              .             .         .  //static void SIGALRM_switch(int signum) { switch_mode = true; }
              .       .     .              .             .           .              .             .         .  
             32       4     4              0             0           0             24             0         0  uint32_t Solver::reduceduplicates(){
              .       .     .              .             .           .              .             .         .      uint32_t removed_duplicates = 0;
              .       .     .              .             .           .              .             .         .      std::vector<std::vector<uint64_t>> tmp;
              .       .     .              .             .           .              .             .         .      //std::map<int32_t,std::map<uint32_t,std::unordered_map<uint64_t,uint32_t>>>  ht;
        124,790       0     0              8             0           0              0             0         0      for (auto & outer_mp: ht){//variables
      1,063,965       0     0              0             0           0              0             0         0          for (auto &inner_mp:outer_mp.second){//sizes
      5,254,510       0     0              0             0           0              0             0         0              for (auto &in_in_mp: inner_mp.second){
      6,566,532       4     4      2,188,844     2,065,819   1,278,131              0             0         0                  if (in_in_mp.second >= 2){
              .       .     .              .             .           .              .             .         .                  //min_number_of_learnts_copies
      3,830,030       4     4      1,532,012         5,430       4,193      1,532,012           342         0                      tmp.push_back({(uint64_t) outer_mp.first,inner_mp.first,in_in_mp.first,in_in_mp.second});
              .       .     .              .             .           .              .             .         .                  }
              .       .     .              .             .           .              .             .         .              }                    
              .       .     .              .             .           .              .             .         .           }
              .       .     .              .             .           .              .             .         .      }          
             12       0     0              4             4           4              4             0         0      removed_duplicates = dupl_db_size-tmp.size();  
              .       .     .              .             .           .              .             .         .      ht.clear();
      2,681,041       4     4      1,149,013            39           6              0             0         0      for (auto i=0;i<tmp.size();i++){
      3,830,030       0     0      1,915,015       430,983     430,814      1,149,009            13         5          ht[tmp[i][0]][tmp[i][1]][tmp[i][2]]=tmp[i][3];
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .      return removed_duplicates;
             36       0     0             32            12          11              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  // NOTE: assumptions passed in member-variable 'assumptions'.
              .       .     .              .             .           .              .             .         .  lbool Solver::solve_()
              8       0     0              0             0           0              6             0         0  {
              .       .     .              .             .           .              .             .         .      //signal(SIGALRM, SIGALRM_switch);
              .       .     .              .             .           .              .             .         .      //alarm(2500);
              .       .     .              .             .           .              .             .         .  
              1       1     1              0             0           0              0             0         0      model.clear();
              .       .     .              .             .           .              .             .         .      conflict.clear();
              2       1     1              1             0           0              0             0         0      if (!ok) return l_False;
              .       .     .              .             .           .              .             .         .  
              1       1     1              1             1           1              0             0         0      solves++;
              .       .     .              .             .           .              .             .         .  
              5       0     0              2             0           0              1             0         0      max_learnts               = nClauses() * learntsize_factor;
              3       0     0              1             1           1              0             0         0      learntsize_adjust_confl   = learntsize_adjust_start_confl;
              1       0     0              0             0           0              1             1         1      learntsize_adjust_cnt     = (int)learntsize_adjust_confl;
              .       .     .              .             .           .              .             .         .      lbool   status            = l_Undef;
              .       .     .              .             .           .              .             .         .  
              3       0     0              1             0           0              0             0         0      if (verbosity >= 1){
              2       0     0              0             0           0              1             0         0          printf("c ============================[ Search Statistics ]==============================\n");
              2       1     1              0             0           0              1             0         0          printf("c | Conflicts |          ORIGINAL         |          LEARNT          | Progress |\n");
              2       0     0              0             0           0              1             0         0          printf("c |           |    Vars  Clauses Literals |    Limit  Clauses Lit/Cl |          |\n");
              2       0     0              0             0           0              1             0         0          printf("c ===============================================================================\n");
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      add_tmp.clear();
              .       .     .              .             .           .              .             .         .  
              1       0     0              0             0           0              1             1         1      VSIDS = true;
              1       1     1              0             0           0              1             0         0      int init = 10000;
            705       0     0            141             0           0              0             0         0      while (status == l_Undef && init > 0 /*&& withinBudget()*/)
            564       4     0              0             0           0            141             0         0          status = search(init);
              1       0     0              0             0           0              1             0         0      VSIDS = false;
              .       .     .              .             .           .              .             .         .  
              3       1     1              0             0           0              2             1         0      duplicates_added_conflicts = 0;
              .       .     .              .             .           .              .             .         .      duplicates_added_minimization=0;
              .       .     .              .             .           .              .             .         .      duplicates_added_tier2 =0;    
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      dupl_db_size=0;
              1       0     0              1             1           0              0             0         0      size_t dupl_db_size_limit = dupl_db_init_size;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // Search:
              1       0     0              0             0           0              0             0         0      int curr_restarts = 0;
              1       0     0              0             0           0              0             0         0      uint64_t curr_props = 0;
              .       .     .              .             .           .              .             .         .      uint32_t removed_duplicates =0;
         69,484  33,193   425              0             0           0              0             0         0      while (status == l_Undef /*&& withinBudget()*/){
         69,484       1     1         34,742        30,428           4              0             0         0          if (dupl_db_size >= dupl_db_size_limit){    
             16       4     4              4             0           0              4             0         0              printf("c Duplicate learnts added (Minimization) %i\n",duplicates_added_minimization);    
             16       0     0              4             4           0              4             0         0              printf("c Duplicate learnts added (conflicts) %i\n",duplicates_added_conflicts);    
             16       0     0              4             0           0              4             0         0              printf("c Duplicate learnts added (tier2) %i\n",duplicates_added_tier2);    
             16       4     4              4             1           0              4             0         0              printf("c Duptime: %i\n",duptime.count());
             16       0     0              4             0           0              4             0         0              printf("c Number of conflicts: %i\n",conflicts);
             16       0     0              4             1           0              4             0         0              printf("c Core size: %i\n",learnts_core.size());
              .       .     .              .             .           .              .             .         .              
              8       0     0              0             0           0              4             0         0              removed_duplicates = reduceduplicates();
             32       4     4              8             8           8              0             0         0              dupl_db_size_limit*=1.1;
              8       0     0              4             4           4              0             0         0              dupl_db_size -= removed_duplicates;
             20       0     0              0             0           0              4             0         0              printf("c removed duplicates %i\n",removed_duplicates);
              .       .     .              .             .           .              .             .         .          }   
        208,452     406   392         69,484        65,191           8              0             0         0          if (propagations - curr_props >  VSIDS_props_limit){
             28       0     0              0             0           0              0             0         0              curr_props = propagations;
             28       0     0              0             0           0             28             0         0              switch_mode = true;
            141       0     0              0             0           0             28             0         0              VSIDS_props_limit = VSIDS_props_limit + VSIDS_props_limit/10;
              .       .     .              .             .           .              .             .         .          }     
         69,484       0     0         34,742             5           4              0             0         0          if (VSIDS){
         30,442       0     0              0             0           0         30,442             0         0              int weighted = INT32_MAX;
        121,768  30,327   217              0             0           0         30,442             0         0              status = search(weighted);
              .       .     .              .             .           .              .             .         .          }else{
         25,800   3,322   266          8,600             0           0          4,300             0         0              int nof_conflicts = luby(restart_inc, curr_restarts) * restart_first;
          4,300       0     0              0             0           0              0             0         0              curr_restarts++;
         21,500   4,298   193              0             0           0          4,300             0         0              status = search(nof_conflicts);
              .       .     .              .             .           .              .             .         .          }
         69,484   4,300   206         34,742        34,742         404              0             0         0          if (switch_mode){ 
             28       0     0              0             0           0             28             0         0              switch_mode = false;
              .       .     .              .             .           .              .             .         .              VSIDS = !VSIDS;
             56       0     0             28             0           0              0             0         0              if (VSIDS){
             28      14    14              0             0           0             14             0         0                  printf("c Switched to VSIDS.\n");
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              else{
             42      14    14              0             0           0             14             0         0                 printf("c Switched to LRB.\n");
              .       .     .              .             .           .              .             .         .              }
              .       .     .              .             .           .              .             .         .              //            reduceduplicates();            
             56      14    14             28            28          28             28             0         0              fflush(stdout);
              .       .     .              .             .           .              .             .         .              picked.clear();
              .       .     .              .             .           .              .             .         .              conflicted.clear();
              .       .     .              .             .           .              .             .         .              almost_conflicted.clear();
              .       .     .              .             .           .              .             .         .  #ifdef ANTI_EXPLORATION
              .       .     .              .             .           .              .             .         .              canceled.clear();
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              3       1     1              1             1           0              0             0         0      if (verbosity >= 1)
              2       0     0              0             0           0              1             0         0          printf("c ===============================================================================\n");
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  #ifdef BIN_DRUP
              3       0     0              1             0           0              0             0         0      if (drup_file && status == l_False) binDRUP_flush(drup_file);
              .       .     .              .             .           .              .             .         .  #endif
              .       .     .              .             .           .              .             .         .  
              2       1     1              0             0           0              0             0         0      if (status == l_True){
              .       .     .              .             .           .              .             .         .          // Extend & copy model:
              .       .     .              .             .           .              .             .         .          model.growTo(nVars());
          7,927       0     0          3,955           989           0          3,958           990         0          for (int i = 0; i < nVars(); i++) model[i] = value(i);
              .       .     .              .             .           .              .             .         .      }else if (status == l_False && conflict.size() == 0)
              .       .     .              .             .           .              .             .         .          ok = false;
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      cancelUntil(0);
              1       0     0              0             0           0              0             0         0      return status;
              8       1     1              7             1           1              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  //=================================================================================================
              .       .     .              .             .           .              .             .         .  // Writing CNF to DIMACS:
              .       .     .              .             .           .              .             .         .  // 
              .       .     .              .             .           .              .             .         .  // FIXME: this needs to be rewritten completely.
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  static Var mapVar(Var x, vec<Var>& map, Var& max)
              .       .     .              .             .           .              .             .         .  {
-- line 2341 ----------------------------------------
-- line 2409 ----------------------------------------
              .       .     .              .             .           .              .             .         .          printf("c Wrote %d clauses with %d variables.\n", cnt, max);
              .       .     .              .             .           .              .             .         .  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  //=================================================================================================
              .       .     .              .             .           .              .             .         .  // Garbage Collection methods:
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::relocAll(ClauseAllocator& to)
          2,800     279   279              0             0           0          2,240             0         0  {
              .       .     .              .             .           .              .             .         .      // All watchers:
              .       .     .              .             .           .              .             .         .      //
              .       .     .              .             .           .              .             .         .      // for (int i = 0; i < watches.size(); i++)
            560       0     0              0             0           0            280             0         0      watches.cleanAll();
            560       0     0              0             0           0            280             0         0      watches_bin.cleanAll();
    177,152,080      39    39    124,005,560       128,270          21     17,715,600           279         0      for (int v = 0; v < nVars(); v++)
     70,860,160       0     0     35,430,080             0           0              0             0         0          for (int s = 0; s < 2; s++){
              .       .     .              .             .           .              .             .         .              Lit p = mkLit(v, s);
              .       .     .              .             .           .              .             .         .              // printf(" >>> RELOCING: %s%d\n", sign(p)?"-":"", var(p)+1);
              .       .     .              .             .           .              .             .         .              vec<Watcher>& ws = watches[p];
  1,108,555,756     162   162    506,003,384     8,857,800   8,054,289              0             0         0              for (int j = 0; j < ws.size(); j++)
              .       .     .              .             .           .              .             .         .                  ca.reloc(ws[j].cref, to);
              .       .     .              .             .           .              .             .         .              vec<Watcher>& ws_bin = watches_bin[p];
    356,305,940       1     1    144,271,032     8,980,820   8,394,946              0             0         0              for (int j = 0; j < ws_bin.size(); j++)
              .       .     .              .             .           .              .             .         .                  ca.reloc(ws_bin[j].cref, to);
              .       .     .              .             .           .              .             .         .          }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // All reasons:
              .       .     .              .             .           .              .             .         .      //
     11,073,018       0     0            840             0           0              0             0         0      for (int i = 0; i < trail.size(); i++){
              .       .     .              .             .           .              .             .         .          Var v = var(trail[i]);
              .       .     .              .             .           .              .             .         .  
     15,248,914       0     0      2,088,788     1,568,108     424,766              0             0         0          if (reason(v) != CRef_Undef && (ca[reason(v)].reloced() || locked(ca[reason(v)])))
     10,444,500       0     0      2,088,788             0           0      2,088,788           275       275              ca.reloc(vardata[v].reason, to);
              .       .     .              .             .           .              .             .         .      }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // All learnt:
              .       .     .              .             .           .              .             .         .      //
     84,299,570     279   279     42,149,644           564         284              0             0         0      for (int i = 0; i < learnts_core.size(); i++)
              .       .     .              .             .           .              .             .         .          ca.reloc(learnts_core[i], to);
      4,313,236     839   839      2,156,617         1,114         280              0             0         0      for (int i = 0; i < learnts_tier2.size(); i++)
              .       .     .              .             .           .              .             .         .          ca.reloc(learnts_tier2[i], to);
      7,978,188     280   280      3,988,535           278           0              0             0         0      for (int i = 0; i < learnts_local.size(); i++)
     11,963,925       0     0              0             0           0      3,987,975             0         0          ca.reloc(learnts_local[i], to);
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      // All original:
              .       .     .              .             .           .              .             .         .      //
              .       .     .              .             .           .              .             .         .      int i, j;
    157,744,336     280   280          1,120           280           0              0             0         0      for (i = j = 0; i < clauses.size(); i++)
    157,741,816       0     0              0             0           0              0             0         0          if (ca[clauses[i]].mark() != 1){
    236,613,284     279   279     78,870,908           278           0     78,870,908             1         0              ca.reloc(clauses[i], to);
    788,708,800     280   280    315,483,352             0           0     78,870,908             0         0              clauses[j++] = clauses[i]; }
            280     279   279              0             0           0              0             0         0      clauses.shrink(i - j);
          2,240     279   279          1,960           280          13              0             0         0  }
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .  void Solver::garbageCollect()
              .       .     .              .             .           .              .             .         .  {
              .       .     .              .             .           .              .             .         .      // Initialize the next region to a size corresponding to the estimated utilization degree. This
              .       .     .              .             .           .              .             .         .      // is not precise but should avoid some unnecessary reallocations for the new region:
              .       .     .              .             .           .              .             .         .      ClauseAllocator to(ca.size() - ca.wasted());
              .       .     .              .             .           .              .             .         .  
              .       .     .              .             .           .              .             .         .      relocAll(to);
              .       .     .              .             .           .              .             .         .      if (verbosity >= 2)
              .       .     .              .             .           .              .             .         .          printf("c |  Garbage collection:   %12d bytes => %12d bytes             |\n",
              .       .     .              .             .           .              .             .         .                 ca.size()*ClauseAllocator::Unit_Size, to.size()*ClauseAllocator::Unit_Size);
              .       .     .              .             .           .              .             .         .      to.moveTo(ca);
            155      18    18             47             4           4             61             0         0  }

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Heap.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr             D1mr          DLmr      Dw             D1mw        DLmw      

-- line 31 ----------------------------------------
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  template<class Comp>
             .      .    .              .             .         .              .           .         .  class Heap {
             .      .    .              .             .         .              .           .         .      Comp     lt;       // The heap is a minimum-heap with respect to this comparator
             .      .    .              .             .         .              .           .         .      vec<int> heap;     // Heap of integers
             .      .    .              .             .         .              .           .         .      vec<int> indices;  // Each integers position (index) in the Heap
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .      // Index "traversal" functions
 5,527,934,039     53   51              0             0         0              0           0         0      static inline int left  (int i) { return i*2+1; }
19,164,683,393    164  143  7,663,829,038 5,203,853,564 2,380,974              0           0         0      static inline int right (int i) { return (i+1)*2; }
 4,402,436,576     71   68    374,865,414             0         0              0           0         0      static inline int parent(int i) { return (i-1) >> 1; }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
   749,730,828     61   53              0             0         0    749,730,828     110,739         0      void percolateUp(int i)
             .      .    .              .             .         .              .           .         .      {
 2,461,769,047      0    0  1,467,829,643   316,504,684   172,757    619,073,990           0         0          int x  = heap[i];
             .      .    .              .             .         .              .           .         .          int p  = parent(i);
             .      .    .              .             .         .              .           .         .          
13,928,900,336  1,714  817  4,771,205,248 1,864,516,372   553,953    153,357,056           0         0          while (i != 0 && lt(x, heap[p])){
 1,230,561,143    118  106              0             0         0  1,230,561,143           0         0              heap[i]          = heap[p];
 1,230,561,143      0    0              0             0         0  1,230,561,143 787,464,985   191,090              indices[heap[p]] = i;
             .      .    .              .             .         .              .           .         .              i                = p;
 1,497,952,198      0    0              0             0         0              0           0         0              p                = parent(p);
             .      .    .              .             .         .              .           .         .          }
 1,092,964,229     32   15    309,770,757             0         0    783,193,472           0         0          heap   [i] = x;
 1,195,330,651      2    2    310,185,722             0         0    783,634,466          50         0          indices[x] = i;
 1,590,474,180      0    0  1,124,596,242             0         0              0           0         0      }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
25,409,571,376      0    0  3,629,938,768             0         0 21,779,632,608   1,514,373         0      void percolateDown(int i)
             .      .    .              .             .         .              .           .         .      {
11,204,508,602  9,276  606  7,398,193,658 3,302,762,863   224,532  3,801,647,676           0         0          int x = heap[i];
21,249,319,274 23,039  809  5,436,266,553           104         0              0           0         0          while (left(i) < heap.size()){
26,862,295,291    143  127  3,827,570,440   301,006,507    34,707              0           0         0              int child = right(i) < heap.size() && lt(heap[right(i)], heap[left(i)]) ? right(i) : left(i);
10,255,655,951    278  231              0             0         0              0           0         0              if (!lt(heap[child], x)) break;
 1,754,353,553      0    0              0             0         0  1,754,353,553           0         0              heap[i]          = heap[child];
 1,760,800,623      0    0      6,447,070             0         0  1,754,353,553 878,269,667   244,955              indices[heap[i]] = i;
 1,503,701,640      0    0              0             0         0              0           0         0              i                = child;
             .      .    .              .             .         .              .           .         .          }
 7,532,487,621    176  149  3,766,258,970            13         0  3,766,228,651           0         0          heap   [i] = x;
 4,034,220,865     17   14    138,395,838             0         0  3,766,228,651     728,175         0          indices[x] = i;
25,467,223,112      0    0 25,409,571,376             0         0              0           0         0      }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .    public:
             .      .    .              .             .         .              .           .         .      Heap(const Comp& c) : lt(c) { }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .      int  size      ()          const { return heap.size(); }
    98,377,106      1    1     98,377,106     5,126,056       331              0           0         0      bool empty     ()          const { return heap.size() == 0; }
70,398,626,530  7,578  598 36,525,373,597 6,223,430,890 1,520,432              0           0         0      bool inHeap    (int n)     const { return n < indices.size() && indices[n] >= 0; }
   138,512,584     26   26     82,091,137     3,170,722       235              0           0         0      int  operator[](int index) const { assert(index < heap.size()); return heap[index]; }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
 1,906,767,178      0    0  1,328,249,003         1,353         0    374,865,414       3,032         0      void decrease  (int n) { assert(inHeap(n)); percolateUp  (indices[n]); }
19,157,515,793     15   15 11,897,638,256             9         0  3,629,938,768           0         0      void increase  (int n) { assert(inHeap(n)); percolateDown(indices[n]); }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .      // Safe variant of insert/decrease/increase:
             .      .    .              .             .         .              .           .         .      void update(int n)
             .      .    .              .             .         .              .           .         .      {
             .      .    .              .             .         .              .           .         .          if (!inHeap(n))
             .      .    .              .             .         .              .           .         .              insert(n);
             .      .    .              .             .         .              .           .         .          else {
             .      .    .              .             .         .              .           .         .              percolateUp(indices[n]);
       935,048      0    0        467,524             0         0              0           0         0              percolateDown(indices[n]); }
             .      .    .              .             .         .              .           .         .      }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .      void insert(int n)
             .      .    .              .             .         .              .           .         .      {
    98,557,301      2    2              0             0         0              0           0         0          indices.growTo(n+1, -1);
             .      .    .              .             .         .              .           .         .          assert(!inHeap(n));
             .      .    .              .             .         .              .           .         .  
   197,114,602      1    1     98,557,301             0         0     98,557,301           0         0          indices[n] = heap.size();
       576,223      1    1              0             0         0        384,082           0         0          heap.push(n);
   197,114,602      0    0     98,557,301            25         0              0           0         0          percolateUp(indices[n]); 
             .      .    .              .             .         .              .           .         .      }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .      int  removeMin()
             .      .    .              .             .         .              .           .         .      {
   295,131,315      1    1    196,754,210     4,657,284       159     98,377,105         692         0          int x            = heap[0];
   196,754,210      0    0     98,377,105    12,650,497     6,808     98,377,105           0         0          heap[0]          = heap.last();
   196,754,210     54   51     98,377,105             0         0     98,377,105  90,733,746    51,898          indices[heap[0]] = 0;
    98,377,105      1    1              0             0         0     98,377,105   7,689,531       374          indices[x]       = -1;
             .      .    .              .             .         .              .           .         .          heap.pop();
   196,754,210      0    0              0             0         0              0           0         0          if (heap.size() > 1) percolateDown(0);
             .      .    .              .             .         .              .           .         .          return x; 
             .      .    .              .             .         .              .           .         .      }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .      // Rebuild the heap from scratch, using the elements in 'ns':
             .      .    .              .             .         .              .           .         .      void build(const vec<int>& ns) {
    18,897,926    179  151      9,448,963           274        82              0           0         0          for (int i = 0; i < heap.size(); i++)
     9,449,374    137  114            411             0         0      9,448,141   5,198,058 1,035,551              indices[heap[i]] = -1;
           411      0    0              0             0         0              0           0         0          heap.clear();
             .      .    .              .             .         .              .           .         .  
    18,671,547    118  113      9,335,157           411         0              0           0         0          for (int i = 0; i < ns.size(); i++){
    18,669,492      0    0      9,334,746             0         0      9,334,746   1,596,814       204              indices[ns[i]] = i;
             .      .    .              .             .         .              .           .         .              heap.push(ns[i]); }
             .      .    .              .             .         .              .           .         .  
    32,675,123    388  348      4,667,679             0         0            411           0         0          for (int i = heap.size() / 2 - 1; i >= 0; i--)
             .      .    .              .             .         .              .           .         .              percolateDown(i);
             .      .    .              .             .         .              .           .         .      }
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .      void clear(bool dealloc = false) 
             .      .    .              .             .         .              .           .         .      { 
             4      0    0              2             1         1              0           0         0          for (int i = 0; i < heap.size(); i++)
             .      .    .              .             .         .              .           .         .              indices[heap[i]] = -1;
             .      .    .              .             .         .              .           .         .          heap.clear(dealloc); 
             .      .    .              .             .         .              .           .         .      }
             .      .    .              .             .         .              .           .         .  };
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  
             .      .    .              .             .         .              .           .         .  //=================================================================================================
             .      .    .              .             .         .              .           .         .  }
-- line 146 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /usr/include/c++/8/cmath
--------------------------------------------------------------------------------
Ir            I1mr ILmr Dr            D1mr       DLmr Dw            D1mw       DLmw 

-- line 410 ----------------------------------------
            .    .    .             .          .    .             .          .    .  #endif
            .    .    .             .          .    .             .          .    .  
            .    .    .             .          .    .             .          .    .    template<typename _Tp, typename _Up>
            .    .    .             .          .    .             .          .    .      inline _GLIBCXX_CONSTEXPR
            .    .    .             .          .    .             .          .    .      typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
            .    .    .             .          .    .             .          .    .      pow(_Tp __x, _Up __y)
            .    .    .             .          .    .             .          .    .      {
            .    .    .             .          .    .             .          .    .        typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
9,386,558,906   36   35 1,347,966,817 12,048,449  169 3,970,087,933 13,160,999    0        return pow(__type(__x), __type(__y));
            .    .    .             .          .    .             .          .    .      }
            .    .    .             .          .    .             .          .    .  
            .    .    .             .          .    .             .          .    .    using ::sin;
            .    .    .             .          .    .             .          .    .  
            .    .    .             .          .    .             .          .    .  #ifndef __CORRECT_ISO_CPP_MATH_H_PROTO
            .    .    .             .          .    .             .          .    .    inline _GLIBCXX_CONSTEXPR float
            .    .    .             .          .    .             .          .    .    sin(float __x)
            .    .    .             .          .    .             .          .    .    { return __builtin_sinf(__x); }
-- line 426 ----------------------------------------

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Alloc.h
--------------------------------------------------------------------------------
Ir             I1mr   ILmr Dr             D1mr       DLmr       Dw          D1mw DLmw 

-- line 40 ----------------------------------------
             .      .    .              .          .          .           .    .    .      void capacity(uint32_t min_cap);
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .   public:
             .      .    .              .          .          .           .    .    .      // TODO: make this a class for better type-checking?
             .      .    .              .          .          .           .    .    .      typedef uint32_t Ref;
             .      .    .              .          .          .           .    .    .      enum { Ref_Undef = UINT32_MAX };
             .      .    .              .          .          .           .    .    .      enum { Unit_Size = sizeof(uint32_t) };
             .      .    .              .          .          .           .    .    .  
         1,406      1    1              0          0          0       1,124    0    0      explicit RegionAllocator(uint32_t start_cap = 1024*1024) : memory(NULL), sz(0), cap(0), wasted_(0){ capacity(start_cap); }
             .      .    .              .          .          .           .    .    .      ~RegionAllocator()
             .      .    .              .          .          .           .    .    .      {
             .      .    .              .          .          .           .    .    .          if (memory != NULL)
             .      .    .              .          .          .           .    .    .              ::free(memory);
             .      .    .              .          .          .           .    .    .      }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .      uint32_t size      () const      { return sz; }
             .      .    .              .          .          .           .    .    .      uint32_t wasted    () const      { return wasted_; }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .      Ref      alloc     (int size); 
    17,717,593      0    0      5,905,816          0          0   5,905,816    0    0      void     free      (int size)    { wasted_ += size; }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .      // Deref, Load Effective Address (LEA), Inverse of LEA (AEL):
34,080,768,390  1,241  966 17,977,629,515 70,124,433 46,456,364     623,618    0    0      T&       operator[](Ref r)       { assert(r >= 0 && r < sz); return memory[r]; }
   159,513,467      0    0    159,513,467 22,076,843  7,810,992           0    0    0      const T& operator[](Ref r) const { assert(r >= 0 && r < sz); return memory[r]; }
             .      .    .              .          .          .           .    .    .  
   406,748,625 12,848  115      6,452,822          0          0           0    0    0      T*       lea       (Ref r)       { assert(r >= 0 && r < sz); return &memory[r]; }
     6,210,184      0    0              0          0          0           0    0    0      const T* lea       (Ref r) const { assert(r >= 0 && r < sz); return &memory[r]; }
             .      .    .              .          .          .           .    .    .      Ref      ael       (const T* t)  { assert((void*)t >= (void*)&memory[0] && (void*)t < (void*)&memory[sz-1]);
             .      .    .              .          .          .           .    .    .          return  (Ref)(t - &memory[0]); }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .      void     moveTo(RegionAllocator& to) {
         1,120      0    0            280          0          0         280    0    0          if (to.memory != NULL) ::free(to.memory);
           560      0    0            280          0          0         280    0    0          to.memory = memory;
           560      0    0            280          0          0         280    0    0          to.sz = sz;
             .      .    .              .          .          .           .    .    .          to.cap = cap;
           560      0    0            280          0          0         280    0    0          to.wasted_ = wasted_;
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .          memory = NULL;
             .      .    .              .          .          .           .    .    .          sz = cap = wasted_ = 0;
             .      .    .              .          .          .           .    .    .      }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  };
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  template<class T>
         2,694    208  208              0          0          0         898  279    0  void RegionAllocator<T>::capacity(uint32_t min_cap)
             .      .    .              .          .          .           .    .    .  {
   400,775,034      5    5    133,591,675          0          0           0    0    0      if (cap >= min_cap) return;
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .      uint32_t prev_cap = cap;
        18,066      0    0              0          0          0         452    0    0      while (cap < min_cap){
             .      .    .              .          .          .           .    .    .          // NOTE: Multiply by a factor (13/8) without causing overflow, then add 2 and make the
             .      .    .              .          .          .           .    .    .          // result even by clearing the least significant bit. The resulting sequence of capacities
             .      .    .              .          .          .           .    .    .          // is carefully chosen to hit a maximum capacity that is close to the '2^32-1' limit when
             .      .    .              .          .          .           .    .    .          // using 'uint32_t' as indices so that as much as possible of this space can be used.
        52,842      0    0              0          0          0           0    0    0          uint32_t delta = ((cap >> 1) + (cap >> 3) + 2) & ~1;
         8,807      0    0              0          0          0           0    0    0          cap += delta;
             .      .    .              .          .          .           .    .    .  
        17,614      0    0              0          0          0           0    0    0          if (cap <= prev_cap)
             .      .    .              .          .          .           .    .    .              throw OutOfMemoryException();
             .      .    .              .          .          .           .    .    .      }
             .      .    .              .          .          .           .    .    .      // printf(" .. (%p) cap = %u\n", this, cap);
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .      assert(cap > 0);
           907      3    3              0          0          0         452  166  163      memory = (T*)xrealloc(memory, sizeof(T)*cap);
         1,796      0    0          1,347          0          0           0    0    0  }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  template<class T>
             .      .    .              .          .          .           .    .    .  typename RegionAllocator<T>::Ref
     1,913,512      2    2              0          0          0   1,435,134    0    0  RegionAllocator<T>::alloc(int size)
             .      .    .              .          .          .           .    .    .  { 
             .      .    .              .          .          .           .    .    .      // printf("ALLOC called (this = %p, size = %d)\n", this, size); fflush(stdout);
             .      .    .              .          .          .           .    .    .      assert(size > 0);
   781,711,520      0    0    133,591,394  5,440,372         69 387,390,112  968  100      capacity(sz + size);
             .      .    .              .          .          .           .    .    .  
   405,313,446      0    0    260,251,541          0          0           0    0    0      uint32_t prev_sz = sz;
   133,591,394      2    2              0          0          0 133,591,394    0    0      sz += size;
             .      .    .              .          .          .           .    .    .      
             .      .    .              .          .          .           .    .    .      // Handle overflow:
   648,598,500    354  354    127,138,571          0          0           0    0    0      if (sz < prev_sz)
             2      1    1              1          1          1           0    0    0          throw OutOfMemoryException();
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .      return prev_sz;
     1,913,512      0    0      1,913,512          0          0           0    0    0  }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  //=================================================================================================
             .      .    .              .          .          .           .    .    .  }
             .      .    .              .          .          .           .    .    .  
             .      .    .              .          .          .           .    .    .  #endif

--------------------------------------------------------------------------------
-- Auto-annotated source: /home/jshen/git/MapleLCMDiscChronoBT/sources/simp/../mtl/Vec.h
--------------------------------------------------------------------------------
Ir              I1mr    ILmr  Dr             D1mr          DLmr      Dw             D1mw          DLmw       

-- line 40 ----------------------------------------
              .       .     .              .             .         .              .             .          .      int sz;
              .       .     .              .             .         .              .             .          .      int cap;
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .      // Don't allow copying (error prone):
              .       .     .              .             .         .              .             .          .      vec<T>&  operator = (vec<T>& other) { assert(0); return *this; }
              .       .     .              .             .         .              .             .          .               vec        (vec<T>& other) { assert(0); }
              .       .     .              .             .         .              .             .          .               
              .       .     .              .             .         .              .             .          .      // Helpers for calculating next capacity:
     13,526,958      12    12              0             0         0              0             0          0      static inline int  imax   (int x, int y) { int mask = (y-x) >> (sizeof(int)*8-1); return (x&mask) + (y&(~mask)); }
              .       .     .              .             .         .              .             .          .      //static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .     .              .             .         .              .             .          .      static inline void nextCap(int& cap){ cap += ((cap >> 1) + 2) & ~1; }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  public:
              .       .     .              .             .         .              .             .          .      // Constructors:
      2,723,944      73    73              2             0         0      2,407,600       109,078     72,022      vec()                       : data(NULL) , sz(0)   , cap(0)    { }
             64       0     0              0             0         0             64             0          0      explicit vec(int size)      : data(NULL) , sz(0)   , cap(0)    { growTo(size); }
              .       .     .              .             .         .              .             .          .      vec(int size, const T& pad) : data(NULL) , sz(0)   , cap(0)    { growTo(size, pad); }
              .       .     .              .             .         .              .             .          .     ~vec()                                                          { clear(true); }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .      // Pointer to first element:
              .       .     .              .             .         .              .             .          .      operator T*       (void)           { return data; }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .      // Size operations:
              .       .     .              .             .         .              .             .          .      int      size     (void) const     { return sz; }
 12,069,086,028   2,212   741    486,759,565     1,221,901         0    418,385,058             3          0      void     shrink   (int nelems)     { assert(nelems <= sz); for (int i = 0; i < nelems; i++) sz--, data[sz].~T(); }
              .       .     .              .             .         .              .             .          .      void     shrink_  (int nelems)     { assert(nelems <= sz); sz -= nelems; }
              .       .     .              .             .         .              .             .          .      int      capacity (void) const     { return cap; }
              .       .     .              .             .         .              .             .          .      void     capacity (int min_cap);
              .       .     .              .             .         .              .             .          .      void     growTo   (int size);
              .       .     .              .             .         .              .             .          .      void     growTo   (int size, const T& pad);
              .       .     .              .             .         .              .             .          .      void     clear    (bool dealloc = false);
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .      // Stack interface:
     24,396,653  11,749   106     12,209,245        26,459         0      6,044,616           220          0      void     push  (void)              { if (sz == cap) capacity(sz+1); new (&data[sz]) T(); sz++; }
156,537,993,204 257,068 4,474 64,742,049,898 4,472,757,796 3,721,333 41,491,313,417 5,175,604,337 58,800,316      void     push  (const T& elem)     { if (sz == cap) capacity(sz+1); data[sz++] = elem; }
 22,137,391,581       0     0  5,703,489,086       193,366         0 10,908,743,158   337,274,354    380,891      void     push_ (const T& elem)     { assert(sz < cap); data[sz++] = elem; }
  5,886,483,071     221    28     98,377,105             0         0  2,894,361,427             0          0      void     pop   (void)              { assert(sz > 0); sz--, data[sz].~T(); }
              .       .     .              .             .         .              .             .          .      // NOTE: it seems possible that overflow can happen in the 'sz+1' expression of 'push()', but
              .       .     .              .             .         .              .             .          .      // in fact it can not since it requires that 'cap' is equal to INT_MAX. This in turn can not
              .       .     .              .             .         .              .             .          .      // happen given the way capacities are calculated (below). Essentially, all capacities are
              .       .     .              .             .         .              .             .          .      // even, but INT_MAX is odd.
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .      const T& last  (void) const        { return data[sz-1]; }
  2,795,260,430       0     0              0             0         0              0             0          0      T&       last  (void)              { return data[sz-1]; }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .      // Vector interface:
118,188,208,168   3,865   862  3,720,700,559           954         0    100,080,114             6          0      const T& operator [] (int index) const { return data[index]; }
151,745,800,357   2,751 1,841 37,119,626,125    30,141,239   413,579  5,764,639,877     3,859,895          0      T&       operator [] (int index)       { return data[index]; }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .      // Duplicatation (preferred instead):
  4,688,268,385      55    55  1,566,739,345    28,417,726         0    774,407,435             0          0      void copyTo(vec<T>& copy) const { copy.clear(); copy.growTo(sz); for (int i = 0; i < sz; i++) copy[i] = data[i]; }
        529,147       0     0        529,054            12         0             62             0          0      void moveTo(vec<T>& dest) { dest.clear(true); dest.data = data; dest.sz = sz; dest.cap = cap; data = NULL; sz = 0; cap = 0; }
              .       .     .              .             .         .              .             .          .  };
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  template<class T>
      3,381,572       0     0              0             0         0      1,690,786             0          0  void vec<T>::capacity(int min_cap) {
     25,843,197      61    36      8,614,399            14         0              0             0          0      if (cap >= min_cap) return;
     11,836,161     101    95              0             0         0             18             0          0      int add = imax((min_cap - cap + 1) & ~1, ((cap >> 1) + 2) & ~1);   // NOTE: grow by approximately 3/2
     22,108,936     223   126      1,690,934            41         0      5,072,623        28,513          0      if (add > INT_MAX - cap || ((data = (T*)::realloc(data, (cap += add) * sizeof(T))) == NULL) && errno == ENOMEM)
              .       .     .              .             .         .              .             .          .          throw OutOfMemoryException();
     10,052,113       5     5     10,052,113            72         0              0             0          0   }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  template<class T>
              .       .     .              .             .         .              .             .          .  void vec<T>::growTo(int size, const T& pad) {
    296,241,315       8     8     98,683,837         2,376         0              0             0          0      if (sz >= size) return;
      1,265,360       4     4        126,536             0         0        569,412             0          0      capacity(size);
      7,149,286       7     7      1,138,825             5         0        569,413         8,595          0      for (int i = sz; i < size; i++) data[i] = pad;
    169,566,357      27    27         90,987             0         0        569,412             0          0      sz = size; }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  template<class T>
      1,265,360       1     1              0             0         0        506,144             0          0  void vec<T>::growTo(int size) {
     13,468,151       1     1        442,879         1,254         0        253,072             0          0      if (sz >= size) return;
     24,025,937   3,347   976              0             0         0     12,012,953             0          0      capacity(size);
     88,709,391      95    58     24,532,050             0         0     11,949,684             0          0      for (int i = sz; i < size; i++) new (&data[i]) T();
     19,253,234       0     0      6,734,135            25         0      6,291,200            12          0      sz = size; }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  template<class T>
              .       .     .              .             .         .              .             .          .  void vec<T>::clear(bool dealloc) {
  2,350,615,667 449,140 2,051    740,533,877     7,506,102    43,115         54,828             0          0      if (data != NULL){
        126,542       0     0              1             0         0              0             0          0          for (int i = 0; i < sz; i++) data[i].~T();
  7,907,911,326      73    70     61,568,858             1         0    810,655,746       364,922          1          sz = 0;
        935,023       4     4        260,624             9         0        640,516            14          0          if (dealloc) free(data), data = NULL, cap = 0; } }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  //=================================================================================================
              .       .     .              .             .         .              .             .          .  }
              .       .     .              .             .         .              .             .          .  
              .       .     .              .             .         .              .             .          .  #endif

--------------------------------------------------------------------------------
Ir                I1mr      ILmr   Dr                D1mr            DLmr        Dw              D1mw           DLmw        
--------------------------------------------------------------------------------
3,417,683,119,967 1,706,953 75,629 1,142,242,214,177 116,950,894,568 583,875,639 407,932,587,721 29,937,475,089 170,956,544  events annotated

